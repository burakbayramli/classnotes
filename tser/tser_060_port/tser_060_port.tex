\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Portföy Ýdaresi

Çeþitlendirmenin (diversification), yani portföye farklý enstrümanlar koymanýn,
farklý sektörlerden olsun, farklý ülkelerden olsun, iyi bir þey olduðu hep
tavsiye edilir, kulaða küpe kuralý ``yumurtalarý ayný sepete koymamak'', teknik
anlamda bu söz portföydeki bir enstrümanýn tamamen çöktüðü durumda (sepetin
düþüp yumurtalarýn kýrýlmasý) kayýplarýn sýnýrlanacaðý çaðrýþtýrmasýný
yapar. Mesela [4, sf. 115]'e göre, ABD borsalarýnda hisselerin artýk getirisinin
ortalama \%3 olduðu bilinir. Eðer yýllýk \%20 standart sapmayý baz alýrsak,
Sharpe oraný (SR) \%3 bölü \%20 = 0.15. Eðer ayný ülkede ama farklý sektörlerde
çeþitlendirirsek aþaðý yukarý SR = 0.2 elde edebiliriz. Eðer farklý ülkelere
çeþitlersek SR 0.25'e çýkabiliriz. Eðer yatýrým sýnýfýný da çeþitlersek, yani
tahviller, senetler, baz ürünlere yatýrým yapmak üzere, o zaman SR 0.4 elde
edebiliriz.

Ýçinde birbiri ile ilintisi olmayan (uncorrelated) varlýklar olan bir
portföyün -ki çeþitlenmiþ olmanýn teknik tercümesi bu aslýnda- toplam
standart sapmasý daha düþüktür. Sharpe oranýný hesaplarken standart sapmaya
böldüðümüz için daha ufak deðer daha büyük SR anlamýna gelir. Matematiksel
olarak sadece bir portföy düþünelim içinde iki varlýk olsun, gelecekteki
getirilerini $R_1,R_2$'yi bildiðimizi farzedelim (tarihi veriden
kestiriyoruz mesela), bu varlýklar $w_1,w_2$ aðýrlýklarý üzerinden
birleþtiriliyor olsun, toplam portföy getirisi,

$$ R_p = w_1 R_1 + w_2 R_2 $$

$R_1,R_2$ rasgele deðiþkenler. Tüm portföyün beklentisi, 

$$ E(R_p) = E(w_1 R_1 + w_2 R_2) $$

$$ = w_1 E(R_1) + w_2 E(R_2) $$

Portföyün varyansý için [5, sf. 73], 

$$Var(w_1 R_1 + w_2 R_2) = w_1^2Var(R_1) + w_2^2 Var(R_2) + w_1w_2Cov(R_1,R_2)
 \mlabel{1}$$

Diyelim ki $w_1,w_2$ eþit; O zaman formülden açýk bir þekilde görülüyor ki
üstteki varyansýn azalacaðý durumlardan biri iki enstrümanýn hiç ilintili
olmadýðý durumdur, çünkü bu durumda iki getirinin kovaryansý sýfýr olur;
$Cov(R_1,R_2)=0$, üstteki formüldeki 3. terim tamamen yokolur, böylece
portföy varyansý azalýr. Varyans azalýnca Sharpe oraný artar. 

N Tane Enstrüman

Çok boyutlu hesap için portföy aðýrlýklarý $w = [w_1,..,w_n]^T$, getiriler 
$R = [R_1,..,R_n]^T$ vektörleri içinde olsun, 

$$ R_p = w^T R $$

Beklenti 

$$ E(R_p) = E(w^T R) = w^TE(R) $$

Varyans

$$ Var(R_p) = E\big( (R_p-E(R_p))(R-E(R_p))^T  \big) $$

$$ = E\big( (R_p-w^TE(R))(R_p-w^TE(R))^T  \big) $$

$$ = E\big( (w^TR-w^TE(R))(w^TR-w^TE(R))^T  \big) $$

$$ = w^T E\big( (R-E(R))(R-E(R))^Tw  \big) $$

$$ = w^T cov (R) w $$

Yine iki enstrüman üzerinden matris formunu kontrol edelim, varyanslar için
$\sigma_1^2,\sigma_2^2$ kullanýrsak,

$$ Var(R_p) = 
\left[\begin{array}{cc} w_1 & w_2  \end{array}\right]
\left[\begin{array}{rr}
\sigma_1^2 & \sigma_{12} \\
\sigma_{2,1}^2 & \sigma_2^2 
\end{array}\right]
\left[\begin{array}{r}
w_1 \\ w_2
\end{array}\right] 
\mlabel{2}
$$

$$ = \left[\begin{array}{cc} 
w_1 \sigma_1^2 + w_2 \sigma_{2,1} & 
w_1 \sigma_{1,2} + w_2\sigma_2^2  \end{array}\right]
\left[\begin{array}{r}
w_1 \\ w_2
\end{array}\right] 
$$

$$ = w_1^2\sigma_1^2 + w_1w_2\sigma_{2,1} + w_1w_2\sigma_{1,2} + w_2^2\sigma_2^2$$

$$ = w_1^2\sigma_1^2 + 2 w_1w_2\sigma_{1,2} + w_2^2\sigma_2^2$$

(1) ile benzer sonuca vardýk. Her iki durumda da enstrumanlar arasýnda
korelasyon olmamasý bir terim eksiltir, ve portföy varyansý azalýr. Bunun matris
tercümesi $cov (R)$'nin köþegeni dýþýndaki öðelerinin sýfýr olmasý anlamýna
gelir, çünkü bir kovaryans matrisinde her enstrüman arasýndaki kovaryanslar
köþegen haricinde olan öðelerde tutulur.

Portföy Aðýrlýklarýný Hesaplamak

Portföy varyansýný, riskini azaltmak enstrümanlar arasý korelasyonu azaltmak ile
mümkün, bunu bir yana koyalým. Bir ek yöntem enstrümanlara ayrýlmýþ sermayeyi,
yani bölüþtürme aðýrlýklarýný optimal bir seviyeye getirmektir. Matematiksel
olarak

$$ \textrm{minimize et } w^T \Sigma w $$

$$ R_p^T w = \mu, \quad w^T 1 = 1 \textrm{ þartlarýna uyarak }$$


ki $\mu$ hedeflenen getiri.

Verimli Sýnýr (Efficient Frontier)

Markovitz'in buluþlarýndan biri (getirisinin standart sapmasý) farklý aðýrlýklar
üzerinden hesaplanan portföyün riskini ve getirisini grafiklediðinde mümkün tüm
getirilerin bir sýnýr oluþturduðunu görmesiydi, buna verimli sýnýr ismi
verildi. Görsel olarak düþünürsek herhangi verili bir risk için dikey yukarý
çýkýp bu sýnýra geliyoruz, ve bu sýnýrdaki risk (ve onu ortaya çýkartan
aðýrlýklar) elde edebileceðimiz en iyi sonuç. Altta üç þirket üzerinde bu hesabý
görebiliriz.

\begin{minted}[fontsize=\footnotesize]{python}
import pandas as pd
df = pd.read_csv("companies.csv",index_col=0,parse_dates=True)
print df.head()
\end{minted}

\begin{verbatim}
                 MSFT       AAPL         KO
Date                                       
2010-01-04  26.045432  28.141855  23.509276
2010-01-05  26.053846  28.190509  23.224888
2010-01-06  25.893956  27.742101  23.216647
2010-01-07  25.624666  27.690818  23.158944
2010-01-08  25.801387  27.874915  22.730305
\end{verbatim}

Þirketler Microsoft, Apple, ve Coca-Cola.

\begin{minted}[fontsize=\footnotesize]{python}
import scipy as sp
import scipy.optimize as scopt
import scipy.stats as spstats

def calc_annual_returns(daily_returns):
    grouped = np.exp(daily_returns.groupby(lambda date: date.year).sum())-1
    return grouped

def calc_portfolio_var(returns, weights):
    sigma = np.cov(returns.T,ddof=0)
    var = (weights * sigma * weights.T).sum()
    return var

def sharpe_ratio(returns, weights, risk_free_rate = 0.015):
    n = returns.columns.size
    var = calc_portfolio_var(returns, weights)
    means = returns.mean()
    return (means.dot(weights) - risk_free_rate)/np.sqrt(var)

def negative_sharpe_ratio_n_minus_1_stock(weights,returns,risk_free_rate):
    weights2 = sp.append(weights, 1-np.sum(weights))
    return -sharpe_ratio(returns, weights2, risk_free_rate)

def optimize_portfolio(returns, risk_free_rate):
    w0 = np.ones(returns.columns.size-1,dtype=float) * 1.0 / returns.columns.size
    w1 = scopt.fmin(negative_sharpe_ratio_n_minus_1_stock,
                    w0, args=(returns, risk_free_rate))
    final_w = sp.append(w1, 1 - np.sum(w1))
    final_sharpe = sharpe_ratio(returns, final_w, risk_free_rate)
    return (final_w, final_sharpe)

def objfun(W, R, target_ret):
    stock_mean = np.mean(R,axis=0)
    port_mean = np.dot(W,stock_mean)
    cov=np.cov(R.T)
    port_var = np.dot(np.dot(W,cov),W.T)
    penalty = 2000*abs(port_mean-target_ret)
    return np.sqrt(port_var) + penalty

def calc_daily_returns(df):
    return np.log(df/df.shift(1))

def calc_efficient_frontier(returns):
    result_means = []
    result_stds = []
    result_weights = []
    means = returns.mean()
    min_mean, max_mean = means.min(), means.max()
    nstocks = returns.columns.size

    for r in np.linspace(min_mean, max_mean, 100):
    	weights = np.ones(nstocks)/nstocks
	bounds = [(0,1) for i in np.arange(nstocks)]
	constraints = ({'type': 'eq','fun': lambda W: np.sum(W) - 1})
	results = scopt.minimize(objfun, weights, (returns, r),
                                 method='SLSQP',constraints = constraints,
                                 bounds = bounds)
	if not results.success: raise Exception(result.message)
	result_means.append(np.round(r,4)) # 4 decimal places
	std_=np.round(np.std(np.sum(returns*results.x,axis=1)),6)
	result_stds.append(std_)
	result_weights.append(np.round(results.x, 5))
	
    return {'Means': result_means, 'Stds': result_stds, 'Weights': result_weights}

def calc_port_perf(w, ret, covs):
    port_ret = np.sum( ret*w )
    port_std = np.sqrt(np.dot(w.T, np.dot(covs, w)))
    return port_ret, port_std

def plot_all_possible_portfolios(ann_rets):
    res = []
    for i in range(1000):
        w = np.random.random(len(df.columns))
        w /= np.sum(w)
        r,s = calc_port_perf(w, ann_rets.mean(),ann_rets.cov())
        res.append([r,s])
    vw = pd.DataFrame(res,columns=['return','sigma'])
    return vw
    
    
def plot_efficient_frontier(ef_data):
    plt.title(u'Verimli Sýnýr')
    plt.xlabel(u'Portföy Standart Sapmasý (Risk))')
    plt.ylabel(u'Portföy Getirisi')
    plt.plot(ef_data['Stds'], ef_data['Means'], '--');
\end{minted}

Günlük getiriler,

\begin{minted}[fontsize=\footnotesize]{python}
daily_returns = calc_daily_returns(df)
print daily_returns.head()
\end{minted}

\begin{verbatim}
                MSFT      AAPL        KO
Date                                    
2010-01-04       NaN       NaN       NaN
2010-01-05  0.000323  0.001727 -0.012171
2010-01-06 -0.006156 -0.016034 -0.000355
2010-01-07 -0.010454 -0.001850 -0.002489
2010-01-08  0.006873  0.006626 -0.018682
\end{verbatim}

Yýllýk getiri,

\begin{minted}[fontsize=\footnotesize]{python}
annual_returns = calc_annual_returns(daily_returns)
print annual_returns.head()
\end{minted}

\begin{verbatim}
          MSFT      AAPL        KO
2010 -0.079441  0.507219  0.189366
2011 -0.045157  0.255580  0.094586
2012  0.057989  0.325669  0.065276
2013  0.442980  0.080695  0.172330
2014  0.275646  0.406225  0.052661
\end{verbatim}

Eþit aðýrlýklar üzerinden oluþturulmuþ portföyün varyansý,

\begin{minted}[fontsize=\footnotesize]{python}
eq_weights = np.array([1/3.,1/3.,1/3.])
print calc_portfolio_var(annual_returns,weights=eq_weights)
\end{minted}

\begin{verbatim}
0.00287954016535
\end{verbatim}

Sharpe Oraný

\begin{minted}[fontsize=\footnotesize]{python}
print sharpe_ratio(annual_returns,eq_weights)
\end{minted}

\begin{verbatim}
3.20109292169
\end{verbatim}

Farklý (rasgele) portföy aðýrlýklarýnýn oluþturacaðý risk / getiri grafiði, 

\begin{minted}[fontsize=\footnotesize]{python}
vw = plot_all_possible_portfolios(annual_returns)
vw.plot(x='sigma',y='return',kind='scatter')
plt.savefig('tser_port_04.png')
\end{minted}

\includegraphics[height=8cm]{tser_port_04.png}

Þimdi optimizasyon ile global bir optimal nokta bulalým,

\begin{minted}[fontsize=\footnotesize]{python}
print optimize_portfolio(annual_returns, 0.0003)
\end{minted}

\begin{verbatim}
Optimization terminated successfully.
         Current function value: -7.829867
         Iterations: 38
         Function evaluations: 74
(array([ 0.02615542,  0.76347385,  0.21037072]), 7.8298669383774486)
\end{verbatim}

Verimli sýnýr,

\begin{minted}[fontsize=\footnotesize]{python}
frontier_data = calc_efficient_frontier(annual_returns)
\end{minted}

\begin{minted}[fontsize=\footnotesize]{python}
print frontier_data['Stds'][:5]
print frontier_data['Means'][:5]
for x in frontier_data['Weights'][:5]: print x
\end{minted}

\begin{verbatim}
[0.055842999999999997, 0.053446, 0.052564, 0.051706000000000002, 0.050871]
[0.1148, 0.1169, 0.11890000000000001, 0.12089999999999999, 0.1229]
[ 0.  0.  1.]
[ 0.06407  0.00512  0.93081]
[ 0.06733  0.01497  0.9177 ]
[ 0.07228  0.02469  0.90303]
[ 0.07493  0.03458  0.89049]
\end{verbatim}


\begin{minted}[fontsize=\footnotesize]{python}
vw = plot_all_possible_portfolios(annual_returns)
vw.plot(x='sigma',y='return',kind='scatter')
plt.hold(True)
plot_efficient_frontier(frontier_data)
plt.savefig('tser_port_03.png')
\end{minted}

\includegraphics[height=8cm]{tser_port_03.png}

Bootstrap

Dikkat: üstteki optimizasyonu olduðu gibi kullanmak sayýsal olarak pek ise
yaramayabilir.  Mesela, üç yatýrým var, S\&P 500, NASDAQ ve 20 yýllýk ABD
tahvili. Bu varlýklarý basit bir þekilde kullanacaðýz, onlarý sadece alýp elde
tutacaðýz. Eðer tek periyot (eldeki tüm veriyi) Markowitz optimizasyonu
üzerinden aðýrlýklarý hesaplarsak, aðýrlýklar çok ekstrem, stabil olmuyor. Çözüm
için bootstrap tekniði kullanýlýr; veriden ardý ardýna örneklem alýrýz, yani
veriden yeni veri yaratýrýz, beklediðimiz o ki örneklemlerin daðýlýmý ``gerçek''
verinin daðýlýmý ile benzer olacak. Bu iþlemin yan etkisi veriyi fazlalaþtýrmak,
ardýndan yapýlan hesabýn ortalamasýný alýnca stabiliteye daha yaklaþmýþ olmak.

Zaman serisinden örneklem almanýn deðiþik yollarý var, bir tanesi blok örneklem
yöntemi, kesintisiz zaman seri parçalarý almak. Bir diðeri noktalar ardý ardýna
olsun olmasýn verinin rasgele noktalarýndan örneklem toplamak. Alttaki ikinci
yöntemi takip ediyor,

\inputminted[fontsize=\footnotesize]{python}{boot.py}

\begin{minted}[fontsize=\footnotesize]{python}
import zipfile, pandas as pd, random
symbols = ['SP500','NASDAQ','US20']
df = pd.DataFrame()
with zipfile.ZipFile('../tser_voltar/legacycsv.zip', 'r') as z:
    for symbol in symbols:
        f = '%s_price.csv' % symbol
        df[symbol] = pd.read_csv(z.open(f),sep=',',
                                 index_col=0,
                                 parse_dates=True)['PRICE']
    
df['SP500'] = df.SP500.pct_change()
df['NASDAQ'] = df.NASDAQ.pct_change()
df['US20'] = df.US20.pct_change()

df = df[(df.index >= '1999-08-02') & (df.index <= '2015-04-22')]
    
random.seed(0)

w=boot.optimise_over_periods(df)
\end{minted}


\begin{minted}[fontsize=\footnotesize]{python}
w.plot()
plt.savefig('tser_port_01.png')
\end{minted}

\includegraphics[height=8cm]{tser_port_01.png}

Bu sonuç [1. sf. 172]'dakine yakýn, aðýrlýklar çok daha stabil.

Kodda oynaklýðýn standardize edildiðine dikkat; tüm zaman serilerinin oynaklýðý
eþitleniyor, ve maksimize edilmeye uðraþýlan getiri. 


\end{document}
