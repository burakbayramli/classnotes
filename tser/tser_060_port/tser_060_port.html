<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Portföy İdaresi</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="portföy-idaresi">Portföy İdaresi</h1>
<p>Çeşitlendirmenin (diversification), yani portföye farklı enstrümanlar
koymanın, farklı sektörlerden olsun, farklı ülkelerden olsun, iyi bir
şey olduğu hep tavsiye edilir, kulağa küpe kuralı “yumurtaları aynı
sepete koymamak’’, teknik anlamda bu söz portföydeki bir enstrümanın
tamamen çöktüğü durumda (sepetin düşüp yumurtaların kırılması)
kayıpların sınırlanacağı çağrıştırmasını yapar. Mesela [4, sf. 115]’e
göre, ABD borsalarında hisselerin artık getirisinin ortalama %3 olduğu
bilinir. Eğer yıllık %20 standart sapmayı baz alırsak, Sharpe oranı (SR)
%3 bölü %20 = 0.15. Eğer aynı ülkede ama farklı sektörlerde
çeşitlendirirsek aşağı yukarı SR = 0.2 elde edebiliriz. Eğer farklı
ülkelere çeşitlersek SR 0.25’e çıkabiliriz. Eğer yatırım sınıfını da
çeşitlersek, yani tahviller, senetler, baz ürünlere yatırım yapmak
üzere, o zaman SR 0.4 elde edebiliriz.</p>
<p>İçinde birbiri ile ilintisi olmayan (uncorrelated) varlıklar olan bir
portföyün -ki çeşitlenmiş olmanın teknik tercümesi bu aslında- toplam
standart sapması daha düşüktür. Sharpe oranını hesaplarken standart
sapmaya böldüğümüz için daha ufak değer daha büyük SR anlamına gelir.
Matematiksel olarak sadece bir portföy düşünelim içinde iki varlık
olsun, gelecekteki getirilerini <span
class="math inline">\(R_1,R_2\)</span>’yi bildiğimizi farzedelim (tarihi
veriden kestiriyoruz mesela), bu varlıklar <span
class="math inline">\(w_1,w_2\)</span> ağırlıkları üzerinden
birleştiriliyor olsun, toplam portföy getirisi,</p>
<p><span class="math display">\[ R_p = w_1 R_1 + w_2 R_2 \]</span></p>
<p><span class="math inline">\(R_1,R_2\)</span> rasgele değişkenler. Tüm
portföyün beklentisi,</p>
<p><span class="math display">\[ E(R_p) = E(w_1 R_1 + w_2 R_2)
\]</span></p>
<p><span class="math display">\[ = w_1 E(R_1) + w_2 E(R_2) \]</span></p>
<p>Portföyün varyansı için [5, sf. 73],</p>
<p><span class="math display">\[Var(w_1 R_1 + w_2 R_2) = w_1^2Var(R_1) +
w_2^2 Var(R_2) + w_1w_2Cov(R_1,R_2)
\qquad (1)\]</span></p>
<p>Diyelim ki <span class="math inline">\(w_1,w_2\)</span> eşit; O zaman
formülden açık bir şekilde görülüyor ki üstteki varyansın azalacağı
durumlardan biri iki enstrümanın hiç ilintili olmadığı durumdur, çünkü
bu durumda iki getirinin kovaryansı sıfır olur; <span
class="math inline">\(Cov(R_1,R_2)=0\)</span>, üstteki formüldeki 3.
terim tamamen yokolur, böylece portföy varyansı azalır. Varyans azalınca
Sharpe oranı artar.</p>
<p>N Tane Enstrüman</p>
<p>Çok boyutlu hesap için portföy ağırlıkları <span
class="math inline">\(w = [w_1,..,w_n]^T\)</span>, getiriler <span
class="math inline">\(R = [R_1,..,R_n]^T\)</span> vektörleri içinde
olsun,</p>
<p><span class="math display">\[ R_p = w^T R \]</span></p>
<p>Beklenti</p>
<p><span class="math display">\[ E(R_p) = E(w^T R) = w^TE(R)
\]</span></p>
<p>Varyans</p>
<p><span class="math display">\[ Var(R_p) = E\big(
(R_p-E(R_p))(R-E(R_p))^T  \big) \]</span></p>
<p><span class="math display">\[ = E\big(
(R_p-w^TE(R))(R_p-w^TE(R))^T  \big) \]</span></p>
<p><span class="math display">\[ = E\big(
(w^TR-w^TE(R))(w^TR-w^TE(R))^T  \big) \]</span></p>
<p><span class="math display">\[ = w^T E\big( (R-E(R))(R-E(R))^Tw  \big)
\]</span></p>
<p><span class="math display">\[ = w^T cov (R) w \]</span></p>
<p>Yine iki enstrüman üzerinden matris formunu kontrol edelim,
varyanslar için <span
class="math inline">\(\sigma_1^2,\sigma_2^2\)</span> kullanırsak,</p>
<p><span class="math display">\[ Var(R_p) =
\left[\begin{array}{cc} w_1 &amp; w_2  \end{array}\right]
\left[\begin{array}{rr}
\sigma_1^2 &amp; \sigma_{12} \\
\sigma_{2,1}^2 &amp; \sigma_2^2
\end{array}\right]
\left[\begin{array}{r}
w_1 \\ w_2
\end{array}\right]
\qquad (2)
\]</span></p>
<p><span class="math display">\[ = \left[\begin{array}{cc}
w_1 \sigma_1^2 + w_2 \sigma_{2,1} &amp;
w_1 \sigma_{1,2} + w_2\sigma_2^2  \end{array}\right]
\left[\begin{array}{r}
w_1 \\ w_2
\end{array}\right]
\]</span></p>
<p><span class="math display">\[ = w_1^2\sigma_1^2 + w_1w_2\sigma_{2,1}
+ w_1w_2\sigma_{1,2} + w_2^2\sigma_2^2\]</span></p>
<p><span class="math display">\[ = w_1^2\sigma_1^2 + 2
w_1w_2\sigma_{1,2} + w_2^2\sigma_2^2\]</span></p>
<ol type="1">
<li>ile benzer sonuca vardık. Her iki durumda da enstrumanlar arasında
korelasyon olmaması bir terim eksiltir, ve portföy varyansı azalır.
Bunun matris tercümesi <span class="math inline">\(cov (R)\)</span>’nin
köşegeni dışındaki öğelerinin sıfır olması anlamına gelir, çünkü bir
kovaryans matrisinde her enstrüman arasındaki kovaryanslar köşegen
haricinde olan öğelerde tutulur.</li>
</ol>
<p>Portföy Ağırlıklarını Hesaplamak</p>
<p>Portföy varyansını, riskini azaltmak enstrümanlar arası korelasyonu
azaltmak ile mümkün, bunu bir yana koyalım. Bir ek yöntem enstrümanlara
ayrılmış sermayeyi, yani bölüştürme ağırlıklarını optimal bir seviyeye
getirmektir. Matematiksel olarak</p>
<p><span class="math display">\[ \textrm{minimize et } w^T \Sigma w
\]</span></p>
<p><span class="math display">\[ R_p^T w = \mu, \quad w^T 1 = 1 \textrm{
şartlarına uyarak }\]</span></p>
<p>ki <span class="math inline">\(\mu\)</span> hedeflenen getiri.</p>
<p>Verimli Sınır (Efficient Frontier)</p>
<p>Markovitz’in buluşlarından biri (getirisinin standart sapması) farklı
ağırlıklar üzerinden hesaplanan portföyün riskini ve getirisini
grafiklediğinde mümkün tüm getirilerin bir sınır oluşturduğunu
görmesiydi, buna verimli sınır ismi verildi. Görsel olarak düşünürsek
herhangi verili bir risk için dikey yukarı çıkıp bu sınıra geliyoruz, ve
bu sınırdaki risk (ve onu ortaya çıkartan ağırlıklar) elde
edebileceğimiz en iyi sonuç. Altta üç şirket üzerinde bu hesabı
görebiliriz.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(<span class="st">&quot;companies.csv&quot;</span>,index_col<span class="op">=</span><span class="dv">0</span>,parse_dates<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> df.head()</span></code></pre></div>
<pre><code>                 MSFT       AAPL         KO
Date                                       
2010-01-04  26.045432  28.141855  23.509276
2010-01-05  26.053846  28.190509  23.224888
2010-01-06  25.893956  27.742101  23.216647
2010-01-07  25.624666  27.690818  23.158944
2010-01-08  25.801387  27.874915  22.730305</code></pre>
<p>Şirketler Microsoft, Apple, ve Coca-Cola.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy <span class="im">as</span> sp</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.optimize <span class="im">as</span> scopt</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.stats <span class="im">as</span> spstats</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calc_annual_returns(daily_returns):</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    grouped <span class="op">=</span> np.exp(daily_returns.groupby(<span class="kw">lambda</span> date: date.year).<span class="bu">sum</span>())<span class="op">-</span><span class="dv">1</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> grouped</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calc_portfolio_var(returns, weights):</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    sigma <span class="op">=</span> np.cov(returns.T,ddof<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    var <span class="op">=</span> (weights <span class="op">*</span> sigma <span class="op">*</span> weights.T).<span class="bu">sum</span>()</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> var</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sharpe_ratio(returns, weights, risk_free_rate <span class="op">=</span> <span class="fl">0.015</span>):</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> returns.columns.size</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    var <span class="op">=</span> calc_portfolio_var(returns, weights)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    means <span class="op">=</span> returns.mean()</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (means.dot(weights) <span class="op">-</span> risk_free_rate)<span class="op">/</span>np.sqrt(var)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> negative_sharpe_ratio_n_minus_1_stock(weights,returns,risk_free_rate):</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    weights2 <span class="op">=</span> sp.append(weights, <span class="dv">1</span><span class="op">-</span>np.<span class="bu">sum</span>(weights))</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span>sharpe_ratio(returns, weights2, risk_free_rate)</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> optimize_portfolio(returns, risk_free_rate):</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    w0 <span class="op">=</span> np.ones(returns.columns.size<span class="op">-</span><span class="dv">1</span>,dtype<span class="op">=</span><span class="bu">float</span>) <span class="op">*</span> <span class="fl">1.0</span> <span class="op">/</span> returns.columns.size</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    w1 <span class="op">=</span> scopt.fmin(negative_sharpe_ratio_n_minus_1_stock,</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>                    w0, args<span class="op">=</span>(returns, risk_free_rate))</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    final_w <span class="op">=</span> sp.append(w1, <span class="dv">1</span> <span class="op">-</span> np.<span class="bu">sum</span>(w1))</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>    final_sharpe <span class="op">=</span> sharpe_ratio(returns, final_w, risk_free_rate)</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (final_w, final_sharpe)</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> objfun(W, R, target_ret):</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>    stock_mean <span class="op">=</span> np.mean(R,axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>    port_mean <span class="op">=</span> np.dot(W,stock_mean)</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>    cov<span class="op">=</span>np.cov(R.T)</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>    port_var <span class="op">=</span> np.dot(np.dot(W,cov),W.T)</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>    penalty <span class="op">=</span> <span class="dv">2000</span><span class="op">*</span><span class="bu">abs</span>(port_mean<span class="op">-</span>target_ret)</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.sqrt(port_var) <span class="op">+</span> penalty</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calc_daily_returns(df):</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.log(df<span class="op">/</span>df.shift(<span class="dv">1</span>))</span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calc_efficient_frontier(returns):</span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>    result_means <span class="op">=</span> []</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>    result_stds <span class="op">=</span> []</span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>    result_weights <span class="op">=</span> []</span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>    means <span class="op">=</span> returns.mean()</span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>    min_mean, max_mean <span class="op">=</span> means.<span class="bu">min</span>(), means.<span class="bu">max</span>()</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>    nstocks <span class="op">=</span> returns.columns.size</span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> r <span class="kw">in</span> np.linspace(min_mean, max_mean, <span class="dv">100</span>):</span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>        weights <span class="op">=</span> np.ones(nstocks)<span class="op">/</span>nstocks</span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>    bounds <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>) <span class="cf">for</span> i <span class="kw">in</span> np.arange(nstocks)]</span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a>    constraints <span class="op">=</span> ({<span class="st">&#39;type&#39;</span>: <span class="st">&#39;eq&#39;</span>,<span class="st">&#39;fun&#39;</span>: <span class="kw">lambda</span> W: np.<span class="bu">sum</span>(W) <span class="op">-</span> <span class="dv">1</span>})</span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> scopt.minimize(objfun, weights, (returns, r),</span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a>                                 method<span class="op">=</span><span class="st">&#39;SLSQP&#39;</span>,constraints <span class="op">=</span> constraints,</span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a>                                 bounds <span class="op">=</span> bounds)</span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> results.success: <span class="cf">raise</span> <span class="pp">Exception</span>(result.message)</span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a>    result_means.append(np.<span class="bu">round</span>(r,<span class="dv">4</span>)) <span class="co"># 4 decimal places</span></span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a>    std_<span class="op">=</span>np.<span class="bu">round</span>(np.std(np.<span class="bu">sum</span>(returns<span class="op">*</span>results.x,axis<span class="op">=</span><span class="dv">1</span>)),<span class="dv">6</span>)</span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a>    result_stds.append(std_)</span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a>    result_weights.append(np.<span class="bu">round</span>(results.x, <span class="dv">5</span>))</span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {<span class="st">&#39;Means&#39;</span>: result_means, <span class="st">&#39;Stds&#39;</span>: result_stds, <span class="st">&#39;Weights&#39;</span>: result_weights}</span>
<span id="cb3-65"><a href="#cb3-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-66"><a href="#cb3-66" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calc_port_perf(w, ret, covs):</span>
<span id="cb3-67"><a href="#cb3-67" aria-hidden="true" tabindex="-1"></a>    port_ret <span class="op">=</span> np.<span class="bu">sum</span>( ret<span class="op">*</span>w )</span>
<span id="cb3-68"><a href="#cb3-68" aria-hidden="true" tabindex="-1"></a>    port_std <span class="op">=</span> np.sqrt(np.dot(w.T, np.dot(covs, w)))</span>
<span id="cb3-69"><a href="#cb3-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> port_ret, port_std</span>
<span id="cb3-70"><a href="#cb3-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-71"><a href="#cb3-71" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_all_possible_portfolios(ann_rets):</span>
<span id="cb3-72"><a href="#cb3-72" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> []</span>
<span id="cb3-73"><a href="#cb3-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1000</span>):</span>
<span id="cb3-74"><a href="#cb3-74" aria-hidden="true" tabindex="-1"></a>        w <span class="op">=</span> np.random.random(<span class="bu">len</span>(df.columns))</span>
<span id="cb3-75"><a href="#cb3-75" aria-hidden="true" tabindex="-1"></a>        w <span class="op">/=</span> np.<span class="bu">sum</span>(w)</span>
<span id="cb3-76"><a href="#cb3-76" aria-hidden="true" tabindex="-1"></a>        r,s <span class="op">=</span> calc_port_perf(w, ann_rets.mean(),ann_rets.cov())</span>
<span id="cb3-77"><a href="#cb3-77" aria-hidden="true" tabindex="-1"></a>        res.append([r,s])</span>
<span id="cb3-78"><a href="#cb3-78" aria-hidden="true" tabindex="-1"></a>    vw <span class="op">=</span> pd.DataFrame(res,columns<span class="op">=</span>[<span class="st">&#39;return&#39;</span>,<span class="st">&#39;sigma&#39;</span>])</span>
<span id="cb3-79"><a href="#cb3-79" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> vw</span>
<span id="cb3-80"><a href="#cb3-80" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-81"><a href="#cb3-81" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-82"><a href="#cb3-82" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_efficient_frontier(ef_data):</span>
<span id="cb3-83"><a href="#cb3-83" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="st">u&#39;Verimli Sınır&#39;</span>)</span>
<span id="cb3-84"><a href="#cb3-84" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">u&#39;Portföy Standart Sapması (Risk))&#39;</span>)</span>
<span id="cb3-85"><a href="#cb3-85" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">u&#39;Portföy Getirisi&#39;</span>)</span>
<span id="cb3-86"><a href="#cb3-86" aria-hidden="true" tabindex="-1"></a>    plt.plot(ef_data[<span class="st">&#39;Stds&#39;</span>], ef_data[<span class="st">&#39;Means&#39;</span>], <span class="st">&#39;--&#39;</span>)<span class="op">;</span></span></code></pre></div>
<p>Günlük getiriler,</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>daily_returns <span class="op">=</span> calc_daily_returns(df)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> daily_returns.head()</span></code></pre></div>
<pre><code>                MSFT      AAPL        KO
Date                                    
2010-01-04       NaN       NaN       NaN
2010-01-05  0.000323  0.001727 -0.012171
2010-01-06 -0.006156 -0.016034 -0.000355
2010-01-07 -0.010454 -0.001850 -0.002489
2010-01-08  0.006873  0.006626 -0.018682</code></pre>
<p>Yıllık getiri,</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>annual_returns <span class="op">=</span> calc_annual_returns(daily_returns)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> annual_returns.head()</span></code></pre></div>
<pre><code>          MSFT      AAPL        KO
2010 -0.079441  0.507219  0.189366
2011 -0.045157  0.255580  0.094586
2012  0.057989  0.325669  0.065276
2013  0.442980  0.080695  0.172330
2014  0.275646  0.406225  0.052661</code></pre>
<p>Eşit ağırlıklar üzerinden oluşturulmuş portföyün varyansı,</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>eq_weights <span class="op">=</span> np.array([<span class="dv">1</span><span class="op">/</span><span class="fl">3.</span>,<span class="dv">1</span><span class="op">/</span><span class="fl">3.</span>,<span class="dv">1</span><span class="op">/</span><span class="fl">3.</span>])</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> calc_portfolio_var(annual_returns,weights<span class="op">=</span>eq_weights)</span></code></pre></div>
<pre><code>0.00287954016535</code></pre>
<p>Sharpe Oranı</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> sharpe_ratio(annual_returns,eq_weights)</span></code></pre></div>
<pre><code>3.20109292169</code></pre>
<p>Farklı (rasgele) portföy ağırlıklarının oluşturacağı risk / getiri
grafiği,</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>vw <span class="op">=</span> plot_all_possible_portfolios(annual_returns)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>vw.plot(x<span class="op">=</span><span class="st">&#39;sigma&#39;</span>,y<span class="op">=</span><span class="st">&#39;return&#39;</span>,kind<span class="op">=</span><span class="st">&#39;scatter&#39;</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_port_04.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_port_04.png" /></p>
<p>Şimdi optimizasyon ile global bir optimal nokta bulalım,</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> optimize_portfolio(annual_returns, <span class="fl">0.0003</span>)</span></code></pre></div>
<pre><code>Optimization terminated successfully.
         Current function value: -7.829867
         Iterations: 38
         Function evaluations: 74
(array([ 0.02615542,  0.76347385,  0.21037072]), 7.8298669383774486)</code></pre>
<p>Verimli sınır,</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>frontier_data <span class="op">=</span> calc_efficient_frontier(annual_returns)</span></code></pre></div>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> frontier_data[<span class="st">&#39;Stds&#39;</span>][:<span class="dv">5</span>]</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> frontier_data[<span class="st">&#39;Means&#39;</span>][:<span class="dv">5</span>]</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> frontier_data[<span class="st">&#39;Weights&#39;</span>][:<span class="dv">5</span>]: <span class="bu">print</span> x</span></code></pre></div>
<pre><code>[0.055842999999999997, 0.053446, 0.052564, 0.051706000000000002, 0.050871]
[0.1148, 0.1169, 0.11890000000000001, 0.12089999999999999, 0.1229]
[ 0.  0.  1.]
[ 0.06407  0.00512  0.93081]
[ 0.06733  0.01497  0.9177 ]
[ 0.07228  0.02469  0.90303]
[ 0.07493  0.03458  0.89049]</code></pre>
<div class="sourceCode" id="cb18"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>vw <span class="op">=</span> plot_all_possible_portfolios(annual_returns)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>vw.plot(x<span class="op">=</span><span class="st">&#39;sigma&#39;</span>,y<span class="op">=</span><span class="st">&#39;return&#39;</span>,kind<span class="op">=</span><span class="st">&#39;scatter&#39;</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>plt.hold(<span class="va">True</span>)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>plot_efficient_frontier(frontier_data)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_port_03.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_port_03.png" /></p>
<p>Bootstrap</p>
<p>Dikkat: üstteki optimizasyonu olduğu gibi kullanmak sayısal olarak
pek ise yaramayabilir. Mesela, üç yatırım var, S&amp;P 500, NASDAQ ve 20
yıllık ABD tahvili. Bu varlıkları basit bir şekilde kullanacağız, onları
sadece alıp elde tutacağız. Eğer tek periyot (eldeki tüm veriyi)
Markowitz optimizasyonu üzerinden ağırlıkları hesaplarsak, ağırlıklar
çok ekstrem, stabil olmuyor. Çözüm için bootstrap tekniği kullanılır;
veriden ardı ardına örneklem alırız, yani veriden yeni veri yaratırız,
beklediğimiz o ki örneklemlerin dağılımı “gerçek’’ verinin dağılımı ile
benzer olacak. Bu işlemin yan etkisi veriyi fazlalaştırmak, ardından
yapılan hesabın ortalamasını alınca stabiliteye daha yaklaşmış
olmak.</p>
<p>Zaman serisinden örneklem almanın değişik yolları var, bir tanesi
blok örneklem yöntemi, kesintisiz zaman seri parçaları almak. Bir diğeri
noktalar ardı ardına olsun olmasın verinin rasgele noktalarından
örneklem toplamak. Alttaki ikinci yöntemi takip ediyor,</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> zipfile, pandas <span class="im">as</span> pd, util</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np, random, datetime</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> minimize</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_dull_pd_matrix(dullvalue<span class="op">=</span><span class="fl">0.0</span>, dullname<span class="op">=</span><span class="st">&quot;A&quot;</span>,</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>                          startdate<span class="op">=</span>pd.datetime(<span class="dv">1970</span>,<span class="dv">1</span>,<span class="dv">1</span>).date(),</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>                          enddate<span class="op">=</span>datetime.datetime.now().date(), index<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> index <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>        index<span class="op">=</span>pd.date_range(startdate, enddate)    </span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    dullvalue<span class="op">=</span>np.array([dullvalue]<span class="op">*</span><span class="bu">len</span>(index))    </span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    ans<span class="op">=</span>pd.DataFrame(dullvalue, index, columns<span class="op">=</span>[dullname])    </span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> addem(weights):</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fl">1.0</span> <span class="op">-</span> <span class="bu">sum</span>(weights)</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> variance(weights, sigma):</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (np.matrix(weights)<span class="op">*</span>sigma<span class="op">*</span>np.matrix(weights).transpose())[<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> neg_SR(weights, sigma, mus):</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>    estreturn<span class="op">=</span>(np.matrix(weights)<span class="op">*</span>mus)[<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>    std_dev<span class="op">=</span>(variance(weights,sigma)<span class="op">**</span><span class="fl">.5</span>)    </span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span>estreturn<span class="op">/</span>std_dev</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> equalise_vols(returns, default_vol):    </span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>    factors<span class="op">=</span>(default_vol<span class="op">/</span><span class="fl">16.0</span>)<span class="op">/</span>returns.std(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>    facmat<span class="op">=</span>create_dull_pd_matrix(dullvalue<span class="op">=</span>factors,</span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>                                 dullname<span class="op">=</span>returns.columns,</span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a>                                 index<span class="op">=</span>returns.index)</span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>    norm_returns<span class="op">=</span>returns<span class="op">*</span>facmat</span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>    norm_returns.columns<span class="op">=</span>returns.columns</span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> norm_returns</span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> markosolver(returns, default_vol, default_SR):        </span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a>    use_returns<span class="op">=</span>equalise_vols(returns, default_vol)    </span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>    sigma<span class="op">=</span>use_returns.cov().values</span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a>    mus <span class="op">=</span> use_returns[asset_name].mean() <span class="cf">for</span> asset_name <span class="kw">in</span> use_returns.columns</span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a>    mus<span class="op">=</span>np.array([mus], ndmin<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a>    mus<span class="op">=</span>mus.transpose()</span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a>    number_assets<span class="op">=</span>use_returns.shape[<span class="dv">1</span>]</span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a>    start_weights<span class="op">=</span>[<span class="fl">1.0</span><span class="op">/</span>number_assets]<span class="op">*</span>number_assets    </span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a>    bounds<span class="op">=</span>[(<span class="fl">0.0</span>,<span class="fl">1.0</span>)]<span class="op">*</span>number_assets</span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a>    cdict<span class="op">=</span>[{<span class="st">&#39;type&#39;</span>:<span class="st">&#39;eq&#39;</span>, <span class="st">&#39;fun&#39;</span>:addem}]    </span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a>    ans<span class="op">=</span>minimize(neg_SR, start_weights,</span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a>                 (sigma, mus),</span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true" tabindex="-1"></a>                 method<span class="op">=</span><span class="st">&#39;SLSQP&#39;</span>,</span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true" tabindex="-1"></a>                 bounds<span class="op">=</span>bounds,</span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true" tabindex="-1"></a>                 constraints<span class="op">=</span>cdict,</span>
<span id="cb19-49"><a href="#cb19-49" aria-hidden="true" tabindex="-1"></a>                 tol<span class="op">=</span><span class="fl">0.00001</span>)</span>
<span id="cb19-50"><a href="#cb19-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans[<span class="st">&#39;x&#39;</span>]</span>
<span id="cb19-51"><a href="#cb19-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-52"><a href="#cb19-52" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_fitting_dates(data, rollyears):</span>
<span id="cb19-53"><a href="#cb19-53" aria-hidden="true" tabindex="-1"></a>    start_date<span class="op">=</span>data.index[<span class="dv">0</span>]</span>
<span id="cb19-54"><a href="#cb19-54" aria-hidden="true" tabindex="-1"></a>    end_date<span class="op">=</span>data.index[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb19-55"><a href="#cb19-55" aria-hidden="true" tabindex="-1"></a>    yearstarts<span class="op">=</span><span class="bu">list</span>(pd.date_range(start_date, end_date, freq<span class="op">=</span><span class="st">&quot;12M&quot;</span>))<span class="op">+</span>[end_date]   </span>
<span id="cb19-56"><a href="#cb19-56" aria-hidden="true" tabindex="-1"></a>    periods<span class="op">=</span>[]</span>
<span id="cb19-57"><a href="#cb19-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> tidx <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(yearstarts))[<span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb19-58"><a href="#cb19-58" aria-hidden="true" tabindex="-1"></a>        period_start<span class="op">=</span>yearstarts[tidx]</span>
<span id="cb19-59"><a href="#cb19-59" aria-hidden="true" tabindex="-1"></a>        period_end<span class="op">=</span>yearstarts[tidx<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb19-60"><a href="#cb19-60" aria-hidden="true" tabindex="-1"></a>        fit_start<span class="op">=</span>start_date            </span>
<span id="cb19-61"><a href="#cb19-61" aria-hidden="true" tabindex="-1"></a>        fit_end<span class="op">=</span>period_start        </span>
<span id="cb19-62"><a href="#cb19-62" aria-hidden="true" tabindex="-1"></a>        periods.append([fit_start, fit_end, period_start, period_end])</span>
<span id="cb19-63"><a href="#cb19-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-64"><a href="#cb19-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> periods</span>
<span id="cb19-65"><a href="#cb19-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-66"><a href="#cb19-66" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bootstrap_portfolio(returns_to_bs,monte_carlo,</span>
<span id="cb19-67"><a href="#cb19-67" aria-hidden="true" tabindex="-1"></a>                        monte_length,default_vol,default_SR):</span>
<span id="cb19-68"><a href="#cb19-68" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb19-69"><a href="#cb19-69" aria-hidden="true" tabindex="-1"></a>    weightlist<span class="op">=</span>[]</span>
<span id="cb19-70"><a href="#cb19-70" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> unused_index <span class="kw">in</span> <span class="bu">range</span>(monte_carlo):</span>
<span id="cb19-71"><a href="#cb19-71" aria-hidden="true" tabindex="-1"></a>        bs_idx<span class="op">=</span>[<span class="bu">int</span>(random.uniform(<span class="dv">0</span>,<span class="dv">1</span>)<span class="op">*</span><span class="bu">len</span>(returns_to_bs)) <span class="op">\</span></span>
<span id="cb19-72"><a href="#cb19-72" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(monte_length)]        </span>
<span id="cb19-73"><a href="#cb19-73" aria-hidden="true" tabindex="-1"></a>        returns<span class="op">=</span>returns_to_bs.iloc[bs_idx,:] </span>
<span id="cb19-74"><a href="#cb19-74" aria-hidden="true" tabindex="-1"></a>        weight<span class="op">=</span>markosolver(returns, default_vol<span class="op">=</span>default_vol, default_SR<span class="op">=</span>default_SR)</span>
<span id="cb19-75"><a href="#cb19-75" aria-hidden="true" tabindex="-1"></a>        weightlist.append(weight)</span>
<span id="cb19-76"><a href="#cb19-76" aria-hidden="true" tabindex="-1"></a>     </span>
<span id="cb19-77"><a href="#cb19-77" aria-hidden="true" tabindex="-1"></a>    theweights_mean<span class="op">=</span><span class="bu">list</span>(np.mean(weightlist, axis<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb19-78"><a href="#cb19-78" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> theweights_mean</span>
<span id="cb19-79"><a href="#cb19-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-80"><a href="#cb19-80" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> optimise_over_periods(data,rollyears, monte_carlo,monte_length):</span>
<span id="cb19-81"><a href="#cb19-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-82"><a href="#cb19-82" aria-hidden="true" tabindex="-1"></a>    fit_periods<span class="op">=</span>generate_fitting_dates(data, rollyears<span class="op">=</span>rollyears)    </span>
<span id="cb19-83"><a href="#cb19-83" aria-hidden="true" tabindex="-1"></a>    weight_list<span class="op">=</span>[]</span>
<span id="cb19-84"><a href="#cb19-84" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> fit_tuple <span class="kw">in</span> fit_periods:</span>
<span id="cb19-85"><a href="#cb19-85" aria-hidden="true" tabindex="-1"></a>        period_subset_data<span class="op">=</span>data[fit_tuple[<span class="dv">0</span>]:fit_tuple[<span class="dv">1</span>]]        </span>
<span id="cb19-86"><a href="#cb19-86" aria-hidden="true" tabindex="-1"></a>        weights<span class="op">=</span>bootstrap_portfolio(period_subset_data,</span>
<span id="cb19-87"><a href="#cb19-87" aria-hidden="true" tabindex="-1"></a>                                    monte_carlo<span class="op">=</span>monte_carlo,</span>
<span id="cb19-88"><a href="#cb19-88" aria-hidden="true" tabindex="-1"></a>                                    monte_length<span class="op">=</span>monte_length,</span>
<span id="cb19-89"><a href="#cb19-89" aria-hidden="true" tabindex="-1"></a>                                    default_vol<span class="op">=</span><span class="fl">0.2</span>, default_SR<span class="op">=</span><span class="fl">1.0</span> )</span>
<span id="cb19-90"><a href="#cb19-90" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb19-91"><a href="#cb19-91" aria-hidden="true" tabindex="-1"></a>        dindex<span class="op">=</span>[fit_tuple[<span class="dv">2</span>]<span class="op">+</span>datetime.timedelta(seconds<span class="op">=</span><span class="dv">1</span>),</span>
<span id="cb19-92"><a href="#cb19-92" aria-hidden="true" tabindex="-1"></a>                fit_tuple[<span class="dv">3</span>]<span class="op">-</span>datetime.timedelta(seconds<span class="op">=</span><span class="dv">1</span>)] </span>
<span id="cb19-93"><a href="#cb19-93" aria-hidden="true" tabindex="-1"></a>        weight_row<span class="op">=</span>pd.DataFrame([weights]<span class="op">*</span><span class="dv">2</span>,</span>
<span id="cb19-94"><a href="#cb19-94" aria-hidden="true" tabindex="-1"></a>                                index<span class="op">=</span>dindex,</span>
<span id="cb19-95"><a href="#cb19-95" aria-hidden="true" tabindex="-1"></a>                                columns<span class="op">=</span>data.columns) </span>
<span id="cb19-96"><a href="#cb19-96" aria-hidden="true" tabindex="-1"></a>        weight_list.append(weight_row)</span>
<span id="cb19-97"><a href="#cb19-97" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb19-98"><a href="#cb19-98" aria-hidden="true" tabindex="-1"></a>    weight_df<span class="op">=</span>pd.concat(weight_list, axis<span class="op">=</span><span class="dv">0</span>)    </span>
<span id="cb19-99"><a href="#cb19-99" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> weight_df</span></code></pre></div>
<div class="sourceCode" id="cb20"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> zipfile, pandas <span class="im">as</span> pd, random</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>symbols <span class="op">=</span> [<span class="st">&#39;SP500&#39;</span>,<span class="st">&#39;NASDAQ&#39;</span>,<span class="st">&#39;US20&#39;</span>]</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame()</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> zipfile.ZipFile(<span class="st">&#39;../tser_voltar/legacycsv.zip&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> z:</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> symbol <span class="kw">in</span> symbols:</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>        f <span class="op">=</span> <span class="st">&#39;</span><span class="sc">%s</span><span class="st">_price.csv&#39;</span> <span class="op">%</span> symbol</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>        df[symbol] <span class="op">=</span> pd.read_csv(z.<span class="bu">open</span>(f),sep<span class="op">=</span><span class="st">&#39;,&#39;</span>,</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>                                 index_col<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>                                 parse_dates<span class="op">=</span><span class="va">True</span>)[<span class="st">&#39;PRICE&#39;</span>]</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;SP500&#39;</span>] <span class="op">=</span> df.SP500.pct_change()</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;NASDAQ&#39;</span>] <span class="op">=</span> df.NASDAQ.pct_change()</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;US20&#39;</span>] <span class="op">=</span> df.US20.pct_change()</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df[(df.index <span class="op">&gt;=</span> <span class="st">&#39;1999-08-02&#39;</span>) <span class="op">&amp;</span> (df.index <span class="op">&lt;=</span> <span class="st">&#39;2015-04-22&#39;</span>)]</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>random.seed(<span class="dv">0</span>)</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>w<span class="op">=</span>boot.optimise_over_periods(df)</span></code></pre></div>
<div class="sourceCode" id="cb21"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>w.plot()</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_port_01.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_port_01.png" /></p>
<p>Bu sonuç [1. sf. 172]’dakine yakın, ağırlıklar çok daha stabil.</p>
<p>Kodda oynaklığın standardize edildiğine dikkat; tüm zaman serilerinin
oynaklığı eşitleniyor, ve maksimize edilmeye uğraşılan getiri.</p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
