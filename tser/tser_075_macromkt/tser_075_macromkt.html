<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>

  <title>Makro Bilgisi ve Piyasaların Gidişatının Bağlantısı</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  
  
  
  
</head>
<body>
<h1 id="makro-bilgisi-ve-piyasaların-gidişatının-bağlantısı">Makro Bilgisi ve Piyasaların Gidişatının Bağlantısı</h1>
<p>Hedgeye kuruluşunun CEO'su Keith Mccollough (KM) başlangıç olarak iki değişkene bakarak genel olarak hangi varlıklara, ne zaman yatırım yapılması gerektiğine karar verebilmekte. Bu iki değişken enflasyon ve ekonomik büyümedir. Fakat önemli bir nokta KM bu değişkenlerin ikinci türevine bakıyor, yani değişimin değişimine, ya da değişim hızına (rate of change). Fizikle alakalandırmak gerekirse enflasyonun &quot;ivmesinden'' ya da &quot;frenlemesinden (ters ivme)'' bahsediyor mesela ki ivme ikinci türevdir (mesafenin zamana göre türevi hız, onun türevi ivme). Niye ikinci türev? Çünkü KM tarihi veriye bakarak bulmuştur ki enflasyon ve büyümenin değişim hızı senetlerin, o dönemdeki tahvillerin, senetlerin getirisi ile çok yakından bağlantılıdır.</p>
<p>Değişimin değişimini KM şu şekilde hesaplıyor: ilk türev yıl-üzeri-yıl (year-over-year, YoY) üzerinden yani, mesela, bir çeyrek için büyüme yüzdesi hesaplanacaksa bu aynı senedeki bir önceki çeyreğe değil, 1 sene önceki aynı çeyreğe bakılarak yapılıyor. Böylece elmaları elmalar ile karşılaştırmış oluruz, mevsimsel farklılıklar hakkında endiselenmek gerekmez. Eğer 2010 senesindeki 4. çeyrek, 3. çeyrekten büyük ise, belki bu büyüklük kış sezonunda bazı eylemlerin hep daha fazla olmasindan ileri geliyordur, yani büyüme &quot;gerçek'' değil sezonsaldır. Ama 2010 4. çeyreği 2009 4. çeyreği ile karşılaştırırsak bu mevsimsel farklılıkları hesaba almamış oluruz. Bu birinci türev. Bu zaman serisi hesaplandıktan sonra ikinci ikinci fark / türev hesabı bir önceki öğeye bakarak klasik şekilde yapılabilir.</p>
<p>Enflasyon aynı şekilde, YoY, sonra klasik fark.</p>
<p>Genel olarak düşünmek gerekirse KM makro değişkenlerini, ekonomiyi çevrimsel / dönemsel (cycliç) olarak görüyor, aynen bir yılın mevsimleri olduğu gibi. İnen bir süre sonra aşağı inmek zorundadır, düşen bir süre sonra yukarı çıkmak zorundadır. Bu bir çember görüntüsü kafamızda oluşturabilir, ya da zaman indisini de hesaba katarsak sağa doğru açılmış bir çember, yani bir sinüs eğrisinden bahsediyoruz. Her değişken KM'e göre bir sinüs eğrisinde hareket etmektedir; enflasyon ve büyüme sinüs eğrilerinin de tabii kendine has parametreleri olabilir, bazıları daha geniştir belki bazıları daha dardır, genliği kimisinin daha yüksektir. Farklı ülkelerin büyümeleri de farklı eğrilerde olacaktır. Ama KM tüm değişkenleri sinüste farzeder. O zaman metodun yaptığı bir değişkenin ikinci türevine bakarak sinüs eğrisinin neresinde olduğunu anlamaya uğraşmaktır. Bu anlayışın getirdiği ilk rapor altta.</p>
<p>ABD verisi üzerinde uygulayalım,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pandas <span class="im">as</span> pd

df1 <span class="op">=</span> pd.read_csv(<span class="st">&#39;quandl-gdp.csv&#39;</span>,index_col<span class="op">=</span><span class="dv">0</span>,parse_dates<span class="op">=</span><span class="va">True</span>)
df2 <span class="op">=</span> pd.read_csv(<span class="st">&#39;quandl-inf.csv&#39;</span>,index_col<span class="op">=</span><span class="dv">0</span>,parse_dates<span class="op">=</span><span class="va">True</span>)

df1[<span class="st">&#39;gdpyoy&#39;</span>] <span class="op">=</span> (df1.Value <span class="op">-</span> df1.Value.shift(<span class="dv">4</span>)) <span class="op">/</span> df1.Value.shift(<span class="dv">4</span>) <span class="op">*</span> <span class="fl">100.0</span>
<span class="kw">def</span> f(x):
    <span class="cf">if</span> x.name.month <span class="op">==</span> <span class="dv">4</span>: <span class="cf">return</span> <span class="st">&quot;</span><span class="sc">%d%s</span><span class="st">&quot;</span> <span class="op">%</span> (x.name.year,<span class="st">&quot;Q1&quot;</span>)
    <span class="cf">elif</span> x.name.month <span class="op">==</span> <span class="dv">7</span>: <span class="cf">return</span> <span class="st">&quot;</span><span class="sc">%d%s</span><span class="st">&quot;</span> <span class="op">%</span> (x.name.year, <span class="st">&quot;Q2&quot;</span>)
    <span class="cf">elif</span> x.name.month <span class="op">==</span> <span class="dv">10</span>: <span class="cf">return</span> <span class="st">&quot;</span><span class="sc">%d%s</span><span class="st">&quot;</span> <span class="op">%</span> (x.name.year, <span class="st">&quot;Q3&quot;</span>)
    <span class="cf">elif</span> x.name.month <span class="op">==</span> <span class="dv">1</span>: <span class="cf">return</span> <span class="st">&quot;</span><span class="sc">%d%s</span><span class="st">&quot;</span> <span class="op">%</span> (x.name.year<span class="dv">-1</span>, <span class="st">&quot;Q4&quot;</span>)

df1[<span class="st">&#39;Q&#39;</span>] <span class="op">=</span> df1.<span class="bu">apply</span>(f, axis<span class="op">=</span><span class="dv">1</span>)
<span class="bu">print</span> (df1[[<span class="st">&#39;gdpyoy&#39;</span>,<span class="st">&#39;Q&#39;</span>]].tail(<span class="dv">3</span>))

df2[<span class="st">&#39;cpi&#39;</span>] <span class="op">=</span> df2.resample(<span class="st">&#39;Q&#39;</span>)[[<span class="st">&#39;Value&#39;</span>]].mean()
df2c <span class="op">=</span> df2.dropna()

<span class="kw">def</span> f(x):
    <span class="cf">if</span> x.name.month <span class="op">==</span> <span class="dv">3</span>: <span class="cf">return</span> <span class="st">&quot;</span><span class="sc">%d%s</span><span class="st">&quot;</span> <span class="op">%</span> (x.name.year,<span class="st">&quot;Q1&quot;</span>)
    <span class="cf">elif</span> x.name.month <span class="op">==</span> <span class="dv">6</span>: <span class="cf">return</span> <span class="st">&quot;</span><span class="sc">%d%s</span><span class="st">&quot;</span> <span class="op">%</span> (x.name.year, <span class="st">&quot;Q2&quot;</span>)
    <span class="cf">elif</span> x.name.month <span class="op">==</span> <span class="dv">9</span>: <span class="cf">return</span> <span class="st">&quot;</span><span class="sc">%d%s</span><span class="st">&quot;</span> <span class="op">%</span> (x.name.year, <span class="st">&quot;Q3&quot;</span>)
    <span class="cf">elif</span> x.name.month <span class="op">==</span> <span class="dv">12</span>: <span class="cf">return</span> <span class="st">&quot;</span><span class="sc">%d%s</span><span class="st">&quot;</span> <span class="op">%</span> (x.name.year, <span class="st">&quot;Q4&quot;</span>)

df2c[<span class="st">&#39;Q&#39;</span>] <span class="op">=</span> df2c.<span class="bu">apply</span>(f, axis<span class="op">=</span><span class="dv">1</span>)
<span class="bu">print</span> (df2c[[<span class="st">&#39;cpi&#39;</span>,<span class="st">&#39;Q&#39;</span>]].tail(<span class="dv">3</span>))
<span class="bu">print</span> (df2c.tail(<span class="dv">3</span>))</code></pre></div>
<pre><code>              gdpyoy       Q
Date                        
2018-01-01  2.580414  2017Q4
2018-04-01  2.869807  2018Q1
2018-07-01  3.039632  2018Q2
                 cpi       Q
Date                        
2018-03-31  2.214333  2018Q1
2018-06-30  2.712000  2018Q2
2018-09-30  2.642000  2018Q3
            Value   ...         Q
Date                ...          
2018-03-31  2.360   ...    2018Q1
2018-06-30  2.872   ...    2018Q2
2018-09-30  2.277   ...    2018Q3

[3 rows x 3 columns]</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df <span class="op">=</span> df1[[<span class="st">&#39;gdpyoy&#39;</span>,<span class="st">&#39;Q&#39;</span>]].merge(df2c[[<span class="st">&#39;cpi&#39;</span>,<span class="st">&#39;Q&#39;</span>]], on<span class="op">=</span><span class="st">&#39;Q&#39;</span>)
df[<span class="st">&#39;gdpyoy&#39;</span>] <span class="op">=</span> df.gdpyoy.shift(<span class="dv">1</span>)
df[<span class="st">&#39;gdpdiff&#39;</span>] <span class="op">=</span> df.gdpyoy.diff()
df[<span class="st">&#39;cpidiff&#39;</span>] <span class="op">=</span> df.cpi.diff()
df <span class="op">=</span> df.dropna()</code></pre></div>
<p>Değişim hızını üstteki şekilde elde edince şimdi çok önemli bir raporu ortaya çıkarmak mümkün. İki değişken +, -, yani ivmeleneme, frenleme üzerinden 4 farklı şekilde kombine edilebilir; hem büyümede hem enflasyonda ivme vardır, ya da büyümede ivme enflasyonda fren vardır, vs. bu dört kombinasyonu Quad (Bölge) 1, Quad 2, Quad 3, .. diye ayrılır. KM her quad'ın kendine has özellikleri, yatırım usulleri olduğunu söyler (çünkü geçmise dönük analizi ona bu fikri vermiştir).</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> random
plt.xlim(<span class="op">-</span><span class="fl">1.0</span>,<span class="fl">1.0</span>)
plt.ylim(<span class="op">-</span><span class="fl">1.0</span>,<span class="fl">1.0</span>)
plt.grid()
res <span class="op">=</span> df[[<span class="st">&#39;Q&#39;</span>,<span class="st">&#39;cpidiff&#39;</span>,<span class="st">&#39;gdpdiff&#39;</span>]].tail(<span class="dv">14</span>)
<span class="cf">for</span> (q,x,y) <span class="kw">in</span> np.array(res):
    plt.plot(x,y,<span class="st">&#39;rd&#39;</span>)
    xa <span class="op">=</span> random.choice(np.linspace(<span class="dv">0</span>,<span class="fl">0.05</span>,<span class="dv">3</span>))
    plt.text(x<span class="op">+</span>xa,y<span class="op">+</span>xa,q)
plt.savefig(<span class="st">&#39;tser_macromkt_03.png&#39;</span>)    </code></pre></div>
<div class="figure">
<img src="tser_macromkt_03.png" />

</div>
<p>Geçmişe dönük Quad'ların nerede olduğunu görüyoruz. Quad 1 iyi, Quad 2 çok iyi. Her iki durumda da büyüme yukarı çıkıyor. Quad 2'de büyüme ve enflasyon aynı anda yukarı çıkıyor. Bu bölgede herşey kazanıyor, tek istisnalar altın, tahviller ve dolar. Kıyasla Quad 4'te büyüme ve enflasyon aynı anda aşağı iniyor, burada dolar, aşağı beta defansif hisseler, günlük ihtiyaçlara hitap eden şirketler (enerji, alışveriş, vs), tahviller. Satılacaklar momentum, büyüme, ve Google, Microsoft gibi teknoloji şirketleri.</p>
<p>Not: Beta bir senetin tüm borsaya nazaran oynaklığıyla alakalı, borsadaki tüm senetler üzerinden hesaplanan oynaklık sayısı 1 kabul edilir, bunun altında (kat bağlamında) olan her diğer senet oynaklığı bu beta biriminden raporlanır. Mesela bir senetin oynaklığı borsa oynaklığının iki katıysa ona &quot;2 beta'' senedi denir, yarısıysa &quot;0.5 beta''.</p>
<p>Quad 3 stagflasyon. Bu noktaya çoğunlukla Quad 4'te olduğunu farkeden merkez bankaları yüzünden gelinir. Merkez bankacı panikleyerek kuru devalue eder, değerini indirir, ve &quot;varlık fiyatı enflasyonu'' yaratırlar, senetlerde, emlak piyasasında mesela. Çinliler bunu 2018'de yaptılar, Quad 4'teydiler, yuan'ı yüzde 4 devalüe ettiler, ve varlıklarda enflasyon pompalayarak &quot;büyüme hayali'' yarattılar, ama sonucunda ekonomik stagflasyona mahkum oldular.</p>
<p>Quad 2 ile Quad 4 birbirinin neredeyse tam zıttı. Birinde iyi olan diğerinde kötü, ve diğer şekilde.</p>
<p>Enflasyon ve büyüme bu kadar önemli kararları etkilediği için onları tahmin edebilen makro geleceği tahmin eder, ve Hedgeye şirketi bu ise müthiş odaklıdır. Aslında kabaca düşününce bu tahminin imkansız olmayacağı anlaşılır, eğer sinüs eğrisinin neresinde olacağımızı tahmin etmeye uğraşıyorsak, bunu nerede olduğumüza, nereden geldiğimize bakarak yapabilmemiz gerekir. HE hakikaten YoY verisinden geriye bakarak ortalamaya dönüş zamanını, işaret değişimini tahmin edebiliyor. Tam değişim hızı tahmini için 30 tane makro faktörü kullanarak bir başka regresyon yapıyorlar [10].</p>
<p>İma Edilen Oynaklık (İmplied Volatility)</p>
<p>HE sistemi Quad'lara ek olarak gerçek / tarihi ve ima edilen oynaklık [5,6,7] arasındaki ilişkiye bakarak ta işlem yapıyor. İma edilen oynaklık gelecekteki oynaklıktır. Fakat gelecekteki oynaklığı nasıl tahmin edeceğiz?</p>
<p>Belki başkalarının yaptığı tahmini kullanarak kendi tahminimizi oluştururuz. Ekler bölümünde opsiyonları anlattık; <span class="math inline">\(\sigma\)</span> tahmininin Black-Scholes formülüne dışarıdan verilerek opsiyon fiyatlaması yapıldığını biliyoruz. Biz bu sistematiği tersine çevirerek başkalarının hesapladığı / verdiği / yayınladığı opsiyon fiyatlarından geriye giderek ima edilen oynaklığı elde edecegiz.</p>
<p>B-S formülünün kendisinin türetilmesine burada girmeyeceğiz, onu sadece şu şekilde gösterelim,</p>
<p><span class="math display">\[
V = BS(S,K,r,T,\sigma)
\]</span></p>
<p>ki <span class="math inline">\(S\)</span> o andaki senet fiyatı, <span class="math inline">\(K\)</span> kullanım (strike) fıyatı, <span class="math inline">\(r\)</span> risksiz faiz oranı, <span class="math inline">\(T\)</span> ise opsiyonun bitişine kadar geçecek zaman. Dikkat edersek <span class="math inline">\(\sigma\)</span> haricindeki tüm parametreler biliniyor.</p>
<p>Bir örnek üzerinde görelim, piyasada mevcut opsiyonlara baktığımızda GOOG (Google) için 18 Ekim 2014'te biten bir opsiyon görüyoruz, kullanım fiyatı $585, teklif fiyatı $17.50. Yani <span class="math inline">\(V,K,T\)</span> elimizde. Bugünkü (opsiyon bitişinden kabaca bir ay önce, 9 Eylül) senet fiyatlarına bakıyoruz, GOOG $586.08 seviyesinde, bu da <span class="math inline">\(S\)</span>. Risksiz faiz <span class="math inline">\(r\)</span> için 4 haftalık tahvil faizlerine bakabiliriz, ki o da şu anda %0.02 seviyesinde. Bu verilerle</p>
<p><span class="math display">\[ V = BS(S,K,r,T,\sigma) \]</span></p>
<p><span class="math display">\[ 17.50 = BS(586.08, 585.00, 0.0002, 0.10958.., \sigma)\]</span></p>
<p>Şimdi elimizde tek bilinmeyen <span class="math inline">\(\sigma\)</span>. Fiyatlandırmayı yapan kuruluşlar tabii ki oraya bir değer girerek 17.50 fiyatını bulmuşlar, biz <span class="math inline">\(\sigma\)</span> harici bilinen tüm parametreleri kullanıp tek bilinmeyen <span class="math inline">\(\sigma\)</span>'yi bulmaya uğraşacağız [8].</p>
<p>Ne yazık ki B-S denklemini cebirsel olarak tekrar düzenleyip <span class="math inline">\(\sigma\)</span>'yı eşitliğin bir tarafında tek başına bırakmak analitik olarak mümkün değil. Ama sayısal kök bulma yöntemlerini kullanabiliriz. Bu yöntemlerden Newton'un yöntemini [11] yazısında gördük. Bir <span class="math inline">\(f(x)\)</span> için <span class="math inline">\(f(x)=0\)</span> sonucunu verecek <span class="math inline">\(x\)</span> değerlerini bulmak kök bulmaktır. Tabii üstteki problemde sıfıra değil, belli bir sabit değere olan eşitlik var, <span class="math inline">\(f(x) = a\)</span> gibi, ama bu önemli değil, bu problemi sıfıra eşitliği baz alan kök bulmaya çevirebiliriz, <span class="math inline">\(g(x) = a-f(x) = 0\)</span> ile mesela. Ardından Newton yöntemini yine olduğu gibi, <span class="math inline">\(g\)</span> üzerinde kullanırız,</p>
<p><span class="math display">\[
x_{n+1} = x_n - \frac{g(x_n)}{g&#39;(x_n)}
\]</span></p>
<p>ya da</p>
<p><span class="math display">\[
x_{n+1} = x_n - \frac{a-f(x_n)}{f&#39;(x_n)}
\]</span></p>
<p>Peki türev <span class="math inline">\(g&#39;(x)\)</span> nereden geliyor? B-S türetimini bilenler oynaklığa göre <span class="math inline">\(g(x)\)</span>'nin türevinin &quot;vega fonksiyonu'' olduğunu bilirler. Bu fonksiyon B-S matematiği içinde bilinen, standart bir fonksiyon.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> scipy.stats <span class="im">import</span> norm
<span class="im">import</span> datetime, numpy <span class="im">as</span> np

<span class="kw">def</span> find_vol(target_value, call_put, S, K, T, r):
    MAX_ITERATIONS <span class="op">=</span> <span class="dv">100</span>
    PRECISION <span class="op">=</span> <span class="fl">1.0e-5</span>

    sigma <span class="op">=</span> <span class="fl">0.5</span>
    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, MAX_ITERATIONS):
        price <span class="op">=</span> bs_price(call_put, S, K, T, r, sigma)
        vega <span class="op">=</span> bs_vega(call_put, S, K, T, r, sigma)
        diff <span class="op">=</span> target_value <span class="op">-</span> price  <span class="co"># our root</span>

        <span class="bu">print</span> (i, sigma, diff)

        <span class="cf">if</span> (<span class="bu">abs</span>(diff) <span class="op">&lt;</span> PRECISION): <span class="cf">return</span> sigma
        sigma <span class="op">=</span> sigma <span class="op">+</span> diff<span class="op">/</span>vega <span class="co"># f(x) / f&#39;(x)</span>

    <span class="cf">return</span> sigma


n <span class="op">=</span> norm.pdf
N <span class="op">=</span> norm.cdf

<span class="kw">def</span> bs_price(cp_flag,S,K,T,r,v,q<span class="op">=</span><span class="fl">0.0</span>):
    d1 <span class="op">=</span> (np.log(S<span class="op">/</span>K)<span class="op">+</span>(r<span class="op">+</span>v<span class="op">*</span>v<span class="op">/</span><span class="fl">2.</span>)<span class="op">*</span>T)<span class="op">/</span>(v<span class="op">*</span>np.sqrt(T))
    d2 <span class="op">=</span> d1<span class="op">-</span>v<span class="op">*</span>np.sqrt(T)
    <span class="cf">if</span> cp_flag <span class="op">==</span> <span class="st">&#39;c&#39;</span>:
        price <span class="op">=</span> S<span class="op">*</span>np.exp(<span class="op">-</span>q<span class="op">*</span>T)<span class="op">*</span>N(d1)<span class="op">-</span>K<span class="op">*</span>np.exp(<span class="op">-</span>r<span class="op">*</span>T)<span class="op">*</span>N(d2)
    <span class="cf">else</span>:
        price <span class="op">=</span> K<span class="op">*</span>np.exp(<span class="op">-</span>r<span class="op">*</span>T)<span class="op">*</span>N(<span class="op">-</span>d2)<span class="op">-</span>S<span class="op">*</span>np.exp(<span class="op">-</span>q<span class="op">*</span>T)<span class="op">*</span>N(<span class="op">-</span>d1)
    <span class="cf">return</span> price

<span class="kw">def</span> bs_vega(cp_flag,S,K,T,r,v,q<span class="op">=</span><span class="fl">0.0</span>):
    d1 <span class="op">=</span> (np.log(S<span class="op">/</span>K)<span class="op">+</span>(r<span class="op">+</span>v<span class="op">*</span>v<span class="op">/</span><span class="fl">2.</span>)<span class="op">*</span>T)<span class="op">/</span>(v<span class="op">*</span>np.sqrt(T))
    <span class="cf">return</span> S <span class="op">*</span> np.sqrt(T)<span class="op">*</span>n(d1)

<span class="kw">def</span> test1():
    
    V_market <span class="op">=</span> <span class="fl">17.5</span>
    K <span class="op">=</span> <span class="dv">585</span>
    T <span class="op">=</span> (datetime.date(<span class="dv">2014</span>,<span class="dv">10</span>,<span class="dv">18</span>) <span class="op">-</span> datetime.date(<span class="dv">2014</span>,<span class="dv">9</span>,<span class="dv">8</span>)).days <span class="op">/</span> <span class="fl">365.</span>
    S <span class="op">=</span> <span class="fl">586.08</span>
    r <span class="op">=</span> <span class="fl">0.0002</span>
    cp <span class="op">=</span> <span class="st">&#39;c&#39;</span> <span class="co"># call option</span>
    
    implied_vol <span class="op">=</span> find_vol(V_market, cp, S, K, T, r)
    
    <span class="bu">print</span> (<span class="st">&#39;Ima edilen oynaklik (implied vol): </span><span class="sc">%.2f%%</span><span class="st">&#39;</span> <span class="op">%</span> (implied_vol <span class="op">*</span> <span class="dv">100</span>))
    
    <span class="bu">print</span> (<span class="st">&#39;Piyasa fiyat (market price) = </span><span class="sc">%.2f</span><span class="st">&#39;</span> <span class="op">%</span> V_market)
    <span class="bu">print</span> (<span class="st">&#39;Model fiyati (model price) = </span><span class="sc">%.2f</span><span class="st">&#39;</span> <span class="op">%</span> bs_price(cp, S, K, T, r, implied_vol))

test1()</code></pre></div>
<pre><code>0 0.5 -21.669539271534063
1 0.21879739316064523 0.03217154881230044
2 0.21921383628613422 1.9891615465894574e-08
Ima edilen oynaklik (implied vol): 21.92%
Piyasa fiyat (market price) = 17.50
Model fiyati (model price) = 17.50</code></pre>
<p>Bir sonuç bulduk. Şimdi opsiyona baktığımızdaki gerçek oynaklık ile bir ay sonrasındaki gerçek oynaklığı karşılaştıralım. Acaba ima edilen oynaklığın geleceği tahmin edici kuvveti var mı?</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pandas <span class="im">as</span> pd
df <span class="op">=</span> pd.read_csv(<span class="st">&#39;GOOG.csv&#39;</span>)
<span class="bu">print</span> (<span class="bu">len</span>(df))
<span class="bu">print</span> (<span class="st">&#39;8 eyluldeki gercek oynaklik&#39;</span>, np.std(df[<span class="st">&#39;Close&#39;</span>].head(<span class="dv">252</span>).pct_change()) <span class="op">*</span> np.sqrt(<span class="dv">252</span>))
<span class="bu">print</span> (<span class="st">&#39;18 ekimdeki gercek oynaklik&#39;</span>, np.std(df[<span class="st">&#39;Close&#39;</span>].tail(<span class="dv">252</span>).pct_change()) <span class="op">*</span> np.sqrt(<span class="dv">252</span>))</code></pre></div>
<pre><code>281
8 eyluldeki gercek oynaklik 0.24023589641421986
18 ekimdeki gercek oynaklik 0.20560500728697875</code></pre>
<p>Yüzde 24'ten yüzde 20'ye bir iniş var, ve üstteki hesaptan da tahmin olarak yüzde 22 elde ettik, yani orada da bir iniş tahmin edildi.</p>
<p>Not:</p>
<p>Altta daha önce Yahoo finans servisinen indirilmiş opsiyon verisi üzerinde bazı işlemleri görüyoruz. Bunları referans amaçlı burada tutuyoruz. Dikkat edersek veride <code>İV</code> adında bir kolon var, bu kolon ima edilen oynaklık olarak gösterilir. Ne kadar gerçeği yansıtıyor bilmiyoruz, ama aklımızda olsun, bu kolonu da belki olduğu gibi kullanmak mümkündür.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pandas <span class="im">as</span> pd
<span class="im">import</span> numpy <span class="im">as</span> np
<span class="im">from</span> datetime <span class="im">import</span> datetime
<span class="im">from</span> datetime <span class="im">import</span> date
<span class="im">import</span> pandas_datareader.data <span class="im">as</span> web

pd.set_option(<span class="st">&#39;display.notebook_repr_html&#39;</span>, <span class="va">False</span>)
pd.set_option(<span class="st">&#39;display.max_columns&#39;</span>, <span class="dv">7</span>)
pd.set_option(<span class="st">&#39;display.max_rows&#39;</span>, <span class="dv">10</span>) 
pd.set_option(<span class="st">&#39;display.width&#39;</span>, <span class="dv">82</span>) 
pd.set_option(<span class="st">&#39;precision&#39;</span>, <span class="dv">3</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">aapl_options <span class="op">=</span> pd.read_csv(<span class="st">&#39;aapl_options.csv&#39;</span>,  parse_dates<span class="op">=</span>[<span class="st">&#39;Expiry&#39;</span>])
aapl_options[<span class="st">&#39;IV&#39;</span>].tail(<span class="dv">4</span>)

aos <span class="op">=</span> aapl_options.sort_values([<span class="st">&#39;Expiry&#39;</span>, <span class="st">&#39;Strike&#39;</span>])[[<span class="st">&#39;Expiry&#39;</span>, <span class="st">&#39;Strike&#39;</span>, <span class="st">&#39;Type&#39;</span>, <span class="st">&#39;IV&#39;</span>, <span class="st">&#39;Bid&#39;</span>, <span class="st">&#39;Ask&#39;</span>, <span class="st">&#39;Underlying_Price&#39;</span>]] 
aos[<span class="st">&#39;IV&#39;</span>] <span class="op">=</span> aos[<span class="st">&#39;IV&#39;</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: <span class="bu">float</span>(x.strip(<span class="st">&#39;%&#39;</span>)))
aos[:<span class="dv">5</span>]

aos[<span class="st">&#39;Expiry&#39;</span>].unique()

aos.loc[<span class="dv">158</span>]

calls1 <span class="op">=</span> aos[(aos.Expiry<span class="op">==</span><span class="st">&#39;2015-02-27&#39;</span>) <span class="op">&amp;</span> (aos.Type<span class="op">==</span><span class="st">&#39;call&#39;</span>)]
calls1[:<span class="dv">5</span>]</code></pre></div>
<pre><code>Out[1]: 
        Expiry  Strike  Type      IV    Bid    Ask  Underlying_Price
158 2015-02-27    75.0  call  271.88  53.60  53.85            128.79
190 2015-02-27    80.0  call  225.78  48.65  48.80            128.79
226 2015-02-27    85.0  call  199.22  43.65  43.80            128.79
265 2015-02-27    90.0  call  175.00  38.65  38.80            128.79
303 2015-02-27    93.0  call  160.16  35.65  35.80            128.79</code></pre>
<p>Kaynaklar</p>
<p>[1] Hedgeye, Ana Ders, <a href="www.youtube.com/watch?v=hS-JOXZrcdU" class="uri">www.youtube.com/watch?v=hS-JOXZrcdU</a></p>
<p>[2] Hedgeye, Ana Ders, <a href="www.youtube.com/watch?v=2NvNGAIvcb0" class="uri">www.youtube.com/watch?v=2NvNGAIvcb0</a></p>
<p>[3] Hedgeye, Ana Ders, <a href="youtu.be/V-uoyDj0tKs" class="uri">youtu.be/V-uoyDj0tKs</a></p>
<p>[4] Hedgeye, Ana Ders, <a href="youtu.be/27SQ5mYf38k" class="uri">youtu.be/27SQ5mYf38k</a></p>
<p>[5] Hedgeye, Oynaklik, <a href="youtube.com/watch?v=FwpckOfUyRk" class="uri">youtube.com/watch?v=FwpckOfUyRk</a></p>
<p>[6] Hedgeye, Oynaklik, <a href="youtube.com/watch?v=-WJtepxbQbE" class="uri">youtube.com/watch?v=-WJtepxbQbE</a></p>
<p>[7] Hedgeye, Oynaklik, <a href="youtube.com/watch?v=USrojq9tgzs" class="uri">youtube.com/watch?v=USrojq9tgzs</a></p>
<p>[8] Codeandfinance, <em>Finding implied volatility</em>, <a href="http://www.codeandfinance.com/finding-implied-vol.html" class="uri">http://www.codeandfinance.com/finding-implied-vol.html</a></p>
<p>[9] Heydt, <em>Mastering Pandas for Finance</em></p>
<p>[10] Hedgeye, <a href="http://app.hedgeye.com/mu/he_2q18_macrothemes_update_5-4-2018?encoded_data=ftvm,3MW2y7jAWWk/RR9BK6C07dDZp9A=," class="uri">http://app.hedgeye.com/mu/he_2q18_macrothemes_update_5-4-2018?encoded_data=ftvm,3MW2y7jAWWk/RR9BK6C07dDZp9A=,</a></p>
<p>[11] Bayramlı, Diferansiyel Denklemler, <em>Kök Bulmak, Karesel Formül</em></p>
</body>
</html>
