<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Risk ve Oynaklık Hedeflemesi</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="risk-ve-oynaklık-hedeflemesi">Risk ve Oynaklık Hedeflemesi</h1>
<p>En basit formunda risk idaresi için risk eşliği yöntemi (risk parity)
var; enstrümanlara portföyde risklerine (oynaklıklarına) ters oranda
ağırlık vermek. [1] buna bazı ekler yapar, bir oynaklık hedefi kavramını
ekler ve bu hedefe göre her alt sistemi ayarlar. Ayrıca risk eşliği
oynaklığı bir kez hesaplar ve bir daha bakmaz, yeni sistem oynaklığı her
gün belli gün geriye bakarak tüm enstrümanlar için tekrar tekrar
hesaplar.</p>
<p>Hedefleme şöyle işler: Önce bir yıllık oynaklık yüzdesi hedefleriz,
yüzde 20 diyelim, ve bu yüzdeden bir nakit oynaklık hedefi hesaplarız.
Sermaye 100,000 lira için bu 20,000 lira, bunu gün seviyesine indiririz,
20,000 / <span class="math inline">\(\sqrt{256}\)</span> = 1,250.
Ardından her enstrümanın günlük fiyat oynaklığını buluruz, ve günlük
oynaklık bölü bu sayı ile o enstrümandan kaç tane alacağımızı
hesaplarız. Bu konunun detaylarını işleyeceğiz. Diğer her parametre bu
hedefe göre değiştirilir. Bu yaklaşımın iyi tarafı yatırımcı kendini
rahat hissettiği, ve getirisini yeterli bulduğu bir oynaklık üzerinde
önceden karar verir, ve portföyünü buna göre düzenler, ve bu oynaklık
bir daha (uzun süre) değişmez.</p>
<p>Sharpe oranı (SO) ile oynaklık hedeflemesi arasında bir ilişki var.
Önce şunu belirtelim, bu yaklaşımda kazanç ile sermaye artmış ise o
zaman oynaklık yüzdesi ile daha çok para yatırıma gitmelidir, kayıpta
daha az. Bu da daha önce gördüğümüz Kelly yaklaşımının bir çeşidi.
Şimdi, oynaklığı SO ile çarparak yıllık beklenen getiriyi hesaplamak
mümkündür, çünkü SO zaten getiri bölü risk, yani bölü oynaklık idi.</p>
<p>Blok Degeri</p>
<p>Bir enstrümanın blok değeri o enstrümanın en ufak biriminde, o
enstrümanın fiyatının %1 değişmesi ile ortaya çıkan fiyat farkıdır.
Mesela ham petrol vadeli işlem sözleşmelerinde 1 kontraktın içinde 1000
varil vardır. Eğer yüzde 1 değişim ile fiyat $75’ten $75.75’e çıkarsa
tüm değişim $.75 * 1000 = $750 demektir. Blok değeri budur.</p>
<p>Fakat yüzde 1’lik değişimin şansı nedir? Senetlerin ortalama fiyat
oynaklığı yüzde 1 olabilir, diğer yanda Almanya 2-yıllık Schatz tahvil
VİS’lerinin günlük standart sapması %0.02’dır. Petrole dönelim, diyelim
ki tarihi veriye bakarak günlük ortalama değişimin yüzde 1.33 olduğunu
bulduk, bu durumda günlük kar veya kaybımız ortalama 750 Dolar x 1.33 =
997.50 Dolar olacak demektir, çünkü yüzde 1’lik değişim 750 Dolar idi.
Bu sonuca enstrüman kur oynaklığı (instrument currency volatility)
diyelim.</p>
<p>Bir adım daha, eğer portföyümüz Türkiye’de TL bazlı bir hesap
kullanıyorsak, kur değişimi yapmamız lazım, bu örnek için İngiliz pound
olsun, USD/GBP kuru bugün 0.67, o zaman 997.50*0.67 = 668.325 Pound.</p>
<p>Formül yerine tek bir değer kayıtlı tutmak daha rahat olduğu için bir
tek sayı değeri de hesaplanabilir, nokta değeri (point value) burada
kullanılır; bir VİS’in fiyatında 1 birimlik değişimin ne kadar toptan
değişimi temsil ettiği yani. Üstteki petrol örneğinde $1’lik degisim
kontraktta 1000 varil olduğu için bu $1000’lik bir değişim demektir,
nokta değeri olarak bu tutulur. Günlük ortalama yüzde değişimi biliyoruz
zaten, 75 x 0.0133 x 1000 = 997.50 Dolar. Aynı sonuca eriştik.</p>
<p>Bu sayı bir enstrümanlık bloğu elde tutmanın günlük riskini
gösteriyor, yani tek bir VİS. Eğer portföyde sadece bu entsruman
olsaydı, ve 1,000,000 Pound yıllık oynaklık hedefimiz olsaydı, günlük
hedef için <span class="math inline">\(\sqrt{256}\)</span>’ya bölüyoruz,
yani 1/16’sı 62,500 Pound olur. Bu günlük oynaklık kapasitemiz içine kaç
tane petrol VİS’i sığdırabilirdik? Bunun için kapasitemizi günlük tek
enstrüman petrol riskine bölüyoruz, 62,500 / 668.325 = 93.52 tane
kontrakt. Dikkat bu noktaya kadar hiç yuvarlama yapmadan geldik. Bu
arada dikkat edildiyse, bu risk doldurma işlemini sanki oynaklık
hedefinin elverdigi tüm parayı sadece o alt sistemde harcayabilirmişiz
gibi yapıyoruz. Daha sonra her alt sisteme ayrılan yüzde ile çarpınca
paylaştırma tam yapılmış oluyor. Ama bu adım sonra geliyor.</p>
<p>Harcamalar (Costs)</p>
<p>Eğer herhangi bir bir enstrüman için o enstrümandan tek bir bloğu
alıp hemen satsaydım, bu git/gel’in o enstrümanın yıllık riskine oranlı
bedeli ne olurdu? Bu “standardize edilmiş bedel” bize her git/gel’in
yıllık bazlı Sharpe oranından ne kadar kaybettireceğini bize söyler.
Sharpe oranı bildiğimiz gibi getirinin yıllık oynaklığa bölünmüş
halidir, getirinin oynaklığa olan oranı yani, standardize edilmiş bedel
de benzer bir hesabı yapar, böylece elde ettiğimiz bedeli direk Sharpe
oranından çıkartabilmemizi sağlar.</p>
<p>Git / gel dedik, yani bu ilk harcamanın hesabı alış fiyatı / satış
fiyatı aralığıyla yapılır. Niye? Çünkü aldığımızda alış, sattığımızda
satış fiyatından satıyoruz. Dikkat: geriye dönük testlerde bir fiyat
kullandığımızda bu fiyat çoğunlukla AFSF iki uç noktasının tam orta
noktasıdır; Fakat ya orta noktadan alım, ya da satım yapamadıysak? İşte
bu “en kötü ihtimal’’ bize bir masraf olarak yansır, ki her zaman bu en
kötü ihtimale göre bir harcama kalemini hesaba katmamız gerekir. O zaman
ASFS yayılımını (spread) buluruz, ve ikiye böleriz, bu harcamadır.</p>
<p>AFSF nereden elde edilir? Borsa aracımızın sağladığı araç üzerinden
enstrümanın en son AFSF’na bakarız, ve (birazdan göreceğimiz şekilde)
masrafı Sharpe oranına oranlı hesaplarız, bu sebeple hacimden,
oynaklıktan ileri gelen değişimlere uyarlanmış bir hesap elde etmiş
oluruz.</p>
<p>Geçmişte, tarihi verideki her günde AFSF’nin ne olduğu çoğunlukla
kaydedilen ve paylaşılan bir veri değildir, ama illa ki gerekiyorsa, onu
tahmin edebilen bazı metotlar mevcut, bkz <em>Ekler</em> bölümü.</p>
<p>Neyse, araca gireriz, vadeli işlem sözleşmeleri için bir kerede kaç
tane sözleşme alınacağı AFSF için bir eşik değeri oluşturabilir, buna da
dikkat, mesela Euro Stoxx 50 için Ocak 23, 2015’te bakıyoruz, 437
sözleşme ve altındaki satımlar için 3369 fiyatı verilmiş, alımlarda 7
sözleşme ve altı alımlar için 3370 fiyatı verilmiş. Harcama demek ki
3370-3369 / 2 = 0.5 (altta <code>slippage</code> kolonunda). Şimdi bu
bedeli yine en son fiyata göre bir yüzdeye çeviririz, 0.5 / 3370 * 100 =
%0.01483. Ardından bu değeri bir para miktarına çeviririz, yüzde 1’lik
değişimi temsil eden değer 3370 fiyat seviyesinde 337 Eur eder (3370 *
nokta değeri * yüzde 1, yani 3370 * 10/100). 337 çarpı 0.0148 = 5
Eur.</p>
<p>Borsa aracı şirketi ek bazı masraflar kesebilir, bu örnekte her
sözleşme için 3 Eur kesiliyor mesela.</p>
<p>Sharpe oranıyla alakalı bir bedel oluşturma yönünde ilerliyoruz.
Çıkartma işlemini şöyle yaparız; bir sene içinde bu enstrümanı, bir
tanesini, sadece bir kez ardı ardına al/sat yaptıysak bu blok masraf C =
5 + 3 = 8 Eur üzerinden 2 <em> C eder. Diyelim Euro Stoxx enstrüman
oynaklığı günlük yüzde 1.5, her yüzde 1’lik hareket 370 Eur ediyor, 370
</em> 1.5 = 506 Eur, bu günlük standart sapma. Onu yıllık standart sapma
haline getirmek için 506 * 16 = 8096 Eur. 2 * 8 /8096 = 0.002 SO
ünitesi. Yani bu değer artık SO’dan çıkartabileceğimiz bir sayıdır.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd, zipfile</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> io <span class="im">import</span> StringIO</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>COSTS<span class="op">=</span><span class="st">u&quot;&quot;&quot;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="st">instrument,currency,point_value,slippage</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="st">CRUDE_W,USD,1000,0.0145328653</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="st">EDOLLAR,USD,2500,0.0025</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="st">US5,USD,1000,0.004</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="st">EUROSTX,EUR,10,0.5</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="st">V2X,EUR,100,0.0255</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="st">MXP,USD,500000,0.000011567</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="st">CORN,USD,50,0.125</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;&quot;&quot;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>costs <span class="op">=</span> pd.read_csv(StringIO(COSTS),index_col<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>my_curr <span class="op">=</span> <span class="st">&#39;USD&#39;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>vol_target <span class="op">=</span> <span class="fl">0.20</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>capital <span class="op">=</span> <span class="dv">250</span><span class="op">*</span><span class="dv">1000</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>exchange <span class="op">=</span> {<span class="st">&#39;USD&#39;</span>: {<span class="st">&#39;EUR&#39;</span>: <span class="fl">1.1</span>, <span class="st">&#39;USD&#39;</span>: <span class="fl">1.0</span>} }</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>daily_vol_target <span class="op">=</span> capital <span class="op">*</span> vol_target <span class="op">/</span> <span class="dv">16</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calc_cost(ins,dt <span class="op">=</span> <span class="st">&#39;2014-10-14&#39;</span>):</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> zipfile.ZipFile(<span class="st">&#39;legacycsv.zip&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> z:</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        dfi <span class="op">=</span> pd.read_csv(z.<span class="bu">open</span>(<span class="st">&#39;</span><span class="sc">%s</span><span class="st">_price.csv&#39;</span> <span class="op">%</span> ins), index_col<span class="op">=</span><span class="dv">0</span>,parse_dates<span class="op">=</span><span class="va">True</span> )</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        vol <span class="op">=</span> (dfi.pct_change()<span class="op">*</span><span class="fl">100.</span>).rolling(<span class="dv">25</span>).std()    </span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> []</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    price <span class="op">=</span> <span class="bu">float</span>(dfi.loc[dt])</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> <span class="bu">float</span>(vol.loc[dt])</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    point_val <span class="op">=</span> price <span class="op">*</span> costs.loc[ins].point_value <span class="op">/</span> <span class="fl">100.</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    block_val <span class="op">=</span> point_val <span class="op">*</span> price  </span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    block_vol <span class="op">=</span> block_val<span class="op">*</span>v</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    inst_value_vol <span class="op">=</span>  block_vol<span class="op">*</span>exchange[my_curr][costs.loc[ins].currency]</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    units <span class="op">=</span> daily_vol_target <span class="op">/</span> inst_value_vol</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    exec_cost <span class="op">=</span> (costs.loc[ins].slippage <span class="op">/</span> price) <span class="op">*</span> <span class="dv">100</span> <span class="op">*</span> block_val</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    so_cost <span class="op">=</span>  (exec_cost <span class="op">*</span> <span class="fl">2.</span>) <span class="op">/</span> (<span class="fl">16.</span> <span class="op">*</span> block_vol)</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> price,v,block_val,block_vol,inst_value_vol,units,exec_cost,so_cost</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>price,v,block_val,block_vol,inst_value_vol,units,exec_cost,so_cost <span class="op">=</span> calc_cost(<span class="st">&#39;EUROSTX&#39;</span>)</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (so_cost)</span></code></pre></div>
<pre class="text"><code>0.001862369502999681</code></pre>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd, zipfile</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> io <span class="im">import</span> StringIO</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>pd.options.display.float_format <span class="op">=</span> <span class="st">&#39;</span><span class="sc">{0:.4f}</span><span class="st">&#39;</span>.<span class="bu">format</span>    </span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>instruments <span class="op">=</span> [<span class="st">&#39;CRUDE_W&#39;</span>,<span class="st">&#39;EDOLLAR&#39;</span>,<span class="st">&#39;US5&#39;</span>,<span class="st">&#39;EUROSTX&#39;</span>,<span class="st">&#39;V2X&#39;</span>,<span class="st">&#39;MXP&#39;</span>,<span class="st">&#39;CORN&#39;</span>]</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>         </span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> <span class="st">&#39;2014-10-14&#39;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> []</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>cols <span class="op">=</span> [<span class="st">&#39;inst&#39;</span>,<span class="st">&#39;price&#39;</span>,<span class="st">&#39;v&#39;</span>,<span class="st">&#39;block_val&#39;</span>,<span class="st">&#39;block_vol&#39;</span>,<span class="st">&#39;inst_value_vol&#39;</span>,<span class="st">&#39;units&#39;</span>,<span class="st">&#39;exec_cost&#39;</span>,<span class="st">&#39;so_cost&#39;</span>]</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> inst <span class="kw">in</span> instruments:</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    price,v,block_val,block_vol,inst_value_vol,units,exec_cost,so_cost <span class="op">=</span> calc_cost(inst)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    res.append([inst,price,v,block_val,block_vol,inst_value_vol,units,exec_cost,so_cost])</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (pd.DataFrame(res,columns<span class="op">=</span>cols)         )</span></code></pre></div>
<pre class="text"><code>      inst     price      v  ...    units  exec_cost  so_cost
0  CRUDE_W   85.3000 1.2678  ...   0.0339  1239.6534   0.0017
1  EDOLLAR   97.0550 0.0563  ...   0.2355   606.5937   0.0057
2      US5  117.0625 0.1699  ...   0.1342   468.2500   0.0025
3  EUROSTX 2816.0000 1.1917  ...   0.0030 14080.0000   0.0019
4      V2X   22.8000 2.6898  ...   2.0318    58.1400   0.0052
5      MXP    0.0717 0.5110  ... 237.5827     0.4150   0.0039
6     CORN  422.7500 1.2475  ...   0.0280  2642.1875   0.0030

[7 rows x 9 columns]</code></pre>
<p>Devir (Turnover)</p>
<p>Tabii SO’dan çıkartma yapmadan önce bir enstrümanı senede yaklaşık
kaç kez alıp sattığımızı bilmemiz gerekir, çünkü biraz önceki
standardize edilmiş harcama tek bir al/sat’ı baz alıyor. Eğer bir
enstrümanın masrafı 0.01 standardize SO ünitesi ise, ve bir senede
yaklaşık 10 al/sat yapıyorsak, ve bu enstrümanı baz alan bir strateji
bize SO 0.5 getiri sağlayacaksa, masrafların çıkartıldığı nihai SO 0.5 -
0.01*10 = 0.4 olacaktır. Senede yapılan yaklaşık al/sat’a devir
(turnover) ismi verelim. Devir sayısını belirleyen nedir? Birkaç faktör
akla gelebilir; mesela stratejimizin yaptığı enstrüman fiyat tahmini;
düşeceğini tahmin ettiğimiz bir enstrümanın pozisyonunu azaltmak
isteyebiliriz, bu satım yapmak demektir, ve masraf ortaya çıkar. Ya da
oynaklıkta değişim olur, ve portföyümüzün oynaklık hedefini aynı
seviyede tutmak için bazı pozisyonlara girmek, ya da mevcut olanlardan
çıkmak gerekebilir.</p>
<p>[1]’in yaklaşımında hedefler tanımlanıyor, mesela oynaklık hedefi,
böylece riskimizin ne olacağını daha baştan biliyoruz, ve bu risk
seviyesi hiç değişmiyor. Aynı şekilde devir için bir hedef koymak, ve bu
hedef üzerinden onu kısıtlamak ta mümkün. Test ettiğimiz bir stratejinin
1/3’ünden fazlasını masraflara kaybetmenin anlamı yok, bu sebeple her
stratejinin SO’sunun 1/3’unu bir devir sayısı sınırını hesaplamak için
kullanabiliriz. Eğer SO 0.4 ise, onun 1/3’u 0.13 eder, yani masraflar
için yıllık 0.13 SO’yu hiçbir şartta geçmemeliyiz , bu demektir ki eğer
masraf 0.002 SO ünitesi olan Euro Stoxx için yıllık devir muhakkak 65
altında olmalıdır.</p>
<p>Not: Eğer masraflar 0.13 SO’su ise ve mesela oynaklık hedefimiz
yıllık yüzde 50 ise, bu getirimizin 0.13 * %50 = yüzde 6.5’si masraflara
gider demektir. Bu az bir oran değil! Şahsi olarak bundan daha fazlasını
tavsiye etmemiz mümkün değil.</p>
<p>Tahminler</p>
<p>Risk elimizdeki denklemin bir parçası. Diğer bir parçası bizim, ya da
algoritmamızın, gelecekte bir varlığın nasıl davranacağı hakkındaki
tahmini. Prensip olarak ikisel tahminlerden kaçınmalıyız, yani 0,1
türünde, evet/hayır, al/sat şeklindeki tahminler. Tahmin bir reel sayı
olmalı, -20/+20 arasında mesela, ve işimizi kolaylaştırması açısından
averaj bir al tahmini için +10 iyidir, açıga satışta averaj -10 değeri
uygundur. O zaman +5 gibi bir tahmin nisbeten daha zayıf bir alım demek,
-20 ise çok kuvvetli bir sat tahmini olacaktır.</p>
<p>O zaman tahminleri öncelikle oynaklık standardizasyonuna tabi tutmak
lazım, ki tahmin Sharpe oranına kıyaslanabilir bir şey olsun, yani
üretilen tahmini önce zaman serisinin yakın zamandaki getirilerinin
standart sapmasına bölmek lazım. Ardından tahminlerin uzun süreli
ortalamasının 10 olmasını istiyoruz, o zaman tahminlerimizin uzun süreli
ortalamasını hesaplayıp, tüm tahminleri “10 / bu ortalama’’ ile
ölçeklememiz lazım, bu sayıya tahmin çarpanı (forecast scalar) ismi
verebiliriz.</p>
<p>Tahmin çarpanları her tahmin algoritması temel alarak hesaplanır,
yani hangi veri tahmin ediliyorsa edilsin bir stratejinin belli bir
çarpanı vardır. Bu hesabı bu yazının altında bulabilirsiniz. Şimdilik bu
çarpanı bildiğimizi farzedelim, EWMA 32,128 için 2.84.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd, zipfile, util</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> zipfile.ZipFile(<span class="st">&#39;legacycsv.zip&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> z:</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span>  pd.read_csv(z.<span class="bu">open</span>(<span class="st">&#39;EUROSTX_price.csv&#39;</span>),sep<span class="op">=</span><span class="st">&#39;,&#39;</span>,index_col<span class="op">=</span><span class="dv">0</span>,parse_dates<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>pred <span class="op">=</span> util.ewma(df.PRICE,<span class="dv">32</span>,<span class="dv">128</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>forecast_scalar <span class="op">=</span> <span class="fl">2.84</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>pred_scaled <span class="op">=</span> pred <span class="op">*</span> forecast_scalar</span></code></pre></div>
<p>Şimdi alt sistem alım ya da satım işlemine gelirsek; üstteki petrol
kontrakt alımını gelecek tahmini üzerinden nasıl ayarlarız? Eğer petrol
VİS’i için averaj, 10 seviyesinde bir alım beklentimiz var ise hiçbir
şey yapmamıza gerek yok, 93.52 tane kontrakt alıyoruz, bu durumda sanki
10 ile çarpıp 10 ile bölmüş oluyoruz, hiçbir etki yok. Fakat tahmin +5.0
ise o zaman 93.50 / 2 = 46.76 tane kontrakt alacağız demektir, satım
için benzer durum, -20 tahmin 93.50 * 2 = 187.04 kontraktı açığa satmak
demektir.</p>
<p>Devir hesabının tahminler ile yakın alakası var. Tahmin zaman
serisinin farkının ortalamasını alıp, bu ortalamayı bir yıldaki iş günü
sayısı ile çarparsak, bu tahmin serisinin sebep olacağı al/sat sayısını
yaklaşık olarak hesaplamış oluruz. Eğer tahminler 10,20,10 olsaydı
mesela bu bir alım, bir satım demektir, farklar 10,-10,.. bu durumu
hemen gösteriyor. Üstteki tahmin serisi için [1, sf. 276],</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>avg <span class="op">=</span>  (pred_scaled <span class="op">/</span> <span class="dv">10</span>).diff().<span class="bu">abs</span>().mean()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;devir&#39;</span>, avg <span class="op">*</span> <span class="dv">256</span>)</span></code></pre></div>
<pre class="text"><code>devir 8.695810384014125</code></pre>
<p>Alt Sistemlerin Ağırlıkları</p>
<p>Daha önce üç tane VİS’i sadece alıp elde tutmak üzerinden ağırlık
hesabı yapmıştık. Alttaki örnekte iki enstrüman üzerinde iki farklı
stratejiyi işleteceğiz, elde iki tane alt sistem (subsystem) olacak, ve
her sistem içinde iki tane tahmin edici bulunacak, ve biz bu her sisteme
ne kadar ağırlık vereceğimizi hesaplayacağız.</p>
<p>Alt sistem içinde aynı enstrüman üzerinde iki strateji işletmek, iki
farklı tahmin yöntemi demektir, yani aynı zaman serisine bakarak iki
yöntem farklı al/sat sinyalleri üretebilirler (tabii aynı fikirde
oldukları zaman bu daha iyi). [1]‘in araştırmalarına göre “strateji
karıştırmanın’’ faydalı olduğu görülmüştür. Tahmin çarpanını daha önce
gördük, alttaki değerler direk [1, sf. 309]’dan geliyor. Ayrıca -20/20
üzeri değerleri -20/20’ye eşitliyoruz, sistemin aşırı büyük tahminler
yapmaması için. Ağırlıkların bulunması için yine bootstrap
kullanıldı.</p>
<p>Tahminlere her sistem içinde eşit ağırlık verdik, yani 0.5 ve 0.5.
İki strateji EWMAC 2,8 ve EWMAC 32,128. Her iki tahminin al/sat
sinyalini bir ileri kaydırıyoruz, ve bir sonraki günün getirisi
üzerinden bu sinyal ile gerçek getiriyi hesaplıyoruz.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> zipfile, pandas <span class="im">as</span> pd, util, random</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>random.seed(<span class="dv">0</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">0</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ewmac(price,slow,fast):</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    vol <span class="op">=</span> util.robust_vol_calc(price.diff())</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    fast_ewma <span class="op">=</span> price.ewm(span<span class="op">=</span>slow).mean()</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    slow_ewma <span class="op">=</span> price.ewm(span<span class="op">=</span>fast).mean()</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    raw_ewmac <span class="op">=</span> fast_ewma <span class="op">-</span> slow_ewma</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> raw_ewmac <span class="op">/</span>  vol </span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>symbols <span class="op">=</span> [<span class="st">&#39;SP500&#39;</span>,<span class="st">&#39;US20&#39;</span>]</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame()</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> zipfile.ZipFile(<span class="st">&#39;legacycsv.zip&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> z:</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> symbol <span class="kw">in</span> symbols:</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        f <span class="op">=</span> <span class="st">&#39;</span><span class="sc">%s</span><span class="st">_price.csv&#39;</span> <span class="op">%</span> symbol</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        df[symbol] <span class="op">=</span> pd.read_csv(z.<span class="bu">open</span>(f),sep<span class="op">=</span><span class="st">&#39;,&#39;</span>,index_col<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>                                 parse_dates<span class="op">=</span><span class="va">True</span>)[<span class="st">&#39;PRICE&#39;</span>]</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.sort_index()</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>forecast <span class="op">=</span> df.copy()</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>ewmac8_32_scalar <span class="op">=</span> <span class="fl">10.6</span> </span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>ewmac32_128_scalar <span class="op">=</span> <span class="fl">2.65</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;US20_ewmac8_32&#39;</span>] <span class="op">=</span> ewmac(df[<span class="st">&#39;US20&#39;</span>], <span class="dv">8</span>, <span class="dv">32</span>) <span class="op">*</span> ewmac8_32_scalar <span class="op">/</span><span class="fl">10.</span> </span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;US20_ewmac32_128&#39;</span>] <span class="op">=</span> ewmac(df[<span class="st">&#39;US20&#39;</span>], <span class="dv">32</span>, <span class="dv">128</span>) <span class="op">*</span> ewmac32_128_scalar <span class="op">/</span><span class="fl">10.</span> </span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;SP500_ewmac8_32&#39;</span>] <span class="op">=</span> ewmac(df[<span class="st">&#39;SP500&#39;</span>], <span class="dv">8</span>, <span class="dv">32</span>) <span class="op">*</span> ewmac8_32_scalar<span class="op">/</span><span class="fl">10.</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;SP500_ewmac32_128&#39;</span>] <span class="op">=</span> ewmac(df[<span class="st">&#39;SP500&#39;</span>], <span class="dv">32</span>, <span class="dv">128</span>) <span class="op">*</span> ewmac32_128_scalar<span class="op">/</span><span class="fl">10.</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>forecast[<span class="st">&#39;US20&#39;</span>] <span class="op">=</span> (df[<span class="st">&#39;US20_ewmac8_32&#39;</span>] <span class="op">+</span> df[<span class="st">&#39;US20_ewmac32_128&#39;</span>]) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>forecast[<span class="st">&#39;SP500&#39;</span>] <span class="op">=</span> (df[<span class="st">&#39;SP500_ewmac8_32&#39;</span>] <span class="op">+</span> df[<span class="st">&#39;SP500_ewmac32_128&#39;</span>]) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>forecast.loc[forecast.US20 <span class="op">&gt;</span> <span class="dv">20</span>, <span class="st">&#39;US20&#39;</span>] <span class="op">=</span> <span class="fl">20.</span></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>forecast.loc[forecast.SP500 <span class="op">&gt;</span> <span class="dv">20</span>, <span class="st">&#39;SP500&#39;</span>] <span class="op">=</span> <span class="fl">20.</span></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>forecast.loc[forecast.US20 <span class="op">&lt;</span> <span class="op">-</span><span class="dv">20</span>, <span class="st">&#39;US20&#39;</span>] <span class="op">=</span> <span class="op">-</span><span class="fl">20.</span></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>forecast.loc[forecast.SP500 <span class="op">&lt;</span> <span class="op">-</span><span class="dv">20</span>, <span class="st">&#39;SP500&#39;</span>] <span class="op">=</span> <span class="op">-</span><span class="fl">20.</span></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;US20&#39;</span>] <span class="op">=</span> df[<span class="st">&#39;US20&#39;</span>].pct_change() <span class="op">*</span> forecast.shift(<span class="dv">1</span>).US20 <span class="op">/</span> <span class="fl">10.</span></span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;SP500&#39;</span>] <span class="op">=</span> df[<span class="st">&#39;SP500&#39;</span>].pct_change() <span class="op">*</span> forecast.shift(<span class="dv">1</span>).SP500 <span class="op">/</span> <span class="fl">10.</span></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df[[<span class="st">&#39;US20&#39;</span>,<span class="st">&#39;SP500&#39;</span>]]</span></code></pre></div>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys<span class="op">;</span> sys.path.append(<span class="st">&#39;../tser_060_port&#39;</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> boot</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>weights<span class="op">=</span>boot.optimise_over_periods(df,rollyears<span class="op">=</span><span class="dv">20</span>, monte_carlo<span class="op">=</span><span class="dv">20</span>,monte_length<span class="op">=</span><span class="dv">250</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (np.array(weights.tail(<span class="dv">1</span>)))</span></code></pre></div>
<pre class="text"><code>[[0.45390697 0.54609303]]</code></pre>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>weights.plot()</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_voltar_01.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_voltar_01.png" /></p>
<p>Enstruman Çeşitlendirme Çarpanı (Instrument Diversification
Multiplier - IDM)</p>
<p>Tekrar üzerinden geçersek, risk hedeflememizi yaptık, her alt sistem
içine bu hedefe göre strateji doldurduk ki her alt sistem aynı riske
sahip, ardından alt sistem ağırlıklarını hesapladık ve her alt sisteme
gerekli parayı ayırdık. Fakat bu noktada ortaya bir problem çıkar, çünkü
ağırlık kullanımı, ve alt sistem getirilerinin arasında (elimizden
geldiğince) korelasyonu az tutmuş olmamız sebebiyle nihai sistemin genel
riski azaldı. Yani hedeflediğimiz riskten sapmış olduk. Elde etmek
istediğimiz risk sanki her alt sistemi kendi başına işletiyormuş gibi
elde edeceğimiz risk gibi olmalı. O zaman bize öyle bir çarpan lazım ki
risk azalmasını telafi etsin, ve pozisyon hesabını yaparken bu çarpanı
uygulayarak risk hedefine geri dönelim.</p>
<p>N tane alt sistemimizin olduğunu düşünelim, bu sistemlerin
getirilerinin korelasyon matrisi <span class="math inline">\(H\)</span>
olsun, ve biraz önce bulduğumuz ağırlıklar <span
class="math inline">\(W\)</span> (ki ağırlıkların toplamı 1). O zaman
IDM, <span class="math inline">\(1 / \sqrt{(W \cdot H \cdot
W^T)}\)</span> olacaktır. Dikkat edersek bu formül (2)’nin tam
tersi.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>H <span class="op">=</span> df.corr()</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>H <span class="op">=</span> H.clip(lower<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;Korelasyon&#39;</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (H)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>W <span class="op">=</span> np.array([[<span class="fl">0.34</span>,  <span class="fl">0.66</span>]]) <span class="co"># ustteki sonuc</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>idm<span class="op">=</span><span class="fl">1.0</span> <span class="op">/</span> (<span class="bu">float</span>(np.dot(np.dot(W, H), W.transpose()))) <span class="op">**</span><span class="fl">.5</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;</span><span class="ch">\n</span><span class="st">IDM&#39;</span>, idm)</span></code></pre></div>
<pre class="text"><code>Korelasyon
        US20  SP500
US20  1.0000 0.0895
SP500 0.0895 1.0000

IDM 1.300377852662791</code></pre>
<p>Tahmin Çarpanlarını Hesaplamak</p>
<p>Her tahmin algoritmasi için eldeki <em>tüm</em> veriler üzerinde
tahmin üretiriz, yani her enstrüman verisi için tahmin üretip, tüm bu
tahminleri birleştirip koca bir zaman serisi oluştururuz (bu tekniğe
havuzlama -pooling- ismi veriliyor), ve bu serinin mutlak değerlerinin
(absolute value) ortalamasını alırız.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> util, zipfile, pandas <span class="im">as</span> pd</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>ewmacs <span class="op">=</span> [(<span class="dv">2</span>,<span class="dv">8</span>),(<span class="dv">4</span>,<span class="dv">16</span>),(<span class="dv">8</span>,<span class="dv">32</span>),(<span class="dv">16</span>,<span class="dv">64</span>),(<span class="dv">32</span>,<span class="dv">128</span>),(<span class="dv">64</span>,<span class="dv">256</span>)]</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (fast,slow) <span class="kw">in</span> ewmacs: </span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> zipfile.ZipFile(<span class="st">&#39;legacycsv.zip&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> z:</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        res <span class="op">=</span> []</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> x <span class="kw">in</span>  z.namelist():</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="st">&#39;_price&#39;</span> <span class="kw">in</span> x:</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>                df <span class="op">=</span> pd.read_csv(z.<span class="bu">open</span>(x), index_col<span class="op">=</span><span class="dv">0</span>,parse_dates<span class="op">=</span><span class="va">True</span> )</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>                tmp <span class="op">=</span> util.ewma(df.PRICE, fast, slow)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>                res.append(tmp)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    tmp <span class="op">=</span> pd.DataFrame(pd.concat(res))</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    tmp.columns <span class="op">=</span> [<span class="st">&#39;forecast&#39;</span>]</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    target_abs_forecast <span class="op">=</span> <span class="fl">10.</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    tmp<span class="op">=</span>tmp.<span class="bu">abs</span>().iloc[:,<span class="dv">0</span>]</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    avg_abs_value<span class="op">=</span>tmp.mean()    </span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span> (<span class="st">&#39;ewma&#39;</span>, slow,fast,<span class="st">&#39;=&#39;</span>, target_abs_forecast<span class="op">/</span>avg_abs_value)</span></code></pre></div>
<pre class="text"><code>ewma 8 2 = 12.862857782026538
ewma 16 4 = 8.9180572164055
ewma 32 8 = 6.100627559062258
ewma 64 16 = 4.172707518719636
ewma 128 32 = 2.842377277196493
ewma 256 64 = 1.924451529561536</code></pre>
<p>Taşıma kuralı (carry) için (not: TK verisini ayrı kontratlardan nasıl
yaratabileceğimizi <em>Vadeli İşlem Sözleşmeleri</em> bölümünde
görmüştük, bu yazıda basitlik amacı ile [1] için yaratılmış hazır veriyi
kullanıyoruz),</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> util, zipfile</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> zipfile.ZipFile(<span class="st">&#39;legacycsv.zip&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> z:</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> []</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> z.namelist():</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="st">&#39;_carrydata&#39;</span> <span class="kw">in</span> x:</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>            df <span class="op">=</span> pd.read_csv(z.<span class="bu">open</span>(x), index_col<span class="op">=</span><span class="dv">0</span>,parse_dates<span class="op">=</span><span class="va">True</span> )</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>            f <span class="op">=</span> x.replace(<span class="st">&quot;__carrydata&quot;</span>,<span class="st">&quot;_price&quot;</span>)</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>            dfc <span class="op">=</span> pd.read_csv(z.<span class="bu">open</span>(f),index_col<span class="op">=</span><span class="dv">0</span>,parse_dates<span class="op">=</span><span class="va">True</span> )     </span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>            vol <span class="op">=</span> util.robust_vol_calc(dfc.PRICE.diff())</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>            carryoffset <span class="op">=</span> np.<span class="bu">abs</span>(((df.PRICE_CONTRACT <span class="op">-</span> df.CARRY_CONTRACT).tail(<span class="dv">1</span>)).astype(<span class="bu">float</span>))</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>            forecast <span class="op">=</span>  util.carry(df.CARRY<span class="op">-</span>df.PRICE, vol,np.<span class="bu">abs</span>(carryoffset)<span class="op">/</span><span class="dv">12</span>)</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>            res.append(forecast)</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    tmp <span class="op">=</span> pd.DataFrame(pd.concat(res))</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    tmp <span class="op">=</span> tmp.dropna()</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    tmp.columns <span class="op">=</span> [<span class="st">&#39;forecast&#39;</span>]</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    tmp<span class="op">=</span>tmp.<span class="bu">abs</span>().iloc[:,<span class="dv">0</span>]</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>    avg_abs_value<span class="op">=</span>tmp.mean()</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span> (<span class="fl">10.</span><span class="op">/</span>avg_abs_value )</span></code></pre></div>
<pre class="text"><code>42.560661077684045</code></pre>
<p>Bu değerler [1, sf. 309] ile uyumlu.</p>
<p>Strateji Ağırlıklarını Hesaplamak (Forecast Weight Estimation)</p>
<p>[1]’in yaklaşımlarından bir diğeri seçilen stratejilerin hangi
ağırlıklarla her alt sistem üzerinde kullanılacağını bulmak. Daha önce
alt sistem içinde stratejilere eşit ağırlık vermiştik. Gerçek dünyada bu
ağırlıkların optimal olması iyi olur. Her alt sistemde aynı strateji
demeti olur, bu demetlere belli ağırlıklar verilir, ve her alt sistem,
aynı demeti bu ağırlıklar üzerinden kullanır. Mesela petrol VİS’i
üzerinde EWMAC 2,8, EWMAC 16,64 ve taşıma kuralı (carry trade, TK)
kullanıyor olabiliriz, bunların ağırlığı 0.2, 0.3, 0.5 olabilir. Diğer
bir alt sistem, mesela kahve, Eurodollar aynı ağırlıkları aynı şekilde
kullanır.</p>
<p>Ağırlıkları bulmadan önce, hangi strateji demetiyle başlamak lazım?
Bir liste çıkartmak çok zor değil, [1, sf. 309]’a göre EWMAC’ın yavaş ve
hızlı parametreleri arasında 1’e 4 oranı mantıklı, yani EW 1,4, EW 2,8,
EW 4,16, EW 8,32, diye devam edebiliriz. Bu listeden eleme yapmak için
onların masraflarını kullanmak iyi oluyor, çok masraflı olan
stratejileri direk eleriz. Bu konuya sonra döneceğiz.</p>
<p>Şimdilik nihai demeti kararlaştırmış olduğumuzu düşünelim, mesela
CORN, EDOLLAR, EUROSTX, MXP, US10, V2X üzerinde EW 16,64, EW 32,128, EW
64,256 ve TK stratejilerini kullanacağız. Ağırlıkları hesaplamak için
alt sistemler arası kullandığımız hesaba benzer yaklaşımı kullanacağız,
boostrap tekniğini devreye sokacağız. Ayrıca havuzlama tekniğini de
kullanacağız, eldeki <em>tüm</em> enstrümanlar üzerinden elde edilen
stratejilerin tahminlerini birleştireceğiz. Mesela EWMAC 16,64 ile CORN,
EDOLLAR, vs tahminleri yapıp bu serileri uç uca koyacağız, böylece
eldeki veriyi arttırmış olacağız.</p>
<p>[atlandi]</p>
<p>Kaynaklar</p>
<p>[1] Carver, <em>Systematic Trading</em></p>
<p>[2] Heydt, <em>Mastering Pandas for Finance</em></p>
<p>[3] Carver, <em>Correlations, Weights, Multipliers…. </em>, <a
href="http://qoppac.blogspot.co.uk/2016/01/correlations-weights-multipliers.html">http://qoppac.blogspot.co.uk/2016/01/correlations-weights-multipliers.html</a></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
