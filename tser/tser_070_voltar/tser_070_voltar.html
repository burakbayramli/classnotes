<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Risk ve Oynaklık Hedeflemesi</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="risk-ve-oynaklık-hedeflemesi">Risk ve Oynaklık Hedeflemesi</h1>
<p>En basit formunda risk idaresi için risk eşliği yöntemi (risk parity)
var; enstrümanlara portföyde risklerine (oynaklıklarına) ters oranda
ağırlık vermek. [1] buna bazı ekler yapar, bir oynaklık hedefi kavramını
ekler ve bu hedefe göre her alt sistemi ayarlar. Ayrıca risk eşliği
oynaklığı bir kez hesaplar ve bir daha bakmaz, yeni sistem oynaklığı her
gün belli gün geriye bakarak tüm enstrümanlar için tekrar tekrar
hesaplar.</p>
<p>Hedefleme şöyle işler: Önce bir yıllık oynaklık yüzdesi hedefleriz,
yüzde 20 diyelim, ve bu yüzdeden bir nakit oynaklık hedefi hesaplarız.
Sermaye 100,000 lira için bu 20,000 lira, bunu gün seviyesine indiririz,
20,000 / <span class="math inline">\(\sqrt{256}\)</span> = 1,250.
Ardından her enstrümanın günlük fiyat oynaklığını buluruz, ve günlük
oynaklık bölü bu sayı ile o enstrümandan kaç tane alacağımızı
hesaplarız. Bu konunun detaylarını işleyeceğiz. Diğer her parametre bu
hedefe göre değiştirilir. Bu yaklaşımın iyi tarafı yatırımcı kendini
rahat hissettiği, ve getirisini yeterli bulduğu bir oynaklık üzerinde
önceden karar verir, ve portföyünü buna göre düzenler, ve bu oynaklık
bir daha (uzun süre) değişmez.</p>
<p>Sharpe oranı (SO) ile oynaklık hedeflemesi arasında bir ilişki var.
Önce şunu belirtelim, bu yaklaşımda kazanç ile sermaye artmış ise o
zaman oynaklık yüzdesi ile daha çok para yatırıma gitmelidir, kayıpta
daha az. Bu da daha önce gördüğümüz Kelly yaklaşımının bir çeşidi.
Şimdi, oynaklığı SO ile çarparak yıllık beklenen getiriyi hesaplamak
mümkündür, çünkü SO zaten getiri bölü risk, yani bölü oynaklık idi.</p>
<p>Blok Degeri</p>
<p>Bir enstrümanın blok değeri o enstrümanın en ufak biriminde, o
enstrümanın fiyatının %1 değişmesi ile ortaya çıkan fiyat farkıdır.
Mesela ham petrol vadeli işlem sözleşmelerinde 1 kontraktın içinde 1000
varil vardır. Eğer yüzde 1 değişim ile fiyat $75’ten $75.75’e çıkarsa
tüm değişim $.75 * 1000 = $750 demektir. Blok değeri budur.</p>
<p>Fakat yüzde 1’lik değişimin şansı nedir? Senetlerin ortalama fiyat
oynaklığı yüzde 1 olabilir, diğer yanda Almanya 2-yıllık Schatz tahvil
VİS’lerinin günlük standart sapması %0.02’dır. Petrole dönelim, diyelim
ki tarihi veriye bakarak günlük ortalama değişimin yüzde 1.33 olduğunu
bulduk, bu durumda günlük kar veya kaybımız ortalama 750 Dolar x 1.33 =
997.50 Dolar olacak demektir, çünkü yüzde 1’lik değişim 750 Dolar idi.
Bu sonuca enstrüman kur oynaklığı (instrument currency volatility)
diyelim.</p>
<p>Bir adım daha, eğer portföyümüz Türkiye’de TL bazlı bir hesap
kullanıyorsak, kur değişimi yapmamız lazım, bu örnek için İngiliz pound
olsun, USD/GBP kuru bugün 0.67, o zaman 997.50*0.67 = 668.325 Pound.</p>
<p>Formül yerine tek bir değer kayıtlı tutmak daha rahat olduğu için bir
tek sayı değeri de hesaplanabilir, nokta değeri (point value) burada
kullanılır; bir VİS’in fiyatında 1 birimlik değişimin ne kadar toptan
değişimi temsil ettiği yani. Üstteki petrol örneğinde $1’lik degisim
kontraktta 1000 varil olduğu için bu $1000’lik bir değişim demektir,
nokta değeri olarak bu tutulur. Günlük ortalama yüzde değişimi biliyoruz
zaten, 75 x 0.0133 x 1000 = 997.50 Dolar. Aynı sonuca eriştik.</p>
<p>Bu sayı bir enstrümanlık bloğu elde tutmanın günlük riskini
gösteriyor, yani tek bir VİS. Eğer portföyde sadece bu entsruman
olsaydı, ve 1,000,000 Pound yıllık oynaklık hedefimiz olsaydı, günlük
hedef için <span class="math inline">\(\sqrt{256}\)</span>’ya bölüyoruz,
yani 1/16’sı 62,500 Pound olur. Bu günlük oynaklık kapasitemiz içine kaç
tane petrol VİS’i sığdırabilirdik? Bunun için kapasitemizi günlük tek
enstrüman petrol riskine bölüyoruz, 62,500 / 668.325 = 93.52 tane
kontrakt. Dikkat bu noktaya kadar hiç yuvarlama yapmadan geldik. Bu
arada dikkat edildiyse, bu risk doldurma işlemini sanki oynaklık
hedefinin elverdigi tüm parayı sadece o alt sistemde harcayabilirmişiz
gibi yapıyoruz. Daha sonra her alt sisteme ayrılan yüzde ile çarpınca
paylaştırma tam yapılmış oluyor. Ama bu adım sonra geliyor.</p>
<p>Harcamalar (Costs)</p>
<p>Eğer herhangi bir bir enstrüman için o enstrümandan tek bir bloğu
alıp hemen satsaydım, bu git/gel’in o enstrümanın yıllık riskine oranlı
bedeli ne olurdu? Bu “standardize edilmiş bedel” bize her git/gel’in
yıllık bazlı Sharpe oranından ne kadar kaybettireceğini bize söyler.
Sharpe oranı bildiğimiz gibi getirinin yıllık oynaklığa bölünmüş
halidir, getirinin oynaklığa olan oranı yani, standardize edilmiş bedel
de benzer bir hesabı yapar, böylece elde ettiğimiz bedeli direk Sharpe
oranından çıkartabilmemizi sağlar.</p>
<p>Git / gel dedik, yani bu ilk harcamanın hesabı alış fiyatı / satış
fiyatı aralığıyla yapılır. Niye? Çünkü aldığımızda alış, sattığımızda
satış fiyatından satıyoruz. Dikkat: geriye dönük testlerde bir fiyat
kullandığımızda bu fiyat çoğunlukla AFSF iki uç noktasının tam orta
noktasıdır; Fakat ya orta noktadan alım, ya da satım yapamadıysak? İşte
bu “en kötü ihtimal’’ bize bir masraf olarak yansır, ki her zaman bu en
kötü ihtimale göre bir harcama kalemini hesaba katmamız gerekir. O zaman
ASFS yayılımını (spread) buluruz, ve ikiye böleriz, bu harcamadır.</p>
<p>AFSF nereden elde edilir? Borsa aracımızın sağladığı araç üzerinden
enstrümanın en son AFSF’na bakarız, ve (birazdan göreceğimiz şekilde)
masrafı Sharpe oranına oranlı hesaplarız, bu sebeple hacimden,
oynaklıktan ileri gelen değişimlere uyarlanmış bir hesap elde etmiş
oluruz.</p>
<p>Geçmişte, tarihi verideki her günde AFSF’nin ne olduğu çoğunlukla
kaydedilen ve paylaşılan bir veri değildir, ama illa ki gerekiyorsa, onu
tahmin edebilen bazı metotlar mevcut, bkz <em>Ekler</em> bölümü.</p>
<p>Neyse, araca gireriz, vadeli işlem sözleşmeleri için bir kerede kaç
tane sözleşme alınacağı AFSF için bir eşik değeri oluşturabilir, buna da
dikkat, mesela Euro Stoxx 50 için Ocak 23, 2015’te bakıyoruz, 437
sözleşme ve altındaki satımlar için 3369 fiyatı verilmiş, alımlarda 7
sözleşme ve altı alımlar için 3370 fiyatı verilmiş. Harcama demek ki
3370-3369 / 2 = 0.5 (altta <code>slippage</code> kolonunda). Şimdi bu
bedeli yine en son fiyata göre bir yüzdeye çeviririz, 0.5 / 3370 * 100 =
%0.01483. Ardından bu değeri bir para miktarına çeviririz, yüzde 1’lik
değişimi temsil eden değer 3370 fiyat seviyesinde 337 Eur eder (3370 *
nokta değeri * yüzde 1, yani 3370 * 10/100). 337 çarpı 0.0148 = 5
Eur.</p>
<p>Borsa aracı şirketi ek bazı masraflar kesebilir, bu örnekte her
sözleşme için 3 Eur kesiliyor mesela.</p>
<p>Sharpe oranıyla alakalı bir bedel oluşturma yönünde ilerliyoruz.
Çıkartma işlemini şöyle yaparız; bir sene içinde bu enstrümanı, bir
tanesini, sadece bir kez ardı ardına al/sat yaptıysak bu blok masraf C =
5 + 3 = 8 Eur üzerinden 2 <em> C eder. Diyelim Euro Stoxx enstrüman
oynaklığı günlük yüzde 1.5, her yüzde 1’lik hareket 370 Eur ediyor, 370
</em> 1.5 = 506 Eur, bu günlük standart sapma. Onu yıllık standart sapma
haline getirmek için 506 * 16 = 8096 Eur. 2 * 8 /8096 = 0.002 SO
ünitesi. Yani bu değer artık SO’dan çıkartabileceğimiz bir sayıdır.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> StringIO <span class="im">import</span> StringIO</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>COSTS<span class="op">=</span><span class="st">u&quot;&quot;&quot;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="st">instrument,currency,point_value,slippage</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="st">CRUDE_W,USD,1000,0.0145328653</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="st">EDOLLAR,USD,2500,0.0025</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="st">US5,USD,1000,0.004</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="st">EUROSTX,EUR,10,0.5</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="st">V2X,EUR,100,0.0255</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="st">MXP,USD,500000,0.000011567</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="st">CORN,USD,50,0.125</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;&quot;&quot;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>costs <span class="op">=</span> pd.read_csv(StringIO(COSTS),index_col<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>my_curr <span class="op">=</span> <span class="st">&#39;USD&#39;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>vol_target <span class="op">=</span> <span class="fl">0.20</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>capital <span class="op">=</span> <span class="dv">250</span><span class="op">*</span><span class="dv">1000</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>exchange <span class="op">=</span> {<span class="st">&#39;USD&#39;</span>: {<span class="st">&#39;EUR&#39;</span>: <span class="fl">1.1</span>, <span class="st">&#39;USD&#39;</span>: <span class="fl">1.0</span>} }</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>daily_vol_target <span class="op">=</span> capital <span class="op">*</span> vol_target <span class="op">/</span> <span class="dv">16</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calc_cost(ins,dt <span class="op">=</span> <span class="st">&#39;2014-10-14&#39;</span>):</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> zipfile.ZipFile(<span class="st">&#39;legacycsv.zip&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> z:</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        dfi <span class="op">=</span> pd.read_csv(z.<span class="bu">open</span>(<span class="st">&#39;</span><span class="sc">%s</span><span class="st">_price.csv&#39;</span> <span class="op">%</span> ins), index_col<span class="op">=</span><span class="dv">0</span>,parse_dates<span class="op">=</span><span class="va">True</span> )</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        vol <span class="op">=</span> pd.rolling_std(dfi.pct_change()<span class="op">*</span><span class="fl">100.</span>, window<span class="op">=</span><span class="dv">25</span>)    </span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> []</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    price <span class="op">=</span> <span class="bu">float</span>(dfi.ix[dt])</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> <span class="bu">float</span>(vol.ix[dt])</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    point_val <span class="op">=</span> price <span class="op">*</span> costs.ix[ins].point_value <span class="op">/</span> <span class="fl">100.</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    block_vol <span class="op">=</span> block_val<span class="op">*</span>v</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    inst_value_vol <span class="op">=</span>  block_vol<span class="op">*</span>exchange[my_curr][costs.ix[ins].currency]</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    units <span class="op">=</span> daily_vol_target <span class="op">/</span> inst_value_vol</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    exec_cost <span class="op">=</span> (costs.ix[ins].slippage <span class="op">/</span> price) <span class="op">*</span> <span class="dv">100</span> <span class="op">*</span> block_val</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    so_cost <span class="op">=</span>  (exec_cost <span class="op">*</span> <span class="fl">2.</span>) <span class="op">/</span> (<span class="fl">16.</span> <span class="op">*</span> block_vol)</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> price,v,block_val,block_vol,inst_value_vol,units,exec_cost,so_cost</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>price,v,block_val,block_vol,inst_value_vol,units,exec_cost,so_cost <span class="op">=</span> calc_cost(<span class="st">&#39;EUROSTX&#39;</span>)</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> so_cost</span></code></pre></div>
<pre><code>0.001862369503</code></pre>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd, zipfile</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> io <span class="im">import</span> StringIO</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>pd.options.display.float_format <span class="op">=</span> <span class="st">&#39;</span><span class="sc">{0:.4f}</span><span class="st">&#39;</span>.<span class="bu">format</span>    </span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>instruments <span class="op">=</span> [<span class="st">&#39;CRUDE_W&#39;</span>,<span class="st">&#39;EDOLLAR&#39;</span>,<span class="st">&#39;US5&#39;</span>,<span class="st">&#39;EUROSTX&#39;</span>,<span class="st">&#39;V2X&#39;</span>,<span class="st">&#39;MXP&#39;</span>,<span class="st">&#39;CORN&#39;</span>]</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>         </span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> <span class="st">&#39;2014-10-14&#39;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> []</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>cols <span class="op">=</span> [<span class="st">&#39;inst&#39;</span>,<span class="st">&#39;price&#39;</span>,<span class="st">&#39;v&#39;</span>,<span class="st">&#39;block_val&#39;</span>,<span class="st">&#39;block_vol&#39;</span>,<span class="st">&#39;inst_value_vol&#39;</span>,<span class="st">&#39;units&#39;</span>,<span class="st">&#39;exec_cost&#39;</span>,<span class="st">&#39;so_cost&#39;</span>]</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> inst <span class="kw">in</span> instruments:</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    price,v,block_val,block_vol,inst_value_vol,units,exec_cost,so_cost <span class="op">=</span> calc_cost(inst)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    res.append([inst,price,v,block_val,block_vol,inst_value_vol,units,exec_cost,so_cost])</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> pd.DataFrame(res,columns<span class="op">=</span>cols)         </span></code></pre></div>
<pre><code>      inst     price      v  block_val  block_vol  inst_value_vol   units  \
0  CRUDE_W   85.3000 1.2678   853.0000  1081.4529       1081.4529  2.8896   
1  EDOLLAR   97.0550 0.0563  2426.3750   136.7107        136.7107 22.8585   
2      US5  117.0625 0.1699  1170.6250   198.9413        198.9413 15.7081   
3  EUROSTX 2816.0000 1.1917   281.6000   335.5940        369.1534  8.4653   
4      V2X   22.8000 2.6898    22.8000    61.3265         67.4592 46.3243   
5      MXP    0.0718 0.5110   358.7500   183.3214        183.3214 17.0466   
6     CORN  422.7500 1.2475   211.3750   263.6875        263.6875 11.8511   

   exec_cost  so_cost  
0    14.5329   0.0017  
1     6.2500   0.0057  
2     4.0000   0.0025  
3     5.0000   0.0019  
4     2.5500   0.0052  
5     5.7835   0.0039  
6     6.2500   0.0030  </code></pre>
<p>Devir (Turnover)</p>
<p>Tabii SO’dan çıkartma yapmadan önce bir enstrümanı senede yaklaşık
kaç kez alıp sattığımızı bilmemiz gerekir, çünkü biraz önceki
standardize edilmiş harcama tek bir al/sat’ı baz alıyor. Eğer bir
enstrümanın masrafı 0.01 standardize SO ünitesi ise, ve bir senede
yaklaşık 10 al/sat yapıyorsak, ve bu enstrümanı baz alan bir strateji
bize SO 0.5 getiri sağlayacaksa, masrafların çıkartıldığı nihai SO 0.5 -
0.01*10 = 0.4 olacaktır. Senede yapılan yaklaşık al/sat’a devir
(turnover) ismi verelim. Devir sayısını belirleyen nedir? Birkaç faktör
akla gelebilir; mesela stratejimizin yaptığı enstrüman fiyat tahmini;
düşeceğini tahmin ettiğimiz bir enstrümanın pozisyonunu azaltmak
isteyebiliriz, bu satım yapmak demektir, ve masraf ortaya çıkar. Ya da
oynaklıkta değişim olur, ve portföyümüzün oynaklık hedefini aynı
seviyede tutmak için bazı pozisyonlara girmek, ya da mevcut olanlardan
çıkmak gerekebilir.</p>
<p>[1]’in yaklaşımında hedefler tanımlanıyor, mesela oynaklık hedefi,
böylece riskimizin ne olacağını daha baştan biliyoruz, ve bu risk
seviyesi hiç değişmiyor. Aynı şekilde devir için bir hedef koymak, ve bu
hedef üzerinden onu kısıtlamak ta mümkün. Test ettiğimiz bir stratejinin
1/3’ünden fazlasını masraflara kaybetmenin anlamı yok, bu sebeple her
stratejinin SO’sunun 1/3’unu bir devir sayısı sınırını hesaplamak için
kullanabiliriz. Eğer SO 0.4 ise, onun 1/3’u 0.13 eder, yani masraflar
için yıllık 0.13 SO’yu hiçbir şartta geçmemeliyiz , bu demektir ki eğer
masraf 0.002 SO ünitesi olan Euro Stoxx için yıllık devir muhakkak 65
altında olmalıdır.</p>
<p>Not: Eğer masraflar 0.13 SO’su ise ve mesela oynaklık hedefimiz
yıllık yüzde 50 ise, bu getirimizin 0.13 * %50 = yüzde 6.5’si masraflara
gider demektir. Bu az bir oran değil! Şahsi olarak bundan daha fazlasını
tavsiye etmemiz mümkün değil.</p>
<p>Tahminler</p>
<p>Risk elimizdeki denklemin bir parçası. Diğer bir parçası bizim, ya da
algoritmamızın, gelecekte bir varlığın nasıl davranacağı hakkındaki
tahmini. Prensip olarak ikisel tahminlerden kaçınmalıyız, yani 0,1
türünde, evet/hayır, al/sat şeklindeki tahminler. Tahmin bir reel sayı
olmalı, -20/+20 arasında mesela, ve işimizi kolaylaştırması açısından
averaj bir al tahmini için +10 iyidir, açıga satışta averaj -10 değeri
uygundur. O zaman +5 gibi bir tahmin nisbeten daha zayıf bir alım demek,
-20 ise çok kuvvetli bir sat tahmini olacaktır.</p>
<p>O zaman tahminleri öncelikle oynaklık standardizasyonuna tabi tutmak
lazım, ki tahmin Sharpe oranına kıyaslanabilir bir şey olsun, yani
üretilen tahmini önce zaman serisinin yakın zamandaki getirilerinin
standart sapmasına bölmek lazım. Ardından tahminlerin uzun süreli
ortalamasının 10 olmasını istiyoruz, o zaman tahminlerimizin uzun süreli
ortalamasını hesaplayıp, tüm tahminleri “10 / bu ortalama’’ ile
ölçeklememiz lazım, bu sayıya tahmin çarpanı (forecast scalar) ismi
verebiliriz.</p>
<p>Tahmin çarpanları her tahmin algoritması temel alarak hesaplanır,
yani hangi veri tahmin ediliyorsa edilsin bir stratejinin belli bir
çarpanı vardır. Bu hesabı bu yazının altında bulabilirsiniz. Şimdilik bu
çarpanı bildiğimizi farzedelim, EWMA 32,128 için 2.84.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd, zipfile, util</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> zipfile.ZipFile(<span class="st">&#39;legacycsv.zip&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> z:</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span>  pd.read_csv(z.<span class="bu">open</span>(<span class="st">&#39;EUROSTX_price.csv&#39;</span>),sep<span class="op">=</span><span class="st">&#39;,&#39;</span>,index_col<span class="op">=</span><span class="dv">0</span>,parse_dates<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>pred <span class="op">=</span> util.ewma(df.PRICE,<span class="dv">32</span>,<span class="dv">128</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>forecast_scalar <span class="op">=</span> <span class="fl">2.84</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>pred_scaled <span class="op">=</span> pred <span class="op">*</span> forecast_scalar</span></code></pre></div>
<p>Şimdi alt sistem alım ya da satım işlemine gelirsek; üstteki petrol
kontrakt alımını gelecek tahmini üzerinden nasıl ayarlarız? Eğer petrol
VİS’i için averaj, 10 seviyesinde bir alım beklentimiz var ise hiçbir
şey yapmamıza gerek yok, 93.52 tane kontrakt alıyoruz, bu durumda sanki
10 ile çarpıp 10 ile bölmüş oluyoruz, hiçbir etki yok. Fakat tahmin +5.0
ise o zaman 93.50 / 2 = 46.76 tane kontrakt alacağız demektir, satım
için benzer durum, -20 tahmin 93.50 * 2 = 187.04 kontraktı açığa satmak
demektir.</p>
<p>Devir hesabının tahminler ile yakın alakası var. Tahmin zaman
serisinin farkının ortalamasını alıp, bu ortalamayı bir yıldaki iş günü
sayısı ile çarparsak, bu tahmin serisinin sebep olacağı al/sat sayısını
yaklaşık olarak hesaplamış oluruz. Eğer tahminler 10,20,10 olsaydı
mesela bu bir alım, bir satım demektir, farklar 10,-10,.. bu durumu
hemen gösteriyor. Üstteki tahmin serisi için [1, sf. 276],</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>avg <span class="op">=</span>  (pred_scaled <span class="op">/</span> <span class="dv">10</span>).diff().<span class="bu">abs</span>().mean()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> <span class="st">&#39;devir&#39;</span>, avg <span class="op">*</span> <span class="dv">256</span></span></code></pre></div>
<pre><code>devir 8.72554168599</code></pre>
<p>Alt Sistemlerin Ağırlıkları</p>
<p>Daha önce üç tane VİS’i sadece alıp elde tutmak üzerinden ağırlık
hesabı yapmıştık. Alttaki örnekte iki enstrüman üzerinde iki farklı
stratejiyi işleteceğiz, elde iki tane alt sistem (subsystem) olacak, ve
her sistem içinde iki tane tahmin edici bulunacak, ve biz bu her sisteme
ne kadar ağırlık vereceğimizi hesaplayacağız.</p>
<p>Alt sistem içinde aynı enstrüman üzerinde iki strateji işletmek, iki
farklı tahmin yöntemi demektir, yani aynı zaman serisine bakarak iki
yöntem farklı al/sat sinyalleri üretebilirler (tabii aynı fikirde
oldukları zaman bu daha iyi). [1]‘in araştırmalarına göre “strateji
karıştırmanın’’ faydalı olduğu görülmüştür. Tahmin çarpanını daha önce
gördük, alttaki değerler direk [1, sf. 309]’dan geliyor. Ayrıca -20/20
üzeri değerleri -20/20’ye eşitliyoruz, sistemin aşırı büyük tahminler
yapmaması için. Ağırlıkların bulunması için yine bootstrap
kullanıldı.</p>
<p>Tahminlere her sistem içinde eşit ağırlık verdik, yani 0.5 ve 0.5.
İki strateji EWMAC 2,8 ve EWMAC 32,128. Her iki tahminin al/sat
sinyalini bir ileri kaydırıyoruz, ve bir sonraki günün getirisi
üzerinden bu sinyal ile gerçek getiriyi hesaplıyoruz.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> zipfile, pandas <span class="im">as</span> pd, util, random</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>random.seed(<span class="dv">0</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">0</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ewmac(price,slow,fast):</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    vol <span class="op">=</span> util.robust_vol_calc(price.diff())</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    fast_ewma <span class="op">=</span> pd.ewma(price, span<span class="op">=</span>slow)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    slow_ewma <span class="op">=</span> pd.ewma(price, span<span class="op">=</span>fast)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    raw_ewmac <span class="op">=</span> fast_ewma <span class="op">-</span> slow_ewma</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> raw_ewmac <span class="op">/</span>  vol </span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>symbols <span class="op">=</span> [<span class="st">&#39;SP500&#39;</span>,<span class="st">&#39;US20&#39;</span>]</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame()</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> zipfile.ZipFile(<span class="st">&#39;legacycsv.zip&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> z:</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> symbol <span class="kw">in</span> symbols:</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        f <span class="op">=</span> <span class="st">&#39;</span><span class="sc">%s</span><span class="st">_price.csv&#39;</span> <span class="op">%</span> symbol</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        df[symbol] <span class="op">=</span> pd.read_csv(z.<span class="bu">open</span>(f),sep<span class="op">=</span><span class="st">&#39;,&#39;</span>,index_col<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>                                 parse_dates<span class="op">=</span><span class="va">True</span>)[<span class="st">&#39;PRICE&#39;</span>]</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.sort_index()</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>forecast <span class="op">=</span> df.copy()</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>ewmac8_32_scalar <span class="op">=</span> <span class="fl">10.6</span> </span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>ewmac32_128_scalar <span class="op">=</span> <span class="fl">2.65</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;US20_ewmac8_32&#39;</span>] <span class="op">=</span> ewmac(df[<span class="st">&#39;US20&#39;</span>], <span class="dv">8</span>, <span class="dv">32</span>) <span class="op">*</span> ewmac8_32_scalar <span class="op">/</span><span class="fl">10.</span> </span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;US20_ewmac32_128&#39;</span>] <span class="op">=</span> ewmac(df[<span class="st">&#39;US20&#39;</span>], <span class="dv">32</span>, <span class="dv">128</span>) <span class="op">*</span> ewmac32_128_scalar <span class="op">/</span><span class="fl">10.</span> </span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;SP500_ewmac8_32&#39;</span>] <span class="op">=</span> ewmac(df[<span class="st">&#39;SP500&#39;</span>], <span class="dv">8</span>, <span class="dv">32</span>) <span class="op">*</span> ewmac8_32_scalar<span class="op">/</span><span class="fl">10.</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;SP500_ewmac32_128&#39;</span>] <span class="op">=</span> ewmac(df[<span class="st">&#39;SP500&#39;</span>], <span class="dv">32</span>, <span class="dv">128</span>) <span class="op">*</span> ewmac32_128_scalar<span class="op">/</span><span class="fl">10.</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>forecast[<span class="st">&#39;US20&#39;</span>] <span class="op">=</span> (df[<span class="st">&#39;US20_ewmac8_32&#39;</span>] <span class="op">+</span> df[<span class="st">&#39;US20_ewmac32_128&#39;</span>]) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>forecast[<span class="st">&#39;SP500&#39;</span>] <span class="op">=</span> (df[<span class="st">&#39;SP500_ewmac8_32&#39;</span>] <span class="op">+</span> df[<span class="st">&#39;SP500_ewmac32_128&#39;</span>]) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>forecast.loc[forecast.US20 <span class="op">&gt;</span> <span class="dv">20</span>, <span class="st">&#39;US20&#39;</span>] <span class="op">=</span> <span class="fl">20.</span></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>forecast.loc[forecast.SP500 <span class="op">&gt;</span> <span class="dv">20</span>, <span class="st">&#39;SP500&#39;</span>] <span class="op">=</span> <span class="fl">20.</span></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>forecast.loc[forecast.US20 <span class="op">&lt;</span> <span class="op">-</span><span class="dv">20</span>, <span class="st">&#39;US20&#39;</span>] <span class="op">=</span> <span class="op">-</span><span class="fl">20.</span></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>forecast.loc[forecast.SP500 <span class="op">&lt;</span> <span class="op">-</span><span class="dv">20</span>, <span class="st">&#39;SP500&#39;</span>] <span class="op">=</span> <span class="op">-</span><span class="fl">20.</span></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;US20&#39;</span>] <span class="op">=</span> df[<span class="st">&#39;US20&#39;</span>].pct_change() <span class="op">*</span> forecast.shift(<span class="dv">1</span>).US20 <span class="op">/</span> <span class="fl">10.</span></span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;SP500&#39;</span>] <span class="op">=</span> df[<span class="st">&#39;SP500&#39;</span>].pct_change() <span class="op">*</span> forecast.shift(<span class="dv">1</span>).SP500 <span class="op">/</span> <span class="fl">10.</span></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df[[<span class="st">&#39;US20&#39;</span>,<span class="st">&#39;SP500&#39;</span>]]</span></code></pre></div>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys<span class="op">;</span> sys.path.append(<span class="st">&#39;../tser_port&#39;</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> boot</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>weights<span class="op">=</span>boot.optimise_over_periods(df,rollyears<span class="op">=</span><span class="dv">20</span>, monte_carlo<span class="op">=</span><span class="dv">20</span>,monte_length<span class="op">=</span><span class="dv">250</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> np.array(weights.tail(<span class="dv">1</span>))</span></code></pre></div>
<pre><code>[[ 0.34008769  0.65991231]]</code></pre>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>weights.plot()</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_voltar_01.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_voltar_01.png" /></p>
<p>Enstruman Çeşitlendirme Çarpanı (Instrument Diversification
Multiplier - IDM)</p>
<p>Tekrar üzerinden geçersek, risk hedeflememizi yaptık, her alt sistem
içine bu hedefe göre strateji doldurduk ki her alt sistem aynı riske
sahip, ardından alt sistem ağırlıklarını hesapladık ve her alt sisteme
gerekli parayı ayırdık. Fakat bu noktada ortaya bir problem çıkar, çünkü
ağırlık kullanımı, ve alt sistem getirilerinin arasında (elimizden
geldiğince) korelasyonu az tutmuş olmamız sebebiyle nihai sistemin genel
riski azaldı. Yani hedeflediğimiz riskten sapmış olduk. Elde etmek
istediğimiz risk sanki her alt sistemi kendi başına işletiyormuş gibi
elde edeceğimiz risk gibi olmalı. O zaman bize öyle bir çarpan lazım ki
risk azalmasını telafi etsin, ve pozisyon hesabını yaparken bu çarpanı
uygulayarak risk hedefine geri dönelim.</p>
<p>N tane alt sistemimizin olduğunu düşünelim, bu sistemlerin
getirilerinin korelasyon matrisi <span class="math inline">\(H\)</span>
olsun, ve biraz önce bulduğumuz ağırlıklar <span
class="math inline">\(W\)</span> (ki ağırlıkların toplamı 1). O zaman
IDM, <span class="math inline">\(1 / \sqrt{(W \cdot H \cdot
W^T)}\)</span> olacaktır. Dikkat edersek bu formül (2)’nin tam
tersi.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>H <span class="op">=</span> df.corr()</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>H <span class="op">=</span> H.clip(lower<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> <span class="st">&#39;Korelasyon&#39;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> H</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>W <span class="op">=</span> np.array([[<span class="fl">0.34</span>,  <span class="fl">0.66</span>]]) <span class="co"># ustteki sonuc</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>idm<span class="op">=</span><span class="fl">1.0</span> <span class="op">/</span> (<span class="bu">float</span>(np.dot(np.dot(W, H), W.transpose()))) <span class="op">**</span><span class="fl">.5</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> <span class="st">&#39;</span><span class="ch">\n</span><span class="st">IDM&#39;</span>, idm</span></code></pre></div>
<pre><code>Korelasyon
           US20     SP500
US20   1.000000  0.096425
SP500  0.096425  1.000000

IDM 1.29697910974</code></pre>
<p>Tahmin Çarpanlarını Hesaplamak</p>
<p>Her tahmin algoritmasi için eldeki <em>tüm</em> veriler üzerinde
tahmin üretiriz, yani her enstrüman verisi için tahmin üretip, tüm bu
tahminleri birleştirip koca bir zaman serisi oluştururuz (bu tekniğe
havuzlama -pooling- ismi veriliyor), ve bu serinin mutlak değerlerinin
(absolute value) ortalamasını alırız.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> util, zipfile, pandas <span class="im">as</span> pd</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>ewmacs <span class="op">=</span> [(<span class="dv">2</span>,<span class="dv">8</span>),(<span class="dv">4</span>,<span class="dv">16</span>),(<span class="dv">8</span>,<span class="dv">32</span>),(<span class="dv">16</span>,<span class="dv">64</span>),(<span class="dv">32</span>,<span class="dv">128</span>),(<span class="dv">64</span>,<span class="dv">256</span>)]</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (fast,slow) <span class="kw">in</span> ewmacs: </span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> zipfile.ZipFile(<span class="st">&#39;legacycsv.zip&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> z:</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        res <span class="op">=</span> []</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> x <span class="kw">in</span>  z.namelist():</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="st">&#39;_price&#39;</span> <span class="kw">in</span> x:</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>                df <span class="op">=</span> pd.read_csv(z.<span class="bu">open</span>(x), index_col<span class="op">=</span><span class="dv">0</span>,parse_dates<span class="op">=</span><span class="va">True</span> )</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>                tmp <span class="op">=</span> util.ewma(df.PRICE, fast, slow)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>                res.append(tmp)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    tmp <span class="op">=</span> pd.DataFrame(pd.concat(res))</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    tmp.columns <span class="op">=</span> [<span class="st">&#39;forecast&#39;</span>]</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    target_abs_forecast <span class="op">=</span> <span class="fl">10.</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    tmp<span class="op">=</span>tmp.<span class="bu">abs</span>().iloc[:,<span class="dv">0</span>]</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    avg_abs_value<span class="op">=</span>tmp.mean()    </span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span> <span class="st">&#39;ewma&#39;</span>, slow,fast,<span class="st">&#39;=&#39;</span>, target_abs_forecast<span class="op">/</span>avg_abs_value</span></code></pre></div>
<pre><code>ewma 2 8 = 12.8587606411
ewma 4 16 = 8.91499507015
ewma 8 32 = 6.09843054736
ewma 16 64 = 4.17115322451
ewma 32 128 = 2.84127283125
ewma 64 256 = 1.92365849221</code></pre>
<p>Taşıma kuralı (carry) için (not: TK verisini ayrı kontratlardan nasıl
yaratabileceğimizi <em>Vadeli İşlem Sözleşmeleri</em> bölümünde
görmüştük, bu yazıda basitlik amacı ile [1] için yaratılmış hazır veriyi
kullanıyoruz),</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> util, zipfile</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> zipfile.ZipFile(<span class="st">&#39;legacycsv.zip&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> z:</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> []</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> z.namelist():</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="st">&#39;_carrydata&#39;</span> <span class="kw">in</span> x:</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>            df <span class="op">=</span> pd.read_csv(z.<span class="bu">open</span>(x), index_col<span class="op">=</span><span class="dv">0</span>,parse_dates<span class="op">=</span><span class="va">True</span> )</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>            f <span class="op">=</span> x.replace(<span class="st">&quot;__carrydata&quot;</span>,<span class="st">&quot;_price&quot;</span>)</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>            dfc <span class="op">=</span> pd.read_csv(z.<span class="bu">open</span>(f),index_col<span class="op">=</span><span class="dv">0</span>,parse_dates<span class="op">=</span><span class="va">True</span> )     </span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>            vol <span class="op">=</span> util.robust_vol_calc(dfc.PRICE.diff())</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>            carryoffset <span class="op">=</span> np.<span class="bu">abs</span>(<span class="bu">float</span>((df.PRICE_CONTRACT <span class="op">-</span> df.CARRY_CONTRACT).tail(<span class="dv">1</span>)))</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>            forecast <span class="op">=</span>  util.carry(df.CARRY<span class="op">-</span>df.PRICE, vol,np.<span class="bu">abs</span>(carryoffset)<span class="op">/</span><span class="dv">12</span>)</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>            res.append(forecast)</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    tmp <span class="op">=</span> pd.DataFrame(pd.concat(res))</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    tmp <span class="op">=</span> tmp.dropna()</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    tmp.columns <span class="op">=</span> [<span class="st">&#39;forecast&#39;</span>]</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    tmp<span class="op">=</span>tmp.<span class="bu">abs</span>().iloc[:,<span class="dv">0</span>]</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>    avg_abs_value<span class="op">=</span>tmp.mean()</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span> <span class="fl">10.</span><span class="op">/</span>avg_abs_value </span></code></pre></div>
<pre><code>21.44</code></pre>
<p>Bu değerler [1, sf. 309] ile uyumlu.</p>
<p>Strateji Ağırlıklarını Hesaplamak (Forecast Weight Estimation)</p>
<p>[1]’in yaklaşımlarından bir diğeri seçilen stratejilerin hangi
ağırlıklarla her alt sistem üzerinde kullanılacağını bulmak. Daha önce
alt sistem içinde stratejilere eşit ağırlık vermiştik. Gerçek dünyada bu
ağırlıkların optimal olması iyi olur. Her alt sistemde aynı strateji
demeti olur, bu demetlere belli ağırlıklar verilir, ve her alt sistem,
aynı demeti bu ağırlıklar üzerinden kullanır. Mesela petrol VİS’i
üzerinde EWMAC 2,8, EWMAC 16,64 ve taşıma kuralı (carry trade, TK)
kullanıyor olabiliriz, bunların ağırlığı 0.2, 0.3, 0.5 olabilir. Diğer
bir alt sistem, mesela kahve, Eurodollar aynı ağırlıkları aynı şekilde
kullanır.</p>
<p>Ağırlıkları bulmadan önce, hangi strateji demetiyle başlamak lazım?
Bir liste çıkartmak çok zor değil, [1, sf. 309]’a göre EWMAC’ın yavaş ve
hızlı parametreleri arasında 1’e 4 oranı mantıklı, yani EW 1,4, EW 2,8,
EW 4,16, EW 8,32, diye devam edebiliriz. Bu listeden eleme yapmak için
onların masraflarını kullanmak iyi oluyor, çok masraflı olan
stratejileri direk eleriz. Bu konuya sonra döneceğiz.</p>
<p>Şimdilik nihai demeti kararlaştırmış olduğumuzu düşünelim, mesela
CORN, EDOLLAR, EUROSTX, MXP, US10, V2X üzerinde EW 16,64, EW 32,128, EW
64,256 ve TK stratejilerini kullanacağız. Ağırlıkları hesaplamak için
alt sistemler arası kullandığımız hesaba benzer yaklaşımı kullanacağız,
boostrap tekniğini devreye sokacağız. Ayrıca havuzlama tekniğini de
kullanacağız, eldeki <em>tüm</em> enstrümanlar üzerinden elde edilen
stratejilerin tahminlerini birleştireceğiz. Mesela EWMAC 16,64 ile CORN,
EDOLLAR, vs tahminleri yapıp bu serileri uç uca koyacağız, böylece
eldeki veriyi arttırmış olacağız.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> util, zipfile, pandas <span class="im">as</span> pd, collections</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>ewmacs <span class="op">=</span> [(<span class="dv">16</span>,<span class="dv">64</span>),(<span class="dv">32</span>,<span class="dv">128</span>),(<span class="dv">64</span>,<span class="dv">256</span>)]</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>forecasts <span class="op">=</span> collections.OrderedDict()</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> ewmacs: forecasts[x] <span class="op">=</span> []</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>forecasts[<span class="st">&#39;carry&#39;</span>] <span class="op">=</span> []</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>prices <span class="op">=</span> collections.OrderedDict()</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> ewmacs: prices[x] <span class="op">=</span> []</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>prices[<span class="st">&#39;carry&#39;</span>] <span class="op">=</span> []</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>insts <span class="op">=</span> [<span class="st">&#39;CORN&#39;</span>, <span class="st">&#39;EDOLLAR&#39;</span>, <span class="st">&#39;EUROSTX&#39;</span>, <span class="st">&#39;MXP&#39;</span>, <span class="st">&#39;US10&#39;</span>, <span class="st">&#39;V2X&#39;</span>]</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> zipfile.ZipFile(<span class="st">&#39;legacycsv.zip&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> z:</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> inst <span class="kw">in</span> insts: </span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>        df1 <span class="op">=</span> pd.read_csv(z.<span class="bu">open</span>(<span class="st">&#39;</span><span class="sc">%s</span><span class="st">_price.csv&#39;</span> <span class="op">%</span> inst),<span class="op">\</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>                          index_col<span class="op">=</span><span class="dv">0</span>,parse_dates<span class="op">=</span><span class="va">True</span> )     </span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>        df2 <span class="op">=</span> pd.read_csv(z.<span class="bu">open</span>(<span class="st">&#39;</span><span class="sc">%s</span><span class="st">_carrydata.csv&#39;</span> <span class="op">%</span> inst), <span class="op">\</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>                          index_col<span class="op">=</span><span class="dv">0</span>,parse_dates<span class="op">=</span><span class="va">True</span> )     </span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (fast,slow) <span class="kw">in</span> ewmacs:</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>             vol <span class="op">=</span> util.robust_vol_calc(df1.PRICE.diff())</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>             forecasts[(fast,slow)].append(util.ewma(df1.PRICE, fast, slow))</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>             prices[(fast,slow)].append(df1.PRICE)</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>        raw_carry <span class="op">=</span> df2.CARRY_CONTRACT<span class="op">-</span>df2.PRICE_CONTRACT</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>        carryoffset <span class="op">=</span> df2.PRICE_CONTRACT <span class="op">-</span> df2.CARRY_CONTRACT</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>        forecast <span class="op">=</span>  util.carry(raw_carry, vol,  <span class="op">\</span></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>                               carryoffset<span class="op">*</span><span class="dv">1</span><span class="op">/</span>util.CALENDAR_DAYS_IN_YEAR)</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>        forecasts[<span class="st">&#39;carry&#39;</span>].append(forecast)</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>        prices[<span class="st">&#39;carry&#39;</span>].append(df1.PRICE)</span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> forecasts:</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>    forecasts[x] <span class="op">=</span> pd.concat(forecasts[x])</span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> prices:</span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>    prices[x] <span class="op">=</span> pd.concat(prices[x])</span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a>dff <span class="op">=</span> pd.DataFrame()</span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> forecasts: dff[x] <span class="op">=</span> forecasts[x]</span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a>dfp <span class="op">=</span> pd.DataFrame()</span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> prices: dfp[x] <span class="op">=</span> prices[x]</span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a>rng <span class="op">=</span> pd.date_range(<span class="st">&#39;1/1/1900&#39;</span>, periods<span class="op">=</span><span class="bu">len</span>(dff), freq<span class="op">=</span><span class="st">&#39;D&#39;</span>)</span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a>dff <span class="op">=</span> dff.set_index(rng)</span>
<span id="cb18-44"><a href="#cb18-44" aria-hidden="true" tabindex="-1"></a>dfp <span class="op">=</span> dfp.set_index(rng)</span>
<span id="cb18-45"><a href="#cb18-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-46"><a href="#cb18-46" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> dfp.pct_change() <span class="op">*</span> dff.shift(<span class="dv">1</span>)</span>
<span id="cb18-47"><a href="#cb18-47" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.dropna()</span></code></pre></div>
<div class="sourceCode" id="cb19"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys<span class="op">;</span> sys.path.append(<span class="st">&#39;../tser_port&#39;</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> boot</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>weights<span class="op">=</span>boot.optimise_over_periods(df, rollyears<span class="op">=</span><span class="dv">20</span>, monte_carlo<span class="op">=</span><span class="dv">20</span>,monte_length<span class="op">=</span><span class="dv">250</span>)</span></code></pre></div>
<p>Üstteki kod işledikten sonra EW 16,64, EW 32,128, EW 64,256, TK
stratejileri için sırayla 0.45, 0.05, 0.22, 0.28 ağırlıkları rapor
edilecek. Bu değerler [3]’te verilenlere benziyor, TK üzerinde oldukça
ağırlık var, bu mantıklı çünkü diğer stratejilerle çok korelasyonu
olmayan bir strateji bu. Ortalama hızdaki EWMA’ya yüzde 5 civarı
verilmiş, geri kalanlar arasında daha hızlı olan en çok ağırlığa sahip,
değişimlere hızlı tepki verebilmenin faydası var demek ki.</p>
<p>Stratejilerin Korelasyonu</p>
<p>Farklı EWMA stratejilerinin getirilerinin tek bir enstrüman üzerinden
korelasyonu altta bulunabilir [1, sf. 319].</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> util, zipfile, pandas <span class="im">as</span> pd, collections</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>ewmacs <span class="op">=</span> [(<span class="dv">2</span>,<span class="dv">8</span>),(<span class="dv">4</span>,<span class="dv">16</span>),(<span class="dv">8</span>,<span class="dv">32</span>),(<span class="dv">16</span>,<span class="dv">64</span>),(<span class="dv">32</span>,<span class="dv">128</span>),(<span class="dv">64</span>,<span class="dv">256</span>)]</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>inst <span class="op">=</span> <span class="st">&#39;US5&#39;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> zipfile.ZipFile(<span class="st">&#39;legacycsv.zip&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> z:</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> pd.read_csv(z.<span class="bu">open</span>(<span class="st">&#39;</span><span class="sc">%s</span><span class="st">_price.csv&#39;</span> <span class="op">%</span> inst),<span class="op">\</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>                    index_col<span class="op">=</span><span class="dv">0</span>,parse_dates<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(index<span class="op">=</span>p.index)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (fast,slow) <span class="kw">in</span> ewmacs:</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>     fs <span class="op">=</span> util.ewma(p.PRICE, fast, slow)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>     df[<span class="st">&#39;</span><span class="sc">%d</span><span class="st">-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span> (fast,slow)] <span class="op">=</span> util.ccy_returns(p.PRICE, fs)</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> df.corr()</span></code></pre></div>
<pre><code>             2-8      4-16      8-32     16-64    32-128    64-256
2-8     1.000000  0.869692  0.624934  0.402105  0.233632  0.143689
4-16    0.869692  1.000000  0.898819  0.673206  0.433222  0.270579
8-32    0.624934  0.898819  1.000000  0.902239  0.668067  0.437073
16-64   0.402105  0.673206  0.902239  1.000000  0.896226  0.657881
32-128  0.233632  0.433222  0.668067  0.896226  1.000000  0.891021
64-256  0.143689  0.270579  0.437073  0.657881  0.891021  1.000000</code></pre>
<p>Her stratejinin bir sonraki stratejiyle yakın bağlantısı olduğu
görülüyor, ama en azından bu bağlantı yüzde 99 değil, yüzde 90
civarı.</p>
<p>Oynaklık Standardizasyonu</p>
<p>Ornek: Bund beklenen getirisi yılda %2, beklenen yıllık standart
sapma %8. Schatz vadeli işlem sözleşmesi 1% ama beklenen oynaklık 2%.
Risk her iki tarafta aynı olacak şekilde eşitleme yaparsak, Schatz’in
beklenen getirisi Bund’un iki katıdır.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> util</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>returns <span class="op">=</span> [<span class="fl">2.</span>,<span class="fl">1.</span>] <span class="co"># bund,schatz</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>volatilies <span class="op">=</span> [<span class="fl">8.</span>,<span class="fl">2.</span>] <span class="co"># bund,schatz</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>returns,vols <span class="op">=</span> util.vol_equaliser(returns,volatilies)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> <span class="st">&#39;getiriler&#39;</span>, returns</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> <span class="st">&#39;oynaklik&#39;</span>, vols</span></code></pre></div>
<pre><code>getiriler [1.25, 2.5]
oynaklik [5.0, 5.0]</code></pre>
<p>Oynaklık standardizasyonu hesabı oynaklıklar için bir ortalama
almaktan ibarettir. Tüm oynaklıklar bu ortalamaya eşitlenir, ve aynı
oranda getiriler ayarlanır.</p>
<p>Kaynaklar</p>
<p>[1] Carver, <em>Systematic Trading</em></p>
<p>[2] Heydt, <em>Mastering Pandas for Finance</em></p>
<p>[3] Carver, <em>Correlations, Weights, Multipliers…. </em>, <a
href="http://qoppac.blogspot.co.uk/2016/01/correlations-weights-multipliers.html">http://qoppac.blogspot.co.uk/2016/01/correlations-weights-multipliers.html</a></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
