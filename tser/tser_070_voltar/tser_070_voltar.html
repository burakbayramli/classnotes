<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Risk ve Oynaklık Hedeflemesi</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<h1 id="risk-ve-oynaklık-hedeflemesi">Risk ve Oynaklık Hedeflemesi</h1>
<p>En basit formunda risk idaresi için risk eşliği yöntemi (risk parity) var; enstrümanlara portföyde risklerine (oynaklıklarına) ters oranda ağırlık vermek. [1] buna bazı ekler yapar, bir oynaklık hedefi kavramını ekler ve bu hedefe göre her alt sistemi ayarlar. Ayrıca risk eşliği oynaklığı bir kez hesaplar ve bir daha bakmaz, yeni sistem oynaklığı her gün belli gün geriye bakarak tüm enstrümanlar için tekrar tekrar hesaplar.</p>
<p>Hedefleme şöyle işler: Önce bir yıllık oynaklık yüzdesi hedefleriz, yüzde 20 diyelim, ve bu yüzdeden bir nakit oynaklık hedefi hesaplarız. Sermaye 100,000 lira için bu 20,000 lira, bunu gün seviyesine indiririz, 20,000 / <span class="math inline">\(\sqrt{256}\)</span> = 1,250. Ardından her enstrümanın günlük fiyat oynaklığını buluruz, ve günlük oynaklık bölü bu sayı ile o enstrümandan kaç tane alacağımızı hesaplarız. Bu konunun detaylarını işleyeceğiz. Diğer her parametre bu hedefe göre değiştirilir. Bu yaklaşımın iyi tarafı yatırımcı kendini rahat hissettiği, ve getirisini yeterli bulduğu bir oynaklık üzerinde önceden karar verir, ve portföyünü buna göre düzenler, ve bu oynaklık bir daha (uzun süre) değişmez.</p>
<p>Sharpe oranı (SO) ile oynaklık hedeflemesi arasında bir ilişki var. Önce şunu belirtelim, bu yaklaşımda kazanç ile sermaye artmış ise o zaman oynaklık yüzdesi ile daha çok para yatırıma gitmelidir, kayıpta daha az. Bu da daha önce gördüğümüz Kelly yaklaşımının bir çeşidi. Şimdi, oynaklığı SO ile çarparak yıllık beklenen getiriyi hesaplamak mümkündür, çünkü SO zaten getiri bölü risk, yani bölü oynaklık idi.</p>
<p>Blok Degeri</p>
<p>Bir enstrümanın blok değeri o enstrümanın en ufak biriminde, o enstrümanın fiyatının %1 değişmesi ile ortaya çıkan fiyat farkıdır. Mesela ham petrol vadeli işlem sözleşmelerinde 1 kontraktın içinde 1000 varil vardır. Eğer yüzde 1 değişim ile fiyat $75'ten $75.75'e çıkarsa tüm değişim $.75 * 1000 = $750 demektir. Blok değeri budur.</p>
<p>Fakat yüzde 1'lik değişimin şansı nedir? Senetlerin ortalama fiyat oynaklığı yüzde 1 olabilir, diğer yanda Almanya 2-yıllık Schatz tahvil VİS'lerinin günlük standart sapması %0.02'dır. Petrole dönelim, diyelim ki tarihi veriye bakarak günlük ortalama değişimin yüzde 1.33 olduğunu bulduk, bu durumda günlük kar veya kaybımız ortalama 750 Dolar x 1.33 = 997.50 Dolar olacak demektir, çünkü yüzde 1'lik değişim 750 Dolar idi. Bu sonuca enstrüman kur oynaklığı (instrument currency volatility) diyelim.</p>
<p>Bir adım daha, eğer portföyümüz Türkiye'de TL bazlı bir hesap kullanıyorsak, kur değişimi yapmamız lazım, bu örnek için İngiliz pound olsun, USD/GBP kuru bugün 0.67, o zaman 997.50*0.67 = 668.325 Pound.</p>
<p>Formül yerine tek bir değer kayıtlı tutmak daha rahat olduğu için bir tek sayı değeri de hesaplanabilir, nokta değeri (point value) burada kullanılır; bir VİS'in fiyatında 1 birimlik değişimin ne kadar toptan değişimi temsil ettiği yani. Üstteki petrol örneğinde $1'lik degisim kontraktta 1000 varil olduğu için bu $1000'lik bir değişim demektir, nokta değeri olarak bu tutulur. Günlük ortalama yüzde değişimi biliyoruz zaten, 75 x 0.0133 x 1000 = 997.50 Dolar. Aynı sonuca eriştik.</p>
<p>Bu sayı bir enstrümanlık bloğu elde tutmanın günlük riskini gösteriyor, yani tek bir VİS. Eğer portföyde sadece bu entsruman olsaydı, ve 1,000,000 Pound yıllık oynaklık hedefimiz olsaydı, günlük hedef için <span class="math inline">\(\sqrt{256}\)</span>'ya bölüyoruz, yani 1/16'sı 62,500 Pound olur. Bu günlük oynaklık kapasitemiz içine kaç tane petrol VİS'i sığdırabilirdik? Bunun için kapasitemizi günlük tek enstrüman petrol riskine bölüyoruz, 62,500 / 668.325 = 93.52 tane kontrakt. Dikkat bu noktaya kadar hiç yuvarlama yapmadan geldik. Bu arada dikkat edildiyse, bu risk doldurma işlemini sanki oynaklık hedefinin elverdigi tüm parayı sadece o alt sistemde harcayabilirmişiz gibi yapıyoruz. Daha sonra her alt sisteme ayrılan yüzde ile çarpınca paylaştırma tam yapılmış oluyor. Ama bu adım sonra geliyor.</p>
<p>Harcamalar (Costs)</p>
<p>Eğer herhangi bir bir enstrüman için o enstrümandan tek bir bloğu alıp hemen satsaydım, bu git/gel'in o enstrümanın yıllık riskine oranlı bedeli ne olurdu? Bu &quot;standardize edilmiş bedel&quot; bize her git/gel'in yıllık bazlı Sharpe oranından ne kadar kaybettireceğini bize söyler. Sharpe oranı bildiğimiz gibi getirinin yıllık oynaklığa bölünmüş halidir, getirinin oynaklığa olan oranı yani, standardize edilmiş bedel de benzer bir hesabı yapar, böylece elde ettiğimiz bedeli direk Sharpe oranından çıkartabilmemizi sağlar.</p>
<p>Git / gel dedik, yani bu ilk harcamanın hesabı alış fiyatı / satış fiyatı aralığıyla yapılır. Niye? Çünkü aldığımızda alış, sattığımızda satış fiyatından satıyoruz. Dikkat: geriye dönük testlerde bir fiyat kullandığımızda bu fiyat çoğunlukla AFSF iki uç noktasının tam orta noktasıdır; Fakat ya orta noktadan alım, ya da satım yapamadıysak? İşte bu &quot;en kötü ihtimal'' bize bir masraf olarak yansır, ki her zaman bu en kötü ihtimale göre bir harcama kalemini hesaba katmamız gerekir. O zaman ASFS yayılımını (spread) buluruz, ve ikiye böleriz, bu harcamadır.</p>
<p>AFSF nereden elde edilir? Borsa aracımızın sağladığı araç üzerinden enstrümanın en son AFSF'na bakarız, ve (birazdan göreceğimiz şekilde) masrafı Sharpe oranına oranlı hesaplarız, bu sebeple hacimden, oynaklıktan ileri gelen değişimlere uyarlanmış bir hesap elde etmiş oluruz.</p>
<p>Geçmişte, tarihi verideki her günde AFSF'nin ne olduğu çoğunlukla kaydedilen ve paylaşılan bir veri değildir, ama illa ki gerekiyorsa, onu tahmin edebilen bazı metotlar mevcut, bkz <em>Ekler</em> bölümü.</p>
<p>Neyse, araca gireriz, vadeli işlem sözleşmeleri için bir kerede kaç tane sözleşme alınacağı AFSF için bir eşik değeri oluşturabilir, buna da dikkat, mesela Euro Stoxx 50 için Ocak 23, 2015'te bakıyoruz, 437 sözleşme ve altındaki satımlar için 3369 fiyatı verilmiş, alımlarda 7 sözleşme ve altı alımlar için 3370 fiyatı verilmiş. Harcama demek ki 3370-3369 / 2 = 0.5 (altta <code>slippage</code> kolonunda). Şimdi bu bedeli yine en son fiyata göre bir yüzdeye çeviririz, 0.5 / 3370 * 100 = %0.01483. Ardından bu değeri bir para miktarına çeviririz, yüzde 1'lik değişimi temsil eden değer 3370 fiyat seviyesinde 337 Eur eder (3370 * nokta değeri * yüzde 1, yani 3370 * 10/100). 337 çarpı 0.0148 = 5 Eur.</p>
<p>Borsa aracı şirketi ek bazı masraflar kesebilir, bu örnekte her sözleşme için 3 Eur kesiliyor mesela.</p>
<p>Sharpe oranıyla alakalı bir bedel oluşturma yönünde ilerliyoruz. Çıkartma işlemini şöyle yaparız; bir sene içinde bu enstrümanı, bir tanesini, sadece bir kez ardı ardına al/sat yaptıysak bu blok masraf C = 5 + 3 = 8 Eur üzerinden 2 <em> C eder. Diyelim Euro Stoxx enstrüman oynaklığı günlük yüzde 1.5, her yüzde 1'lik hareket 370 Eur ediyor, 370 </em> 1.5 = 506 Eur, bu günlük standart sapma. Onu yıllık standart sapma haline getirmek için 506 * 16 = 8096 Eur. 2 * 8 /8096 = 0.002 SO ünitesi. Yani bu değer artık SO'dan çıkartabileceğimiz bir sayıdır.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pandas <span class="im">as</span> pd
<span class="im">from</span> StringIO <span class="im">import</span> StringIO

COSTS<span class="op">=</span><span class="st">u&quot;&quot;&quot;</span>
<span class="st">instrument,currency,point_value,slippage</span>
<span class="st">CRUDE_W,USD,1000,0.0145328653</span>
<span class="st">EDOLLAR,USD,2500,0.0025</span>
<span class="st">US5,USD,1000,0.004</span>
<span class="st">EUROSTX,EUR,10,0.5</span>
<span class="st">V2X,EUR,100,0.0255</span>
<span class="st">MXP,USD,500000,0.000011567</span>
<span class="st">CORN,USD,50,0.125</span>
<span class="st">&quot;&quot;&quot;</span>
costs <span class="op">=</span> pd.read_csv(StringIO(COSTS),index_col<span class="op">=</span><span class="dv">0</span>)

my_curr <span class="op">=</span> <span class="st">&#39;USD&#39;</span>
vol_target <span class="op">=</span> <span class="fl">0.20</span>
capital <span class="op">=</span> <span class="dv">250</span><span class="op">*</span><span class="dv">1000</span>
exchange <span class="op">=</span> {<span class="st">&#39;USD&#39;</span>: {<span class="st">&#39;EUR&#39;</span>: <span class="fl">1.1</span>, <span class="st">&#39;USD&#39;</span>: <span class="fl">1.0</span>} }
daily_vol_target <span class="op">=</span> capital <span class="op">*</span> vol_target <span class="op">/</span> <span class="dv">16</span>

<span class="kw">def</span> calc_cost(ins,dt <span class="op">=</span> <span class="st">&#39;2014-10-14&#39;</span>):
    <span class="cf">with</span> zipfile.ZipFile(<span class="st">&#39;legacycsv.zip&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> z:
        dfi <span class="op">=</span> pd.read_csv(z.<span class="bu">open</span>(<span class="st">&#39;</span><span class="sc">%s</span><span class="st">_price.csv&#39;</span> <span class="op">%</span> ins), index_col<span class="op">=</span><span class="dv">0</span>,parse_dates<span class="op">=</span><span class="va">True</span> )
        vol <span class="op">=</span> pd.rolling_std(dfi.pct_change()<span class="op">*</span><span class="fl">100.</span>, window<span class="op">=</span><span class="dv">25</span>)    
    res <span class="op">=</span> []
    price <span class="op">=</span> <span class="bu">float</span>(dfi.ix[dt])
    v <span class="op">=</span> <span class="bu">float</span>(vol.ix[dt])
    point_val <span class="op">=</span> price <span class="op">*</span> costs.ix[ins].point_value <span class="op">/</span> <span class="fl">100.</span>
    block_vol <span class="op">=</span> block_val<span class="op">*</span>v
    inst_value_vol <span class="op">=</span>  block_vol<span class="op">*</span>exchange[my_curr][costs.ix[ins].currency]
    units <span class="op">=</span> daily_vol_target <span class="op">/</span> inst_value_vol
    exec_cost <span class="op">=</span> (costs.ix[ins].slippage <span class="op">/</span> price) <span class="op">*</span> <span class="dv">100</span> <span class="op">*</span> block_val
    so_cost <span class="op">=</span>  (exec_cost <span class="op">*</span> <span class="fl">2.</span>) <span class="op">/</span> (<span class="fl">16.</span> <span class="op">*</span> block_vol)
    <span class="cf">return</span> price,v,block_val,block_vol,inst_value_vol,units,exec_cost,so_cost

price,v,block_val,block_vol,inst_value_vol,units,exec_cost,so_cost <span class="op">=</span> calc_cost(<span class="st">&#39;EUROSTX&#39;</span>)
<span class="bu">print</span> so_cost</code></pre></div>
<pre><code>0.001862369503</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pandas <span class="im">as</span> pd, zipfile
<span class="im">from</span> io <span class="im">import</span> StringIO
pd.options.display.float_format <span class="op">=</span> <span class="st">&#39;</span><span class="sc">{0:.4f}</span><span class="st">&#39;</span>.<span class="bu">format</span>    

instruments <span class="op">=</span> [<span class="st">&#39;CRUDE_W&#39;</span>,<span class="st">&#39;EDOLLAR&#39;</span>,<span class="st">&#39;US5&#39;</span>,<span class="st">&#39;EUROSTX&#39;</span>,<span class="st">&#39;V2X&#39;</span>,<span class="st">&#39;MXP&#39;</span>,<span class="st">&#39;CORN&#39;</span>]
         
dt <span class="op">=</span> <span class="st">&#39;2014-10-14&#39;</span>
res <span class="op">=</span> []
cols <span class="op">=</span> [<span class="st">&#39;inst&#39;</span>,<span class="st">&#39;price&#39;</span>,<span class="st">&#39;v&#39;</span>,<span class="st">&#39;block_val&#39;</span>,<span class="st">&#39;block_vol&#39;</span>,<span class="st">&#39;inst_value_vol&#39;</span>,<span class="st">&#39;units&#39;</span>,<span class="st">&#39;exec_cost&#39;</span>,<span class="st">&#39;so_cost&#39;</span>]
<span class="cf">for</span> inst <span class="kw">in</span> instruments:
    price,v,block_val,block_vol,inst_value_vol,units,exec_cost,so_cost <span class="op">=</span> calc_cost(inst)
    res.append([inst,price,v,block_val,block_vol,inst_value_vol,units,exec_cost,so_cost])
    
<span class="bu">print</span> pd.DataFrame(res,columns<span class="op">=</span>cols)         </code></pre></div>
<pre><code>      inst     price      v  block_val  block_vol  inst_value_vol   units  \
0  CRUDE_W   85.3000 1.2678   853.0000  1081.4529       1081.4529  2.8896   
1  EDOLLAR   97.0550 0.0563  2426.3750   136.7107        136.7107 22.8585   
2      US5  117.0625 0.1699  1170.6250   198.9413        198.9413 15.7081   
3  EUROSTX 2816.0000 1.1917   281.6000   335.5940        369.1534  8.4653   
4      V2X   22.8000 2.6898    22.8000    61.3265         67.4592 46.3243   
5      MXP    0.0718 0.5110   358.7500   183.3214        183.3214 17.0466   
6     CORN  422.7500 1.2475   211.3750   263.6875        263.6875 11.8511   

   exec_cost  so_cost  
0    14.5329   0.0017  
1     6.2500   0.0057  
2     4.0000   0.0025  
3     5.0000   0.0019  
4     2.5500   0.0052  
5     5.7835   0.0039  
6     6.2500   0.0030  </code></pre>
<p>Devir (Turnover)</p>
<p>Tabii SO'dan çıkartma yapmadan önce bir enstrümanı senede yaklaşık kaç kez alıp sattığımızı bilmemiz gerekir, çünkü biraz önceki standardize edilmiş harcama tek bir al/sat'ı baz alıyor. Eğer bir enstrümanın masrafı 0.01 standardize SO ünitesi ise, ve bir senede yaklaşık 10 al/sat yapıyorsak, ve bu enstrümanı baz alan bir strateji bize SO 0.5 getiri sağlayacaksa, masrafların çıkartıldığı nihai SO 0.5 - 0.01*10 = 0.4 olacaktır. Senede yapılan yaklaşık al/sat'a devir (turnover) ismi verelim. Devir sayısını belirleyen nedir? Birkaç faktör akla gelebilir; mesela stratejimizin yaptığı enstrüman fiyat tahmini; düşeceğini tahmin ettiğimiz bir enstrümanın pozisyonunu azaltmak isteyebiliriz, bu satım yapmak demektir, ve masraf ortaya çıkar. Ya da oynaklıkta değişim olur, ve portföyümüzün oynaklık hedefini aynı seviyede tutmak için bazı pozisyonlara girmek, ya da mevcut olanlardan çıkmak gerekebilir.</p>
<p>[1]'in yaklaşımında hedefler tanımlanıyor, mesela oynaklık hedefi, böylece riskimizin ne olacağını daha baştan biliyoruz, ve bu risk seviyesi hiç değişmiyor. Aynı şekilde devir için bir hedef koymak, ve bu hedef üzerinden onu kısıtlamak ta mümkün. Test ettiğimiz bir stratejinin 1/3'ünden fazlasını masraflara kaybetmenin anlamı yok, bu sebeple her stratejinin SO'sunun 1/3'unu bir devir sayısı sınırını hesaplamak için kullanabiliriz. Eğer SO 0.4 ise, onun 1/3'u 0.13 eder, yani masraflar için yıllık 0.13 SO'yu hiçbir şartta geçmemeliyiz , bu demektir ki eğer masraf 0.002 SO ünitesi olan Euro Stoxx için yıllık devir muhakkak 65 altında olmalıdır.</p>
<p>Not: Eğer masraflar 0.13 SO'su ise ve mesela oynaklık hedefimiz yıllık yüzde 50 ise, bu getirimizin 0.13 * %50 = yüzde 6.5'si masraflara gider demektir. Bu az bir oran değil! Şahsi olarak bundan daha fazlasını tavsiye etmemiz mümkün değil.</p>
<p>Tahminler</p>
<p>Risk elimizdeki denklemin bir parçası. Diğer bir parçası bizim, ya da algoritmamızın, gelecekte bir varlığın nasıl davranacağı hakkındaki tahmini. Prensip olarak ikisel tahminlerden kaçınmalıyız, yani 0,1 türünde, evet/hayır, al/sat şeklindeki tahminler. Tahmin bir reel sayı olmalı, -20/+20 arasında mesela, ve işimizi kolaylaştırması açısından averaj bir al tahmini için +10 iyidir, açıga satışta averaj -10 değeri uygundur. O zaman +5 gibi bir tahmin nisbeten daha zayıf bir alım demek, -20 ise çok kuvvetli bir sat tahmini olacaktır.</p>
<p>O zaman tahminleri öncelikle oynaklık standardizasyonuna tabi tutmak lazım, ki tahmin Sharpe oranına kıyaslanabilir bir şey olsun, yani üretilen tahmini önce zaman serisinin yakın zamandaki getirilerinin standart sapmasına bölmek lazım. Ardından tahminlerin uzun süreli ortalamasının 10 olmasını istiyoruz, o zaman tahminlerimizin uzun süreli ortalamasını hesaplayıp, tüm tahminleri &quot;10 / bu ortalama'' ile ölçeklememiz lazım, bu sayıya tahmin çarpanı (forecast scalar) ismi verebiliriz.</p>
<p>Tahmin çarpanları her tahmin algoritması temel alarak hesaplanır, yani hangi veri tahmin ediliyorsa edilsin bir stratejinin belli bir çarpanı vardır. Bu hesabı bu yazının altında bulabilirsiniz. Şimdilik bu çarpanı bildiğimizi farzedelim, EWMA 32,128 için 2.84.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pandas <span class="im">as</span> pd, zipfile, util
<span class="cf">with</span> zipfile.ZipFile(<span class="st">&#39;legacycsv.zip&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> z:
    df <span class="op">=</span>  pd.read_csv(z.<span class="bu">open</span>(<span class="st">&#39;EUROSTX_price.csv&#39;</span>),sep<span class="op">=</span><span class="st">&#39;,&#39;</span>,index_col<span class="op">=</span><span class="dv">0</span>,parse_dates<span class="op">=</span><span class="va">True</span>)
pred <span class="op">=</span> util.ewma(df.PRICE,<span class="dv">32</span>,<span class="dv">128</span>)
forecast_scalar <span class="op">=</span> <span class="fl">2.84</span>
pred_scaled <span class="op">=</span> pred <span class="op">*</span> forecast_scalar</code></pre></div>
<p>Şimdi alt sistem alım ya da satım işlemine gelirsek; üstteki petrol kontrakt alımını gelecek tahmini üzerinden nasıl ayarlarız? Eğer petrol VİS'i için averaj, 10 seviyesinde bir alım beklentimiz var ise hiçbir şey yapmamıza gerek yok, 93.52 tane kontrakt alıyoruz, bu durumda sanki 10 ile çarpıp 10 ile bölmüş oluyoruz, hiçbir etki yok. Fakat tahmin +5.0 ise o zaman 93.50 / 2 = 46.76 tane kontrakt alacağız demektir, satım için benzer durum, -20 tahmin 93.50 * 2 = 187.04 kontraktı açığa satmak demektir.</p>
<p>Devir hesabının tahminler ile yakın alakası var. Tahmin zaman serisinin farkının ortalamasını alıp, bu ortalamayı bir yıldaki iş günü sayısı ile çarparsak, bu tahmin serisinin sebep olacağı al/sat sayısını yaklaşık olarak hesaplamış oluruz. Eğer tahminler 10,20,10 olsaydı mesela bu bir alım, bir satım demektir, farklar 10,-10,.. bu durumu hemen gösteriyor. Üstteki tahmin serisi için [1, sf. 276],</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">avg <span class="op">=</span>  (pred_scaled <span class="op">/</span> <span class="dv">10</span>).diff().<span class="bu">abs</span>().mean()
<span class="bu">print</span> <span class="st">&#39;devir&#39;</span>, avg <span class="op">*</span> <span class="dv">256</span></code></pre></div>
<pre><code>devir 8.72554168599</code></pre>
<p>Alt Sistemlerin Ağırlıkları</p>
<p>Daha önce üç tane VİS'i sadece alıp elde tutmak üzerinden ağırlık hesabı yapmıştık. Alttaki örnekte iki enstrüman üzerinde iki farklı stratejiyi işleteceğiz, elde iki tane alt sistem (subsystem) olacak, ve her sistem içinde iki tane tahmin edici bulunacak, ve biz bu her sisteme ne kadar ağırlık vereceğimizi hesaplayacağız.</p>
<p>Alt sistem içinde aynı enstrüman üzerinde iki strateji işletmek, iki farklı tahmin yöntemi demektir, yani aynı zaman serisine bakarak iki yöntem farklı al/sat sinyalleri üretebilirler (tabii aynı fikirde oldukları zaman bu daha iyi). [1]'in araştırmalarına göre &quot;strateji karıştırmanın'' faydalı olduğu görülmüştür. Tahmin çarpanını daha önce gördük, alttaki değerler direk [1, sf. 309]'dan geliyor. Ayrıca -20/20 üzeri değerleri -20/20'ye eşitliyoruz, sistemin aşırı büyük tahminler yapmaması için. Ağırlıkların bulunması için yine bootstrap kullanıldı.</p>
<p>Tahminlere her sistem içinde eşit ağırlık verdik, yani 0.5 ve 0.5. İki strateji EWMAC 2,8 ve EWMAC 32,128. Her iki tahminin al/sat sinyalini bir ileri kaydırıyoruz, ve bir sonraki günün getirisi üzerinden bu sinyal ile gerçek getiriyi hesaplıyoruz.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> zipfile, pandas <span class="im">as</span> pd, util, random
random.seed(<span class="dv">0</span>)
np.random.seed(<span class="dv">0</span>)

<span class="kw">def</span> ewmac(price,slow,fast):
    vol <span class="op">=</span> util.robust_vol_calc(price.diff())
    fast_ewma <span class="op">=</span> pd.ewma(price, span<span class="op">=</span>slow)
    slow_ewma <span class="op">=</span> pd.ewma(price, span<span class="op">=</span>fast)
    raw_ewmac <span class="op">=</span> fast_ewma <span class="op">-</span> slow_ewma
    <span class="cf">return</span> raw_ewmac <span class="op">/</span>  vol 

symbols <span class="op">=</span> [<span class="st">&#39;SP500&#39;</span>,<span class="st">&#39;US20&#39;</span>]
df <span class="op">=</span> pd.DataFrame()
<span class="cf">with</span> zipfile.ZipFile(<span class="st">&#39;legacycsv.zip&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> z:
    <span class="cf">for</span> symbol <span class="kw">in</span> symbols:
        f <span class="op">=</span> <span class="st">&#39;</span><span class="sc">%s</span><span class="st">_price.csv&#39;</span> <span class="op">%</span> symbol
        df[symbol] <span class="op">=</span> pd.read_csv(z.<span class="bu">open</span>(f),sep<span class="op">=</span><span class="st">&#39;,&#39;</span>,index_col<span class="op">=</span><span class="dv">0</span>,
                                 parse_dates<span class="op">=</span><span class="va">True</span>)[<span class="st">&#39;PRICE&#39;</span>]
    
df <span class="op">=</span> df.sort_index()
forecast <span class="op">=</span> df.copy()

ewmac8_32_scalar <span class="op">=</span> <span class="fl">10.6</span> 
ewmac32_128_scalar <span class="op">=</span> <span class="fl">2.65</span>

df[<span class="st">&#39;US20_ewmac8_32&#39;</span>] <span class="op">=</span> ewmac(df[<span class="st">&#39;US20&#39;</span>], <span class="dv">8</span>, <span class="dv">32</span>) <span class="op">*</span> ewmac8_32_scalar <span class="op">/</span><span class="fl">10.</span> 
df[<span class="st">&#39;US20_ewmac32_128&#39;</span>] <span class="op">=</span> ewmac(df[<span class="st">&#39;US20&#39;</span>], <span class="dv">32</span>, <span class="dv">128</span>) <span class="op">*</span> ewmac32_128_scalar <span class="op">/</span><span class="fl">10.</span> 
df[<span class="st">&#39;SP500_ewmac8_32&#39;</span>] <span class="op">=</span> ewmac(df[<span class="st">&#39;SP500&#39;</span>], <span class="dv">8</span>, <span class="dv">32</span>) <span class="op">*</span> ewmac8_32_scalar<span class="op">/</span><span class="fl">10.</span>
df[<span class="st">&#39;SP500_ewmac32_128&#39;</span>] <span class="op">=</span> ewmac(df[<span class="st">&#39;SP500&#39;</span>], <span class="dv">32</span>, <span class="dv">128</span>) <span class="op">*</span> ewmac32_128_scalar<span class="op">/</span><span class="fl">10.</span>

forecast[<span class="st">&#39;US20&#39;</span>] <span class="op">=</span> (df[<span class="st">&#39;US20_ewmac8_32&#39;</span>] <span class="op">+</span> df[<span class="st">&#39;US20_ewmac32_128&#39;</span>]) <span class="op">/</span> <span class="dv">2</span>
forecast[<span class="st">&#39;SP500&#39;</span>] <span class="op">=</span> (df[<span class="st">&#39;SP500_ewmac8_32&#39;</span>] <span class="op">+</span> df[<span class="st">&#39;SP500_ewmac32_128&#39;</span>]) <span class="op">/</span> <span class="dv">2</span>

forecast.loc[forecast.US20 <span class="op">&gt;</span> <span class="dv">20</span>, <span class="st">&#39;US20&#39;</span>] <span class="op">=</span> <span class="fl">20.</span>
forecast.loc[forecast.SP500 <span class="op">&gt;</span> <span class="dv">20</span>, <span class="st">&#39;SP500&#39;</span>] <span class="op">=</span> <span class="fl">20.</span>
forecast.loc[forecast.US20 <span class="op">&lt;</span> <span class="dv">-20</span>, <span class="st">&#39;US20&#39;</span>] <span class="op">=</span> <span class="fl">-20.</span>
forecast.loc[forecast.SP500 <span class="op">&lt;</span> <span class="dv">-20</span>, <span class="st">&#39;SP500&#39;</span>] <span class="op">=</span> <span class="fl">-20.</span>

df[<span class="st">&#39;US20&#39;</span>] <span class="op">=</span> df[<span class="st">&#39;US20&#39;</span>].pct_change() <span class="op">*</span> forecast.shift(<span class="dv">1</span>).US20 <span class="op">/</span> <span class="fl">10.</span>
df[<span class="st">&#39;SP500&#39;</span>] <span class="op">=</span> df[<span class="st">&#39;SP500&#39;</span>].pct_change() <span class="op">*</span> forecast.shift(<span class="dv">1</span>).SP500 <span class="op">/</span> <span class="fl">10.</span>
df <span class="op">=</span> df[[<span class="st">&#39;US20&#39;</span>,<span class="st">&#39;SP500&#39;</span>]]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> sys<span class="op">;</span> sys.path.append(<span class="st">&#39;../tser_port&#39;</span>)
<span class="im">import</span> boot
weights<span class="op">=</span>boot.optimise_over_periods(df,rollyears<span class="op">=</span><span class="dv">20</span>, monte_carlo<span class="op">=</span><span class="dv">20</span>,monte_length<span class="op">=</span><span class="dv">250</span>)
<span class="bu">print</span> np.array(weights.tail(<span class="dv">1</span>))</code></pre></div>
<pre><code>[[ 0.34008769  0.65991231]]</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">weights.plot()
plt.savefig(<span class="st">&#39;tser_voltar_01.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="tser_voltar_01.png" />

</div>
<p>Enstruman Çeşitlendirme Çarpanı (Instrument Diversification Multiplier - IDM)</p>
<p>Tekrar üzerinden geçersek, risk hedeflememizi yaptık, her alt sistem içine bu hedefe göre strateji doldurduk ki her alt sistem aynı riske sahip, ardından alt sistem ağırlıklarını hesapladık ve her alt sisteme gerekli parayı ayırdık. Fakat bu noktada ortaya bir problem çıkar, çünkü ağırlık kullanımı, ve alt sistem getirilerinin arasında (elimizden geldiğince) korelasyonu az tutmuş olmamız sebebiyle nihai sistemin genel riski azaldı. Yani hedeflediğimiz riskten sapmış olduk. Elde etmek istediğimiz risk sanki her alt sistemi kendi başına işletiyormuş gibi elde edeceğimiz risk gibi olmalı. O zaman bize öyle bir çarpan lazım ki risk azalmasını telafi etsin, ve pozisyon hesabını yaparken bu çarpanı uygulayarak risk hedefine geri dönelim.</p>
<p>N tane alt sistemimizin olduğunu düşünelim, bu sistemlerin getirilerinin korelasyon matrisi <span class="math inline">\(H\)</span> olsun, ve biraz önce bulduğumuz ağırlıklar <span class="math inline">\(W\)</span> (ki ağırlıkların toplamı 1). O zaman IDM, <span class="math inline">\(1 / \sqrt{(W \cdot H \cdot W^T)}\)</span> olacaktır. Dikkat edersek bu formül (2)'nin tam tersi.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">H <span class="op">=</span> df.corr()
H <span class="op">=</span> H.clip(lower<span class="op">=</span><span class="dv">0</span>)
<span class="bu">print</span> <span class="st">&#39;Korelasyon&#39;</span>
<span class="bu">print</span> H
W <span class="op">=</span> np.array([[<span class="fl">0.34</span>,  <span class="fl">0.66</span>]]) <span class="co"># ustteki sonuc</span>
idm<span class="op">=</span><span class="fl">1.0</span> <span class="op">/</span> (<span class="bu">float</span>(np.dot(np.dot(W, H), W.transpose()))) <span class="op">**</span>.<span class="dv">5</span>
<span class="bu">print</span> <span class="st">&#39;</span><span class="ch">\n</span><span class="st">IDM&#39;</span>, idm</code></pre></div>
<pre><code>Korelasyon
           US20     SP500
US20   1.000000  0.096425
SP500  0.096425  1.000000

IDM 1.29697910974</code></pre>
<p>Tahmin Çarpanlarını Hesaplamak</p>
<p>Her tahmin algoritmasi için eldeki <em>tüm</em> veriler üzerinde tahmin üretiriz, yani her enstrüman verisi için tahmin üretip, tüm bu tahminleri birleştirip koca bir zaman serisi oluştururuz (bu tekniğe havuzlama -pooling- ismi veriliyor), ve bu serinin mutlak değerlerinin (absolute value) ortalamasını alırız.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> util, zipfile, pandas <span class="im">as</span> pd

ewmacs <span class="op">=</span> [(<span class="dv">2</span>,<span class="dv">8</span>),(<span class="dv">4</span>,<span class="dv">16</span>),(<span class="dv">8</span>,<span class="dv">32</span>),(<span class="dv">16</span>,<span class="dv">64</span>),(<span class="dv">32</span>,<span class="dv">128</span>),(<span class="dv">64</span>,<span class="dv">256</span>)]

<span class="cf">for</span> (fast,slow) <span class="kw">in</span> ewmacs: 
    <span class="cf">with</span> zipfile.ZipFile(<span class="st">&#39;legacycsv.zip&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> z:
        res <span class="op">=</span> []
        <span class="cf">for</span> x <span class="kw">in</span>  z.namelist():
            <span class="cf">if</span> <span class="st">&#39;_price&#39;</span> <span class="kw">in</span> x:
                df <span class="op">=</span> pd.read_csv(z.<span class="bu">open</span>(x), index_col<span class="op">=</span><span class="dv">0</span>,parse_dates<span class="op">=</span><span class="va">True</span> )
                tmp <span class="op">=</span> util.ewma(df.PRICE, fast, slow)
                res.append(tmp)

    tmp <span class="op">=</span> pd.DataFrame(pd.concat(res))
    tmp.columns <span class="op">=</span> [<span class="st">&#39;forecast&#39;</span>]
    target_abs_forecast <span class="op">=</span> <span class="fl">10.</span>
    tmp<span class="op">=</span>tmp.<span class="bu">abs</span>().iloc[:,<span class="dv">0</span>]
    avg_abs_value<span class="op">=</span>tmp.mean()    
    <span class="bu">print</span> <span class="st">&#39;ewma&#39;</span>, slow,fast,<span class="st">&#39;=&#39;</span>, target_abs_forecast<span class="op">/</span>avg_abs_value</code></pre></div>
<pre><code>ewma 2 8 = 12.8587606411
ewma 4 16 = 8.91499507015
ewma 8 32 = 6.09843054736
ewma 16 64 = 4.17115322451
ewma 32 128 = 2.84127283125
ewma 64 256 = 1.92365849221</code></pre>
<p>Taşıma kuralı (carry) için (not: TK verisini ayrı kontratlardan nasıl yaratabileceğimizi <em>Vadeli İşlem Sözleşmeleri</em> bölümünde görmüştük, bu yazıda basitlik amacı ile [1] için yaratılmış hazır veriyi kullanıyoruz),</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> util, zipfile
<span class="im">import</span> pandas <span class="im">as</span> pd

<span class="cf">with</span> zipfile.ZipFile(<span class="st">&#39;legacycsv.zip&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> z:
    res <span class="op">=</span> []
    <span class="cf">for</span> x <span class="kw">in</span> z.namelist():
        <span class="cf">if</span> <span class="st">&#39;_carrydata&#39;</span> <span class="kw">in</span> x:
            df <span class="op">=</span> pd.read_csv(z.<span class="bu">open</span>(x), index_col<span class="op">=</span><span class="dv">0</span>,parse_dates<span class="op">=</span><span class="va">True</span> )
            f <span class="op">=</span> x.replace(<span class="st">&quot;__carrydata&quot;</span>,<span class="st">&quot;_price&quot;</span>)
            dfc <span class="op">=</span> pd.read_csv(z.<span class="bu">open</span>(f),index_col<span class="op">=</span><span class="dv">0</span>,parse_dates<span class="op">=</span><span class="va">True</span> )     
            vol <span class="op">=</span> util.robust_vol_calc(dfc.PRICE.diff())
            carryoffset <span class="op">=</span> np.<span class="bu">abs</span>(<span class="bu">float</span>((df.PRICE_CONTRACT <span class="op">-</span> df.CARRY_CONTRACT).tail(<span class="dv">1</span>)))
            forecast <span class="op">=</span>  util.carry(df.CARRY<span class="op">-</span>df.PRICE, vol,np.<span class="bu">abs</span>(carryoffset)<span class="op">/</span><span class="dv">12</span>)
            res.append(forecast)

    tmp <span class="op">=</span> pd.DataFrame(pd.concat(res))
    tmp <span class="op">=</span> tmp.dropna()
    tmp.columns <span class="op">=</span> [<span class="st">&#39;forecast&#39;</span>]
    tmp<span class="op">=</span>tmp.<span class="bu">abs</span>().iloc[:,<span class="dv">0</span>]
    avg_abs_value<span class="op">=</span>tmp.mean()
    <span class="bu">print</span> <span class="fl">10.</span><span class="op">/</span>avg_abs_value </code></pre></div>
<pre><code>21.44</code></pre>
<p>Bu değerler [1, sf. 309] ile uyumlu.</p>
<p>Strateji Ağırlıklarını Hesaplamak (Forecast Weight Estimation)</p>
<p>[1]'in yaklaşımlarından bir diğeri seçilen stratejilerin hangi ağırlıklarla her alt sistem üzerinde kullanılacağını bulmak. Daha önce alt sistem içinde stratejilere eşit ağırlık vermiştik. Gerçek dünyada bu ağırlıkların optimal olması iyi olur. Her alt sistemde aynı strateji demeti olur, bu demetlere belli ağırlıklar verilir, ve her alt sistem, aynı demeti bu ağırlıklar üzerinden kullanır. Mesela petrol VİS'i üzerinde EWMAC 2,8, EWMAC 16,64 ve taşıma kuralı (carry trade, TK) kullanıyor olabiliriz, bunların ağırlığı 0.2, 0.3, 0.5 olabilir. Diğer bir alt sistem, mesela kahve, Eurodollar aynı ağırlıkları aynı şekilde kullanır.</p>
<p>Ağırlıkları bulmadan önce, hangi strateji demetiyle başlamak lazım? Bir liste çıkartmak çok zor değil, [1, sf. 309]'a göre EWMAC'ın yavaş ve hızlı parametreleri arasında 1'e 4 oranı mantıklı, yani EW 1,4, EW 2,8, EW 4,16, EW 8,32, diye devam edebiliriz. Bu listeden eleme yapmak için onların masraflarını kullanmak iyi oluyor, çok masraflı olan stratejileri direk eleriz. Bu konuya sonra döneceğiz.</p>
<p>Şimdilik nihai demeti kararlaştırmış olduğumuzu düşünelim, mesela CORN, EDOLLAR, EUROSTX, MXP, US10, V2X üzerinde EW 16,64, EW 32,128, EW 64,256 ve TK stratejilerini kullanacağız. Ağırlıkları hesaplamak için alt sistemler arası kullandığımız hesaba benzer yaklaşımı kullanacağız, boostrap tekniğini devreye sokacağız. Ayrıca havuzlama tekniğini de kullanacağız, eldeki <em>tüm</em> enstrümanlar üzerinden elde edilen stratejilerin tahminlerini birleştireceğiz. Mesela EWMAC 16,64 ile CORN, EDOLLAR, vs tahminleri yapıp bu serileri uç uca koyacağız, böylece eldeki veriyi arttırmış olacağız.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> util, zipfile, pandas <span class="im">as</span> pd, collections

ewmacs <span class="op">=</span> [(<span class="dv">16</span>,<span class="dv">64</span>),(<span class="dv">32</span>,<span class="dv">128</span>),(<span class="dv">64</span>,<span class="dv">256</span>)]

forecasts <span class="op">=</span> collections.OrderedDict()
<span class="cf">for</span> x <span class="kw">in</span> ewmacs: forecasts[x] <span class="op">=</span> []
forecasts[<span class="st">&#39;carry&#39;</span>] <span class="op">=</span> []
prices <span class="op">=</span> collections.OrderedDict()
<span class="cf">for</span> x <span class="kw">in</span> ewmacs: prices[x] <span class="op">=</span> []
prices[<span class="st">&#39;carry&#39;</span>] <span class="op">=</span> []

insts <span class="op">=</span> [<span class="st">&#39;CORN&#39;</span>, <span class="st">&#39;EDOLLAR&#39;</span>, <span class="st">&#39;EUROSTX&#39;</span>, <span class="st">&#39;MXP&#39;</span>, <span class="st">&#39;US10&#39;</span>, <span class="st">&#39;V2X&#39;</span>]
<span class="cf">with</span> zipfile.ZipFile(<span class="st">&#39;legacycsv.zip&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> z:
    <span class="cf">for</span> inst <span class="kw">in</span> insts: 
        df1 <span class="op">=</span> pd.read_csv(z.<span class="bu">open</span>(<span class="st">&#39;</span><span class="sc">%s</span><span class="st">_price.csv&#39;</span> <span class="op">%</span> inst),<span class="op">\</span>
                          index_col<span class="op">=</span><span class="dv">0</span>,parse_dates<span class="op">=</span><span class="va">True</span> )     
        df2 <span class="op">=</span> pd.read_csv(z.<span class="bu">open</span>(<span class="st">&#39;</span><span class="sc">%s</span><span class="st">_carrydata.csv&#39;</span> <span class="op">%</span> inst), <span class="op">\</span>
                          index_col<span class="op">=</span><span class="dv">0</span>,parse_dates<span class="op">=</span><span class="va">True</span> )     
        <span class="cf">for</span> (fast,slow) <span class="kw">in</span> ewmacs:
             vol <span class="op">=</span> util.robust_vol_calc(df1.PRICE.diff())
             forecasts[(fast,slow)].append(util.ewma(df1.PRICE, fast, slow))
             prices[(fast,slow)].append(df1.PRICE)

        raw_carry <span class="op">=</span> df2.CARRY_CONTRACT<span class="op">-</span>df2.PRICE_CONTRACT
        carryoffset <span class="op">=</span> df2.PRICE_CONTRACT <span class="op">-</span> df2.CARRY_CONTRACT
        forecast <span class="op">=</span>  util.carry(raw_carry, vol,  <span class="op">\</span>
                               carryoffset<span class="op">*</span><span class="dv">1</span><span class="op">/</span>util.CALENDAR_DAYS_IN_YEAR)
        forecasts[<span class="st">&#39;carry&#39;</span>].append(forecast)
        prices[<span class="st">&#39;carry&#39;</span>].append(df1.PRICE)
    
<span class="cf">for</span> x <span class="kw">in</span> forecasts:
    forecasts[x] <span class="op">=</span> pd.concat(forecasts[x])
<span class="cf">for</span> x <span class="kw">in</span> prices:
    prices[x] <span class="op">=</span> pd.concat(prices[x])
    
dff <span class="op">=</span> pd.DataFrame()
<span class="cf">for</span> x <span class="kw">in</span> forecasts: dff[x] <span class="op">=</span> forecasts[x]
dfp <span class="op">=</span> pd.DataFrame()
<span class="cf">for</span> x <span class="kw">in</span> prices: dfp[x] <span class="op">=</span> prices[x]

rng <span class="op">=</span> pd.date_range(<span class="st">&#39;1/1/1900&#39;</span>, periods<span class="op">=</span><span class="bu">len</span>(dff), freq<span class="op">=</span><span class="st">&#39;D&#39;</span>)

dff <span class="op">=</span> dff.set_index(rng)
dfp <span class="op">=</span> dfp.set_index(rng)

df <span class="op">=</span> dfp.pct_change() <span class="op">*</span> dff.shift(<span class="dv">1</span>)
df <span class="op">=</span> df.dropna()</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> sys<span class="op">;</span> sys.path.append(<span class="st">&#39;../tser_port&#39;</span>)
<span class="im">import</span> boot
weights<span class="op">=</span>boot.optimise_over_periods(df, rollyears<span class="op">=</span><span class="dv">20</span>, monte_carlo<span class="op">=</span><span class="dv">20</span>,monte_length<span class="op">=</span><span class="dv">250</span>)</code></pre></div>
<p>Üstteki kod işledikten sonra EW 16,64, EW 32,128, EW 64,256, TK stratejileri için sırayla 0.45, 0.05, 0.22, 0.28 ağırlıkları rapor edilecek. Bu değerler [3]'te verilenlere benziyor, TK üzerinde oldukça ağırlık var, bu mantıklı çünkü diğer stratejilerle çok korelasyonu olmayan bir strateji bu. Ortalama hızdaki EWMA'ya yüzde 5 civarı verilmiş, geri kalanlar arasında daha hızlı olan en çok ağırlığa sahip, değişimlere hızlı tepki verebilmenin faydası var demek ki.</p>
<p>Stratejilerin Korelasyonu</p>
<p>Farklı EWMA stratejilerinin getirilerinin tek bir enstrüman üzerinden korelasyonu altta bulunabilir [1, sf. 319].</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> util, zipfile, pandas <span class="im">as</span> pd, collections
ewmacs <span class="op">=</span> [(<span class="dv">2</span>,<span class="dv">8</span>),(<span class="dv">4</span>,<span class="dv">16</span>),(<span class="dv">8</span>,<span class="dv">32</span>),(<span class="dv">16</span>,<span class="dv">64</span>),(<span class="dv">32</span>,<span class="dv">128</span>),(<span class="dv">64</span>,<span class="dv">256</span>)]
inst <span class="op">=</span> <span class="st">&#39;US5&#39;</span>
<span class="cf">with</span> zipfile.ZipFile(<span class="st">&#39;legacycsv.zip&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> z:
    p <span class="op">=</span> pd.read_csv(z.<span class="bu">open</span>(<span class="st">&#39;</span><span class="sc">%s</span><span class="st">_price.csv&#39;</span> <span class="op">%</span> inst),<span class="op">\</span>
                    index_col<span class="op">=</span><span class="dv">0</span>,parse_dates<span class="op">=</span><span class="va">True</span>)
df <span class="op">=</span> pd.DataFrame(index<span class="op">=</span>p.index)
<span class="cf">for</span> (fast,slow) <span class="kw">in</span> ewmacs:
     fs <span class="op">=</span> util.ewma(p.PRICE, fast, slow)
     df[<span class="st">&#39;</span><span class="sc">%d</span><span class="st">-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span> (fast,slow)] <span class="op">=</span> util.ccy_returns(p.PRICE, fs)
<span class="bu">print</span> df.corr()</code></pre></div>
<pre><code>             2-8      4-16      8-32     16-64    32-128    64-256
2-8     1.000000  0.869692  0.624934  0.402105  0.233632  0.143689
4-16    0.869692  1.000000  0.898819  0.673206  0.433222  0.270579
8-32    0.624934  0.898819  1.000000  0.902239  0.668067  0.437073
16-64   0.402105  0.673206  0.902239  1.000000  0.896226  0.657881
32-128  0.233632  0.433222  0.668067  0.896226  1.000000  0.891021
64-256  0.143689  0.270579  0.437073  0.657881  0.891021  1.000000</code></pre>
<p>Her stratejinin bir sonraki stratejiyle yakın bağlantısı olduğu görülüyor, ama en azından bu bağlantı yüzde 99 değil, yüzde 90 civarı.</p>
<p>Oynaklık Standardizasyonu</p>
<p>Ornek: Bund beklenen getirisi yılda %2, beklenen yıllık standart sapma %8. Schatz vadeli işlem sözleşmesi 1% ama beklenen oynaklık 2%. Risk her iki tarafta aynı olacak şekilde eşitleme yaparsak, Schatz'in beklenen getirisi Bund'un iki katıdır.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> util

returns <span class="op">=</span> [<span class="fl">2.</span>,<span class="fl">1.</span>] <span class="co"># bund,schatz</span>
volatilies <span class="op">=</span> [<span class="fl">8.</span>,<span class="fl">2.</span>] <span class="co"># bund,schatz</span>
returns,vols <span class="op">=</span> util.vol_equaliser(returns,volatilies)
<span class="bu">print</span> <span class="st">&#39;getiriler&#39;</span>, returns
<span class="bu">print</span> <span class="st">&#39;oynaklik&#39;</span>, vols</code></pre></div>
<pre><code>getiriler [1.25, 2.5]
oynaklik [5.0, 5.0]</code></pre>
<p>Oynaklık standardizasyonu hesabı oynaklıklar için bir ortalama almaktan ibarettir. Tüm oynaklıklar bu ortalamaya eşitlenir, ve aynı oranda getiriler ayarlanır.</p>
<p>Kaynaklar</p>
<p>[1] Carver, <em>Systematic Trading</em></p>
<p>[2] Heydt, <em>Mastering Pandas for Finance</em></p>
<p>[3] Carver, <em>Correlations, Weights, Multipliers.... </em>, <a href="http://qoppac.blogspot.co.uk/2016/01/correlations-weights-multipliers.html" class="uri">http://qoppac.blogspot.co.uk/2016/01/correlations-weights-multipliers.html</a></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
