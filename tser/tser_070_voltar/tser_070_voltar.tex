\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Risk ve Oynaklýk Hedeflemesi

En basit formunda risk idaresi için risk eþliði yöntemi (risk parity) var;
enstrümanlara portföyde risklerine (oynaklýklarýna) ters oranda aðýrlýk
vermek. [1] buna bazý ekler yapar, bir oynaklýk hedefi kavramýný ekler ve bu
hedefe göre her alt sistemi ayarlar. Ayrýca risk eþliði oynaklýðý bir kez
hesaplar ve bir daha bakmaz, yeni sistem oynaklýðý her gün belli gün geriye
bakarak tüm enstrümanlar için tekrar tekrar hesaplar.

Hedefleme þöyle iþler: Önce bir yýllýk oynaklýk yüzdesi hedefleriz, yüzde 20
diyelim, ve bu yüzdeden bir nakit oynaklýk hedefi hesaplarýz. Sermaye 100,000
lira için bu 20,000 lira, bunu gün seviyesine indiririz, 20,000 / $\sqrt{256}$ =
1,250. Ardýndan her enstrümanýn günlük fiyat oynaklýðýný buluruz, ve günlük
oynaklýk bölü bu sayý ile o enstrümandan kaç tane alacaðýmýzý hesaplarýz. Bu
konunun detaylarýný iþleyeceðiz. Diðer her parametre bu hedefe göre
deðiþtirilir. Bu yaklaþýmýn iyi tarafý yatýrýmcý kendini rahat hissettiði, ve
getirisini yeterli bulduðu bir oynaklýk üzerinde önceden karar verir, ve
portföyünü buna göre düzenler, ve bu oynaklýk bir daha (uzun süre) deðiþmez.

Sharpe oraný (SO) ile oynaklýk hedeflemesi arasýnda bir iliþki var. Önce þunu
belirtelim, bu yaklaþýmda kazanç ile sermaye artmýþ ise o zaman oynaklýk yüzdesi
ile daha çok para yatýrýma gitmelidir, kayýpta daha az. Bu da daha önce
gördüðümüz Kelly yaklaþýmýnýn bir çeþidi. Þimdi, oynaklýðý SO ile çarparak
yýllýk beklenen getiriyi hesaplamak mümkündür, çünkü SO zaten getiri bölü risk,
yani bölü oynaklýk idi.

Blok Degeri

Bir enstrümanýn blok deðeri o enstrümanýn en ufak biriminde, o enstrümanýn
fiyatýnýn \%1 deðiþmesi ile ortaya çýkan fiyat farkýdýr. Mesela ham petrol
vadeli iþlem sözleþmelerinde 1 kontraktýn içinde 1000 varil vardýr. Eðer yüzde 1
deðiþim ile fiyat \$75'ten \$75.75'e çýkarsa tüm deðiþim \$.75 * 1000 = \$750
demektir. Blok deðeri budur. 

Fakat yüzde 1'lik deðiþimin þansý nedir? Senetlerin ortalama fiyat oynaklýðý
yüzde 1 olabilir, diðer yanda Almanya 2-yýllýk Schatz tahvil VÝS'lerinin günlük
standart sapmasý \%0.02'dýr. Petrole dönelim, diyelim ki tarihi veriye bakarak
günlük ortalama deðiþimin yüzde 1.33 olduðunu bulduk, bu durumda günlük kar veya
kaybýmýz ortalama 750 Dolar x 1.33 = 997.50 Dolar olacak demektir, çünkü yüzde
1'lik deðiþim 750 Dolar idi. Bu sonuca enstrüman kur oynaklýðý (instrument
currency volatility) diyelim.

Bir adým daha, eðer portföyümüz Türkiye'de TL bazlý bir hesap kullanýyorsak, kur
deðiþimi yapmamýz lazým, bu örnek için Ýngiliz pound olsun, USD/GBP kuru bugün
0.67, o zaman 997.50*0.67 = 668.325 Pound.

Formül yerine tek bir deðer kayýtlý tutmak daha rahat olduðu için bir tek sayý
deðeri de hesaplanabilir, nokta deðeri (point value) burada kullanýlýr; bir
VÝS'in fiyatýnda 1 birimlik deðiþimin ne kadar toptan deðiþimi temsil ettiði
yani. Üstteki petrol örneðinde \$1'lik degisim kontraktta 1000 varil olduðu için
bu \$1000'lik bir deðiþim demektir, nokta deðeri olarak bu tutulur. Günlük
ortalama yüzde deðiþimi biliyoruz zaten, 75 x 0.0133 x 1000 = 997.50 Dolar. Ayný
sonuca eriþtik.

Bu sayý bir enstrümanlýk bloðu elde tutmanýn günlük riskini gösteriyor, yani tek
bir VÝS. Eðer portföyde sadece bu entsruman olsaydý, ve 1,000,000 Pound yýllýk
oynaklýk hedefimiz olsaydý, günlük hedef için $\sqrt{256}$'ya bölüyoruz, yani
1/16'sý 62,500 Pound olur. Bu günlük oynaklýk kapasitemiz içine kaç tane petrol
VÝS'i sýðdýrabilirdik? Bunun için kapasitemizi günlük tek enstrüman petrol
riskine bölüyoruz, 62,500 / 668.325 = 93.52 tane kontrakt. Dikkat bu noktaya
kadar hiç yuvarlama yapmadan geldik. Bu arada dikkat edildiyse, bu risk doldurma
iþlemini sanki oynaklýk hedefinin elverdigi tüm parayý sadece o alt sistemde
harcayabilirmiþiz gibi yapýyoruz. Daha sonra her alt sisteme ayrýlan yüzde ile
çarpýnca paylaþtýrma tam yapýlmýþ oluyor. Ama bu adým sonra geliyor.

Harcamalar (Costs)

Eðer herhangi bir bir enstrüman için o enstrümandan tek bir bloðu alýp hemen
satsaydým, bu git/gel'in o enstrümanýn yýllýk riskine oranlý bedeli ne olurdu?
Bu "standardize edilmiþ bedel" bize her git/gel'in yýllýk bazlý Sharpe oranýndan
ne kadar kaybettireceðini bize söyler. Sharpe oraný bildiðimiz gibi getirinin
yýllýk oynaklýða bölünmüþ halidir, getirinin oynaklýða olan oraný yani,
standardize edilmiþ bedel de benzer bir hesabý yapar, böylece elde ettiðimiz
bedeli direk Sharpe oranýndan çýkartabilmemizi saðlar.

Git / gel dedik, yani bu ilk harcamanýn hesabý alýþ fiyatý / satýþ fiyatý
aralýðýyla yapýlýr. Niye? Çünkü aldýðýmýzda alýþ, sattýðýmýzda satýþ fiyatýndan
satýyoruz. Dikkat: geriye dönük testlerde bir fiyat kullandýðýmýzda bu fiyat
çoðunlukla AFSF iki uç noktasýnýn tam orta noktasýdýr; Fakat ya orta noktadan
alým, ya da satým yapamadýysak?  Ýþte bu ``en kötü ihtimal'' bize bir masraf
olarak yansýr, ki her zaman bu en kötü ihtimale göre bir harcama kalemini hesaba
katmamýz gerekir. O zaman ASFS yayýlýmýný (spread) buluruz, ve ikiye böleriz, bu
harcamadýr.

AFSF nereden elde edilir?  Borsa aracýmýzýn saðladýðý araç üzerinden enstrümanýn
en son AFSF'na bakarýz, ve (birazdan göreceðimiz þekilde) masrafý Sharpe oranýna
oranlý hesaplarýz, bu sebeple hacimden, oynaklýktan ileri gelen deðiþimlere
uyarlanmýþ bir hesap elde etmiþ oluruz.

Geçmiþte, tarihi verideki her günde AFSF'nin ne olduðu çoðunlukla kaydedilen ve
paylaþýlan bir veri deðildir, ama illa ki gerekiyorsa, onu tahmin edebilen bazý
metotlar mevcut, bkz {\em Ekler} bölümü.

Neyse, araca gireriz, vadeli iþlem sözleþmeleri için bir kerede kaç tane
sözleþme alýnacaðý AFSF için bir eþik deðeri oluþturabilir, buna da dikkat,
mesela Euro Stoxx 50 için Ocak 23, 2015'te bakýyoruz, 437 sözleþme ve altýndaki
satýmlar için 3369 fiyatý verilmiþ, alýmlarda 7 sözleþme ve altý alýmlar için
3370 fiyatý verilmiþ. Harcama demek ki 3370-3369 / 2 = 0.5 (altta
\verb!slippage! kolonunda). Þimdi bu bedeli yine en son fiyata göre bir yüzdeye
çeviririz, 0.5 / 3370 * 100 = \%0.01483. Ardýndan bu deðeri bir para miktarýna
çeviririz, yüzde 1'lik deðiþimi temsil eden deðer 3370 fiyat seviyesinde 337 Eur
eder (3370 * nokta deðeri * yüzde 1, yani 3370 * 10/100). 337 çarpý 0.0148 = 5
Eur.

Borsa aracý þirketi ek bazý masraflar kesebilir, bu örnekte her sözleþme için 3
Eur kesiliyor mesela.

Sharpe oranýyla alakalý bir bedel oluþturma yönünde ilerliyoruz.  Çýkartma
iþlemini þöyle yaparýz; bir sene içinde bu enstrümaný, bir tanesini, sadece bir
kez ardý ardýna al/sat yaptýysak bu blok masraf C = 5 + 3 = 8 Eur üzerinden 2 *
C eder. Diyelim Euro Stoxx enstrüman oynaklýðý günlük yüzde 1.5, her yüzde 1'lik
hareket 370 Eur ediyor, 370 * 1.5 = 506 Eur, bu günlük standart sapma. Onu
yýllýk standart sapma haline getirmek için 506 * 16 = 8096 Eur.  2 * 8 /8096 =
0.002 SO ünitesi. Yani bu deðer artýk SO'dan çýkartabileceðimiz bir sayýdýr.

\begin{minted}[fontsize=\footnotesize]{python}
import pandas as pd
from StringIO import StringIO

COSTS=u"""
instrument,currency,point_value,slippage
CRUDE_W,USD,1000,0.0145328653
EDOLLAR,USD,2500,0.0025
US5,USD,1000,0.004
EUROSTX,EUR,10,0.5
V2X,EUR,100,0.0255
MXP,USD,500000,0.000011567
CORN,USD,50,0.125
"""
costs = pd.read_csv(StringIO(COSTS),index_col=0)

my_curr = 'USD'
vol_target = 0.20
capital = 250*1000
exchange = {'USD': {'EUR': 1.1, 'USD': 1.0} }
daily_vol_target = capital * vol_target / 16

def calc_cost(ins,dt = '2014-10-14'):
    with zipfile.ZipFile('legacycsv.zip', 'r') as z:
        dfi = pd.read_csv(z.open('%s_price.csv' % ins), index_col=0,parse_dates=True )
        vol = pd.rolling_std(dfi.pct_change()*100., window=25)    
    res = []
    price = float(dfi.ix[dt])
    v = float(vol.ix[dt])
    point_val = price * costs.ix[ins].point_value / 100.
    block_vol = block_val*v
    inst_value_vol =  block_vol*exchange[my_curr][costs.ix[ins].currency]
    units = daily_vol_target / inst_value_vol
    exec_cost = (costs.ix[ins].slippage / price) * 100 * block_val
    so_cost =  (exec_cost * 2.) / (16. * block_vol)
    return price,v,block_val,block_vol,inst_value_vol,units,exec_cost,so_cost

price,v,block_val,block_vol,inst_value_vol,units,exec_cost,so_cost = calc_cost('EUROSTX')
print so_cost
\end{minted}

\begin{verbatim}
0.001862369503
\end{verbatim}


\begin{minted}[fontsize=\footnotesize]{python}
import pandas as pd, zipfile
from io import StringIO
pd.options.display.float_format = '{0:.4f}'.format    

instruments = ['CRUDE_W','EDOLLAR','US5','EUROSTX','V2X','MXP','CORN']
         
dt = '2014-10-14'
res = []
cols = ['inst','price','v','block_val','block_vol','inst_value_vol','units','exec_cost','so_cost']
for inst in instruments:
    price,v,block_val,block_vol,inst_value_vol,units,exec_cost,so_cost = calc_cost(inst)
    res.append([inst,price,v,block_val,block_vol,inst_value_vol,units,exec_cost,so_cost])
    
print pd.DataFrame(res,columns=cols)         
\end{minted}

\begin{verbatim}
      inst     price      v  block_val  block_vol  inst_value_vol   units  \
0  CRUDE_W   85.3000 1.2678   853.0000  1081.4529       1081.4529  2.8896   
1  EDOLLAR   97.0550 0.0563  2426.3750   136.7107        136.7107 22.8585   
2      US5  117.0625 0.1699  1170.6250   198.9413        198.9413 15.7081   
3  EUROSTX 2816.0000 1.1917   281.6000   335.5940        369.1534  8.4653   
4      V2X   22.8000 2.6898    22.8000    61.3265         67.4592 46.3243   
5      MXP    0.0718 0.5110   358.7500   183.3214        183.3214 17.0466   
6     CORN  422.7500 1.2475   211.3750   263.6875        263.6875 11.8511   

   exec_cost  so_cost  
0    14.5329   0.0017  
1     6.2500   0.0057  
2     4.0000   0.0025  
3     5.0000   0.0019  
4     2.5500   0.0052  
5     5.7835   0.0039  
6     6.2500   0.0030  
\end{verbatim}

Devir (Turnover)

Tabii SO'dan çýkartma yapmadan önce bir enstrümaný senede yaklaþýk kaç kez alýp
sattýðýmýzý bilmemiz gerekir, çünkü biraz önceki standardize edilmiþ harcama tek
bir al/sat'ý baz alýyor. Eðer bir enstrümanýn masrafý 0.01 standardize SO
ünitesi ise, ve bir senede yaklaþýk 10 al/sat yapýyorsak, ve bu enstrümaný baz
alan bir strateji bize SO 0.5 getiri saðlayacaksa, masraflarýn çýkartýldýðý
nihai SO 0.5 - 0.01*10 = 0.4 olacaktýr. Senede yapýlan yaklaþýk al/sat'a devir
(turnover) ismi verelim. Devir sayýsýný belirleyen nedir? Birkaç faktör akla
gelebilir; mesela stratejimizin yaptýðý enstrüman fiyat tahmini; düþeceðini
tahmin ettiðimiz bir enstrümanýn pozisyonunu azaltmak isteyebiliriz, bu satým
yapmak demektir, ve masraf ortaya çýkar. Ya da oynaklýkta deðiþim olur, ve
portföyümüzün oynaklýk hedefini ayný seviyede tutmak için bazý pozisyonlara
girmek, ya da mevcut olanlardan çýkmak gerekebilir.

[1]'in yaklaþýmýnda hedefler tanýmlanýyor, mesela oynaklýk hedefi, böylece
riskimizin ne olacaðýný daha baþtan biliyoruz, ve bu risk seviyesi hiç
deðiþmiyor. Ayný þekilde devir için bir hedef koymak, ve bu hedef üzerinden onu
kýsýtlamak ta mümkün. Test ettiðimiz bir stratejinin 1/3'ünden fazlasýný
masraflara kaybetmenin anlamý yok, bu sebeple her stratejinin SO'sunun 1/3'unu
bir devir sayýsý sýnýrýný hesaplamak için kullanabiliriz. Eðer SO 0.4 ise, onun
1/3'u 0.13 eder, yani masraflar için yýllýk 0.13 SO'yu hiçbir þartta
geçmemeliyiz , bu demektir ki eðer masraf 0.002 SO ünitesi olan Euro Stoxx için
yýllýk devir muhakkak 65 altýnda olmalýdýr.

Not: Eðer masraflar 0.13 SO'su ise ve mesela oynaklýk hedefimiz yýllýk yüzde 50
ise, bu getirimizin 0.13 * \%50 = yüzde 6.5'si masraflara gider demektir. Bu az
bir oran deðil! Þahsi olarak bundan daha fazlasýný tavsiye etmemiz mümkün deðil.

Tahminler

Risk elimizdeki denklemin bir parçasý. Diðer bir parçasý bizim, ya da
algoritmamýzýn, gelecekte bir varlýðýn nasýl davranacaðý hakkýndaki
tahmini. Prensip olarak ikisel tahminlerden kaçýnmalýyýz, yani 0,1 türünde,
evet/hayýr, al/sat þeklindeki tahminler. Tahmin bir reel sayý olmalý, -20/+20
arasýnda mesela, ve iþimizi kolaylaþtýrmasý açýsýndan averaj bir al tahmini için
+10 iyidir, açýga satýþta averaj -10 deðeri uygundur. O zaman +5 gibi bir tahmin
nisbeten daha zayýf bir alým demek, -20 ise çok kuvvetli bir sat tahmini
olacaktýr.

O zaman tahminleri öncelikle oynaklýk standardizasyonuna tabi tutmak lazým, ki
tahmin Sharpe oranýna kýyaslanabilir bir þey olsun, yani üretilen tahmini önce
zaman serisinin yakýn zamandaki getirilerinin standart sapmasýna bölmek
lazým. Ardýndan tahminlerin uzun süreli ortalamasýnýn 10 olmasýný istiyoruz, o
zaman tahminlerimizin uzun süreli ortalamasýný hesaplayýp, tüm tahminleri ``10 /
bu ortalama'' ile ölçeklememiz lazým, bu sayýya tahmin çarpaný (forecast scalar)
ismi verebiliriz.

Tahmin çarpanlarý her tahmin algoritmasý temel alarak hesaplanýr, yani hangi
veri tahmin ediliyorsa edilsin bir stratejinin belli bir çarpaný vardýr. Bu
hesabý bu yazýnýn altýnda bulabilirsiniz. Þimdilik bu çarpaný bildiðimizi
farzedelim, EWMA 32,128 için 2.84.

\begin{minted}[fontsize=\footnotesize]{python}
import pandas as pd, zipfile, util
with zipfile.ZipFile('legacycsv.zip', 'r') as z:
    df =  pd.read_csv(z.open('EUROSTX_price.csv'),sep=',',index_col=0,parse_dates=True)
pred = util.ewma(df.PRICE,32,128)
forecast_scalar = 2.84
pred_scaled = pred * forecast_scalar
\end{minted}

Þimdi alt sistem alým ya da satým iþlemine gelirsek; üstteki petrol kontrakt
alýmýný gelecek tahmini üzerinden nasýl ayarlarýz? Eðer petrol VÝS'i için
averaj, 10 seviyesinde bir alým beklentimiz var ise hiçbir þey yapmamýza gerek
yok, 93.52 tane kontrakt alýyoruz, bu durumda sanki 10 ile çarpýp 10 ile bölmüþ
oluyoruz, hiçbir etki yok. Fakat tahmin +5.0 ise o zaman 93.50 / 2 = 46.76 tane
kontrakt alacaðýz demektir, satým için benzer durum, -20 tahmin 93.50 * 2 =
187.04 kontraktý açýða satmak demektir.

Devir hesabýnýn tahminler ile yakýn alakasý var. Tahmin zaman serisinin farkýnýn
ortalamasýný alýp, bu ortalamayý bir yýldaki iþ günü sayýsý ile çarparsak, bu
tahmin serisinin sebep olacaðý al/sat sayýsýný yaklaþýk olarak hesaplamýþ
oluruz. Eðer tahminler 10,20,10 olsaydý mesela bu bir alým, bir satým demektir,
farklar 10,-10,.. bu durumu hemen gösteriyor. Üstteki tahmin serisi için [1,
  sf. 276],

\begin{minted}[fontsize=\footnotesize]{python}
avg =  (pred_scaled / 10).diff().abs().mean()
print 'devir', avg * 256
\end{minted}

\begin{verbatim}
devir 8.72554168599
\end{verbatim}

Alt Sistemlerin Aðýrlýklarý

Daha önce üç tane VÝS'i sadece alýp elde tutmak üzerinden aðýrlýk hesabý
yapmýþtýk. Alttaki örnekte iki enstrüman üzerinde iki farklý stratejiyi
iþleteceðiz, elde iki tane alt sistem (subsystem) olacak, ve her sistem içinde
iki tane tahmin edici bulunacak, ve biz bu her sisteme ne kadar aðýrlýk
vereceðimizi hesaplayacaðýz.

Alt sistem içinde ayný enstrüman üzerinde iki strateji iþletmek, iki farklý
tahmin yöntemi demektir, yani ayný zaman serisine bakarak iki yöntem farklý
al/sat sinyalleri üretebilirler (tabii ayný fikirde olduklarý zaman bu daha
iyi). [1]'in araþtýrmalarýna göre ``strateji karýþtýrmanýn'' faydalý olduðu
görülmüþtür. Tahmin çarpanýný daha önce gördük, alttaki deðerler direk [1,
  sf. 309]'dan geliyor. Ayrýca -20/20 üzeri deðerleri -20/20'ye eþitliyoruz,
sistemin aþýrý büyük tahminler yapmamasý için. Aðýrlýklarýn bulunmasý için yine
bootstrap kullanýldý.

Tahminlere her sistem içinde eþit aðýrlýk verdik, yani 0.5 ve 0.5. Ýki strateji
EWMAC 2,8 ve EWMAC 32,128. Her iki tahminin al/sat sinyalini bir ileri
kaydýrýyoruz, ve bir sonraki günün getirisi üzerinden bu sinyal ile gerçek
getiriyi hesaplýyoruz.

\begin{minted}[fontsize=\footnotesize]{python}
import zipfile, pandas as pd, util, random
random.seed(0)
np.random.seed(0)

def ewmac(price,slow,fast):
    vol = util.robust_vol_calc(price.diff())
    fast_ewma = pd.ewma(price, span=slow)
    slow_ewma = pd.ewma(price, span=fast)
    raw_ewmac = fast_ewma - slow_ewma
    return raw_ewmac /  vol 

symbols = ['SP500','US20']
df = pd.DataFrame()
with zipfile.ZipFile('legacycsv.zip', 'r') as z:
    for symbol in symbols:
        f = '%s_price.csv' % symbol
        df[symbol] = pd.read_csv(z.open(f),sep=',',index_col=0,
                                 parse_dates=True)['PRICE']
    
df = df.sort_index()
forecast = df.copy()

ewmac8_32_scalar = 10.6 
ewmac32_128_scalar = 2.65

df['US20_ewmac8_32'] = ewmac(df['US20'], 8, 32) * ewmac8_32_scalar /10. 
df['US20_ewmac32_128'] = ewmac(df['US20'], 32, 128) * ewmac32_128_scalar /10. 
df['SP500_ewmac8_32'] = ewmac(df['SP500'], 8, 32) * ewmac8_32_scalar/10.
df['SP500_ewmac32_128'] = ewmac(df['SP500'], 32, 128) * ewmac32_128_scalar/10.

forecast['US20'] = (df['US20_ewmac8_32'] + df['US20_ewmac32_128']) / 2
forecast['SP500'] = (df['SP500_ewmac8_32'] + df['SP500_ewmac32_128']) / 2

forecast.loc[forecast.US20 > 20, 'US20'] = 20.
forecast.loc[forecast.SP500 > 20, 'SP500'] = 20.
forecast.loc[forecast.US20 < -20, 'US20'] = -20.
forecast.loc[forecast.SP500 < -20, 'SP500'] = -20.

df['US20'] = df['US20'].pct_change() * forecast.shift(1).US20 / 10.
df['SP500'] = df['SP500'].pct_change() * forecast.shift(1).SP500 / 10.
df = df[['US20','SP500']]
\end{minted}


\begin{minted}[fontsize=\footnotesize]{python}
import sys; sys.path.append('../tser_port')
import boot
weights=boot.optimise_over_periods(df,rollyears=20, monte_carlo=20,monte_length=250)
print np.array(weights.tail(1))
\end{minted}

\begin{verbatim}
[[ 0.34008769  0.65991231]]
\end{verbatim}

\begin{minted}[fontsize=\footnotesize]{python}
weights.plot()
plt.savefig('tser_voltar_01.png')
\end{minted}

\includegraphics[height=8cm]{tser_voltar_01.png}

Enstruman Çeþitlendirme Çarpaný (Instrument Diversification Multiplier - IDM)

Tekrar üzerinden geçersek, risk hedeflememizi yaptýk, her alt sistem içine bu
hedefe göre strateji doldurduk ki her alt sistem ayný riske sahip, ardýndan alt
sistem aðýrlýklarýný hesapladýk ve her alt sisteme gerekli parayý ayýrdýk. Fakat
bu noktada ortaya bir problem çýkar, çünkü aðýrlýk kullanýmý, ve alt sistem
getirilerinin arasýnda (elimizden geldiðince) korelasyonu az tutmuþ olmamýz
sebebiyle nihai sistemin genel riski azaldý. Yani hedeflediðimiz riskten sapmýþ
olduk. Elde etmek istediðimiz risk sanki her alt sistemi kendi baþýna
iþletiyormuþ gibi elde edeceðimiz risk gibi olmalý. O zaman bize öyle bir çarpan
lazým ki risk azalmasýný telafi etsin, ve pozisyon hesabýný yaparken bu çarpaný
uygulayarak risk hedefine geri dönelim.

N tane alt sistemimizin olduðunu düþünelim, bu sistemlerin getirilerinin
korelasyon matrisi $H$ olsun, ve biraz önce bulduðumuz aðýrlýklar $W$ (ki
aðýrlýklarýn toplamý 1). O zaman IDM, $1 / \sqrt{(W \cdot H \cdot W^T)}$
olacaktýr. Dikkat edersek bu formül (2)'nin tam tersi. 

\begin{minted}[fontsize=\footnotesize]{python}
H = df.corr()
H = H.clip(lower=0)
print 'Korelasyon'
print H
W = np.array([[0.34,  0.66]]) # ustteki sonuc
idm=1.0 / (float(np.dot(np.dot(W, H), W.transpose()))) **.5
print '\nIDM', idm
\end{minted}

\begin{verbatim}
Korelasyon
           US20     SP500
US20   1.000000  0.096425
SP500  0.096425  1.000000

IDM 1.29697910974
\end{verbatim}

Tahmin Çarpanlarýný Hesaplamak

Her tahmin algoritmasi için eldeki {\em tüm} veriler üzerinde tahmin üretiriz,
yani her enstrüman verisi için tahmin üretip, tüm bu tahminleri birleþtirip koca
bir zaman serisi oluþtururuz (bu tekniðe havuzlama -pooling- ismi veriliyor), ve
bu serinin mutlak deðerlerinin (absolute value) ortalamasýný alýrýz.

\begin{minted}[fontsize=\footnotesize]{python}
import util, zipfile, pandas as pd

ewmacs = [(2,8),(4,16),(8,32),(16,64),(32,128),(64,256)]

for (fast,slow) in ewmacs: 
    with zipfile.ZipFile('legacycsv.zip', 'r') as z:
        res = []
        for x in  z.namelist():
            if '_price' in x:
                df = pd.read_csv(z.open(x), index_col=0,parse_dates=True )
                tmp = util.ewma(df.PRICE, fast, slow)
                res.append(tmp)

    tmp = pd.DataFrame(pd.concat(res))
    tmp.columns = ['forecast']
    target_abs_forecast = 10.
    tmp=tmp.abs().iloc[:,0]
    avg_abs_value=tmp.mean()    
    print 'ewma', slow,fast,'=', target_abs_forecast/avg_abs_value
\end{minted}

\begin{verbatim}
ewma 2 8 = 12.8587606411
ewma 4 16 = 8.91499507015
ewma 8 32 = 6.09843054736
ewma 16 64 = 4.17115322451
ewma 32 128 = 2.84127283125
ewma 64 256 = 1.92365849221
\end{verbatim}

Taþýma kuralý (carry) için (not: TK verisini ayrý kontratlardan nasýl
yaratabileceðimizi {\em Vadeli Ýþlem Sözleþmeleri} bölümünde görmüþtük, bu
yazýda basitlik amacý ile [1] için yaratýlmýþ hazýr veriyi kullanýyoruz),

\begin{minted}[fontsize=\footnotesize]{python}
import util, zipfile
import pandas as pd

with zipfile.ZipFile('legacycsv.zip', 'r') as z:
    res = []
    for x in z.namelist():
        if '_carrydata' in x:
            df = pd.read_csv(z.open(x), index_col=0,parse_dates=True )
            f = x.replace("__carrydata","_price")
            dfc = pd.read_csv(z.open(f),index_col=0,parse_dates=True )     
            vol = util.robust_vol_calc(dfc.PRICE.diff())
            carryoffset = np.abs(float((df.PRICE_CONTRACT - df.CARRY_CONTRACT).tail(1)))
            forecast =  util.carry(df.CARRY-df.PRICE, vol,np.abs(carryoffset)/12)
            res.append(forecast)

    tmp = pd.DataFrame(pd.concat(res))
    tmp = tmp.dropna()
    tmp.columns = ['forecast']
    tmp=tmp.abs().iloc[:,0]
    avg_abs_value=tmp.mean()
    print 10./avg_abs_value 
\end{minted}

\begin{verbatim}
21.44
\end{verbatim}

Bu deðerler [1, sf. 309] ile uyumlu.

Strateji Aðýrlýklarýný Hesaplamak (Forecast Weight Estimation)

[1]'in yaklaþýmlarýndan bir diðeri seçilen stratejilerin hangi aðýrlýklarla her
alt sistem üzerinde kullanýlacaðýný bulmak. Daha önce alt sistem içinde
stratejilere eþit aðýrlýk vermiþtik. Gerçek dünyada bu aðýrlýklarýn optimal
olmasý iyi olur. Her alt sistemde ayný strateji demeti olur, bu demetlere belli
aðýrlýklar verilir, ve her alt sistem, ayný demeti bu aðýrlýklar üzerinden
kullanýr. Mesela petrol VÝS'i üzerinde EWMAC 2,8, EWMAC 16,64 ve taþýma kuralý
(carry trade, TK) kullanýyor olabiliriz, bunlarýn aðýrlýðý 0.2, 0.3, 0.5
olabilir. Diðer bir alt sistem, mesela kahve, Eurodollar ayný aðýrlýklarý ayný
þekilde kullanýr.

Aðýrlýklarý bulmadan önce, hangi strateji demetiyle baþlamak lazým? Bir liste
çýkartmak çok zor deðil, [1, sf. 309]'a göre EWMAC'ýn yavaþ ve hýzlý
parametreleri arasýnda 1'e 4 oraný mantýklý, yani EW 1,4, EW 2,8, EW 4,16, EW
8,32, diye devam edebiliriz. Bu listeden eleme yapmak için onlarýn masraflarýný
kullanmak iyi oluyor, çok masraflý olan stratejileri direk eleriz. Bu konuya
sonra döneceðiz.

Þimdilik nihai demeti kararlaþtýrmýþ olduðumuzu düþünelim, mesela CORN, EDOLLAR,
EUROSTX, MXP, US10, V2X üzerinde EW 16,64, EW 32,128, EW 64,256 ve TK
stratejilerini kullanacaðýz. Aðýrlýklarý hesaplamak için alt sistemler arasý
kullandýðýmýz hesaba benzer yaklaþýmý kullanacaðýz, boostrap tekniðini devreye
sokacaðýz. Ayrýca havuzlama tekniðini de kullanacaðýz, eldeki {\em tüm}
enstrümanlar üzerinden elde edilen stratejilerin tahminlerini
birleþtireceðiz. Mesela EWMAC 16,64 ile CORN, EDOLLAR, vs tahminleri yapýp bu
serileri uç uca koyacaðýz, böylece eldeki veriyi arttýrmýþ olacaðýz.

\begin{minted}[fontsize=\footnotesize]{python}
import util, zipfile, pandas as pd, collections

ewmacs = [(16,64),(32,128),(64,256)]

forecasts = collections.OrderedDict()
for x in ewmacs: forecasts[x] = []
forecasts['carry'] = []
prices = collections.OrderedDict()
for x in ewmacs: prices[x] = []
prices['carry'] = []

insts = ['CORN', 'EDOLLAR', 'EUROSTX', 'MXP', 'US10', 'V2X']
with zipfile.ZipFile('legacycsv.zip', 'r') as z:
    for inst in insts: 
        df1 = pd.read_csv(z.open('%s_price.csv' % inst),\
                          index_col=0,parse_dates=True )     
        df2 = pd.read_csv(z.open('%s_carrydata.csv' % inst), \
                          index_col=0,parse_dates=True )     
        for (fast,slow) in ewmacs:
             vol = util.robust_vol_calc(df1.PRICE.diff())
             forecasts[(fast,slow)].append(util.ewma(df1.PRICE, fast, slow))
             prices[(fast,slow)].append(df1.PRICE)

        raw_carry = df2.CARRY_CONTRACT-df2.PRICE_CONTRACT
        carryoffset = df2.PRICE_CONTRACT - df2.CARRY_CONTRACT
        forecast =  util.carry(raw_carry, vol,  \
                               carryoffset*1/util.CALENDAR_DAYS_IN_YEAR)
        forecasts['carry'].append(forecast)
        prices['carry'].append(df1.PRICE)
    
for x in forecasts:
    forecasts[x] = pd.concat(forecasts[x])
for x in prices:
    prices[x] = pd.concat(prices[x])
    
dff = pd.DataFrame()
for x in forecasts: dff[x] = forecasts[x]
dfp = pd.DataFrame()
for x in prices: dfp[x] = prices[x]

rng = pd.date_range('1/1/1900', periods=len(dff), freq='D')

dff = dff.set_index(rng)
dfp = dfp.set_index(rng)

df = dfp.pct_change() * dff.shift(1)
df = df.dropna()
\end{minted}

\begin{minted}[fontsize=\footnotesize]{python}
import sys; sys.path.append('../tser_port')
import boot
weights=boot.optimise_over_periods(df, rollyears=20, monte_carlo=20,monte_length=250)
\end{minted}

Üstteki kod iþledikten sonra EW 16,64, EW 32,128, EW 64,256, TK stratejileri
için sýrayla 0.45, 0.05, 0.22, 0.28 aðýrlýklarý rapor edilecek. Bu deðerler
[3]'te verilenlere benziyor, TK üzerinde oldukça aðýrlýk var, bu mantýklý
çünkü diðer stratejilerle çok korelasyonu olmayan bir strateji bu. Ortalama
hýzdaki EWMA'ya yüzde 5 civarý verilmiþ, geri kalanlar arasýnda daha hýzlý
olan en çok aðýrlýða sahip, deðiþimlere hýzlý tepki verebilmenin faydasý var
demek ki.

Stratejilerin Korelasyonu

Farklý EWMA stratejilerinin getirilerinin tek bir enstrüman üzerinden
korelasyonu altta bulunabilir [1, sf. 319]. 

\begin{minted}[fontsize=\footnotesize]{python}
import util, zipfile, pandas as pd, collections
ewmacs = [(2,8),(4,16),(8,32),(16,64),(32,128),(64,256)]
inst = 'US5'
with zipfile.ZipFile('legacycsv.zip', 'r') as z:
    p = pd.read_csv(z.open('%s_price.csv' % inst),\
                    index_col=0,parse_dates=True)
df = pd.DataFrame(index=p.index)
for (fast,slow) in ewmacs:
     fs = util.ewma(p.PRICE, fast, slow)
     df['%d-%d' % (fast,slow)] = util.ccy_returns(p.PRICE, fs)
print df.corr()
\end{minted}

\begin{verbatim}
             2-8      4-16      8-32     16-64    32-128    64-256
2-8     1.000000  0.869692  0.624934  0.402105  0.233632  0.143689
4-16    0.869692  1.000000  0.898819  0.673206  0.433222  0.270579
8-32    0.624934  0.898819  1.000000  0.902239  0.668067  0.437073
16-64   0.402105  0.673206  0.902239  1.000000  0.896226  0.657881
32-128  0.233632  0.433222  0.668067  0.896226  1.000000  0.891021
64-256  0.143689  0.270579  0.437073  0.657881  0.891021  1.000000
\end{verbatim}

Her stratejinin bir sonraki stratejiyle yakýn baðlantýsý olduðu görülüyor, ama
en azýndan bu baðlantý yüzde 99 deðil, yüzde 90 civarý. 

Oynaklýk Standardizasyonu 

Ornek: Bund beklenen getirisi yýlda \%2\, beklenen yýllýk standart sapma \%8.
Schatz vadeli iþlem sözleþmesi 1\% ama beklenen oynaklýk 2\%. Risk her iki
tarafta ayný olacak þekilde eþitleme yaparsak, Schatz'in beklenen getirisi
Bund'un iki katýdýr.

\begin{minted}[fontsize=\footnotesize]{python}
import util

returns = [2.,1.] # bund,schatz
volatilies = [8.,2.] # bund,schatz
returns,vols = util.vol_equaliser(returns,volatilies)
print 'getiriler', returns
print 'oynaklik', vols
\end{minted}

\begin{verbatim}
getiriler [1.25, 2.5]
oynaklik [5.0, 5.0]
\end{verbatim}

Oynaklýk standardizasyonu hesabý oynaklýklar için bir ortalama almaktan
ibarettir. Tüm oynaklýklar bu ortalamaya eþitlenir, ve ayný oranda
getiriler ayarlanýr. 

Kaynaklar

[1] Carver, {\em Systematic Trading}

[2] Heydt, {\em Mastering Pandas for Finance}

[3] Carver, {\em Correlations, Weights, Multipliers.... }, \url{http://qoppac.blogspot.co.uk/2016/01/correlations-weights-multipliers.html}

\end{document}
