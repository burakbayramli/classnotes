\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Sinyaller, Geriye Dönük Analiz, Performans

Elimizde bir zaman serisi var, bu seri bir finansal varlığın fiyat seviyesi
olabilir, belki Apple senedidir, ilk gün 100 ikinci gün 102 olmuş, böyle
gidiyor.

\begin{minted}[fontsize=\footnotesize]{python}
import pandas as pd
d = np.array([100,102,104.04,106.12,108.24,110.41])
\end{minted}

Peki bu fiyat seviyeleri günlük hangi yüzde değişimlerine tekabül ediyor?
Bu hesabın bir yolu var, \verb!pct_change! kullanabiliriz,

\begin{minted}[fontsize=\footnotesize]{python}
p = pd.Series(d)
print (list(p))
print (list(np.round(p.pct_change(),2)))
\end{minted}

\begin{verbatim}
[100.0, 102.0, 104.04, 106.12, 108.24, 110.41]
[nan, 0.02, 0.02, 0.02, 0.02, 0.02]
\end{verbatim}

Her gün yüzde 2'lik bir değişim varmış (bu yazı için veri uydururken sayıları
ona göre ayarladık).

Şimdi sadece yüzde değişimleri ve başlangıç fiyat seviyesini kullanarak seriyi
tekrar üretebilir miydik? Tek yüzde değişimle bir sonraki sayıyı nasıl elde
ederiz?  Mesela 100'den yüzde 2 değişimle sonraki değere geçeceğiz, kolay, 1
artı 0.02 yani 1.02 değerini 100 ile çarparız, sonraki sayı çıkar, 102. Bu
metotu diğer yüzde değişimler için kullanabiliriz. O zaman tüm fiyat
seviyelerini hesap için eldeki yüzde değişim listesine 1 sayısını eklersek,
1.02, 1.02, .. elde edilir, ve bu rakamları başta 100 ile, sonra birbirleri ile
çarparsak tüm fiyat listesini tekrar elde ederiz. Bir dizinin tüm öğelerinin
birer birer çarpılıp bunun kümülatif olarak gösterilmesini \verb!cumprod!
halleder,

\begin{minted}[fontsize=\footnotesize]{python}
ret = p.pct_change()
100*np.cumprod(1+ret)
\end{minted}

\begin{verbatim}
Out[1]: 
0       NaN
1    102.00
2    104.04
3    106.12
4    108.24
5    110.41
dtype: float64
\end{verbatim}

Üstteki hesabı bir al-tut stratejisinin performansı olarak ta görebiliriz bu
durumda illa baştaki 100 değerini kullanmaya gerek yok, 100 yerine 1 dersek o
zaman bu stratejiye koyulmuş 1 liranın, 1 doların ne kadar büyüyeceğini görmüş
oluruz.  1 lira 2 lira olduysa mesela bu ikiye katlama demektir, performansın
iyi olduğu sonucuna varabiliriz.

\begin{minted}[fontsize=\footnotesize]{python}
1*np.cumprod(1+ret)
\end{minted}

\begin{verbatim}
Out[1]: 
0       NaN
1    1.0200
2    1.0404
3    1.0612
4    1.0824
5    1.1041
dtype: float64
\end{verbatim}

Yüzde değişimler, kümülatif çarpımlar ile uğraşmamızın bir sebebi var, portföy
perfomansına bakarken herhangi bir strateji için gereken alım / satım
``sinyallerini'' kolayca dahil edebiliyoruz, ve stratejiyi tartarken bir zaman
serisi üzerinden bunu yapabiliyoruz. Elde edilecek serinin istatistiki,
matematiksel özellikleri vardır, ve bu özellikleri ek özet irdelemeler
faydalı olur, mesela Sharpe oranı gibi.

Sinyalleri şöyle kullanabiliriz, bir varlığı belli bir zaman noktasında almış
olmak 1 sinyali ile temsil edilir, varlığın elde olmaması ise 0 ile temsil
edilir.  O zaman kümülatif hesaptan önce tüm yüzde değişimleri sinyal vektörü
ile çarparız, ondan sonra kümülatif hesap devreye girer. Eğer sinyal 1 ise o
noktada yüzde değişim sıfıra iner, o getiri elde edilmemiş olur, kümülatif
hesapta 1+0 = 1, yani hiç bir değişim yaratmaz. Eğer sinyal 1 ise 1 çarpı mesela
yüzde 2 getiri yüzde 2 getirinin aktif olmuş olması demektir, o getiri kümülatif
çarpıma etki eder.

\begin{minted}[fontsize=\footnotesize]{python}
signal = pd.Series(np.array([1,1,1,1,0,1]))
ret*signal
\end{minted}

\begin{verbatim}
Out[1]: 
0         NaN
1    0.020000
2    0.020000
3    0.019992
4    0.000000
5    0.020048
dtype: float64
\end{verbatim}

\begin{minted}[fontsize=\footnotesize]{python}
signal = pd.Series(np.array([1,1,1,1,0,1]))
1*np.cumprod(1+(ret*signal))
\end{minted}

\begin{verbatim}
Out[1]: 
0         NaN
1    1.020000
2    1.040400
3    1.061200
4    1.061200
5    1.082475
dtype: float64
\end{verbatim}

Örnek

Apple senedine bakalım,

\begin{minted}[fontsize=\footnotesize]{python}
import pandas as pd
df = pd.read_csv('../tser_008_data/AAPL.csv',index_col='Date',parse_dates=True)
df.plot()
plt.savefig('tser_011_sign_01.jpg')
\end{minted}

\includegraphics[width=20em]{tser_011_sign_01.jpg}

Diyelim ki müneccim bir yatırımcı bu senedi ne zaman alıp, satacağını bir
şekilde biliyor. 2005-06 civarındaki çıkış öncesi alıyor, o çıkışın tepesinde
satıyor, sonra 2006-09'da tekrar geliyor, ve son düşüş öncesi yine çıkıyor.  Bu
arkadaşın alım / satım stratejisini 1 ve 0 sinyalleri ile temsil edebiliriz.

\begin{minted}[fontsize=\footnotesize]{python}
df['signal'] = 0
filt1 = (df.index > '2005-06-01') & (df.index < '2006-02-01')
df.loc[filt1,'signal'] = 1
filt2 = (df.index > '2006-09-01') & (df.index < '2007-01-01')
df.loc[filt2,'signal'] = 1
\end{minted}

Stratejinin başarısı ne olur acaba? Üstte gördüğümüz yöntemler ile hesaplayalım,

\begin{minted}[fontsize=\footnotesize]{python}
df['ret'] = df.AAPL.pct_change()
cumret = np.cumprod(1+(df.ret*df.signal))
print (cumret.tail(4))
\end{minted}

\begin{verbatim}
Date
2006-12-26    2.233475
2006-12-27    2.233750
2006-12-28    2.215938
2006-12-29    2.324721
dtype: float64
\end{verbatim}

Tüm kümülatif seriye aslında ihtiyaç yok, son gelinen getiri noktası için,

\begin{minted}[fontsize=\footnotesize]{python}
np.prod(1+(df.ret*df.signal))
\end{minted}

\begin{verbatim}
Out[1]: 2.3247214450625857
\end{verbatim}

Yüzde 232 gibi bir artış var! Bu stratejiyi yıllık kazanca nasıl çeviririz?
Stratejinin uygulandığı tüm zaman dilimlerini alırız, ve getiriyi bir sene, yani
252 zaman dilimi (yıl içindeki iş günü miktarı), için ölçekleriz. Mesela eğer 50
gün için bir getiri $g$ hesaplamışsak, bu getiriyi yukarı ölçekleyip kabaca
$g^5$ ile yıllık getiriyi hesaplayabiliriz / tüm sene bazına yukarı
ölçekleyebiliriz (çünkü $252/5 \approx 5$), sonra tüm sonuçtan bir çıkartırız
daha önce eklenen 1 etkisini iptal etmek için. Eğer eldeki zaman serisi miktarı
252'den fazla ise alta ölçekleme de yapılabilirdi, $g^{1/2}$, $g^{1/5}$ gibi,
ama bu hesaplar da yine matematiksel olarak doğrudur ve aynı yöntemle
hesaplanır. Elde edilecek olan yıllık yüzde oranı (annual percentage rate), APR,

\begin{minted}[fontsize=\footnotesize]{python}
print ('APR', ((np.prod(1.+df.ret*df.signal))**(252./len(df.ret)))-1)
\end{minted}

\begin{verbatim}
APR 0.32471861974412564
\end{verbatim}

Getiri yıllık yüzde 32.47.

Eğer strateji üstteki kadar iyi olmasaydı, mesela yatırımcı 2005-06'da
alım yapmış ama senette kalmış, sona kadar satmamış olsaydı, bu durumda,

\begin{minted}[fontsize=\footnotesize]{python}
df = pd.read_csv('../tser_008_data/AAPL.csv',index_col='Date',parse_dates=True)
df['signal'] = 0
filt1 = (df.index > '2005-06-01')
df.loc[filt1,'signal'] = 1
df['ret'] = df.AAPL.pct_change()
print (np.prod(1+(df.ret*df.signal)))
print ('APR', ((np.prod(1.+df.ret*df.signal))**(252./len(df.ret)))-1)
\end{minted}

\begin{verbatim}
2.105210500206348
APR 0.2816374105511763
\end{verbatim}

Daha düşük bir getiri elde etmiş olacaktı.

Not: Getiriyi ölçeklerken \verb!len(df.ret)! ile yukarıdaki grafiğin tümünü
kullandık fakat düşünürsek aslında bu strateji 2004-01 noktasında değil 2005-06
noktasında başlıyor. Bu sebeple tüm seri aslında daha kısa ve APR bu sebeple
daha yüksek olurdu. Neyse örneği basit tutma amacıyla bu değişikliği yapmıyoruz.

Sinyaller

Almış olmanın 1, elde olmama için 0 sinyalinden bahsettik. Aslında sinyal bazlı
strateji hesabı sadece bu iki rakamla sınırlı değildir, mesela eksi değer
kullanırsak, -1 gibi, bu açığa satış stratejisini kodlayabilirdi. Açığa satışta
düşüşten kazanıldığı için zaman serisinin getiri yüzdesi eksi 1 ile
çarpılacaktır, yüzde artışta düşüş var ise o değer eksi değerdir ve eksi yüzde
çarpı eksi 1 artı değer olacağı için, o değişim kazanç olarak portföye yansımış
olacaktır. Değişim -0.01 olabilir, fakat o noktada strateji açığa sat, -1 diyor
ise, -1 * -0.01 = 0.01, bu sayı kazanç olarak haneye yazılır.




























\begin{minted}[fontsize=\footnotesize]{python}
import pandas as pd

a = np.array([2.0, 2.03, 2.07, 2.11, 2.13, 2.17, 2.25, 2.29, 2.33, 2.4])
b = np.array([4.0, 4.06, 4.11, 4.17, 4.22, 4.28, 4.33, 4.39, 4.44, 4.5])

a = pd.Series(a); b = pd.Series(b)
print (list(np.round(a.pct_change(),2)))
print (list(np.round(b.pct_change(),2)))
\end{minted}

\begin{verbatim}
[nan, 0.01, 0.02, 0.02, 0.01, 0.02, 0.04, 0.02, 0.02, 0.03]
[nan, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01]
\end{verbatim}


\begin{minted}[fontsize=\footnotesize]{python}
df = pd.concat([a,b],axis=1)
df.columns = ['a','b']
print (df)
\end{minted}

\begin{verbatim}
      a     b
0  2.00  4.00
1  2.03  4.06
2  2.07  4.11
3  2.11  4.17
4  2.13  4.22
5  2.17  4.28
6  2.25  4.33
7  2.29  4.39
8  2.33  4.44
9  2.40  4.50
\end{verbatim}

\begin{minted}[fontsize=\footnotesize]{python}
positions = np.zeros(df.shape)
positions[:,0] = 0.5
positions[:,1] = 0.5
ret = (df.pct_change() * positions).sum(axis=1)
print (ret)
print (np.prod(1+ret))
print ('APR', ((np.prod(1+ret))**(252./len(ret)))-1)
\end{minted}

\begin{verbatim}
0    0.000000
1    0.015000
2    0.016010
3    0.016961
4    0.010735
5    0.016499
6    0.024274
7    0.015817
8    0.014428
9    0.021778
dtype: float64
1.1620428461381263
APR 43.01472199080321
\end{verbatim}

\begin{minted}[fontsize=\footnotesize]{python}
positions = np.zeros(df.shape)
positions[:,0] = 0.8
positions[:,1] = 0.2
ret = (df.pct_change() * positions).sum(axis=1)
print (np.prod(1+ret))
print ('APR', ((np.prod(1+ret))**(252./len(ret)))-1)
\end{minted}

\begin{verbatim}
1.1847063822264405
APR 70.61274939993416
\end{verbatim}

















\begin{minted}[fontsize=\footnotesize]{python}
import pandas as pd
df = pd.read_csv('eqbnd.csv',index_col='Date',parse_dates=True)
\end{minted}


\begin{minted}[fontsize=\footnotesize]{python}
ge_df = df.copy()
ge_df = ge_df[(ge_df.index > '2003-01-01') & (ge_df.index < '2010-01-01')]
positions = np.zeros(ge_df.shape)
print ('Senet  Tahvil')
for x in np.linspace(0,1,11):
   x = np.round(x,3)
   positions[:,0] = x
   positions[:,1] = 1.0-x
   ret = (ge_df.pct_change() * positions).sum(axis=1)
   print ('%0.2f   %0.2f   %0.2f' % (x, np.round(1-x,2), np.round(np.prod(1.0+ret),3)))
\end{minted}

\begin{verbatim}
Senet  Tahvil
0.00   1.00   1.32
0.10   0.90   1.35
0.20   0.80   1.37
0.30   0.70   1.39
0.40   0.60   1.41
0.50   0.50   1.42
0.60   0.40   1.43
0.70   0.30   1.43
0.80   0.20   1.43
0.90   0.10   1.42
1.00   0.00   1.40
\end{verbatim}


\begin{minted}[fontsize=\footnotesize]{python}
ret = ge_df.SPY.pct_change()
print ('Senet',np.round(np.prod(1.0+ret),2))
ret = ge_df.AGG.pct_change()
print ('Tahvil',np.round(np.prod(1.0+ret),2))
\end{minted}

\begin{verbatim}
Senet 1.4
Tahvil 1.32
\end{verbatim}








[devam edecek]

Kaynaklar

[1] \url{https://www.quantstart.com/qstrader/tutorial-60-40-portfolio/}
  
\end{document}
