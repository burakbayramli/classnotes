<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Ses Verisi İşleme, Tanıma</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="ses-verisi-işleme-tanıma">Ses Verisi İşleme, Tanıma</h1>
<p>Kulağımızla duyduğumuz sesleri tek boyutlu bir zaman serisi olarak
düşünebiliriz. Bir ses parçasını (fonem -phoneme-) grafiklemek istesek
alttaki gibi bir grafik elde ederdik. Örnek olarak altta /ow/ fonemini
kullandık.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>owfile <span class="op">=</span> <span class="st">&quot;../../sk/2024/11/phonemes/ow.wav&quot;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>fs, ow <span class="op">=</span> scipy.io.wavfile.read(owfile)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>plt.plot(ow)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_082_snd_01.jpg&#39;</span>)</span></code></pre></div>
<p><img src="tser_082_snd_01.jpg" /></p>
<p>Kelime sesleri fonem seslerinin birleşiminden oluşurlar. Mesela
İngilizce kedi “cat” kelimesi /c/ /a/ /t/ fonemlerinden oluşur, “cow”
kelimesi /c/ /ow/ fonemlerinden oluşur. Harfler ile fonemler arasında
her zaman birebir eşlik yoktur, mesela İngiliz alfabesinde 26 harf
vardır fakat 44 tane fonem mevcuttur.</p>
<p>Grafiğe dönersek periyodik dalgalar görülebiliyor, fakat bir tane
değil birden fazla var, yani üstteki ses birkaç periyodik zaman
serisinin toplamı. Genel olarak bir ses dalgasının bir ve daha fazla
sinüs eğrisi toplamı olduğunu farzedebiliriz. Sinüs derken tabii ki her
sinüs bileşeninin genliği, frekansı, ve fazi (phase) farklı olabilir. Bu
parametrelerin periyodik grafiği nasıl etkilediğini görmek için alttaki
şekle bakabiliriz.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">4</span>,<span class="dv">100</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, sharex<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>,<span class="dv">0</span>].plot(x,np.sin(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>x))</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>,<span class="dv">0</span>].set_ylim(<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>,<span class="dv">0</span>].grid(<span class="va">True</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>,<span class="dv">0</span>].set_title(<span class="vs">r&#39;$sin(2 \pi x)$&#39;</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>,<span class="dv">1</span>].plot(x,<span class="dv">2</span><span class="op">*</span>np.sin(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>x))</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>,<span class="dv">0</span>].set_ylim(<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>,<span class="dv">1</span>].grid(<span class="va">True</span>)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>,<span class="dv">1</span>].set_title(<span class="vs">r&#39;$2 \cdot sin(2 \pi x)$&#39;</span>)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>,<span class="dv">0</span>].plot(x,np.sin(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>x))</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>,<span class="dv">0</span>].plot(x,np.sin(<span class="dv">4</span><span class="op">*</span>np.pi<span class="op">*</span>x))</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>,<span class="dv">0</span>].set_ylim(<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>,<span class="dv">0</span>].grid(<span class="va">True</span>)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>,<span class="dv">0</span>].set_title(<span class="vs">r&#39;$sin(2 \pi x)$ ve $sin(4 \pi x)$&#39;</span>)</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>,<span class="dv">1</span>].plot(x,np.sin(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>x))</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>,<span class="dv">1</span>].plot(x,np.sin(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>x <span class="op">+</span> <span class="fl">1.0</span>))</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>,<span class="dv">1</span>].set_ylim(<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>,<span class="dv">1</span>].grid(<span class="va">True</span>)</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>,<span class="dv">1</span>].set_title(<span class="vs">r&#39;$sin(2 \pi x)$ ve $sin(2 \pi x + 0.5)$&#39;</span>)</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_082_snd_02.jpg&#39;</span>)</span></code></pre></div>
<p><img src="tser_082_snd_02.jpg" /></p>
<p>Üstteki grafiklerde farklı sinüs eğrileri var. Üst solda bir <span
class="math inline">\(\sin(2 \pi x)\)</span> eğrisi görülüyor. Onun
genliğini (amplitude) arttırmak için bir sabit sayı ile çarpıyoruz,
örnekte iki ile, bu bize sağ üstteki <span class="math inline">\(2 \sin
(2\pi x)\)</span> sonucunu veriyor. Frekans arttırımı için, yani aynı
periyot içinde daha fazla salınım için <span
class="math inline">\(\sin\)</span> hesabına geçilen değer daha yüksek
bir katsayı ile çarpılabilir, bunun sonucu sol altta. Eğer aynı eğriyi
sadece kaydırmak isteseydik bunu <span
class="math inline">\(\sin\)</span> hesabına geçilen değere bir değer
toplayarak yapardık, böylece kaydırım gerçekleşirdi, onun sonucu ise sağ
altta.</p>
<p>Bu kavramları kullanarak kendimiz de suni ses dalgaları
yaratabilirdik, altta mesela iki tane ses dalgası yaratalım. Bazı
tanımlar,</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.io.wavfile</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span> fs <span class="op">=</span> <span class="dv">16000</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="dv">0</span>, T, <span class="bu">int</span>(T<span class="op">*</span>fs), endpoint<span class="op">=</span><span class="va">False</span>) </span></code></pre></div>
<p>Alttaki sürekli bir bip sesi verecek, telefonda meşgul veren sese
benziyor. Bu sesi üretmek için tek bir sinüs eğrisi yeterli.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.sin(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span><span class="dv">440</span><span class="op">*</span>t)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>x_scaled <span class="op">=</span> x <span class="op">*</span> <span class="fl">32767.0</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>x_int16 <span class="op">=</span> x_scaled.astype(np.int16)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>scipy.io.wavfile.write(<span class="st">&#39;/tmp/sound-out1.wav&#39;</span>, fs, x_int16)</span></code></pre></div>
<p>Bir ambulans sirenine benzeyen sesi üretmek için iki tane sinüs
eğrisi birleştirebiliriz, bu dalgaların ikisi farklı frekanslarda, ve
karışımları bize sonuç sesi veriyor.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.sin(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span><span class="dv">1500</span><span class="op">*</span>t <span class="op">-</span> <span class="dv">100</span><span class="op">*</span>np.sin(<span class="dv">2</span><span class="op">*</span><span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>t))</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>x_scaled <span class="op">=</span> x <span class="op">*</span> <span class="fl">32767.0</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>x_int16 <span class="op">=</span> x_scaled.astype(np.int16)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>scipy.io.wavfile.write(<span class="st">&#39;/tmp/sound-out2.wav&#39;</span>, fs, x_int16)</span></code></pre></div>
<h3 id="sinüssel-regresyon-sinusoidal-regression">Sinüssel Regresyon
(Sinusoidal Regression)</h3>
<p>Şimdi ses tanıma konusuna gelelim. Eğer bir sesin birden fazla farklı
sinüs eğrisi toplamı olduğu doğru ise, bu ses dalgasının sinüs
bileşenlerini ayırabilirsek ses tanıma bağlamında sağlam bir adım atmış
olurduk. Fakat sinüs eğrisini, tek sinüs eğrisi olduğu durumda bile,
nasıl genliğini büyüterek, yana kaydırarak, frekansını arttırarak tam
doğru uyum noktasını bulacağız? Yani veriye uydurmak istediğimiz
formül</p>
<p><span class="math display">\[
f(x) = A \sin (x+\varphi)
\qquad (1)
\]</span></p>
<p>Genlik <span class="math inline">\(A\)</span> ile faz ise <span
class="math inline">\(\varphi\)</span> ile gösterilmiş, öyle bir <span
class="math inline">\(A,\varphi\)</span> bulalım ki sonuç sinüs eğrisi
tam veriye uysun.</p>
<p>Veriye uydurma deyince akla lineer regresyon geliyor, fakat üstteki
formülü olduğu gibi regresyona sokmak mümkün değil, çünkü faz kaydırmak
için <span class="math inline">\(\sin\)</span> içindeki parametrenin
değişmesi lazım, regresyon bunları yapamaz. Ama regresyona problemi
“katsayı çarpı basit formül” formunda sunabilir miyiz acaba? Bir
trigonometrik eşitlikten biliyoruz ki</p>
<p><span class="math display">\[  A \sin (x+\varphi) = a\sin(x) +
b\cos(x) \]</span></p>
<p>ki <span class="math inline">\(\sin\varphi =
\frac{b}{\sqrt{a^2+b^2}}\)</span>, ve <span class="math inline">\(A =
\sqrt{a^2+b^2}\)</span> olacak sekilde. Bu eşitliğin doğru olduğunu
kontrol edelim,</p>
<p><span class="math display">\[ a \sin(x) + b \cos(x) = \sqrt{a^2+b^2}
\left(\frac{a}{\sqrt{a^2+b^2}} \sin(x) + \frac{b}{\sqrt{a^2+b^2}}
\cos(x)\right) \]</span></p>
<p><span class="math display">\[  = A\left[\sin(x)\cos(\varphi) +
\cos(x)\sin(\varphi)\right] \]</span></p>
<p><span class="math display">\[ = A\sin(x+\varphi) \]</span></p>
<p>O zaman <span class="math inline">\(a \sin(x) + b \cos(x)\)</span>
için regresyon yapmak (1) için regresyon yapmak ile aynı şeydir [4].
Regresyon iki toplam üzerinden tanımlı o formül için en uygun <span
class="math inline">\(a,b\)</span> katsayılarını hesaplayacak.</p>
<p>Eğer birden fazla farklı frekanstaki eğrileri uydurmak istersek, ana
formülü şu halde düşünebilirdik,</p>
<p><span class="math display">\[
A_1 \sin(2\pi x+\varphi_1) + A_2 \sin(4\pi x+\varphi_2) + ...
\]</span></p>
<p>Ve onun regresyona hazır açılımı</p>
<p><span class="math display">\[
a_1 \sin(2\pi x) + b_1 \cos(2\pi x) + a_1 \sin(4\pi x) + b_1 \cos(4\pi
x) + ...
\]</span></p>
<p>olurdu, ve üstteki formülünü regresyonda kullanırdık.</p>
<p>Ses verisine gelmeden önce alttaki daha basit veri üzerinde görelim,
orada bir veya birden fazla sinüs eğrisi uydurmak istiyoruz.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(<span class="st">&#39;baltic.csv&#39;</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>df.plot(x<span class="op">=</span><span class="st">&#39;toy&#39;</span>,y<span class="op">=</span><span class="st">&#39;degs&#39;</span>,kind<span class="op">=</span><span class="st">&#39;scatter&#39;</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_sinreg_01.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_sinreg_01.png" /></p>
<p>Önce <span class="math inline">\(\sin\)</span> içinde <span
class="math inline">\(2\pi x\)</span> ile başlarız,</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.formula.api <span class="im">as</span> smf</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> smf.ols(<span class="st">&#39;degs ~ np.sin(2*np.pi*toy) + np.cos(2*np.pi*toy)&#39;</span>, data<span class="op">=</span>df).fit()</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (results.summary())</span></code></pre></div>
<pre class="text"><code>                            OLS Regression Results                            
==============================================================================
Dep. Variable:                   degs   R-squared:                       0.969
Model:                            OLS   Adj. R-squared:                  0.968
Method:                 Least Squares   F-statistic:                     704.3
Date:                Fri, 27 Jun 2025   Prob (F-statistic):           1.10e-34
Time:                        12:37:22   Log-Likelihood:                -63.360
No. Observations:                  48   AIC:                             132.7
Df Residuals:                      45   BIC:                             138.3
Df Model:                           2                                         
Covariance Type:            nonrobust                                         
===========================================================================================
                              coef    std err          t      P&gt;|t|      [0.025      0.975]
-------------------------------------------------------------------------------------------
Intercept                   8.2917      0.135     61.407      0.000       8.020       8.564
np.sin(2 * np.pi * toy)    -5.9156      0.191    -30.979      0.000      -6.300      -5.531
np.cos(2 * np.pi * toy)    -4.0463      0.191    -21.190      0.000      -4.431      -3.662
==============================================================================
Omnibus:                       28.673   Durbin-Watson:                   1.051
Prob(Omnibus):                  0.000   Jarque-Bera (JB):                4.298
Skew:                          -0.158   Prob(JB):                        0.117
Kurtosis:                       1.569   Cond. No.                         1.41
==============================================================================</code></pre>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>a,b <span class="op">=</span> results.params[<span class="dv">1</span>],results.params[<span class="dv">2</span>]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> (a<span class="op">**</span><span class="dv">2</span><span class="op">+</span>b<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (A, np.rad2deg(np.arcsin(b<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> A)))</span></code></pre></div>
<pre class="text"><code>51.367286414382804 18.586661396939277</code></pre>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>fit1 <span class="op">=</span> results.params[<span class="dv">0</span>] <span class="op">+</span> results.params[<span class="dv">1</span>] <span class="op">*</span> np.sin(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>df.toy) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>       results.params[<span class="dv">2</span>] <span class="op">*</span> np.cos(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>df.toy)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>plt.scatter(df.toy,df.degs)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>plt.plot(df.toy,fit1)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_sinreg_02.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_sinreg_02.png" /></p>
<p>Uyum fena değil. Daha iyi uyum için daha fazla terim ekleyebiliriz,
mesela <span class="math inline">\(\sin,\cos\)</span> içinde <span
class="math inline">\(2 \pi x\)</span> kullandık, bir de <span
class="math inline">\(4 \pi x\)</span>’li terimler ekleyerek,</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.formula.api <span class="im">as</span> smf</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>formula <span class="op">=</span> <span class="st">&#39;degs ~ np.sin(2*np.pi*toy) + np.cos(2*np.pi*toy) + &#39;</span> <span class="op">+</span> <span class="op">\</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>          <span class="st">&#39;       np.sin(4*np.pi*toy) + np.cos(4*np.pi*toy)&#39;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> smf.ols(formula, data<span class="op">=</span>df).fit()</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (results.summary())</span></code></pre></div>
<pre class="text"><code>                            OLS Regression Results                            
==============================================================================
Dep. Variable:                   degs   R-squared:                       0.999
Model:                            OLS   Adj. R-squared:                  0.999
Method:                 Least Squares   F-statistic:                     9519.
Date:                Fri, 27 Jun 2025   Prob (F-statistic):           9.48e-63
Time:                        12:37:40   Log-Likelihood:                 16.130
No. Observations:                  48   AIC:                            -22.26
Df Residuals:                      43   BIC:                            -12.90
Df Model:                           4                                         
Covariance Type:            nonrobust                                         
===========================================================================================
                              coef    std err          t      P&gt;|t|      [0.025      0.975]
-------------------------------------------------------------------------------------------
Intercept                   8.2917      0.026    314.450      0.000       8.238       8.345
np.sin(2 * np.pi * toy)    -5.9156      0.037   -158.634      0.000      -5.991      -5.840
np.cos(2 * np.pi * toy)    -4.0463      0.037   -108.506      0.000      -4.122      -3.971
np.sin(4 * np.pi * toy)     1.2124      0.037     32.513      0.000       1.137       1.288
np.cos(4 * np.pi * toy)     0.3333      0.037      8.939      0.000       0.258       0.409
==============================================================================
Omnibus:                        0.473   Durbin-Watson:                   2.983
Prob(Omnibus):                  0.790   Jarque-Bera (JB):                0.338
Skew:                          -0.200   Prob(JB):                        0.845
Kurtosis:                       2.909   Cond. No.                         1.41
==============================================================================
</code></pre>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>fit2 <span class="op">=</span> results.params[<span class="dv">0</span>] <span class="op">+</span> <span class="op">\</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>       results.params[<span class="dv">1</span>] <span class="op">*</span> np.sin(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>df.toy) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>       results.params[<span class="dv">2</span>]<span class="op">*</span>np.cos(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>df.toy) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>       results.params[<span class="dv">3</span>] <span class="op">*</span> np.sin(<span class="dv">4</span><span class="op">*</span>np.pi<span class="op">*</span>df.toy) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>       results.params[<span class="dv">4</span>]<span class="op">*</span>np.cos(<span class="dv">4</span><span class="op">*</span>np.pi<span class="op">*</span>df.toy) </span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>plt.scatter(df.toy,df.degs)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>plt.plot(df.toy, fit2)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_sinreg_03.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_sinreg_03.png" /></p>
<p>Uyum daha iyi hale geldi.</p>
<h3 id="regresyon-sesi-katsayılardan-tekrar-oluşturmak">Regresyon, Sesi
Katsayılardan Tekrar Oluşturmak</h3>
<p>Üstte sinüs bileşenlerine ayırmayı başardık, o zaman ses verisi için
de aynı şeyi yapabiliriz. Hatta eğer bir sesi sinüssel bileşenlerine
ayırabiliyorsak, teorik olarak bu bileşenlerden en önemli olanlarını
tutup, gerisini atabilirdik ve bu azaltılmış kümeyi tekrar biraraya
koyarak orijinal ses yakın bir ses elde etmek mümkün olurdu. Bunun
faydası nerede? Çünkü eğer bu yapılabiliyorsa, o azaltılmış kümeyi arama
algoritmalarında kullanmak mümkün olurdu, çünkü her sesi temsil eden bir
nevi özet, “kodlama” bulmuş oluyoruz, ve bu özet üzerinden (ve eğer
elimizde tüm mümkün seslerin özetinin kayıt edildiği bir veri tabanı var
ise) sesin ne olduğunu arayıp bulmak rahatlaşabiliyor.</p>
<p>Daha önce işlediğimiz ses parçası üzerinde görelim,</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>fs, ow <span class="op">=</span> scipy.io.wavfile.read(owfile)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="bu">len</span>(ow) </span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.arange(N) <span class="op">/</span> fs</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>f_start <span class="op">=</span> <span class="fl">100.0</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>f_end <span class="op">=</span> <span class="fl">4000.0</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>frequencies_hz <span class="op">=</span> np.linspace(f_start, f_end, <span class="dv">500</span>)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>basis_functions <span class="op">=</span> {}</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> f <span class="kw">in</span> frequencies_hz:</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    angular_freq <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> np.pi <span class="op">*</span> f <span class="op">*</span> t</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    basis_functions[<span class="ss">f&#39;sin</span><span class="sc">{</span>f<span class="sc">:.6f}</span><span class="ss">&#39;</span>] <span class="op">=</span> np.sin(angular_freq)</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    basis_functions[<span class="ss">f&#39;cos</span><span class="sc">{</span>f<span class="sc">:.6f}</span><span class="ss">&#39;</span>] <span class="op">=</span> np.cos(angular_freq)</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>X_unaugmented <span class="op">=</span> pd.DataFrame(basis_functions)</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> pd.Series(ow, name<span class="op">=</span><span class="st">&#39;wav&#39;</span>).astype(np.float64) </span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>X_full <span class="op">=</span> sm.add_constant(X_unaugmented, prepend<span class="op">=</span><span class="va">True</span>) </span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> sm.OLS(Y, X_full)</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> model.fit()</span></code></pre></div>
<p>Regresyon yapıldı, şimdi bu regresyon sonucundaki istatistik önemi
fazla olan katsayıları tutalım, gerisini atalım, ve elde tutulan
katsayılar ile ses verisini tekrar yaratalım.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>basis_matrix_full <span class="op">=</span> X_full </span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>all_coeffs <span class="op">=</span> results.params</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>is_significant <span class="op">=</span> results.pvalues <span class="op">&lt;</span> <span class="fl">0.05</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>significant_features <span class="op">=</span> results.pvalues[is_significant].index</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="ss">f&#39;tum </span><span class="sc">{</span><span class="bu">len</span>(basis_matrix_full.columns)<span class="sc">}</span><span class="ss"> filtre sonrasi </span><span class="sc">{</span><span class="bu">len</span>(significant_features)<span class="sc">}</span><span class="ss">&#39;</span>)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>selected_basis_matrix <span class="op">=</span> basis_matrix_full.loc[:, significant_features]</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>selected_coeffs <span class="op">=</span> all_coeffs[is_significant]</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>reconstructed_signal_series <span class="op">=</span> selected_basis_matrix.dot(selected_coeffs)</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.array(reconstructed_signal_series).flatten() </span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>y_int16 <span class="op">=</span> y.astype(np.int16)</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>scipy.io.wavfile.write(<span class="st">&#39;/tmp/sound-out3.wav&#39;</span>, fs, y_int16)</span></code></pre></div>
<p>Üstteki tekrar oluşturulmuş sesi dinleyince orijinal ses yakın
olduğunu duyabiliriz.</p>
<p>Not: Dikkat edersek üstteki regresyonu en ufak konuşma ses parçası,
bir fonem üzerinde yaptık. Bu ufak sesin kendine has bir sinüs eğri
karışımı vardı. Fakat insan konuşmasındaki tek bir kelime telafuzunda
birden fazla fonem olacaktır. Yani konuşma tanıma amacıyla bir kelimeyi
alıp sinüs eğrilerine ayırmak işe yaramaz. Eğer kelime bazında regresyon
uygulamak istersek bunu kelime boyunca regresyonun değişmesine izin
veren, özyineli bir şekilde yapmalıyız, ve bu regresyon her zaman bir
unutma faktörü içermelidir ki ses içinde bir fonemden diğerine
geçildiğinde regresyon farklı harmoniklerin katsayılarını
yakalayabilmeye başlasın.</p>
<h3 id="mfcc">MFCC</h3>
<p>Mel Frekansı Kepstral Katsayıları (MFCC), ses işleme alanında,
özellikle konuşma tanıma ve müzik sınıflandırma gibi uygulamalarda
yaygın olarak kullanılan bir özellik çıkarma tekniği. Temelde, bir ses
sinyalinin kısa süreli güç spektrumunun, insan kulağının frekans
algısına (Mel ölçeği) yakından uyan doğrusal olmayan bir frekans ölçeği
temel alınarak temsilidir. İnsan kulağı, düşük frekanslarda daha
hassasken, yüksek frekanslarda daha az hassastır. MFCC, bu doğal insan
algısını taklit ederek, sesin spektral zarfını (tınısını) kısa ve
verimli bir şekilde temsil eden bir dizi katsayı üretir. MFCC
çıkarımının temel adımları,</p>
<p>Ön Vurgulama (Pre-emphasis): Yüksek frekanslardaki enerjiyi artırarak
spektral dengeyi sağlar.</p>
<p>Çerçeveleme (Framing) ve Pencereleme (Windowing): Ses sinyali,
genellikle örtüşen kısa zaman aralıklarına (çerçevelere) bölünür.</p>
<p>Hızlı Fourier Dönüşümü (FFT): Her bir çerçeve, zaman domeninden
frekans domenine dönüştürülür.</p>
<p>Mel Filtre Bankası Uygulaması: Frekans spektrumuna, Mel ölçeğine göre
aralıklandırılmış bir dizi üçgen filtre uygulanır. Bu, insan işitme
sisteminin duyarlılığını taklit eder.</p>
<p>Logaritma Alma: Filtre bankası enerjilerinin logaritması alınır.
(İnsanların yüksek enerjideki küçük değişikliklere daha az duyarlı
olmasıyla uyumludur.)</p>
<p>Ayrık Kosinüs Dönüşümü (DCT): Son olarak, bu log enerjilerine DCT
uygulanarak korelasyonları azaltılmış MFCC katsayıları elde edilir.</p>
<p>Makine öğreniminde MFCC hesaplandığında, bir ses dosyası için zaman
içinde değişen bir katsayılar listesi (bir matris) elde edersiniz. Bu
matrisin her bir satırı farklı bir katsayıyı (spektral çözünürlüğü), her
bir sütunu ise sesin farklı bir zaman dilimini (çerçeveyi) temsil eder.
Bir ses dosyasından elde edilen her bir çerçeveye ait MFCC vektörü, o
kısa zaman dilimindeki sesin ozgun bir özelliğini (parçasını) temsil
eder. Makine öğrenimi sınıflandırıcıları için, bu çerçevelerin her biri,
aynı ses dosyasından gelen, ancak farklı çözünürlüklerde veya anlarda
yakalanmış ayrı birer veri noktası (özellik vektörü) olarak
kullanılabilir. Örneğin, bir ses tanıma modelinde bu vektörler,
konuşulan fonemi (ses birimini) sınıflandırmak için kullanılır.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> librosa.display</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>y, sr <span class="op">=</span> librosa.load(owfile)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>mfccs <span class="op">=</span> librosa.feature.mfcc(y<span class="op">=</span>y, sr<span class="op">=</span>sr, n_mfcc<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">4</span>))</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>librosa.display.specshow(mfccs, x_axis<span class="op">=</span><span class="st">&#39;time&#39;</span>, cmap<span class="op">=</span><span class="st">&#39;viridis&#39;</span>)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>plt.colorbar()</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&#39;MFCC Özellikleri&#39;</span>)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Zaman&#39;</span>)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;MFCC Katsayıları&#39;</span>)</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_082_snd_03.jpg&#39;</span>)</span></code></pre></div>
<p><img src="tser_082_snd_03.jpg" /></p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (mfccs.shape)</span></code></pre></div>
<pre><code>(20, 7)</code></pre>
<p>Üstte görüldüğü gibi MFCC’ye 20 boyutunda özellik vermesini söyledik,
ve sonuç olarak 7 tane 20 boyutlu vektör ortaya çıktı. Tekrar
vurgulayalım, bu 7 vektörün her biri aynı ses dosyasını temsil etmek
için ayrı ayrı birer veri noktası olarak sınıflayıcı algoritmalara
verilmelidir. Üstteki boyutlar üzerinden eğer elimizde iki tane ‘cat’
iki tane ‘dog’ ses veri satırı var ise, MFCC sonrası elimizde 14 tane
‘cat’ satırı, 14 tane ‘dog’ satırı olacaktır, ve yapay öğrenme
algoritmasi 28 veri satırı ile eğitilecektir.</p>
<h3 id="ses-komut-tanıması-gmm-ubm">Ses Komut Tanıması, GMM-UBM</h3>
<p>Ses tanıma yaklaşımlarından bir tanesi her sesi bir Gaussian karışımı
(GMM) olarak görür ve bir test ses verisini teker teker bu GMM’lere
sorarak hangisinin daha yüksek ihtimalli olduğuna bakar. En yüksek
ihtimalli olan aralarından seçilir.</p>
<p>GMM-UBM yaklaşımı GMM [6,7] eğitiminde ilginç bir teknik uygular. İlk
fazda eğitim verisi, hangi komuttan geldiğine bakılmadan, birbirine
karıştırılarak tek bir “evrensel” GMM’nin eğitimi için kullanılır
(eğitim verisinin ne kadarının bu fazda kullanılacağı hiperparametre
optimizasyonunun bir parçası olabilir). İlk faz tamamlandıktan sonra
ikinci fazda komutlar için ayrı ayrı GMM eğitilme aşamasına gelinir.
Fakat bu aşamada her komut başlangıç noktası olarak evrensel GMM’yi
kullanarak ilerler, sıfırdan başlamaz. Yani mesela ‘down’ komutu için
ayrı bir GMM gerekir, bu GMM için evrensel GMM’nin bir kopyası alınır,
ve onun üzerinde güncelleme yapılarak istenen GMM hesaplanır.</p>
<p>Evrensel GMM eğitiminin amacı verideki tüm sesleri kullanarak bir
“ses arkaplanı” oluşturmaktır, yani tüm mümkün veri ile bir akustik
skala, baz seviye elde edilir, ve diğer tüm spesifik sesler bu baz
seviyeden farklılıklar / onun üstüne inşa edilmiş güncellemeler olarak
görülür.</p>
<p>Güncelleme hesabı [3] yazısında gördüğümüz maksimum sonsal hesabı
(maximum a posteriori / MAP) yöntemidir. Bu yazıda standart sapması
bilinen bir Gaussian’ın sadece <span class="math inline">\(\mu\)</span>
güncellemesinin nasıl yapıldığını görmüştük. GMM-UBM için aynı yaklaşım
kullanılıyor, ortalaması ve standart sapması bilinen GMM’lerin sadece
ortalaması yeni veriyle güncelleniyor.</p>
<p>GMM-UBM MAP güncellemesi</p>
<p><span class="math display">\[
\mu_k^{(MAP)} = \frac{N_k \bar{x}_k + \tau \mu_k^{(UBM)}}{N_k + \tau}
\]</span></p>
<p>formunda verilir, ki <span class="math inline">\(k\)</span> bir
GMM’yi oluşturan <span class="math inline">\(k\)</span>’inci Gaussian.
Bizim daha önce gördüğümüz [3] formülü</p>
<p><span class="math display">\[
\mu_n = \frac{n\sigma_0^2}{n\sigma_0^2 + \sigma^2} m_n +
\frac{\sigma^2}{n\sigma_0^2 + \sigma^2} \mu_0
\]</span></p>
<p>şeklindeydi. Tekrar düzenlersek,</p>
<p><span class="math display">\[
\mu_n = \frac{n m_n + \frac{\sigma^2}{\sigma_0^2} \mu_0}{n +
\frac{\sigma^2}{\sigma_0^2}}
\]</span></p>
<p>Birbirlerine eşlersek,</p>
<ul>
<li><span class="math inline">\(n \to N_k\)</span></li>
<li><span class="math inline">\(m_n \to \bar{x}_k\)</span></li>
<li><span class="math inline">\(\mu_0 \to \mu_k^{(UBM)}\)</span></li>
<li><span class="math inline">\(\frac{\sigma^2}{\sigma_0^2} \to
\tau\)</span></li>
</ul>
<p>Formüller aynı.</p>
<p>Ses tanıma için kullanılan GMM tabii ki çok boyutlu Gaussian’ların
karışımı, bizim kullandığımız ölçüler 16 boyutlu MFCC çıktısı, artı bu
çıktıların birinci ve ikinci seviyedeki farklılık (delta) hesapları,
toplam olarak her ses kaydı için 39 boyut elde ediyoruz. Karışımdaki
Gaussian sayısı ise 64 tane.</p>
<p>Alttaki kodlar üç parça halinde, ilk kod evrensel GMM eğitimi için,
ikincisi MAP güncellemesi yapıyor, üçüncü kod test verisi üzerinde
başarıyı ölçüyor. Verilerin <code>/opt/Downloads/gvoice/train.zip</code>
adlı bir dosyada olduğunu farzettik, bu zip dosyasının içeriği [8]
bağlantısından indirilebilir. Biz eğitim/test verisi paylaşımını 90/10
oranında yaptık, ve test işletildiğinde yüzde 95 doğru tanıma sonucunu
elde ettik.</p>
<p>Kodlar</p>
<p><a href="gmmubm1.py">gmmubm1.py</a>, <a
href="gmmubm2.py">gmmubm2.py</a>, <a
href="gmmubm3.py">gmmubm3.py</a></p>
<p>Kaynaklar</p>
<p>[1] <a href="../../sk/2018/01/speech-recognition.html">YSA ile
Konuşma Tanıma (Speech Recognition)</a></p>
<p>[2] <a href="./sk/2024/11/ses-tanima-isleme.html">[Ses Tanıma
İşleme</a></p>
<p>[3] Bayramlı, İstatistik, <em>Tahmin Edici Hesaplar
(Estimators)</em></p>
<p>[4] Cross Validated, <em>How to find a good fit for semi­sinusoidal
model in R?</em>, <a
href="http://stats.stackexchange.com/questions/60500/how-to-find-a-good-fit-for-semi-sinusoidal-model-in-r">http://stats.stackexchange.com/questions/60500/how-to-find-a-good-fit-for-semi-sinusoidal-model-in-r</a></p>
<p>[5] <a href="../../sk/2025/07/voice-command-ses-komut.html">Ses Komut
Tanıma, Dikkat (Attention) Modeli</a></p>
<p>[6] Bayramlı, İstatistik, <em>Gaussian Karışım Modeli (GMM) ile
Kümelemek</em></p>
<p>[7] Bayramlı, İstatistik, <em>Artımsal (Incremental) GMM</em></p>
<p>[8] Kaggle,
<a href="https://www.kaggle.com/datasets/neehakurelli/google-speech-commands">Google
Speech Commands</a></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
