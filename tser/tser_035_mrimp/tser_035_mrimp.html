<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Ortalamaya Dönüş ile İşlem (Trading)</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="ortalamaya-dönüş-ile-işlem-trading">Ortalamaya Dönüş ile İşlem
(Trading)</h1>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.formula.api <span class="im">as</span> smf</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.api <span class="im">as</span> sm</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(<span class="st">&#39;gld_uso.csv&#39;</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>cols <span class="op">=</span> [<span class="st">&#39;GLD&#39;</span>,<span class="st">&#39;USO&#39;</span>]</span></code></pre></div>
<p>Borsada ortalamaya dönüş (mean-reversion) ile nasıl işlem yapılır?
Daha önce örnekleri gördük, Z-skoru yarattık ve ona ters yönde işlem
yaptık. Altta bazı ek noktalar gösterilecek.</p>
<p>Lineer Regresyon ile bulunan yatırım bölüştürme oranı (hedge ratio)
zaman serisinin her anı için “en iyi’’ olmayabilir. Bu durumda yatırımcı
belli bir pencere üzerinden yakın tarihe bakıp oranı sürekli tekrar
tekrar hesaplamayı seçebilir. Altta görülen kod bunu yapıyor,</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.api <span class="im">as</span> sm</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>lookback<span class="op">=</span><span class="dv">20</span><span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;hedgeRatio&#39;</span>] <span class="op">=</span> np.nan</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(lookback,<span class="bu">len</span>(df)):</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.array(df[<span class="st">&#39;GLD&#39;</span>])[t<span class="op">-</span>lookback:t]</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> sm.add_constant(x)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> np.array(df[<span class="st">&#39;USO&#39;</span>])[t<span class="op">-</span>lookback:t]</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    df.loc[t,<span class="st">&#39;hedgeRatio&#39;</span>] <span class="op">=</span> sm.OLS(y,x).fit().params[<span class="dv">1</span>]</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>yport <span class="op">=</span> np.ones(df[cols].shape)<span class="op">;</span> yport[:,<span class="dv">0</span>] <span class="op">=</span> <span class="op">-</span>df[<span class="st">&#39;hedgeRatio&#39;</span>]</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>yport <span class="op">=</span> yport.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>yport <span class="op">=</span> pd.Series(yport)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>data_mean <span class="op">=</span> yport.rolling(window<span class="op">=</span><span class="dv">20</span>).mean()</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>data_std <span class="op">=</span> yport.rolling(window<span class="op">=</span><span class="dv">20</span>).std()</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;numUnits&#39;</span>] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">*</span>(yport<span class="op">-</span>data_mean) <span class="op">/</span> data_std</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>tmp1 <span class="op">=</span> np.ones(df[cols].shape) <span class="op">*</span> np.array([df[<span class="st">&#39;numUnits&#39;</span>]]).T</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>tmp2 <span class="op">=</span> np.ones(df[cols].shape)<span class="op">;</span> tmp2[:, <span class="dv">0</span>] <span class="op">=</span> <span class="op">-</span>df[<span class="st">&#39;hedgeRatio&#39;</span>]</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>positions <span class="op">=</span> pd.DataFrame(tmp1 <span class="op">*</span> tmp2 <span class="op">*</span> df[cols])</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>pnl <span class="op">=</span> positions.shift(<span class="dv">1</span>) <span class="op">*</span> (df[cols] <span class="op">-</span> df[cols].shift(<span class="dv">1</span>))  <span class="op">/</span> df[cols].shift(<span class="dv">1</span>)</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>pnl <span class="op">=</span> pnl.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>ret<span class="op">=</span>pnl <span class="op">/</span> np.<span class="bu">sum</span>(np.<span class="bu">abs</span>(positions.shift(<span class="dv">1</span>)),axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;APR&#39;</span>, ((np.prod(<span class="fl">1.</span><span class="op">+</span>ret))<span class="op">**</span>(<span class="fl">252.</span><span class="op">/</span><span class="bu">len</span>(ret)))<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;Sharpe&#39;</span>, np.sqrt(<span class="fl">252.</span>)<span class="op">*</span>np.mean(ret)<span class="op">/</span>np.std(ret))</span></code></pre></div>
<pre class="text"><code>APR 0.23319087620701384
Sharpe 1.1215726543503066</code></pre>
<p>Yıllık getiri yüzde 23 Sharpe oranı 1.12. Fena değil çünkü bu seri
koentegre bile değil,</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys<span class="op">;</span> sys.path.append(<span class="st">&#39;../tser_030_coint&#39;</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyconometrics</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (pyconometrics.cadf(np.matrix(df[<span class="st">&#39;GLD&#39;</span>]).H,</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>                         np.matrix(df[<span class="st">&#39;USO&#39;</span>]).H,<span class="dv">0</span>,<span class="dv">1</span>))</span></code></pre></div>
<pre class="text"><code>{&#39;alpha&#39;: np.float64(-0.0031124833978737783), &#39;adf&#39;:
np.float64(-1.5150247935770818), &#39;crit&#39;: matrix([[-3.88031, -3.35851,
-3.03798, -1.01144, -0.65334, 0.15312]]), &#39;nlag&#39;: 1, &#39;nvar&#39;: 1}</code></pre>
<p>Oran Kullanımı</p>
<p>Eğer basit bir şekilde <span class="math inline">\(y/x\)</span> ile
iki varlığını oranını “işlem sinyali’’ olarak kullansaydık ne olurdu?
Ayrıca diyelim ki her iki varlığa eşit para yatırıyoruz,</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;hedgeRatio&#39;</span>] <span class="op">=</span> df[<span class="st">&#39;USO&#39;</span>] <span class="op">/</span> df[<span class="st">&#39;GLD&#39;</span>]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>data_mean <span class="op">=</span> df[<span class="st">&#39;hedgeRatio&#39;</span>].rolling(window<span class="op">=</span><span class="dv">20</span>).mean()</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>data_std <span class="op">=</span> df[<span class="st">&#39;hedgeRatio&#39;</span>].rolling(window<span class="op">=</span><span class="dv">20</span>).std()</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;numUnits&#39;</span>] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">*</span>(df[<span class="st">&#39;hedgeRatio&#39;</span>]<span class="op">-</span>data_mean) <span class="op">/</span> data_std</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>positions <span class="op">=</span> df[[<span class="st">&#39;numUnits&#39;</span>,<span class="st">&#39;numUnits&#39;</span>]].copy()</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>positions <span class="op">=</span> positions <span class="op">*</span> np.array([<span class="op">-</span><span class="fl">1.</span>, <span class="fl">1.</span>])</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>pnl <span class="op">=</span> positions.shift(<span class="dv">1</span>) <span class="op">*</span> np.array((df[cols] <span class="op">-</span> df[cols].shift(<span class="dv">1</span>))  </span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>      <span class="op">/</span> df[cols].shift(<span class="dv">1</span>))</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>pnl <span class="op">=</span> pnl.fillna(<span class="dv">0</span>).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>ret<span class="op">=</span>pnl <span class="op">/</span> np.<span class="bu">sum</span>(np.<span class="bu">abs</span>(positions.shift(<span class="dv">1</span>)),axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;APR&#39;</span>, ((np.prod(<span class="fl">1.</span><span class="op">+</span>ret))<span class="op">**</span>(<span class="fl">252.</span><span class="op">/</span><span class="bu">len</span>(ret)))<span class="op">-</span><span class="fl">1.</span>)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;Sharpe&#39;</span>, np.sqrt(<span class="fl">252.</span>)<span class="op">*</span>np.mean(ret)<span class="op">/</span>np.std(ret))</span></code></pre></div>
<pre class="text"><code>APR -0.14067355886298372
Sharpe -0.7495829329023052</code></pre>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>plt.plot(np.cumprod(<span class="dv">1</span><span class="op">+</span>ret)<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_mrimp_01.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_mrimp_01.png" /></p>
<p>Sonuç iyi değil.</p>
<p>Bollinger Bantları</p>
<p>Şimdiye kadar gösterilen lineer strateji basit: tek birimlik
durağanlaştırılmış portföy eğer piyasanın yürüyen ortalama üzerinden
olan fiyatın üzerine çıkmışsa, bu çıkış oranında varlık al, düşüşte
satmaya başla. Bölüştürme oranı iki kere kullanılıyor yani, ilk önce
yürüyen ortalama fiyatlarını birleştirmek için, ve sonra en son piyasa
fiyatlarını birleştirmek için. Bu iki serinin birisi durağan serinin son
hali, ortalamadan sapmayı bu ikinci serinin birincisine oranla
ölçüyoruz.</p>
<p>Bu strateji seçildi çünkü hiçbir dış parametre gerektirmeyen bir
strateji. Az parametre iyi bir şey, böylece aşırı uygunluk (overfitting)
gibi problemlerden biraz daha uzaklaşmış oluyoruz (parametreler geçmiş
veriye aşırı iyi uyuyor, bu sebeple geleceği tahmin yeteneği
kayboluyor).</p>
<p>Bollinger bantları üstteki stratejinin bir uzantısı, yine ortalamadan
uzaklaşınca pozisyona giriyoruz, fakat bu uzaklaşmanın kaç standart
sapma oranında olduğuna bakıyoruz. Mesela uzaklaşma 1 standart sapma
oranından fazla ise girebiliriz, 0 standart sapma oranında ise (yani
ortalama üzerinde) pozisyondan çıkarız (bu parametre isimleri sırasıyla
<code>entryZscore</code>, <code>exitZscore</code>. Ya da
<code>entryZscore=1</code>, <code>exitZscore=-1</code> diyebilirdik, bu
durumda üstte ve altta 1 standart sapmadan fazla olduğu zaman alım,
satım olurdu.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>lookback<span class="op">=</span><span class="dv">20</span><span class="op">;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;hedgeRatio&#39;</span>] <span class="op">=</span> np.nan</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(lookback,<span class="bu">len</span>(df)):</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.array(df[<span class="st">&#39;GLD&#39;</span>])[t<span class="op">-</span>lookback:t]</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> sm.add_constant(x)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> np.array(df[<span class="st">&#39;USO&#39;</span>])[t<span class="op">-</span>lookback:t]</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    df.loc[t,<span class="st">&#39;hedgeRatio&#39;</span>] <span class="op">=</span> sm.OLS(y,x).fit().params[<span class="dv">1</span>]   </span></code></pre></div>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>cols <span class="op">=</span> [<span class="st">&#39;GLD&#39;</span>,<span class="st">&#39;USO&#39;</span>]</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>yport <span class="op">=</span> np.ones(df[cols].shape)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>yport[:,<span class="dv">0</span>] <span class="op">=</span> <span class="op">-</span>df[<span class="st">&#39;hedgeRatio&#39;</span>]</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>yport <span class="op">=</span> yport <span class="op">*</span> df[cols]</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>yport <span class="op">=</span> yport[cols].<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>yport <span class="op">=</span> pd.Series(yport)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>data_mean <span class="op">=</span> yport.rolling(window<span class="op">=</span><span class="dv">20</span>).mean()</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>data_std <span class="op">=</span> yport.rolling(window<span class="op">=</span><span class="dv">20</span>).std()</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>zScore<span class="op">=</span>(yport<span class="op">-</span>data_mean)<span class="op">/</span>data_std</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>entryZscore<span class="op">=</span><span class="fl">1.</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>exitZscore<span class="op">=</span><span class="dv">0</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>longsEntry<span class="op">=</span>zScore <span class="op">&lt;</span> <span class="op">-</span>entryZscore</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>longsExit<span class="op">=</span>zScore <span class="op">&gt;</span> <span class="op">-</span>exitZscore</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>shortsEntry<span class="op">=</span>zScore <span class="op">&gt;</span> entryZscore</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>shortsExit<span class="op">=</span>zScore <span class="op">&lt;</span> exitZscore</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>numUnitsLong <span class="op">=</span> pd.Series([np.nan <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(df))])</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>numUnitsShort <span class="op">=</span> pd.Series([np.nan <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(df))])</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>numUnitsLong[<span class="dv">0</span>] <span class="op">=</span> <span class="fl">0.</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>numUnitsShort[<span class="dv">0</span>] <span class="op">=</span> <span class="fl">0.</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>numUnitsLong[longsEntry] <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>numUnitsLong[longsExit] <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>numUnitsLong <span class="op">=</span> numUnitsLong.fillna(method<span class="op">=</span><span class="st">&#39;ffill&#39;</span>)</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>numUnitsShort[shortsEntry] <span class="op">=</span> <span class="op">-</span><span class="fl">1.0</span></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>numUnitsShort[shortsExit] <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>numUnitsShort <span class="op">=</span> numUnitsShort.fillna(method<span class="op">=</span><span class="st">&#39;ffill&#39;</span>)</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;numUnits&#39;</span>] <span class="op">=</span> numUnitsShort <span class="op">+</span> numUnitsLong</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>tmp1 <span class="op">=</span> np.ones(df[cols].shape) <span class="op">*</span> np.array([df[<span class="st">&#39;numUnits&#39;</span>]]).T</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>tmp2 <span class="op">=</span> np.ones(df[cols].shape)<span class="op">;</span> tmp2[:, <span class="dv">0</span>] <span class="op">=</span> <span class="op">-</span>df[<span class="st">&#39;hedgeRatio&#39;</span>]</span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>positions <span class="op">=</span> pd.DataFrame(tmp1 <span class="op">*</span> tmp2 <span class="op">*</span> df[cols])</span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>pnl <span class="op">=</span> positions.shift(<span class="dv">1</span>) <span class="op">*</span> (df[cols] <span class="op">-</span> df[cols].shift(<span class="dv">1</span>))  <span class="op">/</span> df[cols].shift(<span class="dv">1</span>)</span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>pnl <span class="op">=</span> pnl.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>ret<span class="op">=</span>pnl <span class="op">/</span> np.<span class="bu">sum</span>(np.<span class="bu">abs</span>(positions.shift(<span class="dv">1</span>)),axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>ret<span class="op">=</span>ret.fillna(<span class="dv">0</span>)</span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;APR&#39;</span>, ((np.prod(<span class="fl">1.</span><span class="op">+</span>ret))<span class="op">**</span>(<span class="fl">252.</span><span class="op">/</span><span class="bu">len</span>(ret)))<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;Sharpe&#39;</span>, np.sqrt(<span class="fl">252.</span>)<span class="op">*</span>np.mean(ret)<span class="op">/</span>np.std(ret))</span></code></pre></div>
<pre class="text"><code>APR 0.1977158548013851
Sharpe 1.064087612417886</code></pre>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>plt.plot(np.cumprod(<span class="dv">1</span><span class="op">+</span>ret)<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">u&#39;Kümülatif Birleşik Getiri&#39;</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_mrimp_02.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_mrimp_02.png" /></p>
<p>Kalman Filtreleri ile Dinamik Lineer Regresyon</p>
<p>Gerçekten koentegre halinde olan iki fiyat zaman serisi için
yapılacaklar basit - bulabildiğin kadar tarihi veri bul, basit lineer
regresyon ya da Johansen test kullanarak özvektörleri bul. Fakat diğer
yazılarda gördüğümüz gibi pür koentegresyon çok az sayıda fiyat zaman
serisinin erişebildiği bir mertebe. O zaman, zamana göre değişebilecek
yatırım bölüştürme oranını (hedge ratio) nasıl hesaplayacağız? Diğer
örneklerde gördük, bir geriye bakış penceresi kararlaştır, ve oranı
sadece bu pencere içindeki tarihe veriden hesapla. Bu yaklaşımın
dezavantajı, eğer pencere ufak ise pencere kaydırıldıkça yatırım oranı
aşırı sapmalar gösterebilmesi. Aynı durum ortalamayı ve standard sapma
için yürüyen ortalama ve yürüyen sapma kullanırken de ortaya çıkacak. O
zaman eğer en sondaki verilere öncekilerden daha fazla ağırlık veren, ve
kullanıcının kafasından attığı bir başlangıç noktasına göre pencere
oluşturmayan bir yöntem olsa bu bir ilerleme olurdu. Yatırım bölüştürme
oranını Kalman filtresi (KF) kullanarak hesaplayarak bu ilerlemeyi
sağlamayı umuyoruz [1, sf 74].</p>
<p>KF hakkında detaylar [2] yazısında bulunabilir; KF formüllerinin
türetilmesi orada anlatıldı. Bu yazıda gereken bölüştürme oranı, ve yan
ürün olarak bu oranın ortalamasını ve uçuculuğunu (volatility)
hesaplamak, o zaman gizli değişken bölüştürme oranı <span
class="math inline">\(\beta\)</span>, görünen (observable) değişken ise
fiyat zaman serisi <span class="math inline">\(y\)</span> olacak, yani
daha önce basit lineer regresyona <span class="math inline">\(y\)</span>
olarak verilen fiyat serisi. Tüm KF modeli,</p>
<p><span class="math display">\[ \beta_t = I \cdot \beta_{t-1} +
\omega_{t-1}\]</span></p>
<p><span class="math display">\[ y_t = x_t \beta_t + \epsilon_t
\]</span></p>
<p><span class="math inline">\(\omega_{t-1},\epsilon_t\)</span> Gaussian
gürültü olmak üzere.</p>
<p>Yukarıda ilginç birkaç “numara’’ yapıldı; aslında her iki seriyi de,
hem <span class="math inline">\(x\)</span>’i, hem <span
class="math inline">\(y\)</span>’yi biliyoruz, yani onlar”görünüyor’’.
Ama yapmak istediğimiz numara bağlamında onlardan sadece birini görünen
yaptık, ayrıca gizli değişkeni <span
class="math inline">\(\beta\)</span> yaptık, genellikle bu tür bir
parametre gizli değişkeni transforme eden matris olarak ele alınırdı.
Görünen tek veri ise modele göre <span class="math inline">\(y\)</span>.
Bu durumda <span class="math inline">\(x\)</span> gizli değişkeni
transforme eden matris gibi kullanılıyor, bu da ilginç.</p>
<p>Üstteki formüllerden birincisi geçiş (transition) formülü, ve biz
eldeki tüm verileri temsil eden tek bir <span
class="math inline">\(\beta\)</span> aradığımız için bu <span
class="math inline">\(\beta\)</span>’nin değişmediğini modele
söylüyoruz, bu sebeple geçiş matrisi <span
class="math inline">\(I\)</span>, yani birim matris, bu matris çarpımda
hiçbir etki yaratmıyor.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kalman_filter(x,y):</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    delta<span class="op">=</span><span class="fl">0.0001</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    Ve<span class="op">=</span><span class="fl">0.001</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    yhat <span class="op">=</span> np.ones(<span class="bu">len</span>(y))<span class="op">*</span>np.nan</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    e <span class="op">=</span> np.ones(<span class="bu">len</span>(y))<span class="op">*</span>np.nan</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    Q <span class="op">=</span> np.ones(<span class="bu">len</span>(y))<span class="op">*</span>np.nan</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    R <span class="op">=</span> np.zeros((<span class="dv">2</span>,<span class="dv">2</span>))</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    P <span class="op">=</span> np.zeros((<span class="dv">2</span>,<span class="dv">2</span>))</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    beta <span class="op">=</span> np.matrix(np.zeros((<span class="dv">2</span>,<span class="bu">len</span>(y)))<span class="op">*</span>np.nan)</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    Vw<span class="op">=</span>delta<span class="op">/</span>(<span class="dv">1</span><span class="op">-</span>delta)<span class="op">*</span>np.eye(<span class="dv">2</span>)</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>    beta[:, <span class="dv">0</span>]<span class="op">=</span><span class="fl">0.</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(y)):</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (t <span class="op">&gt;</span> <span class="dv">0</span>):</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>            beta[:, t]<span class="op">=</span>beta[:, t<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>            R<span class="op">=</span>P<span class="op">+</span>Vw</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>        yhat[t]<span class="op">=</span>np.dot(x[t, :],beta[:, t])</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>        xt <span class="op">=</span> np.matrix(x[t, :])</span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>        Q[t] <span class="op">=</span> np.dot(np.dot(xt,R),xt.T) <span class="op">+</span> Ve</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>        e[t]<span class="op">=</span>y[t]<span class="op">-</span>yhat[t]</span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>        K<span class="op">=</span>np.dot(R,np.matrix(x[t, :]).T) <span class="op">/</span> Q[t]</span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>        beta[:, t]<span class="op">=</span>beta[:, t]<span class="op">+</span>np.dot(K,np.matrix(e[t]))</span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>        P<span class="op">=</span>R<span class="op">-</span>np.dot(np.dot(K,xt),R)</span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> beta, e, Q</span></code></pre></div>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd, kf</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>ewdf <span class="op">=</span> pd.read_csv(<span class="st">&#39;../tser_030_coint/ETF.csv&#39;</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> ewdf[[<span class="st">&#39;ewa&#39;</span>]].copy()</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> ewdf[[<span class="st">&#39;ewc&#39;</span>]].copy()</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>x[<span class="st">&#39;intercept&#39;</span>] <span class="op">=</span> <span class="fl">1.</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.array(x)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.array(y)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>beta, e, Q <span class="op">=</span> kf.kalman_filter(x,y)</span></code></pre></div>
<div class="sourceCode" id="cb15"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>plt.plot(beta[<span class="dv">0</span>, :].T)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&#39;EWC(y) ve EWA(x) Arasındaki Eğim - Beta[0,t]&#39;</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_mrimp_03.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_mrimp_03.png" /></p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>plt.plot(beta[<span class="dv">1</span>, :].T)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&#39;Kesi, Beta[1,t]&#39;</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_mrimp_04.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_mrimp_04.png" /></p>
<p>Bu modelin güzel yan etkilerinden biri şu oldu: KF’in doğal olarak
hesapladığı parametreler ile direk bir ortalamaya-dönüş stratejisi
kodlayabiliriz. <span class="math inline">\(e_t\)</span> içinde ölçüm
tahmin hatası var, ki bu hata EWC-EWA’nın tahmin edilen ortalamasından
sapmasından başka bir şey değil. Bu sapmayı satın alırız, eğer çok
pozitif ise al-tut yaparız, çok negatif ise açığa satış. Çok pozitif,
çok negatif neye göre belirlenir? Bu da <span
class="math inline">\(e_t\)</span>’nin tahmin edilen standart
sapmasından başka bir şey değil, ki bu bilgi de <span
class="math inline">\(\sqrt{Q_t}\)</span> içinde! Her iki parametreyi
grafiklersek alttaki görüntü çıkıyor.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>plt.plot(e[<span class="dv">2</span>:], <span class="st">&#39;r&#39;</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>plt.plot(np.sqrt(Q[<span class="dv">2</span>:]))</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_mrimp_05.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_mrimp_05.png" /></p>
<p>Geri kalanlar daha önce Bollinger bantlarında gördüğümüz gibi.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>cols <span class="op">=</span> [<span class="st">&#39;ewa&#39;</span>,<span class="st">&#39;ewc&#39;</span>]</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>y2 <span class="op">=</span> ewdf[cols]</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>longsEntry<span class="op">=</span>e <span class="op">&lt;</span> <span class="op">-</span><span class="dv">1</span><span class="op">*</span>np.sqrt(Q)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>longsExit<span class="op">=</span>e <span class="op">&gt;</span> <span class="op">-</span><span class="dv">1</span><span class="op">*</span>np.sqrt(Q)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>shortsEntry<span class="op">=</span>e <span class="op">&gt;</span> np.sqrt(Q)</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>shortsExit<span class="op">=</span>e <span class="op">&lt;</span> np.sqrt(Q)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>numUnitsLong <span class="op">=</span> pd.Series([np.nan <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(ewdf))])</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>numUnitsShort <span class="op">=</span> pd.Series([np.nan <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(ewdf))])</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>numUnitsLong[<span class="dv">0</span>]<span class="op">=</span><span class="fl">0.</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>numUnitsShort[<span class="dv">0</span>]<span class="op">=</span><span class="fl">0.</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>numUnitsLong[longsEntry]<span class="op">=</span><span class="fl">1.</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>numUnitsLong[longsExit]<span class="op">=</span><span class="dv">0</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>numUnitsLong <span class="op">=</span> numUnitsLong.fillna(method<span class="op">=</span><span class="st">&#39;ffill&#39;</span>)</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>numUnitsShort[shortsEntry]<span class="op">=-</span><span class="fl">1.</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>numUnitsShort[shortsExit]<span class="op">=</span><span class="dv">0</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>numUnitsShort <span class="op">=</span> numUnitsShort.fillna(method<span class="op">=</span><span class="st">&#39;ffill&#39;</span>)</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>ewdf[<span class="st">&#39;numUnits&#39;</span>]<span class="op">=</span>numUnitsLong<span class="op">+</span>numUnitsShort</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>tmp1 <span class="op">=</span> np.tile(np.matrix(ewdf.numUnits).T, <span class="bu">len</span>(cols))</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>tmp2 <span class="op">=</span> np.hstack((<span class="op">-</span><span class="dv">1</span><span class="op">*</span>beta[<span class="dv">0</span>, :].T,np.ones((<span class="bu">len</span>(ewdf),<span class="dv">1</span>))))</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>positions <span class="op">=</span> np.array(tmp1)<span class="op">*</span>np.array(tmp2)<span class="op">*</span>y2</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>positions <span class="op">=</span> pd.DataFrame(positions)</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>tmp1 <span class="op">=</span> np.tile(np.matrix(ewdf.numUnits).T, <span class="bu">len</span>(cols))</span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>tmp2 <span class="op">=</span> np.hstack((<span class="op">-</span><span class="dv">1</span><span class="op">*</span>beta[<span class="dv">0</span>, :].T,np.ones((<span class="bu">len</span>(ewdf),<span class="dv">1</span>))))</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>positions <span class="op">=</span> np.array(tmp1)<span class="op">*</span>np.array(tmp2)<span class="op">*</span>y2</span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>positions <span class="op">=</span> pd.DataFrame(positions)</span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a>tmp1 <span class="op">=</span> np.array(positions.shift(<span class="dv">1</span>))</span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a>tmp2 <span class="op">=</span> np.array(y2<span class="op">-</span>y2.shift(<span class="dv">1</span>))</span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a>tmp3 <span class="op">=</span> np.array(y2.shift(<span class="dv">1</span>))</span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a>pnl <span class="op">=</span> np.<span class="bu">sum</span>(tmp1 <span class="op">*</span> tmp2 <span class="op">/</span> tmp3,axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a>ret <span class="op">=</span> pnl <span class="op">/</span> np.<span class="bu">sum</span>(np.<span class="bu">abs</span>(positions.shift(<span class="dv">1</span>)),axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a>ret <span class="op">=</span> ret.fillna(<span class="dv">0</span>)</span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;APR&#39;</span>, ((np.prod(<span class="fl">1.</span><span class="op">+</span>ret))<span class="op">**</span>(<span class="fl">252.</span><span class="op">/</span><span class="bu">len</span>(ret)))<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;Sharpe&#39;</span>, np.sqrt(<span class="fl">252.</span>)<span class="op">*</span>np.mean(ret)<span class="op">/</span>np.std(ret))</span></code></pre></div>
<pre class="text"><code>APR 0.262251943494046
Sharpe 2.361949085176113</code></pre>
<p>ETF ve ETF’in Öğe Hisseleri Arasında Arbitraj</p>
<p>Bir ETF ve onu oluşturan öğe hisseler arasında da arbitraj fırsatları
vardır. Bu portföyü oluşturmak için her öğe hisse ile ETF arasında teker
teker koentegrasyon aranır, diğerleri atılır. Bu örneği dünyanın belki
de en ünlü ETF’i üzerinde göstereceğiz. Standart &amp; Poors endeksini
baz alan SPY.</p>
<p>Tarihi veri olarak Ocak 1, 2007 ile Aralık 31, 2007 arasını seçtik,
bu aralıktaki SPY öğelerinin SPY’in kendisi ile en az yüzde 90 koentegre
olma şartını Johansen testi ile kontrol edeceğiz. Ardından bu seçilen
senetlerin her birine eşit sermaye ayıracağız, ve tüm portföy üzerinde
tekrar Johansen testi uygulayıp hala koentegre olup olmadığını kontrol
edeceğiz. Bu ikinci test lazım çünkü her öğeye verilen kafamıza göre
verdiğimiz (burada eşit) sermaye ağırlığı üzerinden oluşturulmuş
portföyün illa koentegre olacağı gibi bir şart yoktur. Bu ikinci test
için log fiyat kullanacağız, çünkü bu portföyü her gün tekrar
dengeleyeceğimizi bekliyoruz, yani senet miktarı üzerinden değil sermaye
seviyesini sabit tutacağız.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd, zipfile</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> zipfile.ZipFile(<span class="st">&#39;SPY3.zip&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> z:</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    dfspy3 <span class="op">=</span>  pd.read_csv(z.<span class="bu">open</span>(<span class="st">&#39;SPY3.csv&#39;</span>),sep<span class="op">=</span><span class="st">&#39;,&#39;</span>)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>dfspy3 <span class="op">=</span> dfspy3.set_index(<span class="st">&#39;Date&#39;</span>)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>train <span class="op">=</span> dfspy3[(dfspy3.index<span class="op">&gt;=</span><span class="dv">20070101</span>) <span class="op">&amp;</span> (dfspy3.index<span class="op">&lt;=</span><span class="dv">20071231</span>)]</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>testspy3 <span class="op">=</span> dfspy3[(dfspy3.index <span class="op">&gt;</span> <span class="dv">20071231</span>)]</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>resdf <span class="op">=</span> pd.DataFrame(index<span class="op">=</span>dfspy3.columns)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>resdf[<span class="st">&#39;isCoint&#39;</span>] <span class="op">=</span> np.nan</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys<span class="op">;</span> sys.path.append(<span class="st">&#39;../tser_coint&#39;</span>)</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> johansen <span class="im">import</span> coint_johansen, print_johan_stats</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> s <span class="kw">in</span> dfspy3.columns: </span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>   <span class="cf">if</span> s <span class="op">==</span> <span class="st">&#39;SPY&#39;</span>: <span class="cf">continue</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>   <span class="co"># johansen cagrisini kullaniyoruz boylece y,x hangisi secmemiz </span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>   <span class="co"># gerekmiyor</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>   data <span class="op">=</span> train[[s,<span class="st">&#39;SPY&#39;</span>]].dropna()</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>   <span class="cf">if</span> <span class="bu">len</span>(data) <span class="op">&lt;</span> <span class="dv">250</span>: <span class="cf">continue</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>   res <span class="op">=</span> coint_johansen(data, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>   <span class="cf">if</span> res.lr1[<span class="dv">0</span>] <span class="op">&gt;</span> res.cvt[<span class="dv">0</span>][<span class="dv">0</span>]: </span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>       resdf.loc[s,<span class="st">&#39;isCoint&#39;</span>] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (resdf.isCoint.<span class="bu">sum</span>())</span></code></pre></div>
<pre class="text"><code>98</code></pre>
<p>98 tane senet koentegre imiş. Şimdi bu senetlerle portföy
oluşturalım, ve tekrar koentegrasyon testi yapalım,</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>coint_cols <span class="op">=</span> <span class="bu">list</span>(resdf[resdf.isCoint<span class="op">==</span><span class="va">True</span>].index)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>yN <span class="op">=</span> train[coint_cols]</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>logMktVal_long <span class="op">=</span> np.log(yN).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>ytest <span class="op">=</span> pd.concat([logMktVal_long, np.log(train.SPY)],axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> coint_johansen(ytest, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>print_johan_stats(res)</span></code></pre></div>
<pre class="text"><code>trace statistic [15.86864835  6.19735725]
critical vals %90,%95,%99
r&lt;=0 [13.4294 15.4943 19.9349]
r&lt;=1 [2.7055 3.8415 6.6349]
eigen statistic [9.6712911  6.19735725]
critical values  %90,%95,%99
r&lt;=0 [12.2971 14.2639 18.52  ]
r&lt;=1 [2.7055 3.8415 6.6349]
ozdegerler [0.0380959  0.02458181]
ozvektorler
[[   1.09386171   -0.27989806]
 [-105.55999232   56.09328286]]</code></pre>
<div class="sourceCode" id="cb24"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>tmp1 <span class="op">=</span> np.ones((<span class="bu">len</span>(testspy3),resdf.isCoint.<span class="bu">sum</span>()))<span class="op">*</span>res.evec[<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>tmp2 <span class="op">=</span> np.ones((<span class="bu">len</span>(testspy3),<span class="dv">1</span>))<span class="op">*</span>res.evec[<span class="dv">1</span>,<span class="dv">0</span>]</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> np.hstack((tmp1,tmp2))</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>yNplus <span class="op">=</span> testspy3[coint_cols <span class="op">+</span> [<span class="st">&#39;SPY&#39;</span>]]</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>logMktVal <span class="op">=</span> np.<span class="bu">sum</span>(weights <span class="op">*</span> np.log(yNplus),axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>lookback<span class="op">=</span><span class="dv">5</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>data_mean <span class="op">=</span> logMktVal.rolling(window<span class="op">=</span>lookback).mean()</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>data_std <span class="op">=</span> logMktVal.rolling(window<span class="op">=</span>lookback).std()</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>numUnits <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">*</span>(logMktVal<span class="op">-</span>data_mean) <span class="op">/</span> data_std</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>numUnits2 <span class="op">=</span> np.reshape(numUnits, (<span class="bu">len</span>(numUnits),<span class="dv">1</span>))</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>positions <span class="op">=</span> pd.DataFrame(np.tile(numUnits2, weights.shape[<span class="dv">1</span>]),<span class="op">\</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>                        columns<span class="op">=</span>yNplus.columns)<span class="op">*</span>weights</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>tmp1 <span class="op">=</span> np.log(yNplus)<span class="op">-</span>np.log(yNplus.shift(<span class="dv">1</span>))</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>pnl <span class="op">=</span> np.<span class="bu">sum</span>(np.array(positions.shift(<span class="dv">1</span>)) <span class="op">*</span> np.array(tmp1), axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>ret <span class="op">=</span> pnl <span class="op">/</span> np.<span class="bu">sum</span>(np.<span class="bu">abs</span>(positions.shift(<span class="dv">1</span>)),axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;APR&#39;</span>, ((np.prod(<span class="fl">1.</span><span class="op">+</span>ret))<span class="op">**</span>(<span class="fl">252.</span><span class="op">/</span><span class="bu">len</span>(ret)))<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;Sharpe&#39;</span>, np.sqrt(<span class="fl">252.</span>)<span class="op">*</span>np.mean(ret)<span class="op">/</span>np.std(ret))</span></code></pre></div>
<pre class="text"><code>APR 0.044929874512839474
Sharpe 1.323109852605057</code></pre>
<p>Sonuç ilk deneme için fena sayılmaz; Bazı basit ilerlemeler
mümkündür, mesela her zaman aralığı için portföyü oluşturan senetleri
değiştirmek.</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>plt.plot(np.cumprod(<span class="dv">1</span><span class="op">+</span>ret)<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_mrimp_06.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_mrimp_06.png" /></p>
<p>Trendli Ortalamaya Dönüş</p>
<p>Bir tane de benden. Finans zaman serilerinin çoğunlukla bir trend’e
dönüş yaptığını görebiliriz. Eğer bu trend’i çıkartırsak geriye kalan
nedir? Ortalamaya dönüş yapan, durağan bir zaman serisi değil mi?
S&amp;P 500 üzerinde görelim,</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(<span class="st">&#39;../tser_010_back/SPY.csv&#39;</span>,index_col<span class="op">=</span><span class="st">&#39;Date&#39;</span>,parse_dates<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;SPY&#39;</span>] <span class="op">=</span> df[[<span class="st">&#39;Adj Close&#39;</span>]]</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df[df.index <span class="op">&lt;</span> <span class="st">&#39;2005-01-01&#39;</span>]</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>df.SPY.plot()</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_mrimp_07.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_mrimp_07.png" /></p>
<p>Belli noktalarda geriye dönerek belli bir pencere içindeki zaman seri
parçası üzerinde lineer regresyon uyguluyoruz. Daha sonra bu
uydurduğumuz çizgiyi ileri dönük tahmin olarak kullanıyoruz, bu tahminin
altına düşüşlerde alım, yukarı çıkışlarda satım yapıyoruz.</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.api <span class="im">as</span> sm</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>lookback <span class="op">=</span> <span class="dv">100</span><span class="op">;</span> forward <span class="op">=</span> <span class="dv">30</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>forward_points <span class="op">=</span> <span class="bu">range</span>(lookback, <span class="bu">len</span>(df), forward)</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.ones((lookback,<span class="dv">2</span>))</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>x[:,<span class="dv">1</span>] <span class="op">=</span> np.array(<span class="bu">range</span>(lookback))</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> t <span class="kw">in</span> forward_points:    </span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> df.SPY[t<span class="op">-</span>lookback:t]</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>    f <span class="op">=</span> sm.OLS(y,x).fit()</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>    df.loc[df.index[t],<span class="st">&#39;intercept&#39;</span>] <span class="op">=</span> f.params[<span class="dv">0</span>]</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>    df.loc[df.index[t],<span class="st">&#39;slope&#39;</span>] <span class="op">=</span> f.params[<span class="dv">1</span>]</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;ols&#39;</span>] <span class="op">=</span> np.nan</span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>x_lookback <span class="op">=</span> np.array(<span class="bu">range</span>(lookback))</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> t <span class="kw">in</span> forward_points:</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>   y <span class="op">=</span> x_lookback <span class="op">*</span> df.iloc[t].slope <span class="op">+</span> df.iloc[t].intercept</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>   df.iloc[t<span class="op">-</span>lookback:t].loc[:,<span class="st">&#39;ols&#39;</span>] <span class="op">=</span> y</span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>df[[<span class="st">&#39;SPY&#39;</span>,<span class="st">&#39;ols&#39;</span>]].plot()</span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_mrimp_08.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_mrimp_08.png" /></p>
<p>Trend’i çıkartınca geriye kalanın hakikaten durağan olduğunu
görelim,</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;MR&#39;</span>] <span class="op">=</span> df.SPY <span class="op">-</span> df.ols</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>df.MR.plot()</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_mrimp_09.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_mrimp_09.png" /></p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>win<span class="op">=</span><span class="dv">5</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>data_mean <span class="op">=</span> df.MR.rolling(window<span class="op">=</span>win).mean()</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>data_std <span class="op">=</span> df.MR.rolling(window<span class="op">=</span>win).std()</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;mktVal&#39;</span>] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">*</span>(df.MR<span class="op">-</span>data_mean) <span class="op">/</span> data_std</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>pnl <span class="op">=</span> df[<span class="st">&#39;mktVal&#39;</span>].shift(<span class="dv">1</span>) <span class="op">*</span> (df[<span class="st">&#39;MR&#39;</span>]<span class="op">-</span>df[<span class="st">&#39;MR&#39;</span>].shift(<span class="dv">1</span>))<span class="op">/</span> df[<span class="st">&#39;MR&#39;</span>].shift(<span class="dv">1</span>)</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>ret<span class="op">=</span>pnl.fillna(<span class="dv">0</span>) <span class="op">/</span> np.<span class="bu">sum</span>(np.<span class="bu">abs</span>(df[<span class="st">&#39;mktVal&#39;</span>].shift(<span class="dv">1</span>)))</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;APR&#39;</span>, ((np.prod(<span class="fl">1.</span><span class="op">+</span>ret))<span class="op">**</span>(<span class="fl">252.</span><span class="op">/</span><span class="bu">len</span>(ret)))<span class="op">-</span><span class="fl">1.</span>)</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;Sharpe&#39;</span>, np.sqrt(<span class="fl">252.</span>)<span class="op">*</span>np.mean(ret)<span class="op">/</span>np.std(ret))</span></code></pre></div>
<pre class="text"><code>APR 0.2801817694094304
Sharpe 0.8884148597414459</code></pre>
<p>Kaynaklar</p>
<p>[1] Chan, <em>Algorithmic Trading</em></p>
<p>[2] Bayramlı, Fizik, <em>Kalman Filtreleri</em></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
