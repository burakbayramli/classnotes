<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Balonlar Ne Zaman Patlar?</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="balonlar-ne-zaman-patlar">Balonlar Ne Zaman Patlar?</h1>
<p>Ekonomik krizlerin finans bağlamında kriz öncesi piyasalarda balon
oluşturduğu iddia edilir; mesela ABD’nin 1929, 1987 krizleri,
borsalardaki aşırı çıkışlar ardından düşüş ile başlamıştır, en son 2008
krizi öncesi emlak piyasasında balon oluşmuştur. Aynı dinamik tek bir
sektör endeksi, ya da tek senet bazında da görülebilmektedir. Demek ki
bu tür dinamiği anlayabilmek, tanıyabilmek, hatta nihai gidişatını
tahmin edebilmek yatırımcı için değerli bir yetenek olabilir.</p>
<p>Bu alanda Didier Sornette’in araştırmaları var [1,2], ona göre
balonlar fiyat zaman serisindeki artışın üstel artışı (exponential
increase) bile geçip süper üstel artış haline gelmesi durumudur. Bu
gidişat borsacıların, finansçılar, finans merkezlerinin birbiri ile çok
yönlü etkileşimi sonucunda oluşur, ve nihai bir patlama noktası vardır.
Sornette modeline deprem tahmin etme amacı ile başlamıştır, ardından
aynı yaklaşımı finans balonlarına da uygulayabileceğini
farketmiştir.</p>
<p>Model alttaki formüldür:</p>
<p><span class="math display">\[ \ln(p(t)) = A + B(t_c - t)^\beta
\big[ 1 + C \cos (\omega \ln(t_c-t) + \phi )  \big]
\qquad (1)
\]</span></p>
<p>Türetmek</p>
<p>Sornette’in modelinin başlangıcı bir zaman serisindeki artışının
üstel (exponential) hızı geçtiği zaman sonlu-anda (finite-time) bir
eşsizlik (singularity) çıktığı iddiası [1,4]. Eşsizlik konusunu [8]
notlarında işledik; eşsiz nokta bir fonksiyonun analitikliği kaybettiği
yerdir. Peki modelde eşsizliğin ortaya çıkması gerçek hayatta illa bunun
olacağı anlamına geliyor mu? İlginç bir şekilde eğer matematiksel model
sağlam ise eşsizliğin tahmin edildiği yerde hakikaten bu durum ortaya
çıkıyor, mesela bir materyelin kırılması / parçalanması matematiksel
modelin eşsizlik noktasında olur, ve deneylerde bu anda materyel
kırılması gözlenmiştir.</p>
<p>Sornette’e göre nüfus artışı, bir ekonominin ürettiği değeri temsil
eden gayrısafi yurtiçi hasıla (gross domestic product -GDP-) artışı
rakamlarına dünya bazında bakarsak üstel üstü artışları görebiliyoruz,
ve aynen materyel kırılmasında olduğu gibi modelin eşsizlik tahmin
ettiği yeri “bir fazın bittiği an” olarak görürsek, bu nokta bir tür
sürdüremezliğin geldiği an olacaktır, ve tabiri caizse “inceldiği yerden
kopma” noktasıdır, ve bunun ötesinde mesela ne daha fazla nüfus artışı,
ne de ekonomik büyüme mümkün değildir. En azından mevcut çevre, mevcut
ölçümler üzerinden ekonomik büyüme dediğimiz şey olmayacaktır.</p>
<p>Sonlu an eşsizliğine erişmek için mesela normal nüfus artışı
modelinden başlayalım, nüfusu modellemenin en iyi bilinen yolu Lojistik
Denklemdir, bkz [6], [7], [8]. Model şöyledir;</p>
<p><span class="math display">\[ \frac{dp}{dt} = rp(t) [ K - p(t) ]
\]</span></p>
<p>Lojistik modelde bir taşıma kapasitesi <span
class="math inline">\(K\)</span> vardır, ve bu kapasitenin daha
fazlasını çevre koşullarının taşıması mümkün değildir. Fakat [4]’teki
referanslara göre şu iddia edilmektedir; <span
class="math inline">\(p(t)\)</span> ile birlikte <span
class="math inline">\(K\)</span> de artmaktadır, çünkü araçlarımızı daha
iyi kullanıyoruz, sürekli keşifler yapıyoruz, ilaçlar, gübre çeşitleri,
vs. ve yeni bölgelere yayılıyoruz, yani sürekli taşıma kapasitesini
aşıyoruz. Bu durumda, yani <span class="math inline">\(K &gt;
p(t)\)</span>’in olduğu durumda lojistik denklemini çözümü patlar, yani
uzaklaşır (divergent) hale gelir ve sonsuza gider. Bu gidiş süresi,
eşsizlik öncesi varışta giden zaman sonludur, yani belli bir büyüklüğü
vardır.</p>
<p>Bu durumda denkleme artık hiçbir etkisi olmayan <span
class="math inline">\(-p(t)\)</span> denklemden çıkartılabilir, ve o
zaman geri kalanlar <span class="math inline">\(\delta &gt; 1\)</span>
olacak şekilde <span class="math inline">\(K \propto
p^{1+\delta}\)</span> kabul edilebilir, yani <span
class="math inline">\(K\)</span>’nin kendisi <span
class="math inline">\(p\)</span>’ye oranla büyüyor ve arada bir üstel
kanun (power law) ilişkisi vardır. Şimdi aynı formülü şu şekilde
yazarız,</p>
<p><span class="math display">\[ \frac{dp}{dt} = r [p(t)]^{1+\delta}
\]</span></p>
<p>ki bu formüle göre artış oranı <span class="math inline">\(r
[p(t)]^{1+\delta}\)</span> olarak hızlanmaktadır. Çözelim,</p>
<p><span class="math display">\[ \int \frac{dp}{p(t)^{1+\delta}} = \int
rt\]</span></p>
<p><span class="math display">\[ \int p(t)^{-1-\delta} \,dp = rt + C
\]</span></p>
<p><span class="math inline">\(t_c\)</span>’ye (ki bir sabit) erişmek
amaçlı olarak <span class="math inline">\(C = -rt_c\)</span>
tanımlayalım,</p>
<p><span class="math display">\[ \frac{p(t)^{-\delta}}{-\delta} = rt -
rt_c \]</span></p>
<p><span class="math display">\[ p(t)^{-\delta}= -\delta r(t - t_c)
\]</span></p>
<p><span class="math inline">\(t-t_c = -(t_c-t)\)</span> olduğu için
parantez içindeki çıkartma işlemi şu hale gelir,</p>
<p><span class="math display">\[ p(t)^{-\delta}= \delta r(t_c - t)
\]</span></p>
<p>İstediğimiz forma yaklaştık çünkü <span
class="math inline">\(t_c\)</span>’yi eşsizlik anı olarak hesaplamak
istiyoruz, ve <span class="math inline">\(t\)</span> bu andan önceki
zamanı temsil ediyor olmalı. Şimdi <span class="math inline">\(\alpha =
-\frac{1}{\delta}\)</span> tanımlayalım, ve eşitliğin her iki tarafının
<span class="math inline">\(\alpha\)</span> üstünü alalım,</p>
<p><span class="math display">\[ (p(t)^{-\delta})^\alpha= (\delta r
)^\alpha (t_c - t)^\alpha \]</span></p>
<p>Eğer <span class="math inline">\(p(0) = p_0 = (\delta r
)^\alpha\)</span> kabul edersek, eşitliğin sol tarafını
basitleştirince,</p>
<p><span class="math display">\[ p(t) = p_0 (t_c - t)^\alpha
\]</span></p>
<p>elde ederiz, ki bu denklemin <span class="math inline">\(t_c\)</span>
anında eşsizliği vardır.</p>
<p>Log Salınım (Log Oscillation)</p>
<p>[4,5]’te bu modelin geliştirilerek (1) formülüne nasıl erişildiğinin
detayları bulunabilir. Hikayenin özü şöyle; materyel kırılması ve buna
benzer diğer doğal olaylarda eşsizlik anı öncesi log salınımlar olduğu
da görülmüştür. Bu salınımlara matematiksel olarak erişmek için (2)’deki
formüldeki <span class="math inline">\(z\)</span> üstelinin kompleks
sayı olmasına izin verilir, yani <span class="math inline">\(\beta +
i\omega\)</span> formunda olduğu farz edilir, ve bu şekilde türetime
devam edince ortaya (1)’deki log periyodik salınımlar çıkar. Detaylar
için [1,4]. Sornette bu salınım ekinin formülü “dekore” ettiğini
söylemektedir, güzel bir kelime seçilmiş, hakikaten bu salınımlar ana
formüle bir ek, onu “süslüyor”, fakat tabii ki bu sayede eşsizlik
noktasını yakalamamız kolaylaşıyor çünkü uydurma rutinimiz artık
verideki bu salınımları da veride bulmaya uğraşıyor böylece aradığı tüm
parametrelerin kalitesi artmış oluyor.</p>
<p>Sornette bazı kaynaklarda bir değişik türetim şekli daha uyguluyor
[1,5]; buna göre <span class="math inline">\(p(t)\)</span> olarak
belirttiğimiz <span class="math inline">\(h(t)\)</span>, tehlike oranı
(hazard rate) olarak modellenir, ve fiyat serisi <span
class="math inline">\(p(t)\)</span> olarak rasgele calculus’tan
gelinerek modelleniyor, ve <span class="math inline">\(h(t)\)</span>,
<span class="math inline">\(p(t)\)</span>’ye sokuluyor, ve ortaya log
salınımlı model çıkıyor. Bu türetişin bazı ilginç bağlantıları var,
mesela tehlike oranının kimi aşırı, kimi az ama hepsi birbiriyle
etkileşimde olan borsacıların birbirini taklit etmesi yüzünden <span
class="math inline">\(h(t)\)</span>’nin arttığı modellenmekte, ki bu
artış ta bir üstel kanunu takip ediyor. Fizik ve sosyal modelde birbiri
ile aşırı etkileşim sürekli ortaya üstel kanun çıkartıyor, bunu
biliyoruz. Patlama anı ve öncesinde aslında ortada olan bir kaos değil,
kaos <em>yokluğu</em>. Bütüne bakıldığında biri rasgele bazen satan,
biri rasgele bazen alan borsacıların patlama anı öncesi birdenbire
düzenli bir şekilde hepsi <em>satıyor</em>.</p>
<p>Hesaplamak</p>
<p>Bazı teknik detaylar: Kullanılan Log-Periodic Power Law (LPPL)
modelinin bir uygulamasıdır ve bu modelin en zorlayıcı kısmı, yedi
parametreden dördünün doğrusal, üçünün ise karmaşık bir şekilde doğrusal
olmayan parametreler olması. SciPy ile LPPL optimizasyonunda kullanılan,
iki aşamalı (two-step) en küçük kareler yöntemini uygulayacağız. Bu
yöntem, doğrusal olmayan parametreleri (<span
class="math inline">\(t_c\)</span>, <span
class="math inline">\(\beta/m\)</span>, <span
class="math inline">\(\omega\)</span>) ararken, doğrusal parametreleri
(<span class="math inline">\(A, B, C_1, C_2\)</span>) her iterasyonda
hızlıca bulmak için lineer cebir kullanır. Hesap üstteki formüldeki
salınım terimini iki ayrı lineer bileşene ayırır (<span
class="math inline">\(C \cos(\cdot) + D \sin(\cdot)\)</span> formuna
dönüştürmek).</p>
<p>Formülü kullanmak için onu bilinen bir krizden önce elde olan veriye
uyduracağız. Normal şartlarda yapılacak budur, bir varlığın, endeksin
gidişatının balon olup olmadığı, eğer balon ise ne zaman patlayabileceği
merak konusudur. Örnek olarak 1929 krizini seçtik.</p>
<p>Ekim 1929 krizi Amerika’da “Büyük Depresyon” adı verilen dönemin
başlangıcıydı, ve kriz öncesi Dow Jones (DJIA) endeksinde müthiş bir
artış ardından düşüş gerçekleşti.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.tsa.stattools <span class="im">as</span> st</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd, zipfile</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> zipfile.ZipFile(<span class="st">&#39;djia.zip&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> z:</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    dfj <span class="op">=</span>  pd.read_csv(z.<span class="bu">open</span>(<span class="st">&#39;djia.csv&#39;</span>),index_col<span class="op">=</span><span class="st">&#39;Date&#39;</span>,parse_dates<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>dfj[<span class="st">&#39;Adj Close&#39;</span>].plot()</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>plt.plot()</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_130_bbl_01.jpg&#39;</span>)</span></code></pre></div>
<p><img src="tser_130_bbl_01.jpg" /></p>
<p>Acaba DJİA bu evrede bir balon muydu? Sornette’in denklemini kriz
öncesi veriye uyduralım. Sornette yöntemine göre test için tam kriz
noktasına kadar olan zaman serisi kullanılır, o zaman</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>dfj2 <span class="op">=</span> dfj[(dfj.index <span class="op">&gt;=</span> <span class="st">&#39;1922-01-01&#39;</span>)<span class="op">&amp;</span>(dfj.index <span class="op">&lt;=</span> <span class="st">&#39;1929-01-01&#39;</span>)]    </span></code></pre></div>
<p>filtrelemesini yaparız. Geri kalanlar,</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> least_squares</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy.linalg <span class="im">import</span> lstsq</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lppl_basis(t, tc, m, w):</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co">    LPPL modelinin lineer bileşenlerinin (baz fonksiyonları) hesaplanması.</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co">    t: zaman dizisi (t_c&#39;den küçük olmalı)</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co">    tc, m, w: non-lineer parametreler</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># t_c - t terimi, kritik an (t_c) geçmişte ise tanımsızdır.</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Optimizasyonun t &gt; t_c olduğu durumlarda çalışmasını engellemek için:</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> np.<span class="bu">any</span>(t <span class="op">&gt;=</span> tc):</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Bu, least_squares&#39;ın bu bölgeyi keşfetmesini engellemek için yüksek bir maliyet/hata döndürür</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.inf <span class="op">*</span> np.ones_like(t)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> tc <span class="op">-</span> t</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Baz Fonksiyonları:</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># F1 = 1 (A için)</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># F2 = (tc - t)^m (B için)</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># F3 = (tc - t)^m * cos(w * ln(tc - t)) (C1 için)</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># F4 = (tc - t)^m * sin(w * ln(tc - t)) (C2 için)</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    basis <span class="op">=</span> np.array([</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>        np.ones_like(t),</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>        dt<span class="op">**</span>m,</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>        dt<span class="op">**</span>m <span class="op">*</span> np.cos(w <span class="op">*</span> np.log(dt)),</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>        dt<span class="op">**</span>m <span class="op">*</span> np.sin(w <span class="op">*</span> np.log(dt))</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>    ]).T <span class="co"># Transpoze ile (N_data, N_linear_params) boyutunda matris</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> basis</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lppl_residual_scipy(nonlin_params_array, t, log_p):</span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a><span class="co">    SciPy&#39;ın least_squares fonksiyonu için amaç (hata) fonksiyonu.</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a><span class="co">    Sadece non-lineer parametreleri alır, lineer parametreleri içeride çözer.</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># nonlin_params_array = [tc, m, w]</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>    tc, m, w <span class="op">=</span> nonlin_params_array</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Kısıtlamalar: LPPL için t &lt; t_c olmalı ve 0 &lt; m &lt; 1.0 olmalı</span></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> m <span class="op">&lt;=</span> <span class="dv">0</span> <span class="kw">or</span> m <span class="op">&gt;=</span> <span class="fl">1.0</span> <span class="kw">or</span> np.<span class="bu">any</span>(t <span class="op">&gt;=</span> tc):</span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>        <span class="co"># SciPy&#39;a bu non-lineer parametre setinin çok kötü olduğunu söyle</span></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.full_like(log_p, <span class="fl">1e12</span>) <span class="co"># Çok büyük bir hata döndür</span></span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. Aşama: Baz Fonksiyonlarını Hesapla</span></span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>    basis_matrix <span class="op">=</span> lppl_basis(t, tc, m, w)</span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2. Aşama: Lineer En Küçük Kareler (A, B, C1, C2)</span></span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>    <span class="co"># log_p = basis_matrix @ linear_params + residuals</span></span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Lineer sistemi çöz: A * 1 + B * F2 + C1 * F3 + C2 * F4 = log_p</span></span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>    <span class="co"># lstsq, (A, B, C1, C2) lineer parametrelerini (popt) döndürür</span></span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>    linear_params, residuals, rank, s <span class="op">=</span> lstsq(basis_matrix, log_p, rcond<span class="op">=</span><span class="va">None</span>)</span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a>    <span class="co"># least_squares, minimize edilen bir hata dizisi ister</span></span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>    <span class="co"># residuals[0] bize en küçük kareler toplamını verir, </span></span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ancak least_squares hata Vektörünü ister (bu vektörün karesini alıp toplar)</span></span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Model çıktısını hesaplayalım</span></span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a>    model_log_p <span class="op">=</span> basis_matrix <span class="op">@</span> linear_params</span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Kalan hatayı döndür (SciPy bu dizinin elemanlarının karesini alıp toplar)</span></span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> log_p <span class="op">-</span> model_log_p</span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> run_lppl_fit_scipy(t_data, log_p_data, x0_nonlin, bounds_nonlin):</span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a><span class="co">    LPPL modelini SciPy&#39;ın least_squares ile uydurur.</span></span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a><span class="co">    t_data, log_p_data: uydurulacak veri serileri</span></span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true" tabindex="-1"></a><span class="co">    x0_nonlin: [tc_baslangic, m_baslangic, w_baslangic]</span></span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true" tabindex="-1"></a><span class="co">    bounds_nonlin: ([tc_min, m_min, w_min], [tc_max, m_max, w_max])</span></span>
<span id="cb4-76"><a href="#cb4-76" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb4-77"><a href="#cb4-77" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-78"><a href="#cb4-78" aria-hidden="true" tabindex="-1"></a>    <span class="co"># least_squares çağrısı</span></span>
<span id="cb4-79"><a href="#cb4-79" aria-hidden="true" tabindex="-1"></a>    <span class="co"># &#39;trf&#39; (Trust Region Reflective) metodu, sınırları (bounds) destekler</span></span>
<span id="cb4-80"><a href="#cb4-80" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> least_squares(</span>
<span id="cb4-81"><a href="#cb4-81" aria-hidden="true" tabindex="-1"></a>        fun<span class="op">=</span>lppl_residual_scipy,</span>
<span id="cb4-82"><a href="#cb4-82" aria-hidden="true" tabindex="-1"></a>        x0<span class="op">=</span>x0_nonlin,</span>
<span id="cb4-83"><a href="#cb4-83" aria-hidden="true" tabindex="-1"></a>        bounds<span class="op">=</span>bounds_nonlin,</span>
<span id="cb4-84"><a href="#cb4-84" aria-hidden="true" tabindex="-1"></a>        args<span class="op">=</span>(t_data, log_p_data), <span class="co"># fun&#39;a geçilecek ek argümanlar</span></span>
<span id="cb4-85"><a href="#cb4-85" aria-hidden="true" tabindex="-1"></a>        method<span class="op">=</span><span class="st">&#39;trf&#39;</span>,</span>
<span id="cb4-86"><a href="#cb4-86" aria-hidden="true" tabindex="-1"></a>        max_nfev<span class="op">=</span><span class="dv">3000</span>, <span class="co"># Max fonksiyon değerlendirme sayısı</span></span>
<span id="cb4-87"><a href="#cb4-87" aria-hidden="true" tabindex="-1"></a>        verbose<span class="op">=</span><span class="dv">1</span> <span class="co"># Sonlandırma raporunu göster</span></span>
<span id="cb4-88"><a href="#cb4-88" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb4-89"><a href="#cb4-89" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-90"><a href="#cb4-90" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Optimizasyon Sonuçları:&quot;</span>)</span>
<span id="cb4-91"><a href="#cb4-91" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(result.message)</span>
<span id="cb4-92"><a href="#cb4-92" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Başarılı: </span><span class="sc">{</span>result<span class="sc">.</span>success<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb4-93"><a href="#cb4-93" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Maliyet (Kalanların Kareler Toplamı / 2): </span><span class="sc">{</span>result<span class="sc">.</span>cost<span class="sc">:.4f}</span><span class="ss">&quot;</span>)</span>
<span id="cb4-94"><a href="#cb4-94" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-95"><a href="#cb4-95" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sonuçların Tamamlanması: En iyi non-lineer parametrelerle lineer fit&#39;i tekrar yap</span></span>
<span id="cb4-96"><a href="#cb4-96" aria-hidden="true" tabindex="-1"></a>    tc, m, w <span class="op">=</span> result.x</span>
<span id="cb4-97"><a href="#cb4-97" aria-hidden="true" tabindex="-1"></a>    basis_matrix <span class="op">=</span> lppl_basis(t_data, tc, m, w)</span>
<span id="cb4-98"><a href="#cb4-98" aria-hidden="true" tabindex="-1"></a>    linear_params, _, _, _ <span class="op">=</span> lstsq(basis_matrix, log_p_data, rcond<span class="op">=</span><span class="va">None</span>)</span>
<span id="cb4-99"><a href="#cb4-99" aria-hidden="true" tabindex="-1"></a>    A, B, C1, C2 <span class="op">=</span> linear_params</span>
<span id="cb4-100"><a href="#cb4-100" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-101"><a href="#cb4-101" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Orijinal LPPL C ve phi parametrelerini geri hesapla</span></span>
<span id="cb4-102"><a href="#cb4-102" aria-hidden="true" tabindex="-1"></a>    C_amp <span class="op">=</span> np.sqrt(C1<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> C2<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> np.<span class="bu">abs</span>(B) <span class="co"># C = sqrt(C1^2 + C2^2) / |B|</span></span>
<span id="cb4-103"><a href="#cb4-103" aria-hidden="true" tabindex="-1"></a>    phi_phase <span class="op">=</span> np.arctan2(C2, C1) <span class="co"># phi = atan2(C2, C1)</span></span>
<span id="cb4-104"><a href="#cb4-104" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-105"><a href="#cb4-105" aria-hidden="true" tabindex="-1"></a>    final_params <span class="op">=</span> {</span>
<span id="cb4-106"><a href="#cb4-106" aria-hidden="true" tabindex="-1"></a>        <span class="st">&#39;tc&#39;</span>: tc, <span class="st">&#39;m&#39;</span>: m, <span class="st">&#39;w&#39;</span>: w,</span>
<span id="cb4-107"><a href="#cb4-107" aria-hidden="true" tabindex="-1"></a>        <span class="st">&#39;A&#39;</span>: A, <span class="st">&#39;B&#39;</span>: B, <span class="st">&#39;C1&#39;</span>: C1, <span class="st">&#39;C2&#39;</span>: C2,</span>
<span id="cb4-108"><a href="#cb4-108" aria-hidden="true" tabindex="-1"></a>        <span class="st">&#39;C_amplitude&#39;</span>: C_amp, <span class="st">&#39;phi_phase&#39;</span>: phi_phase</span>
<span id="cb4-109"><a href="#cb4-109" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb4-110"><a href="#cb4-110" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-111"><a href="#cb4-111" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> final_params, result</span>
<span id="cb4-112"><a href="#cb4-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-113"><a href="#cb4-113" aria-hidden="true" tabindex="-1"></a>price_data <span class="op">=</span> dfj2[<span class="st">&#39;Adj Close&#39;</span>].values</span>
<span id="cb4-114"><a href="#cb4-114" aria-hidden="true" tabindex="-1"></a>log_p_data <span class="op">=</span> np.log(price_data) <span class="co"># &lt;--- THIS IS THE CORRECT LOG_P_DATA</span></span>
<span id="cb4-115"><a href="#cb4-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-116"><a href="#cb4-116" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the time data (t_data) and normalize it</span></span>
<span id="cb4-117"><a href="#cb4-117" aria-hidden="true" tabindex="-1"></a>t_index <span class="op">=</span> dfj2.index</span>
<span id="cb4-118"><a href="#cb4-118" aria-hidden="true" tabindex="-1"></a>t_ordinal <span class="op">=</span> t_index.to_series().<span class="bu">apply</span>(<span class="kw">lambda</span> x: x.toordinal()).values</span>
<span id="cb4-119"><a href="#cb4-119" aria-hidden="true" tabindex="-1"></a>t_data <span class="op">=</span> t_ordinal <span class="op">-</span> t_ordinal[<span class="dv">0</span>] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb4-120"><a href="#cb4-120" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-121"><a href="#cb4-121" aria-hidden="true" tabindex="-1"></a>max_t <span class="op">=</span> np.<span class="bu">max</span>(t_data) </span>
<span id="cb4-122"><a href="#cb4-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-123"><a href="#cb4-123" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial guess for non-linear parameters [tc, m, w]</span></span>
<span id="cb4-124"><a href="#cb4-124" aria-hidden="true" tabindex="-1"></a>x0_nonlin <span class="op">=</span> [max_t <span class="op">*</span> <span class="fl">1.05</span>, <span class="fl">0.5</span>, <span class="fl">10.0</span>]</span>
<span id="cb4-125"><a href="#cb4-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-126"><a href="#cb4-126" aria-hidden="true" tabindex="-1"></a><span class="co"># Bounds: ([tc_min, m_min, w_min], [tc_max, m_max, w_max])</span></span>
<span id="cb4-127"><a href="#cb4-127" aria-hidden="true" tabindex="-1"></a>bounds_nonlin <span class="op">=</span> (</span>
<span id="cb4-128"><a href="#cb4-128" aria-hidden="true" tabindex="-1"></a>    [max_t, <span class="fl">0.01</span>, <span class="fl">6.0</span>],</span>
<span id="cb4-129"><a href="#cb4-129" aria-hidden="true" tabindex="-1"></a>    [max_t <span class="op">*</span> <span class="fl">2.0</span>, <span class="fl">0.99</span>, <span class="fl">13.0</span>]</span>
<span id="cb4-130"><a href="#cb4-130" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb4-131"><a href="#cb4-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-132"><a href="#cb4-132" aria-hidden="true" tabindex="-1"></a>final_params, fit_result <span class="op">=</span> run_lppl_fit_scipy(t_data, log_p_data, x0_nonlin, bounds_nonlin)</span>
<span id="cb4-133"><a href="#cb4-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-134"><a href="#cb4-134" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Nihai Parametreler:&quot;</span>)</span>
<span id="cb4-135"><a href="#cb4-135" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> key, value <span class="kw">in</span> final_params.items():</span>
<span id="cb4-136"><a href="#cb4-136" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;</span><span class="sc">{</span>key<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>value<span class="sc">:.6f}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<pre class="text"><code>`ftol` termination condition is satisfied.
Function evaluations 12, initial cost 2.7183e+00, final cost 1.9182e+00, first-order optimality 9.62e-05.

Optimizasyon Sonuçları:
`ftol` termination condition is satisfied.
Başarılı: True
Maliyet (Kalanların Kareler Toplamı / 2): 1.9182

Nihai Parametreler:
tc: 2555.000000
m: 0.742213
w: 7.930258
A: 5.586859
B: -0.003674
C1: 0.000229
C2: -0.000370
C_amplitude: 0.118326
phi_phase: -1.017346</code></pre>
<p>Bir krizin karakteristik imzası <span
class="math inline">\(B&lt;0\)</span>, <span
class="math inline">\(0&lt;m&lt;1\)</span>, <span
class="math inline">\(6&lt;\omega&lt;13\)</span> değerleridir, ve bu
değerleri üstteki sonuçta görüyoruz.</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Parametre</th>
<th style="text-align: left;">Değer</th>
<th style="text-align: left;">LPPL Teorisiyle Uyum</th>
<th style="text-align: left;">Analiz</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Maliyet (Cost)</strong></td>
<td style="text-align: left;"><strong>1.9182</strong></td>
<td style="text-align: left;">Mükemmel</td>
<td style="text-align: left;">Önceki 103.34 olan maliyetin bu kadar
düşmesi, modelin veriye çok iyi oturduğunu gösterir.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong><code>tc</code> (Kritik
An)</strong></td>
<td style="text-align: left;"><strong>2555.000000</strong></td>
<td style="text-align: left;">Mantıksal Sınırda</td>
<td style="text-align: left;">Model, çökeceği tahmin edilen kritik anı
(zaman serinizin başlangıcından itibaren 2555. gün) buldu. SciPy’daki
sınırlandırma (<code>max_t</code>) muhtemelen <code>tc</code>’yi bu
değere itmiştir. Gerçek dünyadaki 1929 Çöküşü, bu dönemin hemen
sonrasına denk gelir.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong><code>m</code></strong></td>
<td style="text-align: left;"><strong>0.742213</strong></td>
<td style="text-align: left;"><strong>Uyumlu (<span
class="math inline">\(0.01 &lt; m &lt; 0.99\)</span>)</strong></td>
<td style="text-align: left;">Süper-üstel büyüme hızı. Beklenen aralıkta
ve balon dinamiği için sağlam bir gösterge.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong><code>w</code></strong></td>
<td style="text-align: left;"><strong>7.930258</strong></td>
<td style="text-align: left;"><strong>Uyumlu (<span
class="math inline">\(6 &lt; w &lt; 13\)</span>)</strong></td>
<td style="text-align: left;">Log-periyodik salınım frekansı. Beklenen
aralıkta olup, piyasa katılımcıları arasındaki artan taklitçiliğin
(mimicry) bir göstergesidir.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong><code>B</code></strong></td>
<td style="text-align: left;"><strong>-0.003674</strong></td>
<td style="text-align: left;"><strong>Teoriyle Uyumlu (<span
class="math inline">\(B &lt; 0\)</span>)</strong></td>
<td style="text-align: left;">En kritik parametre. Negatif olması,
modelin yukarı yönlü bir balon (hızlanan büyüme ve ardından çöküş)
yakaladığı anlamına gelir. Bu, 1929 krizini tahmin eden bir
sinyaldir.</td>
</tr>
<tr class="even">
<td
style="text-align: left;"><strong><code>C_amplitude</code></strong></td>
<td style="text-align: left;"><strong>0.118326</strong></td>
<td style="text-align: left;">Uyumlu</td>
<td style="text-align: left;">Salınım genliği. Pozitif ve anlamlı bir
salınım bileşeninin varlığını gösterir.</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lppl_model(t, tc, m, w, A, B, C1, C2):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Kritik An (tc) ve diğer parametreler kullanılarak log-fiyatı hesaplar.&quot;&quot;&quot;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> tc <span class="op">-</span> t</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># dt &lt;= 0 (t &gt;= tc) olduğunda log ve üs alma hatalarını önler</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    dt[dt <span class="op">&lt;=</span> <span class="dv">0</span>] <span class="op">=</span> <span class="fl">1e-9</span> </span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ln(p(t)) = A + B*(tc-t)^m + (tc-t)^m * (C1*cos(w*ln(tc-t)) + C2*sin(w*ln(tc-t)))</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    oscillatory_term <span class="op">=</span> dt<span class="op">**</span>m <span class="op">*</span> (C1 <span class="op">*</span> np.cos(w <span class="op">*</span> np.log(dt)) <span class="op">+</span> C2 <span class="op">*</span> np.sin(w <span class="op">*</span> np.log(dt)))</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    log_p <span class="op">=</span> A <span class="op">+</span> B <span class="op">*</span> dt<span class="op">**</span>m <span class="op">+</span> oscillatory_term</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> log_p</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="kw">del</span> final_params[<span class="st">&#39;C_amplitude&#39;</span>]</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="kw">del</span> final_params[<span class="st">&#39;phi_phase&#39;</span>]</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>log_p_fit <span class="op">=</span> lppl_model(t_data, <span class="op">**</span>final_params)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>plt.plot(t_data, log_p_data, label<span class="op">=</span><span class="st">&#39;DJIA Log Fiyat (Gerçek Veri)&#39;</span>, color<span class="op">=</span><span class="st">&#39;blue&#39;</span>, alpha<span class="op">=</span><span class="fl">0.6</span>)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>plt.plot(t_data, log_p_fit, label<span class="op">=</span><span class="st">&#39;LPPL Uyum Eğrisi&#39;</span>, color<span class="op">=</span><span class="st">&#39;red&#39;</span>, linestyle<span class="op">=</span><span class="st">&#39;--&#39;</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Kritik An (tc) çizgisini çizme</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>plt.axvline(x<span class="op">=</span>final_params[<span class="st">&#39;tc&#39;</span>], color<span class="op">=</span><span class="st">&#39;black&#39;</span>, linestyle<span class="op">=</span><span class="st">&#39;:&#39;</span>, linewidth<span class="op">=</span><span class="dv">2</span>, </span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>            label<span class="op">=</span><span class="ss">f&#39;Kritik An Tahmini (tc=</span><span class="sc">{</span>final_params[<span class="st">&quot;tc&quot;</span>]<span class="sc">:.0f}</span><span class="ss"> Gün)&#39;</span>)</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&#39;DJIA 1929 Krizi Balon Dönemi LPPL Uyum Grafiği&#39;</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="ss">f&#39;Gün Sayısı (Başlangıç: </span><span class="sc">{</span>t_index[<span class="dv">0</span>]<span class="sc">.</span>strftime(<span class="st">&quot;%Y-%m-</span><span class="sc">%d</span><span class="st">&quot;</span>)<span class="sc">}</span><span class="ss">)&#39;</span>, fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Log(Adj. Kapanış Fiyatı)&#39;</span>, fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, linestyle<span class="op">=</span><span class="st">&#39;--&#39;</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Grafiği kritik anı gösterecek şekilde ayarla</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>plt.xlim(t_data.<span class="bu">min</span>(), final_params[<span class="st">&#39;tc&#39;</span>] <span class="op">*</span> <span class="fl">1.01</span>)</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_130_bbl_02.jpg&#39;</span>)</span></code></pre></div>
<p><img src="tser_130_bbl_02.jpg" /></p>
<p>Kaynaklar</p>
<p>[1] Sornette, <em>Why Stock Markets Crash</em></p>
<p>[2] <a href="https://www.youtube.com/watch?v=C_eFjLZqXt8">Sornette,
How we can predict the next financial crisis</a></p>
<p>[3] Long, Estimates of World GDP, One Million B.C. - Present</p>
<p>[4] Sornette, Finite-time singularity in the dynamics of the world
population, economic and financial indices</p>
<p>[5] Geraskin, Everything You Always Wanted to Know about Log Periodic
Power Laws for Bubble Modelling but Were Afraid to Ask</p>
<p>[6] Bayramlı, Diferansiyel Denklemler, Matematiksel Modelleme</p>
<p>[7] Bayramlı, Gayrı Lineer Dinamik ve Kaos, Ders 1</p>
<p>[8] Bayramlı, Diferansiyel Denklemler, Ders 5</p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
