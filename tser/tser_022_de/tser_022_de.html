<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Değişim Noktası Analizi, CUSUM, Chow Test</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="değişim-noktası-analizi-cusum-chow-test">Değişim Noktası
Analizi, CUSUM, Chow Test</h1>
<p>Değişim noktası zaman serisinin bir nokta öncesi ve sonrasında farklı
karakterde olmasıdır. Bu noktaları bulmak için basit bir yaklaşım
herhangi bir nokta öncesi ve sonrası zaman serisi parçalarını almak, ve
önceki parçada lineer regresyon, yapıp katsayıları alıp gürültünün
normalliğini kontrol etmektir. Eğer normallik varsa, katsayılar alınıp
ikinci parçada kullanılır, gürültü yine normalse kopuş yoktur (aynı
zaman serisi). Birincide gürültü normalliği yoksa kopuş yine yoktur, ilk
parça doğru tanımlı değil. Sezonşallık benzer şekilde kontrol
edilebilir, vs.</p>
<p>Bu alanda pek cok yaklasim var. Pür istatistik bazlı bir Poisson
tekniğini de [8]’de görmüştük.</p>
<h3 id="chow-testi-ve-yapısal-kopma-structural-break">Chow Testi ve
Yapısal Kopma (Structural Break)</h3>
<p>Diyelim ki elimizdeki bir modelin bir verinin iki parçasında değişik
sonuçlar verip vermeyeceğini merak ediyoruz. Önceki regresyon örneğinde
bunu tek kesi ve değişken üzerinden gördük. Peki ya model daha çetrefil
olsaydı?</p>
<p>Bu durumda Chow Testini kullanabiliriz. Bu test daha önce gördüğümüz
F-testini verinin iki parçası üzerinde işletir, modelin her iki parça
üzerindeki SSE değeri, yani hata karelerinin toplamı (sum of squared
errors) üzerinden bir istatistik yaratır. Sıfır hipotezi katsayıların
iki bölgede aynı olduğudur, ve bunun irdelenmesi modelin her iki
bölgedeki varyansına bakılarak yapılır. Tersi yönde kanıt var ise
faraziyeyi reddederiz, ve iki bölgenin (en azından kullandığımız model
açısından) çok farklı olduğu sonucuna varırız.</p>
<p>F-testi için kısıtlı (restricted), ve kısıtlı olmayan (unrestricted)
modeli tanımlamak gerekiyor. Regresyonun her iki veri bölgesinde değişik
değerlere sahip olmasına izin verirsek (yani regresyonu ayrı ayrı iki
parça üzerinde işletirsek) bu kısıtlı olmayan demektir, eğer tüm veri
üzerinde aynı regresyonu kullanıyorsak o zaman katsayılar değişik
bölgelere göre değişemezler, bu da kısıtlı model olacaktır. Getirdiğimiz
kısıtlama sayısı regresyonun kullandığı değişken sayısına eşittir. Eğer
değişken sayısı <span class="math inline">\(k\)</span> veri nokta sayısı
<span class="math inline">\(n\)</span> işe formül,</p>
<p><span class="math display">\[
F = \frac{SSE_r - (SSE_1 + SSE_2) / k}{(SSE_1 + SSE_2) / (n-2k)}
\]</span></p>
<p>ki <span class="math inline">\(SSE_1,SSE_2\)</span> sırasıyla 1. ve
2. bölgedeki hataların kare toplamıdır, <span
class="math inline">\(SSE_u = SSE_1 + SSE_2\)</span>, yani bölgelerin
ayrı ayrı hesaplanan hata kare toplamının toplamı kısıtlı olmayan SSE’yi
verir. <span class="math inline">\(F\)</span> rasgele değişkeni <span
class="math inline">\(F_{k,n-2k}\)</span> serbestlik derecesine sahip
bir F dağılımına sahiptir. Kısıtlama <span
class="math inline">\(k\)</span> çünkü ikinci bölgede <span
class="math inline">\(k\)</span> kadar değişkenin değişik olmasına izin
vermedik.</p>
<p>Örnek</p>
<p>Kullanacağımız veri Amerika’daki benzin tüketimi ile alakalı, bu veri
içinde aslında iki farklı periyotu kapsıyor [8, sf. 209]. 1973’e kadar
dünyada petrol boldu ve dünya petrol fiyatları ya stabil ya da düşüş
trendinde idi. Fakat 1973’teki ambargo piyasada büyük değişimlere sebep
oldu, kıtlık başladı, fiyatlar yükseldi.</p>
<p>Alttaki figürde benzin fiyatı (PG) ile kişi başına tüketim (per
capita consumption) grafikli, ve görüldüğü gibi 1973 öncesi piyasa
oldukça stabil gidiyor (kırmızı noktalar) ama sonrasında işler karışıyor
(mavi noktalar).</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>dfg <span class="op">=</span> pd.read_csv(<span class="st">&#39;gasoline.csv&#39;</span>,sep<span class="op">=</span><span class="st">&#39;</span><span class="ch">\\</span><span class="st">s+&#39;</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>plt.plot(dfg[dfg[<span class="st">&#39;Year&#39;</span>]<span class="op">&lt;=</span><span class="dv">1973</span>].G,dfg[dfg[<span class="st">&#39;Year&#39;</span>]<span class="op">&lt;=</span><span class="dv">1973</span>].Pg,<span class="st">&#39;r.&#39;</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;G&#39;</span>)<span class="op">;</span> plt.ylabel(<span class="st">&#39;PG&#39;</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>plt.plot(dfg[dfg[<span class="st">&#39;Year&#39;</span>]<span class="op">&gt;</span><span class="dv">1973</span>].G,dfg[dfg[<span class="st">&#39;Year&#39;</span>]<span class="op">&gt;</span><span class="dv">1973</span>].Pg,<span class="st">&#39;b.&#39;</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;stat_tests2_02.png&#39;</span>)</span></code></pre></div>
<p><img src="stat_tests2_02.png" /></p>
<p>1973 ve 1980’deki fiyat zıplamaları net bir şekilde görülüyor, ayrıca
tüketimde de daha fazla değişkenlik / varyans mevcut. Eğer bu veriye bir
model uydurmak isteseydik, aynı modelin iki ayrı bölgeye her değişken
için aynı mükemmeliyette uymasını beklemek hayalcilik olurdu.</p>
<p>Test edeceğimiz model şöyle,</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> <span class="st">&#39;Ln_G_Pop ~ Ln_Income_Pop + Ln_Pg + Ln_Pnc + Ln_Puc&#39;</span></span></code></pre></div>
<p>Bu modeldeki fiyatlar <code>G,Pnc,Puc</code>, sırasıyla benzin, yeni
araba ve kullanılmış araba fiyatları. <code>Ln_G_Pop</code>,
<code>G</code> ile <code>Pop</code> (nüfus) bölünmesiyle elde ediliyor,
ve <code>Ln</code> notasyonumuz log işlemi demek. <code>Income</code>
ülke geliri, o da <code>Pop</code> ile bölünüyor ve log’u alınıyor.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>dfg[<span class="st">&#39;Ln_G_Pop&#39;</span>] <span class="op">=</span> np.log(dfg.G<span class="op">/</span>dfg.Pop)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>dfg[<span class="st">&#39;Ln_Income_Pop&#39;</span>] <span class="op">=</span> np.log(dfg.Y<span class="op">/</span>dfg.Pop)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>dfg[<span class="st">&#39;Ln_Pg&#39;</span>] <span class="op">=</span> np.log(dfg.Pg)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>dfg[<span class="st">&#39;Ln_Pnc&#39;</span>] <span class="op">=</span> np.log(dfg.Pnc)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>dfg[<span class="st">&#39;Ln_Puc&#39;</span>] <span class="op">=</span> np.log(dfg.Puc)</span></code></pre></div>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>plt.plot(dfg[<span class="st">&#39;Year&#39;</span>],dfg[<span class="st">&#39;Ln_G_Pop&#39;</span>])</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Sene&#39;</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Ln(G/Nufus)&#39;</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&#39;Amerika Benzin Tuketimi&#39;</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;stat_tests2_03.png&#39;</span>)</span></code></pre></div>
<p><img src="stat_tests2_03.png" /></p>
<p>Modeli tüm veri üzerinde işletirsek,</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> statsmodels.formula.api <span class="im">import</span> ols</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>res_r <span class="op">=</span> ols(model, data<span class="op">=</span>dfg).fit()</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (res_r.summary())</span></code></pre></div>
<pre class="text"><code>                            OLS Regression Results                            
==============================================================================
Dep. Variable:               Ln_G_Pop   R-squared:                       0.969
Model:                            OLS   Adj. R-squared:                  0.965
Method:                 Least Squares   F-statistic:                     243.2
Date:                Mon, 14 Jul 2025   Prob (F-statistic):           6.25e-23
Time:                        13:58:02   Log-Likelihood:                 79.913
No. Observations:                  36   AIC:                            -149.8
Df Residuals:                      31   BIC:                            -141.9
Df Model:                           4                                         
Covariance Type:            nonrobust                                         
=================================================================================
                    coef    std err          t      P&gt;|t|      [0.025      0.975]
---------------------------------------------------------------------------------
Intercept        -7.7892      0.359    -21.679      0.000      -8.522      -7.056
Ln_Income_Pop     2.1175      0.099     21.443      0.000       1.916       2.319
Ln_Pg            -0.0979      0.028     -3.459      0.002      -0.156      -0.040
Ln_Pnc            0.1224      0.112      1.092      0.283      -0.106       0.351
Ln_Puc           -0.1022      0.069     -1.475      0.150      -0.243       0.039
==============================================================================
Omnibus:                        2.323   Durbin-Watson:                   0.891
Prob(Omnibus):                  0.313   Jarque-Bera (JB):                1.281
Skew:                           0.049   Prob(JB):                        0.527
Kurtosis:                       2.081   Cond. No.                         319.
==============================================================================

Notes:
[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.</code></pre>
<p>Şimdi her iki parça üzerinde ayrı ayrı regresyon işletelim, ki
parçaları 1973 değeri üzerinden oluşturacağız, bu bildiğimiz bir değer
ve bir anlamda bu değerin gerçekten bir kopuş noktası olup olmadığını
test etmek istiyoruz, ve ardından Chow testi için gerekli değerleri
hesaplıyoruz,</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>dfg_x <span class="op">=</span> dfg[[<span class="st">&#39;Ln_Income_Pop&#39;</span>,<span class="st">&#39;Ln_Pg&#39;</span>,<span class="st">&#39;Ln_Pnc&#39;</span>,<span class="st">&#39;Ln_Puc&#39;</span>]]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>dfg_y <span class="op">=</span> dfg[<span class="st">&#39;Ln_G_Pop&#39;</span>]</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="bu">len</span>(dfg[dfg.Year<span class="op">&lt;=</span><span class="dv">1973</span>]), <span class="bu">len</span>(dfg[dfg.Year<span class="op">&gt;</span><span class="dv">1973</span>]))</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>res1 <span class="op">=</span> ols(model, data<span class="op">=</span>dfg[dfg.Year<span class="op">&lt;</span><span class="dv">1974</span>]).fit()</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>res2 <span class="op">=</span> ols(model, data<span class="op">=</span>dfg[dfg.Year<span class="op">&gt;=</span><span class="dv">1974</span>]).fit()</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>S_1 <span class="op">=</span> np.<span class="bu">sum</span>(res1.resid<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>S_2 <span class="op">=</span> np.<span class="bu">sum</span>(res2.resid<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>S_r <span class="op">=</span> np.<span class="bu">sum</span>(res_r.resid<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;S 1 =&#39;</span>, S_1)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;S 2 =&#39;</span>, S_2)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;S_r =&#39;</span>, S_r)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;N =&#39;</span>, <span class="bu">len</span>(dfg))</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> dfg_x.shape[<span class="dv">1</span>]</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>tmp1 <span class="op">=</span> (S_r<span class="op">-</span>(S_1<span class="op">+</span>S_2))<span class="op">/</span>k</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>tmp2 <span class="op">=</span> (S_1<span class="op">+</span>S_2)<span class="op">/</span>(<span class="bu">len</span>(dfg)<span class="op">-</span><span class="dv">2</span><span class="op">*</span>k<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> tmp1<span class="op">/</span>tmp2</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;F =&#39;</span>, F)</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.stats <span class="im">as</span> st</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> st.f(k,<span class="bu">len</span>(dfg)<span class="op">-</span><span class="dv">2</span><span class="op">*</span>k<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;p degeri =&#39;</span>, <span class="dv">1</span><span class="op">-</span>f.cdf(F))</span></code></pre></div>
<pre class="text"><code>14 22
S 1 = 0.0025673399475329207
S 2 = 0.00491175470665726
S_r = 0.024873436261972474
N = 36
F = 15.69866558471087
p degeri = 9.40286063455531e-07</code></pre>
<p>Hesaplanan p değeri çok küçük, ve 0.05’ten daha az, demek ki hipotez
reddedildi. Demek ki hakikaten 1973’te bir değişim olmuş!</p>
<p>Paket</p>
<p><code>pip install chowtest</code> ile kurulabilecek bir paket var
[10], bu paketin kullanımı,</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> chow_test, pandas <span class="im">as</span> pd</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame({<span class="st">&#39;x&#39;</span>: [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>, <span class="dv">10</span>,</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>                         <span class="dv">11</span>, <span class="dv">12</span>, <span class="dv">12</span>, <span class="dv">13</span>, <span class="dv">14</span>, <span class="dv">15</span>, <span class="dv">15</span>, <span class="dv">16</span>, <span class="dv">17</span>, <span class="dv">18</span>, <span class="dv">18</span>, <span class="dv">19</span>, <span class="dv">20</span>, <span class="dv">20</span>],</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>                   <span class="st">&#39;y&#39;</span>: [<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">10</span>, <span class="dv">13</span>, <span class="dv">15</span>, <span class="dv">17</span>, <span class="dv">14</span>, <span class="dv">20</span>, <span class="dv">23</span>, <span class="dv">25</span>, <span class="dv">27</span>, <span class="dv">30</span>, <span class="dv">30</span>, <span class="dv">31</span>,</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>                         <span class="dv">33</span>, <span class="dv">32</span>, <span class="dv">32</span>, <span class="dv">30</span>, <span class="dv">32</span>, <span class="dv">34</span>, <span class="dv">34</span>, <span class="dv">37</span>, <span class="dv">35</span>, <span class="dv">34</span>, <span class="dv">36</span>, <span class="dv">34</span>, <span class="dv">37</span>, <span class="dv">38</span>, <span class="dv">36</span>]})</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (df)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> chow_test.chow_test(df[<span class="st">&#39;y&#39;</span>], df[<span class="st">&#39;x&#39;</span>],<span class="dv">15</span>,<span class="dv">16</span>,<span class="fl">.05</span>)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (df.iloc[<span class="dv">15</span>])</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (res)</span></code></pre></div>
<pre class="text"><code>     x   y
0    1   3
1    1   5
2    2   6
3    3  10
4    4  13
5    4  15
6    5  17
7    5  14
8    6  20
9    7  23
10   7  25
11   8  27
12   8  30
13   9  30
14  10  31
15  10  33
16  11  32
17  12  32
18  12  30
19  13  32
20  14  34
21  15  34
22  15  37
23  16  35
24  17  34
25  18  36
26  18  34
27  19  37
28  20  38
29  20  36
Reject the null hypothesis of equality of regression coefficients in the two periods.
Chow Statistic: 37.96716203561837, P_value: 2.6531641550420204e-08
x    10
y    33
Name: 15, dtype: int64
(37.96716203561837, 2.6531641550420204e-08)</code></pre>
<p>Değişim Noktasını Bulmak</p>
<p>Eğer değişim anı 1973’ü bilmeseydik onu nasıl ortaya çıkartırdık? Bir
yaklaşıma göre [5] tüm seneleri teker teker deneyerek Chow testini ardı
ardına işletebilirdik ve elde edilen en büyük F değeri bize değişim
noktasını verirdi. Bu kodu işletirsek,</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> statsmodels.regression.linear_model <span class="im">import</span> OLS</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy.linalg <span class="im">import</span> pinv</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> supf(y, x, p):</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> y.shape[<span class="dv">0</span>]</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">range</span> <span class="op">=</span> np.floor(np.array([N <span class="op">*</span> p, N <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> p)]))</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">range</span> <span class="op">=</span> np.arange(<span class="bu">range</span>[<span class="dv">0</span>], <span class="bu">range</span>[<span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>, dtype<span class="op">=</span>np.int32)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> x <span class="op">-</span> np.mean(x)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> y <span class="op">-</span> np.mean(y)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    e <span class="op">=</span> OLS(y,x).fit().resid</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    S_r <span class="op">=</span> np.<span class="bu">sum</span>(e<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> x.shape[<span class="dv">1</span>]</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span> (<span class="st">&#39;N =&#39;</span>,N)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span> (<span class="st">&#39;k =&#39;</span>,k)</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span> (<span class="st">&#39;N-k =&#39;</span>,N<span class="op">-</span>k)</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    F_stat <span class="op">=</span> np.zeros(N)</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>:</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        X1 <span class="op">=</span> x[:t]</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>        X2 <span class="op">=</span> x[t:]</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>        e[:t] <span class="op">=</span> OLS(y[:t],X1).fit().resid</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>        e[t:] <span class="op">=</span> OLS(y[t:],X2).fit().resid</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>        R2_u <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> e.dot(e) <span class="op">/</span> y.dot(y)</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>        S_u <span class="op">=</span> np.<span class="bu">sum</span>(e<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>        F_stat[t] <span class="op">=</span> ((S_r <span class="op">-</span> S_u) <span class="op">/</span> k) <span class="op">/</span> (( S_u) <span class="op">/</span> (N<span class="op">-</span><span class="dv">2</span><span class="op">*</span>k))</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> F_stat.argmax(),F_stat.<span class="bu">max</span>()</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>idx,val <span class="op">=</span> supf(dfg_y, dfg_x, p)</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (idx,val)</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;Sene&#39;</span>, dfg.Year[idx])</span></code></pre></div>
<pre class="text"><code>N = 36
k = 4
N-k = 32
13 257.74906757993983
Sene 1973</code></pre>
<p>Not: Sene araması için baştan ve sonda bir kısım veri atlandı, ki her
iki parça için elde yeterli veri olabilsin.</p>
<p>Not: <code>lmfit</code> hakkında bazı tavsiyeler için bkz [12]
yazısı.</p>
<p>Sonucu 1974 olarak bulduk. Fena değil!</p>
<p>Not: Fakat şu gözlemi de eklemek gerekiyor.. p değerini nihai bir
karar verici olarak kullanmak her zaman ise yaramayabilir. Dikkat
edersek örneklem büyüklüğü p değeri hesabında önemli bir yer tutuyor, o
sebeple veri setlerinin büyüdüğü bu günlerde p değeri her zaman çok
küçük değerler gösterebilir. Her noktada F değeri hesaplayıp en büyüğünü
bulmak ise yarar fakat tek bir noktaya bakıp “bu nokta ayraç olarak
istatistiki öneme sahip mi?’’ sorusu her örneklem büyüklüğünde
işlemeyebilir.</p>
<h3 id="cusum">Cusum</h3>
<p>Cusum yaklaşımı [5] makalesinde araştırılmış, özyineli (recursive),
yani teker teker her yeni veri noktası üzerinde işlem yapan ve kopuşları
o anda yakalamaya uğraşan bir yaklaşımdır. Özyineli regresyon konusunu
[4]’te gördük. Bir regresyon hipotezi ile başlayıp her veri noktası
geldiğinde regresyonu güncellemek, iyileştirmek mümkündür. Cusum bunu
yapar aynı anda modelin gürültüsünü kontrol eder ve zaman serisinin bazı
hipotezlere uyup uymadığını her defasında kontrol eder, uyum yoksa kopuş
yakalanmış demektir.</p>
<p>Faraziye şudur, normal kopuksuz bir zaman serisi her anda <span
class="math inline">\(\beta_t\)</span> vektöründe katsayılara sahipse,
modelden geri kalan gürültünün ortalaması (mean) sıfır olacaktır, ve her
anda <span class="math inline">\(\sigma_t\)</span> varyasyonu için,</p>
<p><span class="math display">\[
\beta_1 = \beta_2 = ... = \beta_T = \beta
\]</span></p>
<p><span class="math display">\[
\sigma_1^2 = \sigma_2^2 = ... = \sigma_T^2 = \sigma
\]</span></p>
<p>Yani her anda katsayılar ve gürültünün varyasyonu sabit olmalı. Cusum
<span class="math inline">\(\beta_t\)</span>’deki değişimi yakalamak
için ayarlanmıştır, bunu yapmak için gürültü ortalamasının sıfırdan
sapmasını yakalamaya uğraşır. Detaylar için makaleye danışılabilir.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy.linalg <span class="im">import</span> inv</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> recursive_cusum(y, X):</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    y, X <span class="op">=</span> np.asarray(y), np.asarray(X)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    n, k <span class="op">=</span> X.shape</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    w <span class="op">=</span> np.zeros(n)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    S <span class="op">=</span> np.zeros((k, k))</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    beta <span class="op">=</span> np.zeros((k,))</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(k, n):</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        X_t <span class="op">=</span> X[:t]</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>        y_t <span class="op">=</span> y[:t]</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>        S <span class="op">=</span> X_t.T <span class="op">@</span> X_t</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>        beta_t <span class="op">=</span> inv(S) <span class="op">@</span> X_t.T <span class="op">@</span> y_t</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>        x_new <span class="op">=</span> X[t]</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>        y_pred <span class="op">=</span> x_new <span class="op">@</span> beta_t</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>        denom <span class="op">=</span> np.sqrt(<span class="dv">1</span> <span class="op">+</span> x_new <span class="op">@</span> inv(S) <span class="op">@</span> x_new)</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>        w[t] <span class="op">=</span> (y[t] <span class="op">-</span> y_pred) <span class="op">/</span> denom</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># drop initial k zeros</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    w <span class="op">=</span> w[k:]</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>    sigma_hat <span class="op">=</span> np.std(w, ddof<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>    Wt <span class="op">=</span> np.cumsum(w <span class="op">/</span> sigma_hat)</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Wt, w, sigma_hat</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_cusum(Wt, k, alpha<span class="op">=</span><span class="fl">0.05</span>):</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> <span class="bu">len</span>(Wt) <span class="op">+</span> k</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> np.arange(k<span class="op">+</span><span class="dv">1</span>, T<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>    boundary <span class="op">=</span> <span class="fl">0.948</span> <span class="op">*</span> np.sqrt(T <span class="op">-</span> k)  <span class="co"># for alpha=0.05</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>    plt.plot(t, Wt, label<span class="op">=</span><span class="st">&quot;CUSUM of Recursive Residuals&quot;</span>)</span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>    plt.axhline(boundary, color<span class="op">=</span><span class="st">&#39;r&#39;</span>, linestyle<span class="op">=</span><span class="st">&#39;--&#39;</span>, label<span class="op">=</span><span class="st">&#39;5% bounds&#39;</span>)</span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>    plt.axhline(<span class="op">-</span>boundary, color<span class="op">=</span><span class="st">&#39;r&#39;</span>, linestyle<span class="op">=</span><span class="st">&#39;--&#39;</span>)</span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>    plt.axhline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">&#39;k&#39;</span>, linestyle<span class="op">=</span><span class="st">&#39;:&#39;</span>)</span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">&#39;Observation index&#39;</span>)</span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">&#39;CUSUM statistic&#39;</span>)</span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="st">&#39;CUSUM Test (Brown–Durbin–Evans, 1975)&#39;</span>)</span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>    plt.legend()</span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a>    plt.savefig(<span class="st">&#39;tser_022_de_01.jpg&#39;</span>)</span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> dfg[<span class="st">&#39;Ln_G_Pop&#39;</span>].values</span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> dfg[[<span class="st">&#39;Ln_Income_Pop&#39;</span>,<span class="st">&#39;Ln_Pg&#39;</span>,<span class="st">&#39;Ln_Pnc&#39;</span>,<span class="st">&#39;Ln_Puc&#39;</span>]].values</span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a>Wt, w, sigma_hat <span class="op">=</span> recursive_cusum(y, X)</span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a>plot_cusum(Wt, k<span class="op">=</span>X.shape[<span class="dv">1</span>])</span></code></pre></div>
<p><img src="tser_022_de_01.jpg" /></p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (dfg.iloc[<span class="dv">14</span>].Year)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (dfg.iloc[<span class="dv">17</span>].Year)</span></code></pre></div>
<pre class="text"><code>1974.0
1977.0</code></pre>
<h3 id="page-hinkley-cusum">Page-Hinkley Cusum</h3>
<p>Bu metot üstte tarif edilenden biraz farklı, regresyon veya artıklara
bakılmıyor, sadece <span class="math inline">\(x_t = \mu_t +
\epsilon_t\)</span>, <span class="math inline">\(\epsilon_t \sim
N(0,\sigma^2)\)</span> farz ediliyor ve <span
class="math inline">\(\mu_t\)</span> sapmaları tespil edilmeye
uğraşılıyor. Alttaki kod [2]’yi temel alır.</p>
<p><a href="phtcusum.py">phtcusum.py</a></p>
<p>Ornek verideki zaman serisinde bariz kopuşlar var, yaklaşık indeks
100 anında, sonra 200 anında. PHT cusum ile bunları yakalayabiliriz,
geri döndürülen <code>tai</code>, <code>taf</code> birer vektördür, ve
sırasıyla kopuş noktasının başlangıç ve bitiş indisini verirler.
Yukarıda ilk kopuşun indisini görüyoruz.</p>
<p><img src="tser_022_de_06.png" /></p>
<p>Sağa dönük yeşil ok başlangıç, sola dönük bitiş demek. En tepede
ikisi birbirinin üstüne bindi çünkü orada bir parça bitip diğeri
başlıyor, ama olanlar gözüküyor herhalde. Kırmızı noktalar ise alarm
anları olarak tanımlanmış.</p>
<p>Kaynaklar</p>
<p>[1] Brownlee, <em>Introduction to Time Series Modeling with
Python</em></p>
<p>[2] Github, <a
href="https://raw.githubusercontent.com/BMClab/BMC/master/functions/detect_cusum.py">https://raw.githubusercontent.com/BMClab/BMC/master/functions/detect_cusum.py</a></p>
<p>[3] MIT, <em>OCW Single Variable Calculus, unit 5, Session 99</em>,
<a
href="https://ocw.mit.edu/courses/mathematics/18-01sc-single-variable-calculus-fall-2010/index.htm">https://ocw.mit.edu/courses/mathematics/18-01sc-single-variable-calculus-fall-2010/index.htm</a></p>
<p>[4] Bayramlı, <em>Hesapsal Bilim, Özyineli En Az Kareler</em></p>
<p>[5] Brown, et al, <em>Techniques for Testing the Constancy of
Regression Relationships over Time</em></p>
<p>[6] Bayramlı, <em>Zaman Serileri, Sinüssel Regresyon (Sinusoidal
Regression)</em></p>
<p>[7] Bayramlı, <em>Istatistik, Testlere devam</em></p>
<p>[8] Bayramlı, <em>Istatistik, Değişim Noktası Analizi</em></p>
<p>[9] Woroniuk, <em>Chow test</em>, <a
href="https://github.com/David-Woroniuk/chowtest">https://github.com/David-Woroniuk/chowtest</a></p>
<p>[10] Bobbitt, <em>How to Perform a Chow Test in Python</em>, <a
href="https://www.statology.org/chow-test-in-python/">https://www.statology.org/chow-test-in-python/</a></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
