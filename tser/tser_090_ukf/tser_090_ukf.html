<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Sigma Bazlı Kalman Filtreleri (Unscented Kalman Filters -UKF-)</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1
id="sigma-bazlı-kalman-filtreleri-unscented-kalman-filters--ukf-">Sigma
Bazlı Kalman Filtreleri (Unscented Kalman Filters -UKF-)</h1>
<p><em>Kalman Filtereleri</em> yazısında dış ölçümlerin bir iç konumu
anlamak için nasıl kullanıldığını gördük, fakat KF’ler gayrı lineerliği
iyi idare edemiyorlar. Mesela havaya atılan bir topu gürültülü
ölçümlerden takip ettiğimizi düşünelim, top çıkıp inecek, değişim (state
transition) / hareket parabol şeklinde (parabol gayrı lineer). Bu basit
hareket bile KF ile takip edilemiyor. Gayri lineerlik ölçüm sırasında da
ortaya çıkabilir, mesela bir objenin uzaklığını radardan alıyorsak ölçüm
bize yerden yükseklik ve eğim olarak gelebilir, bu ölçümleri direk
mesafeye çevirmek için karelerin toplamının karekökü gerekir ve bu yine
bir gayrı lineerliği probleme sokmuş olur.</p>
<p>Çözüm için farklı yaklaşımlar var; genişletilmiş KF (EKF) lokal bir
nokta etrafında Taylor açılımı kullanarak gayrı lineerliği yakalamaya
uğraşıyor. Fakat hem performans hem doğruluk açısından daha verimli bir
yaklaşım sigma bazlı Kalman filtreleri (UKF).</p>
<p>UKF’in yaptığı nedir? Normal KF’in işleyişi sırasında geçiş ya da
gözlem fonsiyonlarının içinden Gaussian’lar geçirdiği söylenebilir.
Gaussian’lar (yani onların <span
class="math inline">\(\mu,\sigma\)</span> parametreleri) lineerlige tabi
olduklarında bozulmazlar, iki Guassian toplamı yine bir Gaussian’dır,
vs. Fakat gayrı lineer fonksiyonlar işleri bozar.</p>
<p>UKF’in püf noktası o an eldeki Gaussian’ın standart sapma <span
class="math inline">\(\sigma\)</span>’sına oranlı seçilmiş birkaç
noktanın değişim yapan fonksiyona verilmesi; normal KF’i o zaman sadece
merkez nokta <span class="math inline">\(\mu\)</span>’yu işlemden
geçiriyor olarak görebiliriz, fakat UKF ile seçenekleri arttırıyoruz
[1]. Bu noktalar seçildiğinde onları değişim fonksiyonuna tabi
tutuyoruz, böylece ele geçen sonuç Gaussian’ı daha gerçeğe yakın oluyor.
UKF yaklaşımında ayrıca seçilen her nokta için bir ağırlık gerekiyor, ve
bu ağırlıklar da önceden kararlaştırılır, bazı uygulamalarda merkez
noktaya daha fazla ağırlık vermek istenebilir, diğerleri dış noktaları
tercih edebilir.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math, util, scipy.linalg <span class="im">as</span> linalg, <span class="bu">filter</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy <span class="im">import</span> eye, zeros, dot, isscalar, outer</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.linalg <span class="im">import</span> inv, cholesky</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy.random <span class="im">import</span> randn</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> norm, multivariate_normal</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>ax<span class="op">=</span>plt.figure().gca()</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">5</span>])</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>P <span class="op">=</span> np.array([[<span class="dv">4</span>, <span class="op">-</span><span class="fl">2.2</span>], [<span class="op">-</span><span class="fl">2.2</span>, <span class="dv">3</span>]])</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>util.plot_covariance_ellipse(x, P, facecolor<span class="op">=</span><span class="st">&#39;b&#39;</span>, alpha<span class="op">=</span><span class="fl">0.6</span>, variance<span class="op">=</span><span class="dv">9</span>,plt<span class="op">=</span>plt)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>sigmas <span class="op">=</span> <span class="bu">filter</span>.MerweScaledSigmaPoints(<span class="dv">2</span>, alpha<span class="op">=</span><span class="fl">.5</span>, beta<span class="op">=</span><span class="fl">2.</span>, kappa<span class="op">=</span><span class="fl">0.</span>)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> sigmas.sigma_points(x<span class="op">=</span>x, P<span class="op">=</span>P)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>plt.scatter(S[:,<span class="dv">0</span>], S[:,<span class="dv">1</span>], c<span class="op">=</span><span class="st">&#39;k&#39;</span>, s<span class="op">=</span><span class="dv">80</span>)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.array([<span class="dv">15</span>, <span class="dv">5</span>])</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>P <span class="op">=</span> np.array([[<span class="dv">3</span>, <span class="fl">1.2</span>],[<span class="fl">1.2</span>, <span class="dv">6</span>]])</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>util.plot_covariance_ellipse(x, P, facecolor<span class="op">=</span><span class="st">&#39;g&#39;</span>, variance<span class="op">=</span><span class="dv">9</span>, alpha<span class="op">=</span><span class="fl">0.3</span>,plt<span class="op">=</span>plt)</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>ax.add_artist(util.arrow(S[<span class="dv">0</span>,<span class="dv">0</span>], S[<span class="dv">0</span>,<span class="dv">1</span>], <span class="dv">11</span>, <span class="fl">4.1</span>, <span class="fl">0.6</span>))</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>ax.add_artist(util.arrow(S[<span class="dv">1</span>,<span class="dv">0</span>], S[<span class="dv">1</span>,<span class="dv">1</span>], <span class="dv">13</span>, <span class="fl">7.7</span>, <span class="fl">0.6</span>))</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>ax.add_artist(util.arrow(S[<span class="dv">2</span>,<span class="dv">0</span>], S[<span class="dv">2</span>,<span class="dv">1</span>], <span class="fl">16.3</span>, <span class="fl">0.93</span>, <span class="fl">0.6</span>))</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>ax.add_artist(util.arrow(S[<span class="dv">3</span>,<span class="dv">0</span>], S[<span class="dv">3</span>,<span class="dv">1</span>], <span class="fl">16.7</span>, <span class="fl">10.8</span>, <span class="fl">0.6</span>))</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>ax.add_artist(util.arrow(S[<span class="dv">4</span>,<span class="dv">0</span>], S[<span class="dv">4</span>,<span class="dv">1</span>], <span class="fl">17.7</span>, <span class="fl">5.6</span>, <span class="fl">0.6</span>))</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>ax.axes.get_xaxis().set_visible(<span class="va">False</span>)</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>ax.axes.get_yaxis().set_visible(<span class="va">False</span>)</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_ukf_02.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_ukf_02.png" /></p>
<p>“Sigma bazlı transform edilmiş’’ (unscented transform) yeni Gaussian
hesabı şöyle olur,</p>
<p><span class="math display">\[ \mu = \sum_i w_i^m y_i \]</span></p>
<p><span class="math display">\[ \Sigma = \sum_i w_i^c
(y_i-\mu)(y_i-\mu)^T \]</span></p>
<p>Dikkat, bu yaptığımız parçacık filtrelerindeki gibi örneklemek, ya da
her değişik hipotezi temsil eden “parçacıklar’’ yaratmak değil, bir
Gaussian’ın hep belli yerlerindeki belli noktalara bakmak. Bu seçim
tamamen <em>deterministik</em>, hiçbir rasgelelik yok. Seçim nasıl
yapılır? Her uygulama için tasarımcı buna karar verir, altta bazı
örnekler görülüyor,</p>
<p><img src="tser_ukf_03.png" /></p>
<p>Fakat endüstri sigmayı ve ağırlıklarını seçmek için 2005’ten itibaren
[2]’deki yöntemi kabul etmiş görünüyor.</p>
<p>Trasform Örneği</p>
<p>Alttaki gibi bir gayrı-lineer fonksiyon</p>
<p><span class="math display">\[
\left\{ \begin{array}{ll}
x = x + y \\
y = 0.1 x^2 + y^2
\end{array} \right.
\]</span></p>
<p>olsun, bu fonksiyona alttaki çok boyutlu Gaussian’dan örneklenmiş
noktaları geçeceğiz,</p>
<p><span class="math display">\[
\mu = \left[\begin{array}{r} 0 \\ 0 \end{array}\right],
\quad
\Sigma = \left[\begin{array}{rr} 32 &amp; 15 \\ 15 &amp; 40
\end{array}\right]
\]</span></p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f_nonlinear_xy(x, y):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array([x <span class="op">+</span> y, <span class="fl">.1</span><span class="op">*</span>x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> y<span class="op">*</span>y])</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>mean <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> np.array([[<span class="dv">32</span>, <span class="dv">15</span>], [<span class="fl">15.</span>, <span class="fl">40.</span>]])</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute linearized mean</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>mean_fx <span class="op">=</span> f_nonlinear_xy(<span class="op">*</span>mean)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co">#generate random points</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>xs, ys <span class="op">=</span> multivariate_normal.rvs(mean<span class="op">=</span>mean, cov<span class="op">=</span>p, size<span class="op">=</span><span class="dv">2000</span>).T</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>util.plot_monte_carlo_mean(xs, ys, f_nonlinear_xy, mean_fx, <span class="st">&#39;Lineerize Edilmis Ortalama&#39;</span>)<span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_ukf_13.png&#39;</span>)</span></code></pre></div>
<pre><code>Ortalamalardaki fark x=-0.471, y=43.237</code></pre>
<p><img src="tser_ukf_13.png" /></p>
<p>Görülüyor ki eğer EKF ile olduğu gibi bir lineerizasyon yapılsa
ortaya çok büyük bir hata çıkacak. Tekrar vurgulamak gerekirse figürde
görülen “lineerize edilmiş ortalama’’ Gaussian <span
class="math inline">\(\mu\)</span>’sunun gayrı lineer fonksiyona
geçilmiş hali, ki EKF bu şekilde işlem yapar, diğeri Gaussian’dan alınan
noktaların gayrı-lineer fonksiyona geçildikten sonra alınan
ortalama.</p>
<p>Fakat sigma bazlı transform kullanırsak,</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy.random <span class="im">import</span> multivariate_normal</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> util</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">#initial mean and covariance</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>mean <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> np.array([[<span class="fl">32.</span>, <span class="dv">15</span>], [<span class="fl">15.</span>, <span class="fl">40.</span>]])</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co"># create sigma points - we will learn about this later</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> <span class="bu">filter</span>.MerweScaledSigmaPoints(n<span class="op">=</span><span class="dv">2</span>, alpha<span class="op">=</span><span class="fl">.3</span>, beta<span class="op">=</span><span class="fl">2.</span>, kappa<span class="op">=</span><span class="fl">.1</span>)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>Wm, Wc <span class="op">=</span> points.weights()</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>sigmas <span class="op">=</span> points.sigma_points(mean, p)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co">### gayri-lineer fonksiyondan gecir</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>sigmas_f <span class="op">=</span> np.empty((<span class="dv">5</span>, <span class="dv">2</span>))</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>):</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    sigmas_f[i] <span class="op">=</span> f_nonlinear_xy(sigmas[i, <span class="dv">0</span>], sigmas[i ,<span class="dv">1</span>])</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="co">### sigma bazli transform ile yeni ortalama ve kovaryansi hesapla</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>ukf_mean, ukf_cov <span class="op">=</span> <span class="bu">filter</span>.unscented_transform(sigmas_f, Wm, Wc)</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="co"># rasgele noktalar uret</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">100</span>)</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>xs, ys <span class="op">=</span> multivariate_normal(mean<span class="op">=</span>mean, cov<span class="op">=</span>p, size<span class="op">=</span><span class="dv">5000</span>).T</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>util.plot_monte_carlo_mean(xs, ys, f_nonlinear_xy, ukf_mean, <span class="st">&#39;Sigma Bazli Ortalama&#39;</span>)</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="op">-</span><span class="dv">30</span>, <span class="dv">30</span>)<span class="op">;</span> plt.ylim(<span class="dv">0</span>, <span class="dv">90</span>)</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">121</span>)</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>plt.scatter(sigmas[:,<span class="dv">0</span>], sigmas[:,<span class="dv">1</span>], c<span class="op">=</span><span class="st">&#39;r&#39;</span>, s<span class="op">=</span><span class="dv">30</span>)<span class="op">;</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_ukf_12.png&#39;</span>)</span></code></pre></div>
<pre><code>Ortalamalardaki fark x=-0.097, y=0.549</code></pre>
<p><img src="tser_ukf_12.png" /></p>
<p>Bu sonuç bana müthiş geliyor; sadece 5 nokta kullanarak ortalamaya
çok yakın bir sonucu hesaplayabildik, ayrıca bunu gayrı lineerliğin ne
olduğundan tamamen bağımsız olarak yaptık; eğer sigma noktalarını üreten
koda bakarsak göreceğiz ki bu kod gayrı-lineer fonksiyondan
habersiz.</p>
<p>Filtre</p>
<p>UKF formüllerine bakalım. Geçiş ve gözlemin <span
class="math inline">\(f,h\)</span> olduğunu düşünelim, matris formunda
<span class="math inline">\(F,H\)</span>. O anda elde olan <span
class="math inline">\(\mu,\Sigma\)</span>’yı alıp, önceden seçilmiş
sigma noktaları üzerinden bir <span class="math inline">\(X\)</span>
elde ediyoruz. Bir sonraki zaman dilimine</p>
<p><span class="math display">\[ Y = f(X) \]</span></p>
<p>ile geçiyoruz. Şimdi sigma bazlı transform ile tahmini ortalama
kovaryans hesaplarız,</p>
<p><span class="math display">\[ \bar{\mu} = \sum w^m Y \]</span></p>
<p><span class="math display">\[ \bar{\Sigma} = \sum w^c
(Y-\hat{\mu})(Y-\hat{\mu})^T + Q \]</span></p>
<p>KF ile geçiş ortalama için <span class="math inline">\(\bar{x} =
Fx\)</span> ve kovaryans <span class="math inline">\(\bar{P} = FPF^T +
Q\)</span> ile olurdu.</p>
<p>Güncelleme adımında eldeki sigma noktalarını bir tahmine
çeviriyoruz,</p>
<p><span class="math display">\[ Z = h(Y) \]</span></p>
<p>Sonra bu noktaların ortalama ve kovaryansını sigma bazlı transformu
kullanarak hesaplayabiliriz,</p>
<p><span class="math display">\[ \mu_z = \sum w^m Z \]</span></p>
<p><span class="math display">\[ P_z = \sum w^c (Z-\bar{\mu})
(Z-\bar{\mu})^T + R\]</span></p>
<p>Şimdi Kalman kazancı (gain) ve artıkları hesaplanabilir. Artıklar
basit</p>
<p><span class="math display">\[ y = z - \mu_z\]</span></p>
<p>Kazanç için önce konum ve ölçümlerin çapraz kovaryansını
hesaplarız,</p>
<p><span class="math display">\[ P_{xz} = \sum w^c
(X-\mu)(Z-\mu_z)^T    \]</span></p>
<p>sonra kazancı hesaplarız,</p>
<p><span class="math display">\[ K = P_{xz}P_z^{-1} \]</span></p>
<p>Üstteki matris tersi işlemi bir nevi oran hesabı gibi görebiliriz, o
zaman Kalman kazancı</p>
<p><span class="math display">\[
K \approx \frac{P_{xz}}{P_z^{-1}} \approx
\frac{\textrm{mevcut konuma inanç}}{\textrm{ölçüme olan inanç}}
\]</span></p>
<p>oranından ibarettir. Nihayet yeni kestirme hesabı artık ve kazanç
kullanarak hesaplanabilir,</p>
<p><span class="math display">\[ x = \bar{x} + Ky \]</span></p>
<p>yeni kovaryans</p>
<p><span class="math display">\[ P = \bar{P} - KP_zK^T \]</span></p>
<p>Filtrenin iç kodlaması hakkında diğer matematiksel detaylar için [1,
sf. 382].</p>
<p>Dikkat çekilmesi gereken püf nokta KF’te olduğu gibi ölçümleri
üretenin artık bir matris olmadığıdır. Normal Kalman filtreleri ile elde
bir ölçüm “fonksiyonu’’ vardır fakat bu fonksiyonu bir <span
class="math inline">\(H\)</span> matrisi olarak temsil etmek zorundayız.
Efendim boyutları düzgün olmalı, ki konum <span
class="math inline">\(x\)</span>’i çarpabilsin, vs. UKF ile bir <span
class="math inline">\(h\)</span> <em>fonksiyonu</em> var, bu
fonksiyonlar ek işlemler yapılmadan önce verinin kendisini transforme
ediyorlar, ve”yeni’’ veri üzerinde ek filtreleme işlemleri yapıyoruz,
mesela Kalman kazancını bu transform edilmiş veri üzerinden
hesaplıyoruz. Kıyasla KF ile <span class="math inline">\(H\)</span>
matrisi matris olarak direk kazanç hesabında kullanılıyor. Ardından UKF
ile veriye öyle noktalarda (sigma noktaları) bakıyoruz ki <span
class="math inline">\(h\)</span> ne kadar gayrı-lineer olursa olsun onun
temel özelliklerini yakalayabilmiş oluyoruz. Bu geçiş fonksiyonu <span
class="math inline">\(f\)</span> için de geçerli tabii, artık onun da
bir matris olması gerekmiyor. Ama hala <span
class="math inline">\(F,H\)</span> matrislerini tasarlayıp onları <span
class="math inline">\(f,h\)</span> fonksiyonları içinde <span
class="math inline">\(x\)</span>’i çarpmak için kullanabiliriz tabii,
ama bu şart değil.</p>
<p>Örnek</p>
<p>Bir KF tasarlamak için <span class="math inline">\(x,F,H,R\)</span>
matrislerinin ne olduğunu kararlaştırmak gerekiyor demiştik, bu durum
daha önce KF yazısında işlendi. Konum bilgisi nedir, geçiş nedir, ölçüm
nedir? Hareket halindeki bir objeyi takip ettiğimizi düşünelim,
konum</p>
<p><span class="math display">\[ x=\left[\begin{array}{cccc}
x&amp;\dot{x}&amp;y&amp;\dot{y} \end{array}\right]^T \]</span></p>
<p>olabilir. Konum geçişi</p>
<p><span class="math display">\[ F =
\left[\begin{array}{rrrr}
1 &amp; \Delta t &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; \Delta t \\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right]
\]</span></p>
<p>Üstteki denklemle bir Newton formülünü kodlamış oluyoruz,</p>
<p><span class="math display">\[ x_k = x_{k-1} + \dot{x}_{k-1}\Delta t
\]</span></p>
<p>Algılayıcılar hareketli aracın yerini bildiriyor ama hızını
bildiremiyor, o zaman</p>
<p><span class="math display">\[ H = \left[\begin{array}{rrrr}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0
\end{array}\right]\]</span></p>
<p>Diyelim ki algılayıcının pozisyonu belirleme hatası hem <span
class="math inline">\(x\)</span> hem <span
class="math inline">\(y\)</span> kordinatları için <span
class="math inline">\(1\sigma = 0.3\)</span> metre, bu bize alttaki
ölçüm gürültü matrisini veriyor,</p>
<p><span class="math display">\[ R = \left[\begin{array}{cc}
0.3^2  &amp; 0 \\ 0 &amp; 0.3^2
\end{array}\right]\]</span></p>
<p>Konum geçişinde de gürültü var, o da</p>
<p><span class="math display">\[ Q = \left[\begin{array}{cc}
\frac{1}{4} \Delta t^4 &amp; \frac{1}{2} \Delta t^3 \\
\frac{1}{2} \Delta t^3 &amp; \Delta t^2
\end{array}\right] \sigma^2  \]</span></p>
<p>Tabii biz simülasyon amaçlı veri üretirken de üstteki matrisi
kullanacağız.</p>
<p>Kodlar altta,</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math, util, scipy.linalg <span class="im">as</span> linalg</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy <span class="im">import</span> eye, zeros, dot, isscalar, outer</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.linalg <span class="im">import</span> inv, cholesky</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy.random <span class="im">import</span> randn</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> norm, multivariate_normal</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dot3(A,B,C):</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dot(A, dot(B,C))</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> logpdf(x, mean, cov):</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    flat_mean <span class="op">=</span> np.asarray(mean).flatten()</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    flat_x <span class="op">=</span> np.asarray(x).flatten()</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> multivariate_normal.logpdf(flat_x, flat_mean, cov, <span class="va">True</span>)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> unscented_transform(sigmas, Wm, Wc, noise_cov<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>                        mean_fn<span class="op">=</span><span class="va">None</span>, residual_fn<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    kmax, n <span class="op">=</span> sigmas.shape</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> mean_fn <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> np.dot(Wm, sigmas)    <span class="co"># dot = \Sigma^n_1 (W[k]*Xi[k])</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> mean_fn(sigmas, Wm)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> residual_fn <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> sigmas <span class="op">-</span> x[np.newaxis,:]</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>        P <span class="op">=</span> y.T.dot(np.diag(Wc)).dot(y)</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>        P <span class="op">=</span> np.zeros((n, n))</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(kmax):</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>            y <span class="op">=</span> residual_fn(sigmas[k], x)</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>            P <span class="op">+=</span> Wc[k] <span class="op">*</span> np.outer(y, y)</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> noise_cov <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>        P <span class="op">+=</span> noise_cov</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (x, P)</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Q_discrete_white_noise(dim, dt<span class="op">=</span><span class="fl">1.</span>, var<span class="op">=</span><span class="fl">1.</span>):</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> dim <span class="op">==</span> <span class="dv">2</span> <span class="kw">or</span> dim <span class="op">==</span> <span class="dv">3</span></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> dim <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>        Q <span class="op">=</span> np.array([[<span class="fl">.25</span><span class="op">*</span>dt<span class="op">**</span><span class="dv">4</span>, <span class="fl">.5</span><span class="op">*</span>dt<span class="op">**</span><span class="dv">3</span>],</span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>                      [ <span class="fl">.5</span><span class="op">*</span>dt<span class="op">**</span><span class="dv">3</span>,    dt<span class="op">**</span><span class="dv">2</span>]], dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>        Q <span class="op">=</span> np.array([[<span class="fl">.25</span><span class="op">*</span>dt<span class="op">**</span><span class="dv">4</span>, <span class="fl">.5</span><span class="op">*</span>dt<span class="op">**</span><span class="dv">3</span>, <span class="fl">.5</span><span class="op">*</span>dt<span class="op">**</span><span class="dv">2</span>],</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>                      [ <span class="fl">.5</span><span class="op">*</span>dt<span class="op">**</span><span class="dv">3</span>,    dt<span class="op">**</span><span class="dv">2</span>,       dt],</span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a>                      [ <span class="fl">.5</span><span class="op">*</span>dt<span class="op">**</span><span class="dv">2</span>,       dt,        <span class="dv">1</span>]], dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Q <span class="op">*</span> var</span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MerweScaledSigmaPoints(<span class="bu">object</span>):</span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n, alpha, beta, kappa, sqrt_method<span class="op">=</span><span class="va">None</span>, subtract<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n <span class="op">=</span> n</span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.alpha <span class="op">=</span> alpha</span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.beta <span class="op">=</span> beta</span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.kappa <span class="op">=</span> kappa</span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> subtract <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.subtract<span class="op">=</span> np.subtract</span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.subtract <span class="op">=</span> subtract</span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> num_sigmas(<span class="va">self</span>):</span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">2</span><span class="op">*</span><span class="va">self</span>.n <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> sigma_points(<span class="va">self</span>, x, P):</span>
<span id="cb6-68"><a href="#cb6-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> <span class="va">self</span>.n <span class="op">==</span> np.size(x), <span class="op">\</span></span>
<span id="cb6-69"><a href="#cb6-69" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;expected size </span><span class="sc">{}</span><span class="st">, but size is </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(<span class="va">self</span>.n, np.size(x))</span>
<span id="cb6-70"><a href="#cb6-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-71"><a href="#cb6-71" aria-hidden="true" tabindex="-1"></a>        n <span class="op">=</span> <span class="va">self</span>.n</span>
<span id="cb6-72"><a href="#cb6-72" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> np.isscalar(x): x <span class="op">=</span> np.asarray([x])</span>
<span id="cb6-73"><a href="#cb6-73" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>  np.isscalar(P): P <span class="op">=</span> np.eye(n)<span class="op">*</span>P</span>
<span id="cb6-74"><a href="#cb6-74" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>: P <span class="op">=</span> np.asarray(P)</span>
<span id="cb6-75"><a href="#cb6-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-76"><a href="#cb6-76" aria-hidden="true" tabindex="-1"></a>        lambda_ <span class="op">=</span> <span class="va">self</span>.alpha<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> (n <span class="op">+</span> <span class="va">self</span>.kappa) <span class="op">-</span> n</span>
<span id="cb6-77"><a href="#cb6-77" aria-hidden="true" tabindex="-1"></a>        U <span class="op">=</span> cholesky((lambda_ <span class="op">+</span> n)<span class="op">*</span>P)</span>
<span id="cb6-78"><a href="#cb6-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-79"><a href="#cb6-79" aria-hidden="true" tabindex="-1"></a>        sigmas <span class="op">=</span> np.zeros((<span class="dv">2</span><span class="op">*</span>n<span class="op">+</span><span class="dv">1</span>, n))</span>
<span id="cb6-80"><a href="#cb6-80" aria-hidden="true" tabindex="-1"></a>        sigmas[<span class="dv">0</span>] <span class="op">=</span> x</span>
<span id="cb6-81"><a href="#cb6-81" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb6-82"><a href="#cb6-82" aria-hidden="true" tabindex="-1"></a>            sigmas[k<span class="op">+</span><span class="dv">1</span>]   <span class="op">=</span> <span class="va">self</span>.subtract(x, <span class="op">-</span>U[k])</span>
<span id="cb6-83"><a href="#cb6-83" aria-hidden="true" tabindex="-1"></a>            sigmas[n<span class="op">+</span>k<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> <span class="va">self</span>.subtract(x, U[k])</span>
<span id="cb6-84"><a href="#cb6-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-85"><a href="#cb6-85" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> sigmas</span>
<span id="cb6-86"><a href="#cb6-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-87"><a href="#cb6-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-88"><a href="#cb6-88" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> weights(<span class="va">self</span>):</span>
<span id="cb6-89"><a href="#cb6-89" aria-hidden="true" tabindex="-1"></a>        n <span class="op">=</span> <span class="va">self</span>.n</span>
<span id="cb6-90"><a href="#cb6-90" aria-hidden="true" tabindex="-1"></a>        lambda_ <span class="op">=</span> <span class="va">self</span>.alpha<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> (n <span class="op">+</span><span class="va">self</span>.kappa) <span class="op">-</span> n</span>
<span id="cb6-91"><a href="#cb6-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-92"><a href="#cb6-92" aria-hidden="true" tabindex="-1"></a>        c <span class="op">=</span> <span class="fl">.5</span> <span class="op">/</span> (n <span class="op">+</span> lambda_)</span>
<span id="cb6-93"><a href="#cb6-93" aria-hidden="true" tabindex="-1"></a>        Wc <span class="op">=</span> np.full(<span class="dv">2</span><span class="op">*</span>n <span class="op">+</span> <span class="dv">1</span>, c)</span>
<span id="cb6-94"><a href="#cb6-94" aria-hidden="true" tabindex="-1"></a>        Wm <span class="op">=</span> np.full(<span class="dv">2</span><span class="op">*</span>n <span class="op">+</span> <span class="dv">1</span>, c)</span>
<span id="cb6-95"><a href="#cb6-95" aria-hidden="true" tabindex="-1"></a>        Wc[<span class="dv">0</span>] <span class="op">=</span> lambda_ <span class="op">/</span> (n <span class="op">+</span> lambda_) <span class="op">+</span> (<span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.alpha<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> <span class="va">self</span>.beta)</span>
<span id="cb6-96"><a href="#cb6-96" aria-hidden="true" tabindex="-1"></a>        Wm[<span class="dv">0</span>] <span class="op">=</span> lambda_ <span class="op">/</span> (n <span class="op">+</span> lambda_)</span>
<span id="cb6-97"><a href="#cb6-97" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Wm, Wc</span>
<span id="cb6-98"><a href="#cb6-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-99"><a href="#cb6-99" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> UKF(<span class="bu">object</span>):</span>
<span id="cb6-100"><a href="#cb6-100" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, dim_x, dim_z, hx, fx, points,</span>
<span id="cb6-101"><a href="#cb6-101" aria-hidden="true" tabindex="-1"></a>                 x_mean_fn<span class="op">=</span><span class="va">None</span>, z_mean_fn<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb6-102"><a href="#cb6-102" aria-hidden="true" tabindex="-1"></a>                 residual_x<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb6-103"><a href="#cb6-103" aria-hidden="true" tabindex="-1"></a>                 residual_z<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb6-104"><a href="#cb6-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-105"><a href="#cb6-105" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.Q <span class="op">=</span> eye(dim_x)</span>
<span id="cb6-106"><a href="#cb6-106" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.R <span class="op">=</span> eye(dim_z)</span>
<span id="cb6-107"><a href="#cb6-107" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x <span class="op">=</span> zeros(dim_x)</span>
<span id="cb6-108"><a href="#cb6-108" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.P <span class="op">=</span> eye(dim_x)</span>
<span id="cb6-109"><a href="#cb6-109" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._dim_x <span class="op">=</span> dim_x</span>
<span id="cb6-110"><a href="#cb6-110" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._dim_z <span class="op">=</span> dim_z</span>
<span id="cb6-111"><a href="#cb6-111" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.points_fn <span class="op">=</span> points</span>
<span id="cb6-112"><a href="#cb6-112" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._num_sigmas <span class="op">=</span> points.num_sigmas()</span>
<span id="cb6-113"><a href="#cb6-113" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.hx <span class="op">=</span> hx</span>
<span id="cb6-114"><a href="#cb6-114" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fx <span class="op">=</span> fx</span>
<span id="cb6-115"><a href="#cb6-115" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x_mean <span class="op">=</span> x_mean_fn</span>
<span id="cb6-116"><a href="#cb6-116" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.z_mean <span class="op">=</span> z_mean_fn</span>
<span id="cb6-117"><a href="#cb6-117" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.log_likelihood <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb6-118"><a href="#cb6-118" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.Wm, <span class="va">self</span>.Wc <span class="op">=</span> <span class="va">self</span>.points_fn.weights()</span>
<span id="cb6-119"><a href="#cb6-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-120"><a href="#cb6-120" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> residual_x <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb6-121"><a href="#cb6-121" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.residual_x <span class="op">=</span> np.subtract</span>
<span id="cb6-122"><a href="#cb6-122" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb6-123"><a href="#cb6-123" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.residual_x <span class="op">=</span> residual_x</span>
<span id="cb6-124"><a href="#cb6-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-125"><a href="#cb6-125" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> residual_z <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb6-126"><a href="#cb6-126" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.residual_z <span class="op">=</span> np.subtract</span>
<span id="cb6-127"><a href="#cb6-127" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb6-128"><a href="#cb6-128" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.residual_z <span class="op">=</span> residual_z</span>
<span id="cb6-129"><a href="#cb6-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-130"><a href="#cb6-130" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.sigmas_f <span class="op">=</span> zeros((<span class="va">self</span>._num_sigmas, <span class="va">self</span>._dim_x))</span>
<span id="cb6-131"><a href="#cb6-131" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.sigmas_h <span class="op">=</span> zeros((<span class="va">self</span>._num_sigmas, <span class="va">self</span>._dim_z))</span>
<span id="cb6-132"><a href="#cb6-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-133"><a href="#cb6-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-134"><a href="#cb6-134" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> predict(<span class="va">self</span>, dt):</span>
<span id="cb6-135"><a href="#cb6-135" aria-hidden="true" tabindex="-1"></a>        sigmas <span class="op">=</span> <span class="va">self</span>.points_fn.sigma_points(<span class="va">self</span>.x, <span class="va">self</span>.P)        </span>
<span id="cb6-136"><a href="#cb6-136" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>._num_sigmas):</span>
<span id="cb6-137"><a href="#cb6-137" aria-hidden="true" tabindex="-1"></a>            <span class="co"># parametre verilen dt oldugu gibi fx&#39;e geciliyor,</span></span>
<span id="cb6-138"><a href="#cb6-138" aria-hidden="true" tabindex="-1"></a>            <span class="co"># yani UKF matematiginde direk kullanilmiyor</span></span>
<span id="cb6-139"><a href="#cb6-139" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.sigmas_f[i] <span class="op">=</span> <span class="va">self</span>.fx(sigmas[i], dt)            </span>
<span id="cb6-140"><a href="#cb6-140" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x, <span class="va">self</span>.P <span class="op">=</span> unscented_transform(<span class="va">self</span>.sigmas_f,</span>
<span id="cb6-141"><a href="#cb6-141" aria-hidden="true" tabindex="-1"></a>                                             <span class="va">self</span>.Wm,</span>
<span id="cb6-142"><a href="#cb6-142" aria-hidden="true" tabindex="-1"></a>                                             <span class="va">self</span>.Wc,</span>
<span id="cb6-143"><a href="#cb6-143" aria-hidden="true" tabindex="-1"></a>                                             <span class="va">self</span>.Q,</span>
<span id="cb6-144"><a href="#cb6-144" aria-hidden="true" tabindex="-1"></a>                                             <span class="va">self</span>.x_mean,</span>
<span id="cb6-145"><a href="#cb6-145" aria-hidden="true" tabindex="-1"></a>                                             <span class="va">self</span>.residual_x)</span>
<span id="cb6-146"><a href="#cb6-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-147"><a href="#cb6-147" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> predict(<span class="va">self</span>, dt, u):</span>
<span id="cb6-148"><a href="#cb6-148" aria-hidden="true" tabindex="-1"></a>        sigmas <span class="op">=</span> <span class="va">self</span>.points_fn.sigma_points(<span class="va">self</span>.x, <span class="va">self</span>.P)        </span>
<span id="cb6-149"><a href="#cb6-149" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>._num_sigmas):</span>
<span id="cb6-150"><a href="#cb6-150" aria-hidden="true" tabindex="-1"></a>            <span class="co"># parametre verilen dt oldugu gibi fx&#39;e geciliyor,</span></span>
<span id="cb6-151"><a href="#cb6-151" aria-hidden="true" tabindex="-1"></a>            <span class="co"># yani UKF matematiginde direk kullanilmiyor</span></span>
<span id="cb6-152"><a href="#cb6-152" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.sigmas_f[i] <span class="op">=</span> <span class="va">self</span>.fx(sigmas[i], dt, u)</span>
<span id="cb6-153"><a href="#cb6-153" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x, <span class="va">self</span>.P <span class="op">=</span> unscented_transform(<span class="va">self</span>.sigmas_f,</span>
<span id="cb6-154"><a href="#cb6-154" aria-hidden="true" tabindex="-1"></a>                                             <span class="va">self</span>.Wm,</span>
<span id="cb6-155"><a href="#cb6-155" aria-hidden="true" tabindex="-1"></a>                                             <span class="va">self</span>.Wc,</span>
<span id="cb6-156"><a href="#cb6-156" aria-hidden="true" tabindex="-1"></a>                                             <span class="va">self</span>.Q,</span>
<span id="cb6-157"><a href="#cb6-157" aria-hidden="true" tabindex="-1"></a>                                             <span class="va">self</span>.x_mean,</span>
<span id="cb6-158"><a href="#cb6-158" aria-hidden="true" tabindex="-1"></a>                                             <span class="va">self</span>.residual_x)</span>
<span id="cb6-159"><a href="#cb6-159" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-160"><a href="#cb6-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-161"><a href="#cb6-161" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> update(<span class="va">self</span>, z):</span>
<span id="cb6-162"><a href="#cb6-162" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>._num_sigmas):</span>
<span id="cb6-163"><a href="#cb6-163" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.sigmas_h[i] <span class="op">=</span> <span class="va">self</span>.hx(<span class="va">self</span>.sigmas_f[i])</span>
<span id="cb6-164"><a href="#cb6-164" aria-hidden="true" tabindex="-1"></a>        zp, Pz <span class="op">=</span> unscented_transform(<span class="va">self</span>.sigmas_h,</span>
<span id="cb6-165"><a href="#cb6-165" aria-hidden="true" tabindex="-1"></a>                                     <span class="va">self</span>.Wm,</span>
<span id="cb6-166"><a href="#cb6-166" aria-hidden="true" tabindex="-1"></a>                                     <span class="va">self</span>.Wc,</span>
<span id="cb6-167"><a href="#cb6-167" aria-hidden="true" tabindex="-1"></a>                                     <span class="va">self</span>.R,</span>
<span id="cb6-168"><a href="#cb6-168" aria-hidden="true" tabindex="-1"></a>                                     <span class="va">self</span>.z_mean,</span>
<span id="cb6-169"><a href="#cb6-169" aria-hidden="true" tabindex="-1"></a>                                     <span class="va">self</span>.residual_z)</span>
<span id="cb6-170"><a href="#cb6-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-171"><a href="#cb6-171" aria-hidden="true" tabindex="-1"></a>        Pxz <span class="op">=</span> zeros((<span class="va">self</span>._dim_x, <span class="va">self</span>._dim_z))</span>
<span id="cb6-172"><a href="#cb6-172" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>._num_sigmas):</span>
<span id="cb6-173"><a href="#cb6-173" aria-hidden="true" tabindex="-1"></a>            dx <span class="op">=</span> <span class="va">self</span>.residual_x(<span class="va">self</span>.sigmas_f[i], <span class="va">self</span>.x)</span>
<span id="cb6-174"><a href="#cb6-174" aria-hidden="true" tabindex="-1"></a>            dz <span class="op">=</span>  <span class="va">self</span>.residual_z(<span class="va">self</span>.sigmas_h[i], zp)</span>
<span id="cb6-175"><a href="#cb6-175" aria-hidden="true" tabindex="-1"></a>            Pxz <span class="op">+=</span> <span class="va">self</span>.Wc[i] <span class="op">*</span> outer(dx, dz)</span>
<span id="cb6-176"><a href="#cb6-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-177"><a href="#cb6-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-178"><a href="#cb6-178" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.K <span class="op">=</span> dot(Pxz, inv(Pz)) </span>
<span id="cb6-179"><a href="#cb6-179" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.y <span class="op">=</span> <span class="va">self</span>.residual_z(z, zp) </span>
<span id="cb6-180"><a href="#cb6-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-181"><a href="#cb6-181" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x <span class="op">=</span> <span class="va">self</span>.x <span class="op">+</span> dot(<span class="va">self</span>.K, <span class="va">self</span>.y)</span>
<span id="cb6-182"><a href="#cb6-182" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.P <span class="op">=</span> <span class="va">self</span>.P <span class="op">-</span> dot3(<span class="va">self</span>.K, Pz, <span class="va">self</span>.K.T)</span>
<span id="cb6-183"><a href="#cb6-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-184"><a href="#cb6-184" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.log_likelihood <span class="op">=</span> logpdf(<span class="va">self</span>.y, np.zeros(<span class="bu">len</span>(<span class="va">self</span>.y)), Pz)</span>
<span id="cb6-185"><a href="#cb6-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-186"><a href="#cb6-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-187"><a href="#cb6-187" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> cross_variance(<span class="va">self</span>, x, z, sigmas_f, sigmas_h):</span>
<span id="cb6-188"><a href="#cb6-188" aria-hidden="true" tabindex="-1"></a>        Pxz <span class="op">=</span> zeros((sigmas_f.shape[<span class="dv">1</span>], sigmas_h.shape[<span class="dv">1</span>]))</span>
<span id="cb6-189"><a href="#cb6-189" aria-hidden="true" tabindex="-1"></a>        N <span class="op">=</span> sigmas_f.shape[<span class="dv">0</span>]</span>
<span id="cb6-190"><a href="#cb6-190" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb6-191"><a href="#cb6-191" aria-hidden="true" tabindex="-1"></a>            dx <span class="op">=</span> <span class="va">self</span>.residual_x(sigmas_f[i], x)</span>
<span id="cb6-192"><a href="#cb6-192" aria-hidden="true" tabindex="-1"></a>            dz <span class="op">=</span>  <span class="va">self</span>.residual_z(sigmas_h[i], z)</span>
<span id="cb6-193"><a href="#cb6-193" aria-hidden="true" tabindex="-1"></a>            Pxz <span class="op">+=</span> <span class="va">self</span>.Wc[i] <span class="op">*</span> outer(dx, dz)</span>
<span id="cb6-194"><a href="#cb6-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-195"><a href="#cb6-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-196"><a href="#cb6-196" aria-hidden="true" tabindex="-1"></a>    <span class="at">@property</span></span>
<span id="cb6-197"><a href="#cb6-197" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> likelihood(<span class="va">self</span>):</span>
<span id="cb6-198"><a href="#cb6-198" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> math.exp(<span class="va">self</span>.log_likelihood)</span></code></pre></div>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> <span class="bu">filter</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f_cv(x, dt):</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    F <span class="op">=</span> np.array([[<span class="dv">1</span>, dt, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>                 [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>             [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, dt],</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>             [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>]])</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.dot(F, x)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> h_cv(x):</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array([x[<span class="dv">0</span>], x[<span class="dv">2</span>]])</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>std_x, std_y <span class="op">=</span> <span class="fl">.3</span>, <span class="fl">.3</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>zs <span class="op">=</span> [np.array([i <span class="op">+</span> randn()<span class="op">*</span>std_x,i <span class="op">+</span> randn()<span class="op">*</span>std_y]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">100</span>)]</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>sigmas <span class="op">=</span> <span class="bu">filter</span>.MerweScaledSigmaPoints(<span class="dv">4</span>, alpha<span class="op">=</span><span class="fl">.1</span>, beta<span class="op">=</span><span class="fl">2.</span>, kappa<span class="op">=</span><span class="fl">1.</span>)</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>ukf <span class="op">=</span> <span class="bu">filter</span>.UKF(dim_x<span class="op">=</span><span class="dv">4</span>, dim_z<span class="op">=</span><span class="dv">2</span>, fx<span class="op">=</span>f_cv,hx<span class="op">=</span>h_cv, points<span class="op">=</span>sigmas)</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>ukf.x <span class="op">=</span> np.array([<span class="fl">0.</span>, <span class="fl">0.</span>, <span class="fl">0.</span>, <span class="fl">0.</span>])</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>ukf.R <span class="op">=</span> np.diag([<span class="fl">0.09</span>, <span class="fl">0.09</span>])</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>ukf.Q[<span class="dv">0</span>:<span class="dv">2</span>, <span class="dv">0</span>:<span class="dv">2</span>] <span class="op">=</span> <span class="bu">filter</span>.Q_discrete_white_noise(<span class="dv">2</span>, dt<span class="op">=</span><span class="dv">1</span>, var<span class="op">=</span><span class="fl">0.02</span>)</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>ukf.Q[<span class="dv">2</span>:<span class="dv">4</span>, <span class="dv">2</span>:<span class="dv">4</span>] <span class="op">=</span> <span class="bu">filter</span>.Q_discrete_white_noise(<span class="dv">2</span>, dt<span class="op">=</span><span class="dv">1</span>, var<span class="op">=</span><span class="fl">0.02</span>)</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>uxs <span class="op">=</span> []</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> z <span class="kw">in</span> zs:</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    ukf.predict(dt<span class="op">=</span>dt)</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    ukf.update(z)</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>    uxs.append(ukf.x.copy())</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>uxs <span class="op">=</span> np.array(uxs)</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>plt.plot(uxs[:, <span class="dv">0</span>], uxs[:, <span class="dv">2</span>])</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_ukf_01.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_ukf_01.png" /></p>
<p>Bir Uçağı Radar ile Takip Etmek</p>
<p>Şimdi ilk gayrı lineer problemimize gelelim. Yeryüzündeki sabit bir
radarı algılayıcı olarak kullanarak bir uçağı takip edeceğiz. Basitlik
amaçlı olarak radar sinyalleri ve takip iki boyutta olacak. Radarlar
bilindiği gibi radyo sinyallerini etrafa yayarlar, ve etraftaki
cisimlerden geri gelen yansımalara bakarak bir mesafe hesaplarlar. Bu
problemdeki radar bize bir uzaklık ve cismin yerle olan açısını (slant)
raporlayacak. Biz bu eğimi ve mesafeyi alıp bir uzaklık ve irtifa /
yükseklik (altitude) hesabına çevireceğiz.</p>
<p><img src="tser_ukf_07.png" /></p>
<p>Uçağın sabit irtifada uçtuğunu farz edelim,</p>
<p><span class="math display">\[ \vec{x} =
\left[\begin{array}{c}  
\textrm{uzaklık} \\ \textrm{hız} \\ \textrm{irtifa}
\end{array}\right] =
\left[\begin{array}{c}  
x_{pos} \\ x_{vel} \\ x_{alt}
\end{array}\right] =
\left[\begin{array}{c}  
x \\ \dot{x} \\ y
\end{array}\right]
\]</span></p>
<p>Geçiş fonksiyonu lineer</p>
<p><span class="math display">\[ F =
\left[\begin{array}{ccc}
1 &amp; \Delta t &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1
\end{array}\right]
\left[\begin{array}{c} x \\ \dot{x} \\ y \end{array}\right]
\]</span></p>
<p>Şimdi ölçüm fonksiyonunu tasarlamak lazım, probleme tersten bakıyoruz
şimdi, yani “eğer yer seviyesindeki uzaklığı ve irtifayı biliyor
olsaydık açıyı (bearing) ve sinyal uzaklığını (range) nasıl ölçüyor
olurduk?’’ sorusunu cevaplıyoruz. Pitagor denklemini kullanabiliriz,</p>
<p><span class="math display">\[ range = \sqrt{(x_{ac} - x_{radar})^2 +
(z_{ac}-z_{radar})^2 } \]</span></p>
<p>Yer ile açı için</p>
<p><span class="math display">\[ bearing = \tan^{-1}
\frac{z_{ac}-z_{radar}}{x_{ac}-x_{radar}}\]</span></p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f_radar(x, dt):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    F <span class="op">=</span> np.array([[<span class="dv">1</span>, dt, <span class="dv">0</span>],</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>                  [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>],</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>                  [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>]], dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.dot(F, x)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> h_radar(x):</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    dx <span class="op">=</span> x[<span class="dv">0</span>] <span class="op">-</span> h_radar.radar_pos[<span class="dv">0</span>]</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    dz <span class="op">=</span> x[<span class="dv">2</span>] <span class="op">-</span> h_radar.radar_pos[<span class="dv">1</span>]</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    slant_range <span class="op">=</span> math.sqrt(dx<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> dz<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    bearing <span class="op">=</span> math.atan2(dz, dx)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> slant_range, bearing</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>h_radar.radar_pos <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy.linalg <span class="im">import</span> norm</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> math <span class="im">import</span> atan2</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> RadarStation(<span class="bu">object</span>):</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, pos, range_std, bearing_std):</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.pos <span class="op">=</span> np.asarray(pos)</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.range_std <span class="op">=</span> range_std</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.bearing_std <span class="op">=</span> bearing_std</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> reading_of(<span class="va">self</span>, ac_pos):</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>        diff <span class="op">=</span> np.subtract(ac_pos, <span class="va">self</span>.pos)</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>        rng <span class="op">=</span> norm(diff)</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>        brg <span class="op">=</span> atan2(diff[<span class="dv">1</span>], diff[<span class="dv">0</span>])</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> rng, brg</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> noisy_reading(<span class="va">self</span>, ac_pos):</span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>        rng, brg <span class="op">=</span> <span class="va">self</span>.reading_of(ac_pos)</span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>        rng <span class="op">+=</span> randn() <span class="op">*</span> <span class="va">self</span>.range_std</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>        brg <span class="op">+=</span> randn() <span class="op">*</span> <span class="va">self</span>.bearing_std</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> rng, brg</span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> z_to_x(<span class="va">self</span>, slant_range, angle):</span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> cos(angle)<span class="op">*</span>slant_range</span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> sin(angle)<span class="op">*</span>slant_range</span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.pos <span class="op">+</span> (x,z)</span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ACSim(<span class="bu">object</span>):</span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, pos, vel, vel_std):</span>
<span id="cb8-47"><a href="#cb8-47" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.pos <span class="op">=</span> np.asarray(pos, dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb8-48"><a href="#cb8-48" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.vel <span class="op">=</span> np.asarray(vel, dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb8-49"><a href="#cb8-49" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.vel_std <span class="op">=</span> vel_std</span>
<span id="cb8-50"><a href="#cb8-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-51"><a href="#cb8-51" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb8-52"><a href="#cb8-52" aria-hidden="true" tabindex="-1"></a>         dx <span class="op">=</span> <span class="va">self</span>.vel<span class="op">*</span>dt <span class="op">+</span> (randn() <span class="op">*</span> <span class="va">self</span>.vel_std) <span class="op">*</span> dt</span>
<span id="cb8-53"><a href="#cb8-53" aria-hidden="true" tabindex="-1"></a>         <span class="va">self</span>.pos <span class="op">+=</span> dx</span>
<span id="cb8-54"><a href="#cb8-54" aria-hidden="true" tabindex="-1"></a>         <span class="cf">return</span> <span class="va">self</span>.pos</span>
<span id="cb8-55"><a href="#cb8-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-56"><a href="#cb8-56" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb8-57"><a href="#cb8-57" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy <span class="im">import</span> random</span>
<span id="cb8-58"><a href="#cb8-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-59"><a href="#cb8-59" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> <span class="fl">12.</span> <span class="co"># 12 seconds between readings</span></span>
<span id="cb8-60"><a href="#cb8-60" aria-hidden="true" tabindex="-1"></a>range_std <span class="op">=</span> <span class="dv">5</span> <span class="co"># meters</span></span>
<span id="cb8-61"><a href="#cb8-61" aria-hidden="true" tabindex="-1"></a>bearing_std <span class="op">=</span> math.radians(<span class="fl">0.5</span>)</span>
<span id="cb8-62"><a href="#cb8-62" aria-hidden="true" tabindex="-1"></a>ac_pos <span class="op">=</span> (<span class="fl">0.</span>, <span class="fl">1000.</span>)</span>
<span id="cb8-63"><a href="#cb8-63" aria-hidden="true" tabindex="-1"></a>ac_vel <span class="op">=</span> (<span class="fl">100.</span>, <span class="fl">0.</span>)</span>
<span id="cb8-64"><a href="#cb8-64" aria-hidden="true" tabindex="-1"></a>radar_pos <span class="op">=</span> (<span class="fl">0.</span>, <span class="fl">0.</span>)</span>
<span id="cb8-65"><a href="#cb8-65" aria-hidden="true" tabindex="-1"></a>h_radar.radar_pos <span class="op">=</span> radar_pos</span>
<span id="cb8-66"><a href="#cb8-66" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> <span class="bu">filter</span>.MerweScaledSigmaPoints(n<span class="op">=</span><span class="dv">3</span>, alpha<span class="op">=</span><span class="fl">.1</span>, beta<span class="op">=</span><span class="fl">2.</span>, kappa<span class="op">=</span><span class="fl">0.</span>)</span>
<span id="cb8-67"><a href="#cb8-67" aria-hidden="true" tabindex="-1"></a>kf <span class="op">=</span> <span class="bu">filter</span>.UKF(<span class="dv">3</span>, <span class="dv">2</span>, fx<span class="op">=</span>f_radar, hx<span class="op">=</span>h_radar, points<span class="op">=</span>points)</span>
<span id="cb8-68"><a href="#cb8-68" aria-hidden="true" tabindex="-1"></a>kf.Q[<span class="dv">0</span>:<span class="dv">2</span>, <span class="dv">0</span>:<span class="dv">2</span>] <span class="op">=</span> <span class="bu">filter</span>.Q_discrete_white_noise(<span class="dv">2</span>, dt<span class="op">=</span>dt, var<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb8-69"><a href="#cb8-69" aria-hidden="true" tabindex="-1"></a>kf.Q[<span class="dv">2</span>,<span class="dv">2</span>] <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb8-70"><a href="#cb8-70" aria-hidden="true" tabindex="-1"></a>kf.R <span class="op">=</span> np.diag([range_std<span class="op">**</span><span class="dv">2</span>, bearing_std<span class="op">**</span><span class="dv">2</span>])</span>
<span id="cb8-71"><a href="#cb8-71" aria-hidden="true" tabindex="-1"></a>kf.x <span class="op">=</span> np.array([<span class="fl">0.</span>, <span class="fl">90.</span>, <span class="fl">1100.</span>])</span>
<span id="cb8-72"><a href="#cb8-72" aria-hidden="true" tabindex="-1"></a>kf.P <span class="op">=</span> np.diag([<span class="dv">300</span><span class="op">**</span><span class="dv">2</span>, <span class="dv">30</span><span class="op">**</span><span class="dv">2</span>, <span class="dv">150</span><span class="op">**</span><span class="dv">2</span>])</span>
<span id="cb8-73"><a href="#cb8-73" aria-hidden="true" tabindex="-1"></a>random.seed(<span class="dv">200</span>)</span>
<span id="cb8-74"><a href="#cb8-74" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb8-75"><a href="#cb8-75" aria-hidden="true" tabindex="-1"></a>radar <span class="op">=</span> RadarStation(pos, range_std, bearing_std)</span>
<span id="cb8-76"><a href="#cb8-76" aria-hidden="true" tabindex="-1"></a>ac <span class="op">=</span> ACSim(ac_pos, (<span class="dv">100</span>, <span class="dv">0</span>), <span class="fl">0.02</span>)</span>
<span id="cb8-77"><a href="#cb8-77" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> np.arange(<span class="dv">0</span>, <span class="dv">360</span> <span class="op">+</span> dt, dt)</span>
<span id="cb8-78"><a href="#cb8-78" aria-hidden="true" tabindex="-1"></a>xs <span class="op">=</span> []</span>
<span id="cb8-79"><a href="#cb8-79" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _ <span class="kw">in</span> time:</span>
<span id="cb8-80"><a href="#cb8-80" aria-hidden="true" tabindex="-1"></a>    ac.update(dt)</span>
<span id="cb8-81"><a href="#cb8-81" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> radar.noisy_reading(ac.pos)</span>
<span id="cb8-82"><a href="#cb8-82" aria-hidden="true" tabindex="-1"></a>    kf.predict(dt<span class="op">=</span>dt)</span>
<span id="cb8-83"><a href="#cb8-83" aria-hidden="true" tabindex="-1"></a>    kf.update([r[<span class="dv">0</span>], r[<span class="dv">1</span>]])</span>
<span id="cb8-84"><a href="#cb8-84" aria-hidden="true" tabindex="-1"></a>    xs.append(kf.x)</span>
<span id="cb8-85"><a href="#cb8-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-86"><a href="#cb8-86" aria-hidden="true" tabindex="-1"></a>xs <span class="op">=</span> np.asarray(xs)</span>
<span id="cb8-87"><a href="#cb8-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-88"><a href="#cb8-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-89"><a href="#cb8-89" aria-hidden="true" tabindex="-1"></a>plt.figure()</span>
<span id="cb8-90"><a href="#cb8-90" aria-hidden="true" tabindex="-1"></a>plt.plot(time, xs[:, <span class="dv">0</span>]<span class="op">/</span><span class="fl">1000.</span>)</span>
<span id="cb8-91"><a href="#cb8-91" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;zaman(saniye)&#39;</span>)</span>
<span id="cb8-92"><a href="#cb8-92" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;yer(km)&#39;</span>)</span>
<span id="cb8-93"><a href="#cb8-93" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb8-94"><a href="#cb8-94" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_ukf_04.png&#39;</span>)</span>
<span id="cb8-95"><a href="#cb8-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-96"><a href="#cb8-96" aria-hidden="true" tabindex="-1"></a>plt.figure()</span>
<span id="cb8-97"><a href="#cb8-97" aria-hidden="true" tabindex="-1"></a>plt.plot(time, xs[:, <span class="dv">1</span>])</span>
<span id="cb8-98"><a href="#cb8-98" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;zaman(saniye)&#39;</span>)</span>
<span id="cb8-99"><a href="#cb8-99" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">u&#39;hız&#39;</span>)</span>
<span id="cb8-100"><a href="#cb8-100" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb8-101"><a href="#cb8-101" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_ukf_05.png&#39;</span>)</span>
<span id="cb8-102"><a href="#cb8-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-103"><a href="#cb8-103" aria-hidden="true" tabindex="-1"></a>plt.figure()</span>
<span id="cb8-104"><a href="#cb8-104" aria-hidden="true" tabindex="-1"></a>plt.plot(time, xs[:,<span class="dv">2</span>])</span>
<span id="cb8-105"><a href="#cb8-105" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;zaman(saniye)&#39;</span>)</span>
<span id="cb8-106"><a href="#cb8-106" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;irtifa&#39;</span>)</span>
<span id="cb8-107"><a href="#cb8-107" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb8-108"><a href="#cb8-108" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_ukf_06.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_ukf_04.png" /></p>
<p><img src="tser_ukf_05.png" /></p>
<p><img src="tser_ukf_06.png" /></p>
<p>Sonuçlar iyi, fakat uçağın hiç irtifa değiştirmediğini farzettik.
Şimdi uçağın bir dakika sonra daha yükseğe tırmanmaya başladığını
düşünelim, ve simülasyon verisini ona göre üretelim. O zaman tırmanma
oranını da konum matrisine eklememiz gerekir,</p>
<p><span class="math display">\[ \vec{x} =
\left[\begin{array}{c}  
\textrm{uzaklık} \\ \textrm{hız} \\ \textrm{irtifa} \\ \textrm{tırmanma
oranı}
\end{array}\right] =
\left[\begin{array}{c}  
x \\ \dot{x} \\ y \\ \dot{y}
\end{array}\right]
\]</span></p>
<p>Konum geçiş matrisi de değişir,</p>
<p><span class="math display">\[ \vec{x}_{\textrm{geçiş sonrası}} =
\left[\begin{array}{cccc}
1 &amp; \Delta t &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; dt \\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right]
\left[\begin{array}{c}  x \\ \dot{x} \\ y \\ \dot{y} \end{array}\right]
\]</span></p>
<p>ki geçiş hala lineer. Ölçüm fonksiyonu aynı kalıyor, sadece boyutlar
değiştiği için <span class="math inline">\(Q\)</span>’yi buna göre
uyarlamak gerekiyor. Bu kadar.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f_cv_radar(x, dt):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    F <span class="op">=</span> np.array([[<span class="dv">1</span>, dt, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, dt],</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>]], dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.dot(F, x)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cv_UKF(fx, hx, R_std):</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    points <span class="op">=</span> <span class="bu">filter</span>.MerweScaledSigmaPoints(n<span class="op">=</span><span class="dv">4</span>, alpha<span class="op">=</span><span class="fl">.1</span>, beta<span class="op">=</span><span class="fl">2.</span>, kappa<span class="op">=-</span><span class="fl">1.</span>)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    kf <span class="op">=</span> <span class="bu">filter</span>.UKF(<span class="dv">4</span>, <span class="bu">len</span>(R_std), fx<span class="op">=</span>fx, hx<span class="op">=</span>hx, points<span class="op">=</span>points)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    kf.Q[<span class="dv">0</span>:<span class="dv">2</span>, <span class="dv">0</span>:<span class="dv">2</span>] <span class="op">=</span> <span class="bu">filter</span>.Q_discrete_white_noise(<span class="dv">2</span>, dt<span class="op">=</span>dt, var<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    kf.Q[<span class="dv">2</span>:<span class="dv">4</span>, <span class="dv">2</span>:<span class="dv">4</span>] <span class="op">=</span> <span class="bu">filter</span>.Q_discrete_white_noise(<span class="dv">2</span>, dt<span class="op">=</span>dt, var<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    kf.R <span class="op">=</span> np.diag(R_std)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    kf.R <span class="op">=</span> np.dot(kf.R, kf.R) <span class="co"># square to get rariance</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    kf.x <span class="op">=</span> np.array([<span class="fl">0.</span>, <span class="fl">90.</span>, <span class="fl">1100.</span>, <span class="fl">0.</span>])</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    kf.P <span class="op">=</span> np.diag([<span class="dv">300</span><span class="op">**</span><span class="dv">2</span>, <span class="dv">3</span><span class="op">**</span><span class="dv">2</span>, <span class="dv">150</span><span class="op">**</span><span class="dv">2</span>, <span class="dv">3</span><span class="op">**</span><span class="dv">2</span>])</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> kf</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>random.seed(<span class="dv">200</span>)</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>ac <span class="op">=</span> ACSim(ac_pos, (<span class="dv">100</span>, <span class="dv">0</span>), <span class="fl">0.02</span>)</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>kf <span class="op">=</span> cv_UKF(f_cv_radar, h_radar, R_std<span class="op">=</span>[range_std, bearing_std])</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> np.arange(<span class="dv">0</span>, <span class="dv">360</span> <span class="op">+</span> dt, dt)</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>xs <span class="op">=</span> []</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> t <span class="kw">in</span> time:</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> t <span class="op">&gt;=</span> <span class="dv">60</span>:</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>        ac.vel[<span class="dv">1</span>] <span class="op">=</span> <span class="dv">300</span><span class="op">/</span><span class="dv">60</span> <span class="co"># 300 meters/minute climb</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>    ac.update(dt)</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> radar.noisy_reading(ac.pos)</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    kf.predict(dt<span class="op">=</span>dt)</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>    kf.update([r[<span class="dv">0</span>], r[<span class="dv">1</span>]])</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>    xs.append(kf.x)</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>xs <span class="op">=</span> np.array(xs)</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>plt.figure()</span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>plt.plot(time, xs[:,<span class="dv">2</span>])</span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;zaman(saniye)&#39;</span>)</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;yükseklik&#39;</span>)</span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_ukf_08.png&#39;</span>)</span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">u&#39;Gerçek irtifa: </span><span class="sc">{:.1f}</span><span class="st">&#39;</span>.<span class="bu">format</span>(ac.pos[<span class="dv">1</span>]))</span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">u&#39;UKF ile hesaplanan irtifa: </span><span class="sc">{:.1f}</span><span class="st">&#39;</span>.<span class="bu">format</span>(xs[<span class="op">-</span><span class="dv">1</span>][<span class="dv">2</span>]))</span></code></pre></div>
<pre><code>Gerçek irtifa: 2561.9
UKF ile hesaplanan irtifa: 2432.9</code></pre>
<p><img src="tser_ukf_08.png" /></p>
<p>Görüldüğü gibi irtifa tahmini daha zor hale geldi, bolca gürültü var,
fakat takip başarılı.</p>
<p>Birden Fazla Pozisyon Verisini Birleştirmek</p>
<p>GPS icat edilmeden önce gemiler ve uçaklar uzaklık ve açı üzerinden
konum bulma sistemleri kullanırlardı, VOR sistemi bunlardan biriydi.
Mesela bir uçakta iki tane VOR alıcısı olabilirdi, pilot bu alıcılardan
her birini farklı bir istasyona ayarlardı (radyoda doğru frekans ile
kanal bulmak gibi herhalde), ve her VOR alıcısı “radyal (radial)’’ denen
bir bilgiyi verirdi, bu bilgi VOR istasyonunun alıcıya olan açısıydı. Bu
iki radyalı, istasyon sinyal uzaklık kapasitesini kullanıp onun
etrafında bir çember çizerek, istasyonların bilinen yerlerini
kullanarak, ve çemberlerin kesişme noktasında uçağın olduğu yeri
bulabilirdiniz.</p>
<p>Ama tek bir kerelik kesişme bulmak, elle bu hesapları yapmak çok
hataya açık bir yaklaşım. Kalman filtrelemesi ile, ardı ardına, özyineli
olarak çok daha iyi hesap yapabiliriz. Problemi tarif edelim, elde iki
tane algılayıcı var, ve bilinen A, B istasyonlarına olan açıyı elde
ediyoruz,</p>
<p><img src="tser_ukf_09.png" /></p>
<p>Çemberler katlı çizildi, eğer algılayıcıda gürültü varsa çember
çizgisi daha kalın oluyor. İstasyon ile algılayıcı arasındaki açı
(bearing) şöyle hesaplanıyor,</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bearing(sensor, target_pos):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> math.atan2(target_pos[<span class="dv">1</span>] <span class="op">-</span> sensor[<span class="dv">1</span>], </span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>                      target_pos[<span class="dv">0</span>] <span class="op">-</span> sensor[<span class="dv">0</span>])</span></code></pre></div>
<p>Filtre her güncelleme için bir vektör içinde farklı iki algılayıcıdan
gelen iki tane ölçüm alıyor,</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> measurement(A_pos, B_pos, pos):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    angle_a <span class="op">=</span> bearing(A_pos, pos)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    angle_b <span class="op">=</span> bearing(B_pos, pos)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [angle_a, angle_b]</span></code></pre></div>
<p>Şimdi filtrelemeyi yapalım,</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy.random <span class="im">import</span> randn</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math, <span class="bu">filter</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fx_VOR(x, dt):</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    x[<span class="dv">0</span>] <span class="op">+=</span> x[<span class="dv">1</span>] <span class="op">*</span> dt</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    x[<span class="dv">2</span>] <span class="op">+=</span> x[<span class="dv">3</span>] <span class="op">*</span> dt</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>sa_pos <span class="op">=</span> [<span class="op">-</span><span class="dv">400</span>, <span class="dv">0</span>]</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>sb_pos <span class="op">=</span> [<span class="dv">400</span>, <span class="dv">0</span>]</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hx_VOR(x):</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># measurement to A</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    pos <span class="op">=</span> (x[<span class="dv">0</span>], x[<span class="dv">2</span>])</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> measurement(sa_pos, sb_pos, pos)</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> run_vor_filter(target_pos):</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>    np.random.seed(<span class="dv">123</span>)</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    std_noise <span class="op">=</span> math.radians(<span class="fl">0.5</span>)</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>    Q <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>    dt<span class="op">=</span><span class="fl">0.1</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>    kappa<span class="op">=</span><span class="fl">0.0</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>    points <span class="op">=</span> <span class="bu">filter</span>.MerweScaledSigmaPoints(n<span class="op">=</span><span class="dv">4</span>, alpha<span class="op">=</span><span class="fl">.1</span>, beta<span class="op">=</span><span class="fl">2.</span>, kappa<span class="op">=</span>kappa)</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>    f <span class="op">=</span> <span class="bu">filter</span>.UKF(dim_x<span class="op">=</span><span class="dv">4</span>, dim_z<span class="op">=</span><span class="dv">2</span>, hx<span class="op">=</span>hx_VOR, fx<span class="op">=</span>fx_VOR, points<span class="op">=</span>points)</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>    f.x <span class="op">=</span> np.array([target_pos[<span class="dv">0</span>], <span class="fl">1.</span>, target_pos[<span class="dv">1</span>], <span class="fl">1.</span>])</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>    q <span class="op">=</span> <span class="bu">filter</span>.Q_discrete_white_noise(<span class="dv">2</span>, dt, Q)</span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>    f.Q[<span class="dv">0</span>:<span class="dv">2</span>, <span class="dv">0</span>:<span class="dv">2</span>] <span class="op">=</span> q</span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>    f.Q[<span class="dv">2</span>:<span class="dv">4</span>, <span class="dv">2</span>:<span class="dv">4</span>] <span class="op">=</span> q</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>    f.R <span class="op">*=</span> std_noise<span class="op">**</span><span class="dv">2</span></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>    f.P <span class="op">*=</span> <span class="dv">1000</span>    </span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>    xs, txs <span class="op">=</span> [], []</span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">300</span>):</span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>        target_pos[<span class="dv">0</span>] <span class="op">+=</span> <span class="dv">1</span> <span class="op">+</span> randn()<span class="op">*</span><span class="fl">0.0001</span></span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a>        target_pos[<span class="dv">1</span>] <span class="op">+=</span> <span class="dv">1</span> <span class="op">+</span> randn()<span class="op">*</span><span class="fl">0.0001</span></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>        txs.append((target_pos[<span class="dv">0</span>], target_pos[<span class="dv">1</span>]))</span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> measurement(sa_pos, sb_pos, target_pos)</span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a>        z[<span class="dv">0</span>] <span class="op">+=</span> randn() <span class="op">*</span> std_noise</span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a>        z[<span class="dv">1</span>] <span class="op">+=</span> randn() <span class="op">*</span> std_noise</span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a>        f.predict(dt<span class="op">=</span>dt)</span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a>        f.update(z)</span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true" tabindex="-1"></a>        xs.append(f.x)</span>
<span id="cb13-45"><a href="#cb13-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-46"><a href="#cb13-46" aria-hidden="true" tabindex="-1"></a>    xs <span class="op">=</span> np.asarray(xs)</span>
<span id="cb13-47"><a href="#cb13-47" aria-hidden="true" tabindex="-1"></a>    txs <span class="op">=</span> np.asarray(txs)</span>
<span id="cb13-48"><a href="#cb13-48" aria-hidden="true" tabindex="-1"></a>    plt.plot(xs[:, <span class="dv">0</span>], xs[:, <span class="dv">2</span>])</span>
<span id="cb13-49"><a href="#cb13-49" aria-hidden="true" tabindex="-1"></a>    plt.plot(txs[:, <span class="dv">0</span>], txs[:, <span class="dv">1</span>])</span>
<span id="cb13-50"><a href="#cb13-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-51"><a href="#cb13-51" aria-hidden="true" tabindex="-1"></a>run_vor_filter(target_pos <span class="op">=</span> [<span class="dv">100</span>, <span class="dv">200</span>])</span>
<span id="cb13-52"><a href="#cb13-52" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_ukf_10.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_ukf_10.png" /></p>
<p>Sonuç oldukca iyi. Başlangıçta biraz hata var ama hata hemen
düzeliyor, ve gerçeğe oldukca yakın hesabı elde etmeye başlıyoruz.
Şimdi, problemin gayrı-lineerliğini iyi gözlemlemek için hedefi iki
istasyon arasına, aynı y-ekseninde olacak şekilde koyacağım, bu sigma
ortalamalarındaki gayrı-lineerliği daha çok ortaya çıkartacak, çünkü açı
sıfır derece etrafında olacak, ama açı sıfır altına inmeye başlayınca
birdenbire çok büyük bir açı hesaplanıyor olacak tabii, çünkü orada
<span class="math inline">\(2\pi\)</span> açısı var. Bu tabii ki
filtrenin işleyişini oldukca bozuyor,</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>run_vor_filter(target_pos <span class="op">=</span> [<span class="dv">100</span>, <span class="dv">0</span>])</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_ukf_11.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_ukf_11.png" /></p>
<p>Not:</p>
<p>Filtrenin ismindeki “unscented’’ kelimesi nereden geliyor? Bu kelime
ilk kez”unscented transform’’ bağlamında bu kavramı icat eden kişi
tarafından kullanılmış, fakat yazar o makalede niye kelimeyi
kullandığını anlatmamış. Anlamsal olarak terimin çok uyduğu söylenemez,
belki “scent’’ kullanımı İngilizce”iz takibi’‘, “iz sürme’’ çağrışımı
yaptığı için, bu filtre, örneklem bazlı parçacık filtreleri gibi, bir
hipotez peşinden gitmiyor (o alandaki parçacıkları arttırıp), hep
deterministik seçilen belli noktaları kullanıyor. İsmin belki buradan
geldiği düşünülebilir.</p>
<p>Kodlar</p>
<p><a href="filter.py">filter.py</a>, <a href="util.py">util.py</a></p>
<p>Kaynaklar</p>
<p>[1] Labbe, <em>Kalman and Bayesian Filters in Python</em>, <a
href="https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python">https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python</a></p>
<p>[2] Van der Merwe, <em>Sigma-Point Kalman Filters for Probabilistic
Inference in Dynamic State-Space Models, dissertation (2004)</em>,<a
href="http://www.cslu.ogi.edu/publications/ps/merwe04.pdf">http://www.cslu.ogi.edu/publications/ps/merwe04.pdf</a></p>
<p>[3] Julier, <em>The Scaled Unscented Transformation</em>, <a
href="https://www.cs.unc.edu/~welch/kalman/media/pdf/ACC02-IEEE1357.PDF">https://www.cs.unc.edu/~welch/kalman/media/pdf/ACC02-IEEE1357.PDF</a></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
