<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Ders 15</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<h1 id="ders-15">Ders 15</h1>
<p>Bu önemli bir ders, ana konumuz yansıtma / izdüşüm (projection). Mesela <span class="math inline">\(b\)</span> vektörünü alıp <span class="math inline">\(a\)</span> üzerine olan &quot;yansımasını'' hesaplamak. Bu yansımayı sanki <span class="math inline">\(a\)</span>'ya dik bir şekilde bir lamba açtık ve oradan gelen ışık sonucunda <span class="math inline">\(b\)</span>'nin <span class="math inline">\(a\)</span> üzerine düşen &quot;gölgesini'' hesaplıyoruz gibi düşünebiliriz.</p>
<div class="figure">
<img src="15_1.png" />

</div>
<p>Yansıtmayı yapmak için <span class="math inline">\(b\)</span>'nin <span class="math inline">\(a\)</span>'ya en yakın olduğu noktayı bulmalıyım.</p>
<div class="figure">
<img src="15_2.png" />

</div>
<p>Bu noktaya <span class="math inline">\(p\)</span> diyebilirim, <span class="math inline">\(b,a\)</span> arasındaki en kısa mesafeye de bir nevi &quot;hata (error)'' olarak bakabilirim, bu mesafeye <span class="math inline">\(e\)</span> harfini vereceğim. Hata sözünü kullandık, çünkü, sanki <span class="math inline">\(b\)</span>, <span class="math inline">\(a\)</span>'dan &quot;sapmış'' ve biz bu sapmanın ölçüsünü buluyoruz gibi bakılabilir bu probleme.</p>
<p>Peki niye <span class="math inline">\(e = b-p\)</span>? Şu resme bakalım,</p>
<div class="figure">
<img src="15_3.png" />

</div>
<p>Basit vektör aritmetiğinden biliyoruz ki, birbirine zincirleme duran vektörlerde, zincirin başından sonuna direk gidilmek için zincirdeki tüm vektörler birbiriyle toplanır. Üstteki resimde <span class="math inline">\(b = p + e\)</span>. Ufak bir cebirsel işlemle <span class="math inline">\(e = b - p\)</span> buluruz.</p>
<p>Peki <span class="math inline">\(p\)</span>'yi nasıl bulacağız? Amacımız bu, yansımayı bulmak. Muhakkak elimizde bir dik üçgen var, eğer trigonometri yapıyor olsaydık, <span class="math inline">\(\cos, \sin\)</span>, vs kullanıp birşeyler bulabilirdik. Lıneer Cebir'in metotları çok daha temiz.</p>
<p>Bildiklerimiz neler? Biliyoruz ki <span class="math inline">\(p\)</span>, <span class="math inline">\(a\)</span>'nin bir katı, çünkü aynı çizgi üzerindeler.</p>
<p><span class="math display">\[ p = xa \]</span></p>
<p>diyelim. O zaman bulmak istediğim bu <span class="math inline">\(x\)</span> sayısı.</p>
<p>Bildiğimiz bir diğer şey, <span class="math inline">\(e\)</span> ve <span class="math inline">\(a\)</span>'nin birbirine dik olduğu. İki vektörün dik olmasının tercümesi nedir? İki vektörün noktasal çarpımının sıfır olması. O zaman</p>
<p><span class="math display">\[ a^T e = 0 \]</span></p>
<p><span class="math display">\[ a^T(b - p) = 0 \]</span></p>
<p><span class="math display">\[ a^T(b - xa) = 0 \]</span></p>
<p>Tekrar düzenlersem</p>
<p><span class="math display">\[ xa^Ta = a^Tb \]</span></p>
<p>Sol taraftaki <span class="math inline">\(a^Ta\)</span> bir tek sayı artık (çünkü bir noktasal çarpım), onu alıp sağ tarafa bölüm olarak taşıyabilirim,</p>
<p><span class="math display">\[ x = \frac{ a^Tb}{a^Ta} \]</span></p>
<p>İşte ihtiyacımız olan katsayı bu. Bunun içinde cosine bir şekilde var tabii, ama trigonometriye hiç girmemize gerek yok, pür vektörler ile bu işi hallettik. Sonra bu <span class="math inline">\(x\)</span>'i alıp <span class="math inline">\(p = ax\)</span> ile <span class="math inline">\(p\)</span>'yi hesaplıyoruz. Hepsini biraraya koyarsak,</p>
<p><span class="math display">\[ p = a\frac{ a^Tb}{a^Ta} \]</span></p>
<p>Biraz zihin egzersizi yapalım: eğer <span class="math inline">\(b\)</span>'yi iki katına çıkarırsam, <span class="math inline">\(p\)</span> ne olur? İki katına çıkar. Peki <span class="math inline">\(a\)</span>'yi iki katına çıkarırsam? Üstteki resmi düşünürsek, hiç değişmemeli. Cebirsel olarak ta bunu görebiliriz, üstteki ve alttaki <span class="math inline">\(a\)</span>'lardaki artış birbirini iptal edecektir.</p>
<p>Şimdi, olaya matrissel olarak bakmak gerekirse, bir yansıtma matrisi <span class="math inline">\(P\)</span> olsun istiyorum, öyle ki</p>
<p><span class="math display">\[ p = P b \]</span></p>
<p>olsun, yani bu matris <span class="math inline">\(b\)</span>'ye uygulanınca <span class="math inline">\(p\)</span>'yi bulayım. O zaman iki üstteki <span class="math inline">\(p\)</span> formülü içinden <span class="math inline">\(b\)</span> haricindeki kısımları çekip çıkartmam lazım.</p>
<p><span class="math display">\[ P  = \frac{ aa^T}{a^Ta} \]</span></p>
<p>Bu bir matris. Bölünen bir matris, bölen bir skalar. Bazı örnekleri hesaplayalım, ve grafikleyelim,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">o <span class="op">=</span> np.array([<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>])
b <span class="op">=</span> np.array([[<span class="fl">3.</span>,<span class="fl">3.</span>,<span class="fl">3.</span>]]).T
a <span class="op">=</span> np.array([[<span class="dv">0</span>,<span class="fl">5.</span>,<span class="fl">5.</span>]]).T
P <span class="op">=</span> a.dot(a.T) <span class="op">/</span> a.T.dot(a)
p <span class="op">=</span> P.dot(b)
<span class="bu">print</span> P
<span class="bu">print</span> p</code></pre></div>
<pre><code>[[ 0.   0.   0. ]
 [ 0.   0.5  0.5]
 [ 0.   0.5  0.5]]
[[ 0.]
 [ 3.]
 [ 3.]]</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> sys<span class="op">;</span> sys.path.append(<span class="st">&#39;../../vision/vision_02&#39;</span>)
<span class="im">from</span> mpl_toolkits.mplot3d <span class="im">import</span> Axes3D

<span class="im">import</span> plot3d
fig <span class="op">=</span> plt.figure()<span class="op">;</span> ax <span class="op">=</span> Axes3D(fig)

plot3d.plot_vector(fig, o, b)
ax.hold(<span class="va">True</span>)
plot3d.plot_vector(fig, o, a, <span class="st">&#39;cyan&#39;</span>)
ax.hold(<span class="va">True</span>)
plot3d.plot_vector(fig, o, p, <span class="st">&#39;yellow&#39;</span>)
ax.hold(<span class="va">True</span>)
plt.savefig(<span class="st">&#39;linear_15_01.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="linear_15_01.png" />

</div>
<p><span class="math inline">\(P\)</span> ilginç bir matristir. Özellikleri nedir?</p>
<p>Kolon uzayı neydi? Bir vektörü o matris ile çarptığımızda sonuç her zaman matrisin kolon uzayındadır. <span class="math inline">\(P\)</span>'nin kolon uzayı <span class="math inline">\(a\)</span>'dan geçen çizgidir, seviyesi (rank) 1'dir, simetriktir (bir vektörü devriği ile sağdan çarpınca sonuç matrisi simetrik olur), yani <span class="math inline">\(P^T = P\)</span>.</p>
<p>Eger yansıtma matrisini iki kere uygularsam ne olur? Ikinci yansıtmanin hicbir etkisi olmamasi gerekir, yani <span class="math inline">\(P = P^2\)</span>.</p>
<p>Eğer daha yüksek boyutlara geçersek? O zaman üstüne yansıtma yaptığımız bir çizgi olmayacak, üç boyutta bir düzlem, daha yüksek boyutlarda N boyutlu bir altuzay olacak.</p>
<p>Yansıtma neye yarar? Önemli faydalarından biri <span class="math inline">\(Ax = b\)</span> denklemini çözerken ise yarar. Bazen bu denklemin çözümü yoktur. Belki bilinmeyenlerin sayısından daha fazla denklem verilmiştir. O zaman tam denklemi çözmeye uğraşmak yerine, çözülebilecek en yakın şeyi çözmeye uğraşmak gerekir, yani</p>
<p><span class="math display">\[ A\hat{x} = p \]</span></p>
<p>ki <span class="math inline">\(p\)</span>, <span class="math inline">\(b\)</span>'nin <span class="math inline">\(A\)</span>'nin kolon uzayına yansıtılmış hali olacak. Bir &quot;çözüm'' olmak kolon uzayının bir kombinasyonu olmak demek ise, bu kolon uzayına yansıtılan <span class="math inline">\(b\)</span> üzerinden çözümü elde edebilmeyi umabiliriz. 3 boyutta</p>
<div class="figure">
<img src="15_4.png" />

</div>
<p>Üzerine yansıtma yapılacak düzlem nedir? Düzlemi belirlemek için onu tanımlayacak bir baz bulabilirim, iki vektör yani, mesela <span class="math inline">\(a_1,a_2\)</span> diyelim.</p>
<div class="figure">
<img src="15_5.png" />

</div>
<p>Bu iki vektörün birbirine dik olması şart değil, bağımsız olması gerekli ama. <span class="math inline">\(a_1,a_2\)</span>'nin yarattığı düzlem <span class="math inline">\(A\)</span>'nin kolon uzayı ile aynıdır, yani</p>
<p><span class="math display">\[ A = 
\left[\begin{array}{rr}
\uparrow &amp;  \uparrow \\
a_1 &amp;   a_2 \\
\downarrow &amp;  \downarrow 
\end{array}\right]
 \]</span></p>
<p><span class="math inline">\(e\)</span> düzleme diktir. Peki <span class="math inline">\(p\)</span> nedir? <span class="math inline">\(a\)</span> vektörlerinin bir kombinasyonudur, yani</p>
<p><span class="math display">\[ p = \hat{x}_1a_1 + \hat{x}_2a_2 \]</span></p>
<p>ya da daha temiz olarak</p>
<p><span class="math display">\[ p = A\hat{x} \]</span></p>
<p>Aradığımız <span class="math inline">\(\hat{x}\)</span>. Anahtar şurada, <span class="math inline">\(e\)</span> yani</p>
<p><span class="math display">\[  b - A\hat{x}\]</span></p>
<p>düzleme dik. Ve düzleme dik ise, düzlemdeki <em>her vektöre</em> dik. O zaman</p>
<p><span class="math display">\[ a_1^T( b - A\hat{x}) = 0\]</span></p>
<p><span class="math display">\[ a_2^T( b - A\hat{x}) = 0\]</span></p>
<p>Fakat üstteki gibi iki ayrı formül yazmak yerine, matris formu kullanamaz mıyım?</p>
<p><span class="math display">\[ 
\left[\begin{array}{rrr}
 &amp; a_1^T &amp; \\
 &amp; a_2^T &amp; 
\end{array}\right]
(b - A\hat{x}) = 
\left[\begin{array}{rrr}
0 \\
0 
\end{array}\right]
 \]</span></p>
<p>Ya da</p>
<p><span class="math display">\[ A^T(b - A\hat{x})  = 0 \]</span></p>
<p>Bu problemin çizgizel versiyonunde <span class="math inline">\(A\)</span> yerine <span class="math inline">\(a\)</span> kullanmıştık, ve <span class="math inline">\(a\)</span> tek bir vektördü. Zaten <span class="math inline">\(A\)</span> yerine <span class="math inline">\(a\)</span> kullanırsak, aynı formülü elde ediyoruz.</p>
<p>Bir soru soralım şimdi: <span class="math inline">\(e\)</span>, yani <span class="math inline">\(b - A\hat{x}\)</span> hangi uzayın içindedir? Cevap, <span class="math inline">\(A^T\)</span>'nin sıfır uzayındadır (nullspace), yani <span class="math inline">\(N(A^T)\)</span> içinde. Sıfır uzayı hakkında neler biliyoruz? Sıfır uzayı ve kolon uzayları birbirine dikgendir (orthogonal). O zaman <span class="math inline">\(e\)</span> <span class="math inline">\(N(A^T)\)</span> içinde ise, <span class="math inline">\(e \perp C(A)\)</span> demektir, yani <span class="math inline">\(e\)</span> de kolon uzayına dikgendir. Devam edelim, üstteki formülü düzenlersek,</p>
<p><span class="math display">\[ A^TA\hat{x} = A^Tb \]</span></p>
<p>Dikkat edersek, önceki versiyonda <span class="math inline">\(a^Ta\)</span> bir tek sayıydı, böylece onu bölen olarak sağa geçirmiştik. Şimdi ne yapacağız?</p>
<p><span class="math display">\[ \hat{x} = (A^TA)^{-1}A^Tb \]</span></p>
<p>Daha önce</p>
<p><span class="math display">\[ p = A\hat{x} \]</span></p>
<p>demiştik, o zaman</p>
<p><span class="math display">\[ p = A(A^TA)^{-1}A^Tb \]</span></p>
<p>Demek ki yansıtma matrisi eşitliğin sağında <span class="math inline">\(b\)</span> harici olan tüm semboller,</p>
<p><span class="math display">\[ P = A(A^TA)^{-1}A^T \]</span></p>
<p>Şimdi dikkat, bilerek bir hata yapacağım, üstteki formülün sağ tarafını cebirsel olarak manipüle edeceğim</p>
<p><span class="math display">\[  AA^{-1}(A^T)^{-1}A^T = I\]</span></p>
<p>Bu yanlış duruyor, <span class="math inline">\(P\)</span> birim matris olamaz. Nerede hata yaptık? Manipülasyon mekanik, teknik olarak doğru. Hata <span class="math inline">\(A\)</span>'nin kare matrisi olmamasında. O sebeple <span class="math inline">\(A^TA\)</span>'yi üstte yaptığım gibi parçalayamam çünkü bir matrisin tersini alabilmek için onun en azından kare olması gerekir (bu yeterli şart değil tabii ki).</p>
<p>Yansıma matrislerinin simetrik olmasını bekliyordum, ve bakıyorum ki öyle.</p>
<p><span class="math display">\[ P^T = P \]</span></p>
<p>ve</p>
<p><span class="math display">\[ P^2 = P \]</span></p>
<p>Kontrol edelim</p>
<p><span class="math display">\[=  A(A^TA)^{-1}A^T \ A(A^TA)^{-1}A^T \]</span></p>
<p><span class="math display">\[=  A(A^TA)^{-1}\cancel{A^T \ A(A^TA)^{-1}}A^T \]</span></p>
<p><span class="math display">\[=  A(A^TA)^{-1}A^T \]</span></p>
<p>Üstteki son ifade <span class="math inline">\(P\)</span>'ye eşit.</p>
<p>Uygulama: En Az Kareler (Least Squares)</p>
<p>Ne zaman formülden daha fazla veri vardır? Mesela veriye çizgi &quot;uydurmak (fitting)'' istediğimde durum budur. Diyelim ki <span class="math inline">\(t,D\)</span> eksenleri üzerinde</p>
<div class="figure">
<img src="15_6.png" />

</div>
<p>Veri şöyle olsun, <span class="math inline">\((1,1),(2,2),(3,2)\)</span>, üç tane nokta. Bu noktalara en yakın şekilde geçecek çizgi kabaca şöyle olur [çizgi pek düz olmadı ama neyse].</p>
<div class="figure">
<img src="15_7.png" />

</div>
<p>Bu problem ödevde <span class="math inline">\(b = C+Dt\)</span> olarak gösterildi. O zaman</p>
<p><span class="math display">\[ C + D = 1 \]</span></p>
<p><span class="math display">\[ C + 2D = 2 \]</span></p>
<p><span class="math display">\[ C + 3D = 2 \]</span></p>
<p>Bu tür problemleri çözerken anahtar yaklaşım bu, formülü yazalım, ve çözmek istediğimiz (ama çözemediğimiz) denklemler serisini ortaya çıkaralım. Matris olarak yazarsak,</p>
<p><span class="math display">\[ 
\underbrace{
\left[\begin{array}{rr}
1 &amp; 1 \\
1 &amp; 2 \\
1 &amp; 3 
\end{array}\right]
}_{A}
\underbrace{
\left[\begin{array}{r}
C  \\
D  
\end{array}\right]
}_{x}
=
\underbrace{
\left[\begin{array}{r}
1 \\
2 \\
2  
\end{array}\right]
}_{b}
 \]</span></p>
<p>Gördüğümüz gibi 3 tane denklem ve 2 tane bilinmeyen var. Yani verilen (denklemler) bilinmeyenlerden daha fazla. Bu sebeple bazı denklemler (ya da hiçbiri) doğal olarak tam olarak uymayacak. Amaç <span class="math inline">\(Ax = b\)</span>'yi çözmek değil, yansımayı çözmek. O zaman <span class="math inline">\(A\)</span>'yi alttaki yerine koyunca, çözüm ortaya çıkacaktır.</p>
<p><span class="math display">\[ \hat{x} = (A^TA)^{-1}A^Tb \]</span></p>
<p>Matris tersi kullanmadan vektörün düzlem üzerine yansıtmasını daha direk bir şekilde şöyle anlatabilirdik [1]: hatırlarsak, bir <span class="math inline">\(u\)</span> vektörünün diğer bir <span class="math inline">\(v\)</span> vektörünün üzerine yansıtması (operasyonu <span class="math inline">\(\mathrm{proj}\)</span> ile belirtelim)</p>
<p><span class="math display">\[ \mathrm{proj}_v(u) = \frac{u \cdot v}{||v||^2} \]</span></p>
<p>idi. O zaman <span class="math inline">\(u\)</span>'nun bir düzlem üzerine yansıtmasını <span class="math inline">\(u\)</span>'nin içinde o düzleme dik olan bileşenlerini çıkartarak bulabiliriz. Düzlemi yatay olarak düşünürsek <span class="math inline">\(u\)</span> içinden düzleme dikey olan bileşenleri çıkartınca geriye <span class="math inline">\(u\)</span>'nun yatay bileşenleri kalır, bu da <span class="math inline">\(u\)</span>'nun düzleme yansıtılmış hali demektir. Peki düzleme dikey olan vektörü nasıl buluyoruz? Bu vektör zaten biliniyor, bu vektör düzlemin normal vektöründen başka bir şey değil. Normal vektor <span class="math inline">\(n\)</span> icin formul,</p>
<p><span class="math display">\[ \mathrm{proj}_{\textrm{düzlem}}(u) = u - \mathrm{proj}_{n}(u) = u - \frac{u \cdot n}{||n||^2} n \]</span></p>
<p>Bir örnek üzerinde görelim,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> sys<span class="op">;</span> sys.path.append(<span class="st">&#39;../../vision/vision_02&#39;</span>)
<span class="im">from</span> mpl_toolkits.mplot3d <span class="im">import</span> Axes3D
<span class="im">import</span> plot3d
o <span class="op">=</span> np.array([<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>])
u <span class="op">=</span> np.array([<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>])
n <span class="op">=</span> np.array([<span class="op">-</span><span class="dv">1</span><span class="op">/</span><span class="fl">3.</span>,<span class="dv">2</span><span class="op">/</span><span class="fl">3.</span>,<span class="dv">2</span><span class="op">/</span><span class="fl">3.</span>])

fig <span class="op">=</span> plt.figure()
ax <span class="op">=</span> Axes3D(fig)
plot3d.plot_plane(ax, o, n, size<span class="op">=</span><span class="dv">5</span>)
plot3d.plot_vector(fig, o, u)
plot3d.plot_vector(fig, o, <span class="dv">3</span><span class="op">*</span>np.array(n), <span class="st">&#39;red&#39;</span>)
plt.savefig(<span class="st">&#39;15_8.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="15_8.png" />

</div>
<p>Mavi vektörü düzleme yansıtmak istiyoruz.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">p <span class="op">=</span> u <span class="op">-</span> (np.dot(u,n) <span class="op">/</span> np.dot(n,n)) <span class="op">*</span> n
<span class="bu">print</span> p</code></pre></div>
<pre><code>[ 4.  1.  1.]</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">fig <span class="op">=</span> plt.figure()
ax <span class="op">=</span> Axes3D(fig)
plot3d.plot_plane(ax, o, n, size<span class="op">=</span><span class="dv">5</span>)
plot3d.plot_vector(fig, o, u)
plot3d.plot_vector(fig, o, p, <span class="st">&#39;cyan&#39;</span>)
plot3d.plot_vector(fig, o, <span class="dv">3</span><span class="op">*</span>np.array(n), <span class="st">&#39;red&#39;</span>)
plt.savefig(<span class="st">&#39;15_9.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="15_9.png" />

</div>
<p>Bir Düzlem Üzerindeki İki Vektör Arasındaki Açıyı Bulmak</p>
<p>Şu resme bakalım,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">n <span class="op">=</span> np.array([<span class="op">-</span><span class="dv">1</span><span class="op">/</span><span class="fl">3.</span>,<span class="dv">2</span><span class="op">/</span><span class="fl">3.</span>,<span class="dv">2</span><span class="op">/</span><span class="fl">3.</span>])
o <span class="op">=</span> np.array([<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>])
u1 <span class="op">=</span> np.array([<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>])
u2 <span class="op">=</span> np.array([<span class="op">-</span><span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">3</span>])

fig <span class="op">=</span> plt.figure()
ax <span class="op">=</span> Axes3D(fig)
plot3d.plot_plane(ax, o, n, size<span class="op">=</span><span class="dv">5</span>)
p1 <span class="op">=</span> u1 <span class="op">-</span> (np.dot(u1,n) <span class="op">/</span> np.dot(n,n)) <span class="op">*</span> n
p2 <span class="op">=</span> u2 <span class="op">-</span> (np.dot(u2,n) <span class="op">/</span> np.dot(n,n)) <span class="op">*</span> n
plot3d.plot_vector(fig, o, <span class="dv">3</span><span class="op">*</span>n,<span class="st">&#39;red&#39;</span>)
plot3d.plot_vector(fig, o, u1)
plot3d.plot_vector(fig, o, u2)
plot3d.plot_vector(fig, o, p1,<span class="st">&#39;cyan&#39;</span>)
plot3d.plot_vector(fig, o, p2,<span class="st">&#39;skyblue&#39;</span>)
plot3d.plot_vector(fig, o, <span class="fl">0.5</span><span class="op">*</span>np.cross(p1,p2),<span class="st">&#39;yellow&#39;</span>)
ax.view_init(elev<span class="op">=</span><span class="dv">30</span>, azim<span class="op">=</span><span class="dv">30</span>)
plt.savefig(<span class="st">&#39;15_10.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="15_10.png" />

</div>
<p>Koyu mavi iki vektörün düzlem üzerinde yansıtılmasını görüyoruz (açık ve biraz daha açık mavi iki vektör). Bu vektörler arasındaki açı nedir? Tabii açı derken <em>hangi yöne doğru açı</em> bulunmak isteniyor, bu soru da önemli. Çoğu zaman bir referans vektörüne olan ikinci bir vektörün saat yönü ya da onun tersi yöndeki açısını isteriz. Eger açıyı bilinen</p>
<p><span class="math display">\[ \theta = \arccos \frac{u \cdot v}{||u||||v|||}\]</span></p>
<p>ile hesaplarsak, bu hesap bize her zaman iki vektör arası en &quot;yakın'' açıyı verir (yani 180'den daha az olan açıyı). Fakat biz mesela saat yönü tersindeki açıyı istiyorsak, o zaman potansiyel olarak 180'den fazla açılar da elde edebilmemiz gerekir.</p>
<p>Çözüm için çapraz çarpım kullanabiliriz, <span class="math inline">\(n \cdot (u \times v)\)</span> hesabına bakarız, bu hesap artı ise üstteki <span class="math inline">\(\theta\)</span>'yi olduğu gibi alırız, değil ise <span class="math inline">\(360-\theta\)</span>'yi kullanırız. Bunun sebebi <span class="math inline">\(u \times v\)</span> bize sağ el kuralına göre, bkz [2], <span class="math inline">\(u,v\)</span> referanslı bir üçüncü vektör veriyor. Sağ el kuralınında eğer <span class="math inline">\(u\)</span>'dan başlayıp <span class="math inline">\(v\)</span>'ye saat yönü tersine giderken 180 dereceden az bir gidiş yeterli ise, üçüncü vektör yukarı doğru işaret ediyor, yoksa aşağı doğru. Mesela üstteki örnekte vektör düzlem normaline ters, yani aşağı. Bu bize ilgilendiğimiz gidiş yönündeki açının 180'den fazla olduğuna dair bir işaret, o zaman <span class="math inline">\(360 - \theta\)</span> kullanmamız gerekir. Noktasal çarpım aynı yön / terslik hesabı için; üçüncü vektörün düzlem normali ile noktasal çarpımı eğer aynı yönde ise artı, değil ise eksi olacağı için 360'dan çıkartma irdelemesini bu şekilde yapabiliriz.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy.linalg <span class="im">as</span> lin
deg <span class="op">=</span> np.rad2deg(np.arccos(np.dot(p1,p2) <span class="op">/</span> (lin.norm(p1)<span class="op">*</span>lin.norm(p2))))
s <span class="op">=</span> np.dot(n, np.cross(p1,p2))
<span class="bu">print</span> <span class="st">&#39;deg&#39;</span>, deg
<span class="cf">if</span> s <span class="op">&lt;</span> <span class="dv">0</span>: <span class="bu">print</span> <span class="st">&#39;360 - deg =&#39;</span>, <span class="dv">360</span><span class="op">-</span>deg
<span class="cf">else</span>: <span class="bu">print</span> <span class="st">&#39;deg&#39;</span>, deg</code></pre></div>
<pre><code>deg 135.0
360 - deg = 225.0</code></pre>
<p>Ekler</p>
<p>Yansıtma (Projection)</p>
<p>Vektör <span class="math inline">\(\vec{a}\)</span>'nin <span class="math inline">\(\vec{b}\)</span> yönündeki büyüklüğü, yansıması nedir sorusunun cevabı da noktasal çarpım ile bulunabilir,</p>
<p><span class="math display">\[
\vec{a}\cdot\vec{b} = ||\vec{a}||||\vec{b}||\cos\theta
\]</span></p>
<p>formülünü biraz manipüle edersek cevabı alabiliriz,</p>
<p><span class="math display">\[
\frac{\vec{a}\cdot\vec{b}}{||\vec{b}||} = ||\vec{a}|| \cos \theta
\]</span></p>
<div class="figure">
<img src="dot_product_projection.png" />

</div>
<p>Eşitliğin sağ tarafı <span class="math inline">\(||\vec{a}|| \cos \theta\)</span> aradığımız büyüklük, onu elde etmek için <span class="math inline">\(\frac{\vec{a}\cdot\vec{b}}{||\vec{b}||}\)</span> noktasal çarpımını kullanabileceğimizi görüyoruz [4].</p>
<p>Eğer büyüklüksel, skalar yansımasını bulabiliyorsak, bir vektörün diğeri yönündeki tamamen yansımasını da bulabilirdik, <span class="math inline">\(\vec{b}\)</span> yönünü <span class="math inline">\(\frac{\vec{b}}{||\vec{b}||}\)</span> birim vektörü ile gösteriyoruz, o yöndeki <span class="math inline">\(\vec{a}\)</span> büyüklüğünü biraz önce bulduk, <span class="math inline">\(\frac{\vec{a}\cdot\vec{b}}{||\vec{b}||}\)</span>.</p>
<p>Yönü büyüklük ile çarpınca istenilen vektör elde edilmiş olur [3], <span class="math inline">\(\vec{a}\)</span>'nin <span class="math inline">\(\vec{b}\)</span> yönündeki yansıması <span class="math inline">\(\mathrm{proj}_{\vec{b}} \vec{a}\)</span></p>
<p><span class="math display">\[
\mathrm{proj}_{\vec{b}} \vec{a} = \frac{\vec{a}\cdot\vec{b}}{||\vec{b}||} \frac{\vec{b}}{||\vec{b}||}
\]</span></p>
<p><span class="math display">\[
= \frac{\vec{a}\cdot\vec{b}}{||\vec{b}||^2} \vec{b}
\]</span></p>
<p>Baz Değişimi</p>
<p>Aksi belirtilmediği sürece verili herhangi bir matrisin standart <span class="math inline">\(i,j,k,..\)</span> baza sahip olduğu kabul edilir, bu sayede mesela <span class="math inline">\([\begin{array}{cc}1&amp;2\end{array}]\)</span> vektörünü <span class="math inline">\(i\)</span>'dan 1 tane <span class="math inline">\(j\)</span>'den iki tane şeklinde gösterebiliriz [6].</p>
<p>Her temel baz tek bir eksen icin 1 digeri icin 0 degerindedir,</p>
<p><span class="math display">\[
i = \left[\begin{array}{c}1 \\ 0 \end{array}\right], \quad
j = \left[\begin{array}{c}0 \\ 1 \end{array}\right]
\]</span></p>
<div class="figure">
<img src="ijbasis.png" />

</div>
<p>2 boyutta herhangi bir matrisin aslında bu &quot;standart baz üzerinden'' tanımlanmış olduğu kabul edilir,</p>
<p><span class="math display">\[
Bx = 
\left[\begin{array}{ccc}
1 &amp; 0 \\ 0 &amp; 1
\end{array}\right]
\left[\begin{array}{c}
x_1 \\ x_2
\end{array}\right] =
x_1 \left[\begin{array}{c}
1 \\ 0
\end{array}\right] +
x_2 \left[\begin{array}{c}
0 \\ 1
\end{array}\right]
\]</span></p>
<p>Bu bakış açısı faydalı çünkü böylece herhangi bir transformasyona baz değişimi olarak bakılabilir, tek gereken yeni <span class="math inline">\(i\)</span>, ve yeni <span class="math inline">\(j\)</span>'nin (daha üst boyutlarda <span class="math inline">\(k\)</span>, vs) nereye işaret ettiğini bilmek. Mesela kaykılma (shear) transformasyonunu alırsak, tüm dünyayı 45 derece sağa kaydırmak istiyoruz, bunun için yeni <span class="math inline">\(i,j\)</span></p>
<p><span class="math display">\[
i = \left[\begin{array}{c}1 \\ 0 \end{array}\right], \quad
j = \left[\begin{array}{c}1 \\ 1 \end{array}\right]
\]</span></p>
<p>Bu bazla soldan çarparsak, mesela bir <span class="math inline">\([\begin{array}{cc}1&amp;2\end{array}]^T\)</span> vektörü,</p>
<div class="figure">
<img src="shear.jpg" />

</div>
<p>haline gelir.</p>
<p>Baz Değişimi Bakışı Açısı ve Yansıtma</p>
<p>Yansıtmayı baz değişimi (change of basis) olarak görürsek ilginç bir görüşe daha kavuşuyoruz. Biliyoruz ki <span class="math inline">\(x\)</span> vektörünü transforme edip yeni bir <span class="math inline">\(B\)</span> bazına taşımak için <span class="math inline">\(x\)</span>'i soldan çarpmak yeterli, mesela</p>
<p><span class="math display">\[
Bx = 
\left[\begin{array}{ccc}
a &amp; b \\ c &amp; d
\end{array}\right]
\left[\begin{array}{c}
x_1 \\ x_2
\end{array}\right] =
x_1 \left[\begin{array}{c}
a \\ c
\end{array}\right] +
x_2 \left[\begin{array}{c}
b \\ d
\end{array}\right]
\]</span></p>
<p>Her ayri baz <span class="math inline">\(B\)</span> kolonlari icinde, her kolon 2 boyutlu, yani 2 boyuttan 2 boyuta baz degisimi yapmis olduk. Fakat boyut degisimi de olabilirdi, mesela</p>
<p><span class="math display">\[
Bx = 
\left[\begin{array}{ccc}
a &amp; b 
\end{array}\right]
\left[\begin{array}{c}
x_1 \\ x_2
\end{array}\right] =
x_1 \left[\begin{array}{c}
a 
\end{array}\right] +
x_2 \left[\begin{array}{c}
b 
\end{array}\right]
\]</span></p>
<p>Son çarpımlar 1x1 boyutlu &quot;matrisler'' içeriyor, yani bunlar skalar, ki son toplamdan elde edilen sayı da skalar olacaktır, <span class="math inline">\(x_1 a + x_2 b\)</span>. İşte noktasal çarpım, skalar yansıtmaya bakmanın bir diğer yolu bu, bir vektör <span class="math inline">\(v_1\)</span>'in bazını değiştirip <span class="math inline">\(v_2\)</span> haline getirmek ilk vektörü ikincisi üzerinde yansıtmak anlamına gelmez mi?</p>
<p>Kaynaklar</p>
<p>[1] Maplesoft, <em>Projection of a Vector onto a Plane</em>, <a href="http://www.maplesoft.com/support/help/Maple/view.aspx?path=MathApps/ProjectionOfVectorOntoPlane" class="uri">http://www.maplesoft.com/support/help/Maple/view.aspx?path=MathApps/ProjectionOfVectorOntoPlane</a></p>
<p>[2] Bayramlı, Yapay Görüş ve Robotik, <em>Ders 2</em></p>
<p>[3] [http://sites.science.oregonstate.edu/math/home/programs/undergrad/CalculusQuestStudyGuides/vcalc/dotprod/dotprod.html](http://sites.science.oregonstate.edu/math/home/programs/undergrad/CalculusQuestStudyGuides/vcalc/dotprod/dotprod.html)</p>
<p>[4] <em>Math Insight</em>, <a href="https://mathinsight.org/dot_product" class="uri">https://mathinsight.org/dot_product</a></p>
<p>[6] 3Blue1Brown, <a href="https://www.youtube.com/watch?v=k7RM-ot2NWY" class="uri">https://www.youtube.com/watch?v=k7RM-ot2NWY</a></p>
<p>[8] [https://tutorial.math.lamar.edu/classes/calcii/dotproduct.aspx](https://tutorial.math.lamar.edu/classes/calcii/dotproduct.aspx)</p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
