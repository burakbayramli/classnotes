<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Lineer Cebir ile Minimizasyon</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="lineer-cebir-ile-minimizasyon">Lineer Cebir ile
Minimizasyon</h1>
<p>Diyelim ki <span class="math inline">\(Ax\)</span> değerinin mümkün
olduğu kadar 0’a yakın olmasını istiyoruz, yani öyle <span
class="math inline">\(x\)</span> değerleri arıyoruz ki <span
class="math inline">\(Ax\)</span> olabildiğince sıfıra yakın olsun, bir
şartla, <span class="math inline">\(||x||=1\)</span> olmalı. Bu bir
minimizasyon problemidir [8].</p>
<p><span class="math display">\[ \min_{x} ||Ax||^2 \quad \textrm{ öyle
ki } \quad ||x||^2 = 1  \]</span></p>
<p>Her iki ifadeyi açarsak,</p>
<p><span class="math display">\[ ||Ax||^2  = (Ax)^T(Ax) = x^TA^TAx
\]</span></p>
<p><span class="math display">\[ ||x||^2 = x^Tx = 1\]</span></p>
<p>Optimizasyon için alttaki bedel fonksiyonunu yazabiliriz,</p>
<p><span class="math display">\[ L(x) = x^TA^TAx - \lambda (x^Tx-1)
\]</span></p>
<p>Bu bedele Lagrangian bedeli denir ve <span
class="math inline">\(\lambda\)</span> Lagrange çarpanıdır. Lagrangian
terimi kısıtlama şartını bedelin içine gömülmesini sağlar, böylece iki
ayrı ifade yerine tek ifade yeterli oluyor. Artık minimizasyonu şöyle
yazabiliriz,</p>
<p><span class="math display">\[ \min_{x} \left\{ L(x) = x^T A^T A x -
\lambda (x^T x-1) \right\} \]</span></p>
<p><span class="math inline">\(x\)</span>’e göre türev alırsak,</p>
<p><span class="math display">\[ A^TAx - \lambda x = 0 \]</span></p>
<p><span class="math display">\[ A^TAx = \lambda x \]</span></p>
<p>Bu ifade bir özvektör problemidir, <span
class="math inline">\(A^TA\)</span>’nin özvektörleri vardır, şimdi <span
class="math inline">\(\lambda\)</span>’yi özdeğer gibi görebiliriz, ve
her farklı özdeğere tekabül eden özvektör üstteki problemi çözer. Bu
farklı <span class="math inline">\(x\)</span>’lere <span
class="math inline">\(x_\lambda\)</span> diyelim. Ama hangi <span
class="math inline">\(x_\lambda\)</span>’yi istiyoruz? Bedeli şu şekilde
tekrar yazalım,</p>
<p><span class="math display">\[ L(x_\lambda) = x_\lambda^T A^T A
x_\lambda - \lambda (x_\lambda^Tx_\lambda-1) \]</span></p>
<p>Özvektör tanımından <span class="math inline">\(A^TA x_\lambda =
\lambda x_\lambda\)</span> olduğuna göre üstte yerine koyarsak ve
sağdaki terim iptali yaparsak,</p>
<p><span class="math display">\[  = \lambda x_\lambda^T  x_\lambda -
\cancel{\lambda (x_\lambda^Tx_\lambda-1)} \]</span></p>
<p><span class="math inline">\(x_\lambda^T x_\lambda = 1\)</span> olduğu
için,</p>
<p><span class="math display">\[ L(x_\lambda) = \lambda
x_\lambda^T  x_\lambda  = \lambda\]</span></p>
<p>Yani bedel fonksiyonu her <span
class="math inline">\(x_\lambda\)</span> için o özvektörün bağlantılı
olduğu <span class="math inline">\(\lambda\)</span> değerini verir.
Böylece minimizasyon için hangi <span
class="math inline">\(x_\lambda\)</span>’yi seçmeliyiz sorusunun
cevabını vermiş oluyoruz: en küçük <span
class="math inline">\(\lambda\)</span>’nin <span
class="math inline">\(x_\lambda\)</span>’sı!</p>
<p>Örnek</p>
<p>Sıfır uzayı kavramını gördük, eğer <span
class="math inline">\(A\)</span> tam kertede değil ise sıfır uzayı boş
değildir. Bir örnek uyduruyorum, mesela</p>
<p><span class="math display">\[
\left[\begin{array}{rrr} 1 &amp; 2 \\ 3 &amp; 6 \end{array}\right] x = 0
\]</span></p>
<p>Bu örnek için <span class="math inline">\(x\)</span>’in ne olduğunu
biliyorum, kolonlar bağımsız değil, 2. kolon 1.’nin iki katı, yani <span
class="math inline">\(\left[\begin{array}{cc} -2 &amp; 1
\end{array}\right]\)</span> bu problemi çözer, ya da bir öğesi diğerinin
negatif iki katı olan herhangi bir diğer <span
class="math inline">\(x\)</span>. Peki ya problem şöyle olsaydı?</p>
<p><span class="math display">\[
\left[\begin{array}{cc} 1 &amp; 2 \\ 3 &amp; 5.5 \end{array}\right] x =
0
\]</span></p>
<p>Şimdi direk <span class="math inline">\(\left[\begin{array}{cc} -2
&amp; 1 \end{array}\right]\)</span> diyemeyiz, ama biliyoruz ki sıfıra
olabildiğince yaklaşabilmek mümkün, bu problemi minimizasyon olarak
çözmek lazım.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy.linalg <span class="im">as</span> lin</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.array([[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">3</span>,<span class="fl">5.5</span>]])</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="bu">eval</span>,evec <span class="op">=</span> lin.eig(np.dot(A.T,A))</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> <span class="bu">eval</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> evec</span></code></pre></div>
<pre><code>[[-0.8798189  -0.47530906]
 [ 0.47530906 -0.8798189 ]]
[  5.65043904e-03   4.42443496e+01]</code></pre>
<p>En küçük özdeğer birincisi,</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> evec[:,<span class="dv">0</span>]</span></code></pre></div>
<pre><code>[-0.8798189   0.47530906]</code></pre>
<p>Yani <span class="math inline">\(Ax\)</span>’i sıfıra en yaklaştıran
çozum <span class="math inline">\(x = \left[\begin{array}{cc} -0.88
&amp;  0.47 \end{array}\right]\)</span>. Görüldüğü gibi 1. öğe
ikincisinin negatif iki “katımsı’’.</p>
<p>Temel Bileşen Analizi (bkz [2]) tekniğinde görülecek, bu tekniğin
bahsettiğimiz minimizasyon ile yakın alakaları var. Eğer <span
class="math inline">\(A\)</span> matrisi kolonlarını belli ölçümler,
yaş, ağırlık, vs gibi düşünürsek, bu ölçümler üzerinden kovaryansın ne
olduğunu biliyoruz: <span class="math inline">\(A^TA\)</span>. Değil mi?
Peki şimdi şu sorunun cevabını nasıl veririz? Öyle yönler bul ki <span
class="math inline">\(A^TA\)</span> o yönlerde kovaryans yansıması
minimal ya da maksimal olsun.</p>
<p>Yön demek bir birim vektördür, <span class="math inline">\(x\)</span>
diyelim, yani gene <span class="math inline">\(A^TAx\)</span>’yi
minimize / maksimize etmeye geldik (ya da <span
class="math inline">\(x^TA^TAx\)</span>, aynı şey)! Şart <span
class="math inline">\(||x||^2 = 1\)</span> aynen olduğu gibi geçerli
çünkü sadece bir yön arıyoruz. Kovaryansın minimal, maksimal olduğu
yerler öyle yönler olacak ki o yönlerde değişkenlerin beraber değişimi
en az, ya da en fazla olacak, altta örnek PCA örnek grafiğinde
görülüyor, noktaların sağ üste doğru “beraber’’ uzandığı yer en fazla
bağlantı, ona dik olan diğer yönde en az bağlantı var. Bunlar temel
bileşenler.</p>
<p>Rayleigh Bölümü (Quotient)</p>
<p>Başlangıçtaki minimizasyon formatına dönersek, daha genel bir ifade
ile, eğer <span class="math inline">\(M\)</span> simetrik ise (daha
önceki örnekte <span class="math inline">\(A^TA\)</span> kullandık, ama
bu ifade de her zaman simetriktir, çünkü matrisin devriği çarpı kendisi
her zaman simetrik bir matris doğurur),</p>
<p><span class="math display">\[
R(M,x) = \frac{x^TMx}{x^Tx}
\qquad (1)
\]</span></p>
<p>ifadesi de doğru olmalı. <span class="math inline">\(R\)</span>’ye
Rayleigh bölümü adı veriliyor, ve eşitliğin sağı biraz önce gördüğümüz
gibi minimal noktasına en küçük özdeğer/vektör ikilisiyle gelir. Üstte
bir oran görülüyor, fakat bu karışıklık yaratmasın, daha önce <span
class="math inline">\(x^Tx = 1\)</span> şartını ayrı bir şekilde
yazmıştık, ve <span class="math inline">\(x^T M x\)</span> minizasyonu
yapmıştık. Diyelim ki <span class="math inline">\(x\)</span> değil <span
class="math inline">\(v\)</span> kullandık ve <span
class="math inline">\(v\)</span> herhangi bir vektör olabilir, fakat
herhangi bir vektörü birim vektör haline getirmeyi biliyoruz, <span
class="math inline">\(x = v/||v||\)</span>, ve <span
class="math inline">\(x^T M x\)</span> içinde yerine koyarsak (1)’i elde
ederiz [1].</p>
<p>Böylece ileride göreceğimiz Rayleigh-Ritz Teorisi’nin ispatının bir
kısmına da farklı bir çözüm getirmiş olduk.</p>
<p>Optimizasyonu bölüm olarak belirtmenin bazı faydalı var, sınır
şartının illa 1’e eşit olma zorunluğu bazı uygulamalar için çok
kısıtlayıcı olabilir.</p>
<p>Örnek</p>
<p>Karesel denklemler de matris formunda gösterilebilir, mesela</p>
<p><span class="math display">\[ q(x,y) = 3x^2 + 2xy + 3y^2
\]</span></p>
<p>ile</p>
<p><span class="math display">\[
\left[\begin{array}{cc} x &amp; y \end{array}\right]
\left[\begin{array}{rrr}3 &amp; 1 \\ 1 &amp; 3 \end{array}\right]
\left[\begin{array}{c} x \\ y \end{array}\right]
\]</span></p>
<p>aynı şey. Problem <span class="math inline">\(q\)</span>’yu <span
class="math inline">\(x^2+y^2 = 1\)</span> olacak şekilde optimize
etmek. Fakat artık şu şekilde de tanımlayabiliriz,</p>
<p><span class="math display">\[
r(x,y) = \frac{ 3x^2 + 2xy + 3y^2}{x^2+y^2 }
\]</span></p>
<p>Çözüm <span class="math inline">\(\lambda_1=4\)</span> ve <span
class="math inline">\(\lambda_2 = 2\)</span>.</p>
<p><span class="math display">\[
q(-1/\sqrt{2},1/\sqrt{2}) =
2 \le q(x,y) \le 4 =
q(1/\sqrt{2},1/\sqrt{2})
\]</span></p>
<p>Rayleigh-Ritz Teoremi</p>
<p>Sentetik görüntü algoritmasını gösterdiğimizde, Rayleigh-Ritz
kuramına atıf yapmıştık. Bu yazıda bütün kuramın ispatını veriyoruz.
İspatta kullanılan küme sanal sayılar kümesidir. Bizim örneğimiz için
gerçek sayılar kümesi kullanılıyor, fakat aynı ispat hala geçerli
olacak.</p>
<p>Problem</p>
<p>Bir kare matrisin özdeğerlerini büyüklük sırasına dizersek, bu
değerlerin kısıtlı bir minimizasyon / maksimizasyon probleminin çözümü
olduğun görüyoruz. Kısıtlı derken, <span
class="math inline">\(x*x\)</span> (x vektör devriği çarpı <span
class="math inline">\(x\)</span>, yani x’in uzunluğu) çarpımını 1’e
kısıtlı tutmaktan bahsediyorum. Böylece maksimizasyon problemimizin
sonsuzluğa gitmesini engellemiş oluyoruz. <span
class="math inline">\(\lambda\)</span> sembolu genelde özdeğerler için
kullanılır. Yıldız işareti * ise sanal sayılar uzayında, devrik yapmak
demektir. Gerçek sayılar uzayında olsaydık, o zaman T işaretini
kullanabilirdik. (T transpose kelimesinden gelir).</p>
<p><span class="math display">\[ \textrm{forall } x \in \
C^n  \]</span></p>
<p><span class="math display">\[ \lambda_1x^\ast x \le x^\ast A x \le
\lambda_nx^\ast x  \]</span></p>
<p><span class="math display">\[
\lambda_{ust} = \lambda_n =
\max\limits_{x^\ast x=1} (\frac{x^\ast A x}{x^\ast x}) =
\max\limits_{x^\ast x=1}(x^\ast Ax)
\]</span></p>
<p><span class="math display">\[
\lambda_{alt} = \lambda_n =
\max\limits_{x^\ast x=1} (\frac{x^\ast Ax}{x^\ast x}) =
\max\limits_{x^\ast x=1}(x^\ast Ax)
\]</span></p>
<p>Problemi üstte tanımladıktan sonra, ispatına gelelim.</p>
<p>A matrisi, Hermit matrisi olduğu için, elimizde bu A matrisine
tekabül eden birincil (unitary) bir matris var demektir. Bu birincil
matrisi U ile temsil edersek, şu sonuca da varırız.</p>
<p><span class="math display">\[ A = U \Lambda U^\ast \]</span></p>
<p><span class="math display">\[ \Lambda =
diag(\lambda_1\lambda_2...,\lambda_n) \]</span></p>
<p>Bu demektir ki,</p>
<p><span class="math display">\[ \forall x \in  C^n \]</span></p>
<p><span class="math display">\[ x^\ast A x = x^\ast U \Lambda U^\ast x
= (U^\ast x)^\ast \Lambda(U^\ast x) \]</span></p>
<p><span class="math display">\[
\sum_{i=1}^n \lambda_i |(U^\ast x)_i|^2
\]</span></p>
<p>Ufak iki not olarak düşmek gerekiyor. Yukarıdaki 3. eşitliğe
gelmemizin sebebi aşağıdakinin doğru olmasıdır.</p>
<p><span class="math display">\[
x^\ast U = (U^\ast x)^\ast
\]</span></p>
<p>Doğrusal cebirde bilinen çevirimlerden biridir bu. En son not olarak,
toplamlı eşitliğe gelebilmemizin sebebi (4. terim) şundandır. <span
class="math inline">\(U^\ast x\)</span> yerine <span
class="math inline">\(W\)</span> koyarsak, <span
class="math inline">\(W^\ast W\)</span> çarpımının her zaman <span
class="math inline">\(W\)</span>’nin uzunluğunu verir. Yani bir vektörün
uzunluğunu bulmak için vektörün devriğini kendisi ile çarpmak gerekir,
bu çarpım uzunluğun karesidir.</p>
<p>Devam ediyoruz. Her <span class="math inline">\(|(U^\ast
x)_i|^2\)</span> ifadesi artı değerli olmaya mecbur olduğu için,</p>
<p><span class="math display">\[
\lambda_{alt} \sum_{i=1}^n | (U^\ast x)_i |^2 \le x^\ast Ax
\]</span></p>
<p><span class="math display">\[
\sum_{i=1} \lambda_i | (U^\ast x) |^2 \le
\lambda_{ust} \sum_{i=1}^n | (U^\ast x)_i|^2 \le
x^\ast Ax
\]</span></p>
<p>Üstteki eşitsizliğin doğru olmasının bir sebebi var. Elimizde 3 tane
değişik 1..n arası yapılan toplam var. Dikkatle bakarsanız, ortadaki
toplam içinde i ile kontrol edilen, bütün özdeğerlerin toplandığını
göreceksiniz. Buna kıyasla mesela en soldaki, toplam içinde sürekli aynı
‘alt özdeğer’ toplandığını farketmemiz lazım. Buna bakarak anlıyoruz ki,
tabii ki bütün özdeğerlerin toplamı, tekrar eden aynı özdeğer değerinin
toplamından fazla olacaktır! Çünkü iki tarafta da özdeğerler haricindeki
bütün terimler birbirine eşit. Daha da basitleştirmek için U’yu
yokedelim.</p>
<p>U birincil bir matris, o zaman</p>
<p><span class="math display">\[
\sum_{i=1}^{n} |(U^{\ast} x)_{i}|^{2}
\sum_{i=1} | x_{i} |^2 = X^{\ast} x
\]</span></p>
<p>çünkü</p>
<p><span class="math display">\[
|U^\ast x| = |x|
\]</span></p>
<p>İspat</p>
<p><span class="math display">\[
|U^\ast x| = (U^\ast x)^\ast(U^\ast x) = x^\ast UU^\ast x = x^\ast x = |
x |
\]</span></p>
<p>Böylece göstermiş oluyoruz ki,</p>
<p><span class="math display">\[
\lambda_1 x^\ast x \le \lambda_{alt} x^\ast x \le x^\ast Ax \le
\lambda_{ust}
x^\ast x
\]</span></p>
<p>Kaynaklar</p>
<p>[1] Olver, <em>Applied Linear Algebra</em></p>
<p>[2] Bayramlı, Istatistik, <em>Asal Bileşen Analizi (Principal
Component Analysis -PCA-)</em></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
