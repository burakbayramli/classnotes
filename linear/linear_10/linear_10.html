<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Ders 10</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="ders-10">Ders 10</h1>
<p>Lineer cebirin özüne iniyoruz şimdi, 4 temel altuzay nedir ve onların arasındaki ilişki nasıldır?</p>
<p>Dört Temel Altuzay</p>
<ol style="list-style-type: decimal">
<li><p>Kolon uzayı <span class="math inline">\(C(A)\)</span> (columnspace). Boyutları <span class="math inline">\(m \times n\)</span> olan <span class="math inline">\(A\)</span> matrisinin her kolonunun <span class="math inline">\(m\)</span> tane öğesi / hücresi vardır, o zaman <span class="math inline">\(C(A)\)</span> uzayı <span class="math inline">\(\mathbb{R}^m\)</span> içindedir.</p></li>
<li><p>Sıfır uzayı, <span class="math inline">\(N(A)\)</span> (nullspace)</p></li>
<li><p>Satır uzayı (rowspace), bir matrisin satırlarının tüm kombinasyonu. Bu kombinasyon hakkında başka hangi kelimeyi kullanabilirim? Satırlar satır uzayını kapsar (span). <span class="math inline">\(A\)</span>'nin satırları bu uzay için bir baz (basis) oluşturur mu? Belki evet, belki hayır. Eğer satırlar birbirinden bağımsız ise evet.</p></li>
</ol>
<p>Akla gelen bir fikir şu olabilir, satırlar ile uğraşmayı sevmiyorum, şimdiye kadar kolonlar üzerinden işleyen bir sürü araç / dil geliştirdik, bunları kullanmaya devam etmek istiyorum. O zaman basit bir çözüm şu, <span class="math inline">\(A\)</span>'nin devriğini alırım, böylece satırlar kolon haline gelir ve ben de <span class="math inline">\(A^T\)</span>'nin kolonlarıyla iş yapmaya devam ederim. Bildik notasyonu kullanabilirim, <span class="math inline">\(C(A^T)\)</span> mesela. Bunun işleyip işlemediğini göreceğiz.</p>
<ol start="4" style="list-style-type: decimal">
<li><span class="math inline">\(A^T\)</span>'nin sıfır uzayı, <span class="math inline">\(N(A^T)\)</span>. Bu sıfır uzayına &quot;<span class="math inline">\(A\)</span>'nin sol sıfır uzayı'' adı da veriliyor.</li>
</ol>
<div class="figure">
<img src="10_01.png" />

</div>
<p>Temel altuzaylar hakkında bilmek istediklerim şunlar: Bu uzayların bazı nedir? Boyutları nedir?</p>
<p><span class="math inline">\(C(A)\)</span>'nin boyutu <span class="math inline">\(A\)</span>'nin kertesi <span class="math inline">\(r\)</span>. Bunu önceki derste bir örnek üzerinden görmüştük.</p>
<p>Satır uzayının, yani <span class="math inline">\(C(A^T)\)</span>'nin boyutu aynen <span class="math inline">\(C(A)\)</span> gibi <span class="math inline">\(r\)</span>'ye eşit, yani matris kertesi ile aynı.</p>
<p>Alttaki matrisin satır boyutu nedir?</p>
<p><span class="math display">\[ 
\left[\begin{array}{rrr}
1 &amp; 2 &amp; 3 \\
1 &amp; 2 &amp; 3 \\
2 &amp; 5 &amp; 8 
\end{array}\right]
 \]</span></p>
<p>Boyut sayısı 2'dır. Satırlara bakınca 1. ve 2. satır aynı, bağımsız sadece iki tane satır var. Kolon ve satır uzaylarının boyut eşitliği kuralından hareketle, o zaman kolon uzayı boyutu da 2. Eliminasyon sırasında 2 tane pivot kolonu çıkacaktır, ve kolonlar da bağımlıdır. Bu örnek aslında ilginç çünkü kolonlara bakınca bağımlılık bariz değil (3. kolon 1. ve 2. kolonun direk toplamı değil mesela), ama satırlara bakınca bağımlılık belli oluyor.</p>
<p>Sıfır uzayı için baz özel çözümlerdir, ki eğer hatırlarsak, her serbest değişken için bir özel çözüm vardır. Özel çözüm sayısı ise <span class="math inline">\(n-r\)</span>, o zaman sıfır uzayı boyutu <span class="math inline">\(n-r\)</span>. Demek ki sıfır uzay için özel çözümler bir baz oluştururlar.</p>
<p><span class="math inline">\(N(A^T)\)</span>'nin boyutu ise <span class="math inline">\(m-r\)</span>, çünkü <span class="math inline">\(A^T\)</span>'nin kolon sayısı <span class="math inline">\(A\)</span>'nin satır sayısı, kolon sayısını elde edince geri kalan işlem üstteki sıfır uzayı ile aynı, <span class="math inline">\(N(A^T)\)</span>'nin serbest değişken sayısı devreye girer, vs.</p>
<p>Şimdi baz bulma konusuna dönelim; kolon uzayının bazını bulmayı biliyoruz, pivot içeren kolonlar baz oluşturur. Peki satır uzayı için bazı nasıl buluruz? Akla hemen şu gelebilir, matrisin devriğini alırım, ve o devrik üzerinde bildiğim işlemleri yaparım, eliminasyon, pivot bulma, vs. Ama bu fikre balıklama atlamadan önce, acaba bildiğimiz tekniği olduğu gibi kullanmak acaba daha iyi bir fikir olabilir mi? Bir örneğe bakalım, klasik eliminasyon senaryosu uygulayalım,</p>
<p><span class="math display">\[ 
\left[\begin{array}{rrrr}
1 &amp; 2 &amp; 3 &amp; 1 \\
1 &amp; 1 &amp; 2 &amp; 1 \\
1 &amp; 2 &amp; 3 &amp; 1
\end{array}\right] \rightarrow
\left[\begin{array}{rrrr}
1 &amp; 2 &amp; 3 &amp; 1 \\
0 &amp; -1 &amp; -1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0
\end{array}\right]
 \]</span></p>
<p>İkinci pivot'ta eksi olmayan değer istiyorum, 2. satırı -1 ile çarpayım. Sonra 2. satır 2 ile çarpıp 1. satırdan çıkartayım,</p>
<p><span class="math display">\[ R =
\left[\begin{array}{rrrr}
1 &amp; 0 &amp; 1 &amp; 1 \\
0 &amp; 1 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0
\end{array}\right]
 \]</span></p>
<p>Bunlar bildiğimiz işlemler. Şimdi sol üst köşede <span class="math inline">\(2 \times 2\)</span> boyutlu <span class="math inline">\(I\)</span> var, hemen yanında <span class="math inline">\(F\)</span>, ve en alt satır sıfır.</p>
<p>Neler olduğuna dikkat edelim, üstteki işlemler sırasında matrisin kolon uzayı değişti. Yani artık <span class="math inline">\(A\)</span>'nin kolon uzayı <span class="math inline">\(R\)</span>'nin kolon uzayı ile aynı değil, <span class="math inline">\(C(A) \ne C(R)\)</span>. Satır işlemleri yaptık (satır uzayı değişmedi), ve kolon uzayında değişime sebep olduk.</p>
<p>Neyse; şimdi <span class="math inline">\(R\)</span>'nin satır uzayı için baz nedir, ki bu baz <span class="math inline">\(A\)</span>'nin aynı olan satır uzayı için de aynı olacaktır? <span class="math inline">\(R\)</span>'den bariz görülüyor, ilk iki satırı, yani ilk <span class="math inline">\(r\)</span> satırı, baz oluşturur. Bu şekilde satır uzayını bulmak faydalı çünkü eliminasyon sırasında <span class="math inline">\(R\)</span>'yi zaten olabileceği en temiz hale getiriyorum, bu işlem tamamlandıktan sonra <span class="math inline">\(R\)</span>'den bazları çekip çıkartabilirim.</p>
<p>Bir soru: madem bir baz elde ettim, <span class="math inline">\(A\)</span>'nin satırlarının <span class="math inline">\(R\)</span> satırlarının kombinasyonu olup olmadığından nasıl emin olabilirim? Çok basit, eliminasyon sırasında yaptığım işlemleri tersine çevirirsem, bir tür kombinasyon işlemi yapmış olurum, ve bu kombinasyon bana kesinlikle <span class="math inline">\(A\)</span>'nin satırlarını verecektir, çünkü başlangıç noktam zaten <span class="math inline">\(A\)</span> idi.</p>
<p>Nihayet son uzayımız, <span class="math inline">\(N(A^T)\)</span>'nin uzayı için bir baz nasıl bulurum?</p>
<p>Bu uzaya niçin &quot;sol'' sıfır uzayı deniyor?</p>
<p>Bu uzayın içinde vektörler vardır, tabii ki, <span class="math inline">\(A^Ty = 0\)</span> denklemini tatmin eden <span class="math inline">\(y\)</span>'ler bu vektörlerdir. Bu denklemin devriğini alırsam,</p>
<p><span class="math display">\[ y^TA = 0 \]</span></p>
<p>Bu denkleme göre yatay vektör <span class="math inline">\(y^T\)</span>, <span class="math inline">\(A\)</span>'yi &quot;soldan'' çarpıyor, sol sıfır uzayı sözü buradan geliyor. Fakat bu bir kullanım şekli tabii, ben şahsen <span class="math inline">\(A^Ty=0\)</span> formunu tercih ediyorum [herhalde devrik alma sebebi <span class="math inline">\(A^T\)</span>'yi <span class="math inline">\(A\)</span> haline getirmek, bu işlem sırasında <span class="math inline">\(y\)</span> de &quot;sola'' geçmiş oluyor].</p>
<p>Bazı nasıl bulurum?</p>
<p><span class="math inline">\(A\)</span> üzerinde pivot bulma, eliminasyon gibi işlemler bize <span class="math inline">\(R\)</span>'yi vermişti, bu işlemler tabii <span class="math inline">\(A\)</span> üzerindedir, <span class="math inline">\(A^T\)</span> üzerinde değildir, ama sezgisel olarak bu işlemlerin bize sol sıfır uzayı hakkında da birşeyler söylediğini tahmin edebiliriz. <span class="math inline">\(A\)</span>'dan <span class="math inline">\(R\)</span>'ye gelirken bazı işlemler yaptık, ve bu işlemlerin tamamı ile ilgileniyorum, yani bu tüm işlemleri temsil eden o tek matrisle ilgileniyorum. Bu matrisi nasıl buluruz?</p>
<p>Gauss-Jordan'ı hatırlıyor musunuz? Hani matris üzerinde işlemler yaparken ona yandan bir ekstra birim matrisi eklemiştik. GJ kullanımını bir kare matrisin tersini almak için kullanmıştık. Şimdi matris kare değil, çoğunlukla dikdörtgen, ama yine de birim matrisi ekleyebiliriz,</p>
<p><span class="math display">\[ 
\left[\begin{array}{rr}
A_{m \times n} &amp; I_{m \times m}
\end{array}\right]
 \]</span></p>
<p>Ve bu matris üzerinde rref uygularım. Sonuç ne olur? <span class="math inline">\(A\)</span> tabii ki <span class="math inline">\(R\)</span>'ye dönüşecek, aynı işlemler <span class="math inline">\(I\)</span> üzerinde de uygulanmış olacak, ve orada da ortaya bir matris çıkacak, bu matrise <span class="math inline">\(E\)</span> matrisi diyelim,</p>
<p><span class="math display">\[ 
\left[\begin{array}{rr}
R_{m \times n} &amp; E_{m \times m}
\end{array}\right]
 \]</span></p>
<p>Eğer düşünürsek <span class="math inline">\(E\)</span> matrisinin <span class="math inline">\(A\)</span> üzerinde yaptığımız tüm işlemlerin bir kayıdı olduğunu görebiliriz. İşlemlerimizin arkada bıraktığı &quot;iz'' bu <span class="math inline">\(E\)</span> içinde bir bakıma. O zaman şunu da söyleyebiliriz, <span class="math inline">\(A\)</span> üzerinde yaptığımız işlemler <span class="math inline">\(E\)</span> içindeyse, o zaman</p>
<p><span class="math display">\[ 
E
\left[\begin{array}{rr}
A_{m \times n} &amp; I_{m \times m}
\end{array}\right] = 
\left[\begin{array}{rr}
EA &amp; EI
\end{array}\right] = 
\left[\begin{array}{rr}
R_{m \times n} &amp; E_{m \times m}
\end{array}\right]
 \]</span></p>
<p>çünkü</p>
<p><span class="math display">\[ EA = R \]</span></p>
<p>Daha önce Gauss-Jordan gördüğümüzde amacımız matris tersi almaktı, hedefimiz <span class="math inline">\(R\)</span>'e erişmek değil, <span class="math inline">\(I\)</span>'ya erişmekti, ve <span class="math inline">\(E\)</span> bize <span class="math inline">\(A\)</span>'yi değiştirip <span class="math inline">\(A^{-1}\)</span>'yi vermişti. Burada hedef farklı, fakat ana fikir aynı.</p>
<p>Biraz önceki örneğimiz üzerinde görelim,</p>
<p><span class="math display">\[ 
A = \left[\begin{array}{rrrr}
1 &amp; 2 &amp; 3 &amp; 1 \\
1 &amp; 1 &amp; 2 &amp; 1 \\
1 &amp; 2 &amp; 3 &amp; 1
\end{array}\right]
 \]</span></p>
<p>Bu matrisi <span class="math inline">\(R\)</span>'ye dönüştürmek için yaptığım tüm işlemleri <span class="math inline">\(3 \times 3\)</span> boyutlu bir <span class="math inline">\(I\)</span> üzerinde uygularsam,</p>
<p><span class="math display">\[ 
\left[\begin{array}{rrr}
-1 &amp; 2 &amp; 0 \\
1 &amp; -1 &amp; 0 \\
-1 &amp; 0 &amp; 1 
\end{array}\right]
 \]</span></p>
<p>Bu zannediyorum ki <span class="math inline">\(E\)</span>. Kontrol etmek için <span class="math inline">\(A\)</span>'yi bu matrisle soldan çarpalım, ve <span class="math inline">\(R\)</span>'yi elde edip etmeyeceğimizi görelim,</p>
<p><span class="math display">\[ 
\left[\begin{array}{rrr}
-1 &amp;  2 &amp; 0 \\
1 &amp; -1 &amp; 0 \\
-1 &amp; 0 &amp; 1
\end{array}\right]
\left[\begin{array}{rrrr}
1 &amp; 2 &amp; 3 &amp; 1 \\
1 &amp; 1 &amp; 2 &amp; 1 \\
1 &amp; 2 &amp; 3 &amp; 1
\end{array}\right]
 \]</span></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">E <span class="op">=</span> np.array([[<span class="op">-</span><span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">0</span>],[<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>],[<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>]])
A <span class="op">=</span> np.array([[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>]])
<span class="bu">print</span> np.dot(E,A)</code></pre></div>
<pre><code>[[1 0 1 1]
 [0 1 1 0]
 [0 0 0 0]]</code></pre>
<p>Evet, <span class="math inline">\(R\)</span>'yi elde ettik.</p>
<p>Tüm bunları <span class="math inline">\(A\)</span>'nin sol sıfır uzayını elde etmek için yaptım. Daha ilerlemeden, bu arada, sol sıfır uzayının boyutu nedir? Boyut <span class="math inline">\(m-r\)</span>, yani 3-2=1, yani boyut 1. Yani baz tek bir vektör, yani <span class="math inline">\(A\)</span>'nin satırlarını kombine edip sıfır sonucunu ortaya çıkarabilecek tek bir vektör var.</p>
<p>O vektör nedir? <span class="math inline">\(E\)</span>'nin son satırı bize o vektörü gösteriyor, çünkü o satır <span class="math inline">\(A\)</span>'yi soldan çarparken <span class="math inline">\(A\)</span>'nin satırlarını kombine ederek <span class="math inline">\(R\)</span>'nin tamamen sıfır olan o son satırını ortaya çıkartmıştır.</p>
<p><span class="math display">\[ R =
\left[\begin{array}{rrrr}
1 &amp; 0 &amp; 1 &amp; 1 \\
0 &amp; 1 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0
\end{array}\right]
 \]</span></p>
<p>Yani <span class="math inline">\(R\)</span>'nin son satırına tekabül eden <span class="math inline">\(E\)</span>'nin son satırı aradığımız vektördür.</p>
<p>Bu sonucu bulmak için <span class="math inline">\(E\)</span>'yi ortaya çıkartmamız gerekti, fakat bu işlem daha doğal, <span class="math inline">\(A\)</span>'nin devriğini alıp onun üzerinde daha çetrefil işlemler yapmak gerekmedi.</p>
<p>Dört altuzay işte bunlardır.</p>
<p>Bu dersi kapatmadan önce şimdiye kadar görmediğimiz yeni bir tür vektör uzayından bahsetmek istiyorum.</p>
<p>Bir örnek, tüm <span class="math inline">\(3 \times 3\)</span> boyutundaki matrisler. Ama bir dakika diyebilirsiniz, vs. boyutundaki matrisler nasıl bir <em>vektör</em> uzayı ortaya çıkarabilirler. Fakat biraz düşünürsek, matrislerin vektör uzayı oluşturmak için vektörler üzerinde uyguladığımız kurallara aynen uyabileceğini görürüz. Matrislerin lineer kombinasyonlarını alabilirim, onları bir skalar (tek sayı) ile çarpabilirim, vs. Vektör uzayları için geçerli tüm kurallar burada da geçerli olabilir.</p>
<p>Peki altuzaylara ne olur? Bu &quot;matris uzayının'', ki üstteki örnekteki uzaya <span class="math inline">\(M\)</span> diyelim şimdilik, bir altuzayı var mıdır? Bir tane bulayım mesela.. tüm <span class="math inline">\(3 \times 3\)</span> boyutundaki.. üstüçgensel matrisler. Ya da.. simetrik matrisler. Devam edelim; İki altuzayın kesişiminin yeni bir altuzay olduğunu biliyoruz, hatta önceki bir derste bunu ispatlamıştık bile, o zaman simetrik ve üstüçgensel matrislerin uzaylarının kesişimini kullanabilir miyiz? İlginç bir durum bu aslında, çünkü üstüçgensel matrislerin köşegeni (diagonal) altında tamamen sıfır vardır, eğer simetriklik şartı arıyorsak, o zaman köşegenin üstü de sıfır olmalıdır, o zaman geriye sadece köşegeninde değerler olan matrisler kalır, ki bu matrisler köşegen (diagonal) matrislerdir. Bir altuzay da bu yani, köşegen matrisler, tabii üstüçgensel ve simetrik matrislerin altuzayından daha küçük bir altuzay.</p>
<p>Bu kelimeyi kullanabilir miyim? Küçük? Bu durumda küçüklük ne demektir? Eh, köşegen matrislerin altuzayı diğerlerinin içindedir, vs. Fakat daha spesifik olarak altuzay boyutu kavramını kullanabilirim şimdi; Tabii boyut için bir baz hesaplamam gerekli, bunu yapınca bu bazda kaç tane eleman olduğunu sayarım ve sonucu bulurum. Köşegen matris altuzayı için, bence bu sayı 3. Nereden biliyorum? Mesela üç tane matris yazacağım,</p>
<p><span class="math display">\[ 
\left[\begin{array}{rrr}
1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 
\end{array}\right], 
\left[\begin{array}{rrr}
1 &amp; 0 &amp; 0 \\
0 &amp; 3 &amp; 0 \\
0 &amp; 0 &amp; 0 
\end{array}\right], 
\left[\begin{array}{rrr}
0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 7 
\end{array}\right]
 \]</span></p>
<p>Bence bu bir baz. Birbirinden bağımsızlar, ve tüm köşegen matrisler bu üçünün bir kombinasyonu, yani bu üç matris tüm köşegen matrisler altuzayını kapsıyorlar.</p>
<p>Şimdiye kadar gördüğümüz fikirleri yeni bir ortam için bayağı esnettik, fakat fikirler burada da geçerli.</p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
