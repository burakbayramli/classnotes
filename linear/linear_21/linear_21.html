<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Ders 21</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="ders-21">Ders 21</h1>
<p>Bu özdeğer/vektörler hakkındaki ilk dersimiz. Bu değerler özel
büyüklüklerdir, özel sayılardır, ve onları niye istediğimizi, niye
hesapladığımızı göreceğiz.</p>
<p>Özvektör nedir?</p>
<p>Elimde bir <span class="math inline">\(A\)</span> matrisi var. Bir
matris ne yapar? Vektörler üzerinde, mesela <span
class="math inline">\(x\)</span> vektörü, etkide bulunabilir, onları
değiştirebilir. Sanki <span class="math inline">\(A\)</span>’yi bir
fonksiyon gibi de görebiliriz, <span class="math inline">\(x\)</span>
vektörü <span class="math inline">\(A\)</span>’ya “giriyor’’
ve”dışarıya’’ bir <span class="math inline">\(Ax\)</span> çıkıyor.
Calculus’ta olduğu gibi <span class="math inline">\(f()\)</span>’e bir
tek sayı <span class="math inline">\(x\)</span> veriliyor, <span
class="math inline">\(f(x)\)</span> geri dışarı çıkıyor [hakikaten de
<span class="math inline">\(x\)</span> ve <span
class="math inline">\(Ax\)</span> aynı boyutta yani giriş çıkış
analojisi çok uygun]. Lineer Cebirde daha çok boyut var, giren ve çıkan
vektörler.</p>
<p>Bu derste özellikle ilgilendiğim vektörler ise dışarı çıktığı zaman
girdiği haliyle <em>aynı yönü gösteren</em> vektörler. Dikkat, “aynı’’
olan vektörler değil çıkınca aynı”yönü’’ gösteren vektörler. Bu tipik
bir durum olmazdı değil mi? Çoğunlukla <span
class="math inline">\(A\)</span>’yi bir uyguladık mı dışarı çıkan vektör
tamamen başka bir yönü gösterir. Bizim ilgilendiğimiz durumda öyle
olmayacak, bu durumda <span class="math inline">\(Ax\)</span>, <span
class="math inline">\(x\)</span>’e paralel olacak. İşte bu vektörler
özvektörler olacak.</p>
<p>Paralel ne demektir? Formülle daha rahat belirtilir,</p>
<p><span class="math display">\[ Ax = \lambda x \]</span></p>
<p><span class="math inline">\(\lambda\)</span>, yani özdeğer, bir
skalardır. İki tarafta <span class="math inline">\(x\)</span>’in olması
paralelliğe işaret ediyor, sadece büyüklük (<span
class="math inline">\(\lambda\)</span> üzerinden) değişik olabiliyor.
Tabii büyüklük derken <span class="math inline">\(\lambda\)</span> eksi
değerde olabileceği için vektörün ters yönde olmasına da izin vermiş
oluyoruz. <span class="math inline">\(\lambda\)</span> sıfır da
olabilir, hatta hayali sayı bile olabilir.</p>
<p>Özdeğer sıfır üzerinde biraz daha duralım. Bu durumda <span
class="math inline">\(Ax = 0 \cdot x\)</span> elde ederiz yani <span
class="math inline">\(Ax = 0\)</span>. Bu ne demektir? <span
class="math inline">\(x\)</span>’lerin <span
class="math inline">\(A\)</span>’nin sıfır uzayında (nullspace) olması…
Eğer <span class="math inline">\(A\)</span> eşsiz (singular) ise, ki
<span class="math inline">\(Ax = 0\)</span> bu demek zaten demek ki öyle
bir <span class="math inline">\(x\)</span> olabiliyor ki <span
class="math inline">\(Ax = 0\)</span> olabiliyor, o zaman <span
class="math inline">\(x\)</span> sıfır olmayan bir vektördür, ve <span
class="math inline">\(\lambda = 0\)</span> bir özdeğer olmalıdır.</p>
<p>Bir yansıtma matrisine bakalım, mesela <span
class="math inline">\(P\)</span>. Elimizde bir düzlem (plane) var, ve bu
sathın üzerinde yansıtma yapan bir <span
class="math inline">\(P\)</span> var.</p>
<p><img src="21_1.png" /></p>
<p><span class="math inline">\(b\)</span>, <span
class="math inline">\(P\)</span>’nin bir özvektörü müdür? Değildir.
Çünkü <span class="math inline">\(b\)</span> ve <span
class="math inline">\(Pb\)</span> aynı yönü göstermiyorlar.</p>
<p>Peki, bu resme göre, yansıtma sonrası aynı yönde olacak bir vektör
var mıdır? Varsa nerededir? Cevap, eğer <span
class="math inline">\(x\)</span> üstteki düzlemin tam üzerinde ise <span
class="math inline">\(P\)</span> yansıtması sonrası aynı yönde kalır.
Tabii yansıtma tekrar kendisini verir, yani vektör hiç değişmemiş olur.
<span class="math inline">\(Px = x\)</span>, ki <span
class="math inline">\(\lambda = 1\)</span>.</p>
<p>Başka bir özvektör var mı? Olmasını umuyorum çünkü 3 boyuttayım ve bu
demektir ki 2 tane daha birbirinden bağımsız özvektör bulabilmeliyim, ki
nihayetinde özvektörlerin ikisi düzlem üzerinde [düzlem iki boyutlu bir
şey olduğuna göre], o zaman üçüncüsü düzlem dışında olacak. Düzlem
dışında olan özvektör dik olan özvektör olmalı.</p>
<p><img src="21_2.png" /></p>
<p>Bu durumda <span class="math inline">\(Px = 0\)</span>, ve <span
class="math inline">\(\lambda = 0\)</span>, çünkü dikliğin bir diğer
tanımı çarpım sonrası sonucun sıfır olması.</p>
<p>Bir diğer örnek. Şu permutasyon matrisine bakalım.</p>
<p><span class="math display">\[
A = \left[\begin{array}{cc}
0 &amp; 1 \\
1 &amp; 0
\end{array}\right]
\]</span></p>
<p>Bu matrisi hangi vektör ile çarparsam aynı yönde bir vektör elde
ederim? Permutasyon matrisi tanım itibariyle permutasyon yapar, yani
öğelerin yerini değiştirir. İki boyut bağlamında bir vektörün iki
öğesinin yerini değiştirecektir. Peki hangi vektörün öğeleri yer
değiştirirse yine kendisi olur? Cevap basit, <span
class="math inline">\(x = \left[\begin{array}{cc} 1 &amp; 1
\end{array}\right]\)</span>.</p>
<p><span class="math display">\[
x = \left[\begin{array}{c} 1 \\ 1 \end{array}\right], \quad
Ax = \left[\begin{array}{c} 1 \\ 1 \end{array}\right],  \quad
\lambda = 1,  \quad
Ax = x
\]</span></p>
<p>Bir tane daha özdeğer/vektör lazım. Bu diğer özdeğer <span
class="math inline">\(\lambda = -1\)</span> olmalı. Peki nasıl bir
vektör olmalı ki öğeleri yer değiştirince ters yönü göstersin?</p>
<p><span class="math display">\[
x = \left[\begin{array}{r} -1 \\
1 \end{array}\right],  \quad
Ax = \left[\begin{array}{r} 1 \\
-1 \end{array}\right],  \quad
\lambda = -1,  \quad
Ax = -x
\]</span></p>
<p>Özvektör/değerler hakkında ufak bir şey daha söylemek istiyorum.
<span class="math inline">\(N \times N\)</span> matrisinin <span
class="math inline">\(N\)</span> tane özdeğeri vardır. Bu değerleri
bulmak kolay değildir. 1., 2., hatta <span
class="math inline">\(N\)</span>’inci seviye bir denklemden çıkar bu
değerler. Fakat bize yardım eden bir numara vardır, tüm özdeğerlerin
toplamı matrisin köşegen değerlerinin toplamına eşittir, ki bu toplama
“iz’’ (trace) ismi verilir.</p>
<p>Bu numarayı üstteki örnekte kullanırsak, <span
class="math inline">\(\lambda = 1\)</span> bulduğum anda diğer özdeğerin
-1 olduğunu hemen bilirim, çünkü ana matrisin izi sıfır, <span
class="math inline">\(0 - 1 = -1\)</span>.</p>
<p>Artık özdeğer/vektör hesabına gelelim. <span class="math inline">\(Ax
= \lambda x\)</span> denklemi var, bu denklemde iki bilinmeyen var. Bu
denklemi nasıl çözerim? Bir numara, her şeyi tek tarafa gönderirim,</p>
<p><span class="math display">\[ (A-\lambda I )x = 0 \]</span></p>
<p>Şimdi bu denklem bana bir şeyler söylüyor. Eğer bir <span
class="math inline">\(x\)</span> “var’’ ise, bu varlık, <span
class="math inline">\(A-\lambda I\)</span>’nin eşsiz olduğu anlamına
gelir. Peki eşsiz matrisler hakkında ne biliyorum? Determinantlarının
sıfır olduğunu biliyorum. Yani,</p>
<p><span class="math display">\[ \det (A -\lambda I) = 0 \]</span></p>
<p>Bu denklem özdeğer denklemi, ya da karakteristik denklem
(characteristic equation) olarak bilinir.</p>
<p>İlk önce <span class="math inline">\(\lambda\)</span> bulmakla işe
başlarım. Tabii <span class="math inline">\(N\)</span> tane <span
class="math inline">\(\lambda\)</span> olacaktır, bunların hepsini
bulmakla işe başlarım. Not: <span class="math inline">\(N\)</span> <span
class="math inline">\(\lambda\)</span> olması demek <span
class="math inline">\(N\)</span> değişik <span
class="math inline">\(\lambda\)</span> olması anlamına gelmiyor, bazı
<span class="math inline">\(\lambda\)</span> değerleri kendini tekrar
edebilir. Tabii tekrarlanan <span class="math inline">\(\lambda\)</span>
bizim dersteki her türlü derdin kaynağıdır [biraz şaka biraz gerçek
havasıyla söylüyor hoca].</p>
<p><span class="math inline">\(\lambda\)</span>’yi bulunca ne yaparım?
Matrisin sıfır uzayını hesaplarım, ki artık bu işlemde usta olduk,
eliminasyona başlarım, pivot bulurum, vs.</p>
<p>Örnek</p>
<p><span class="math display">\[
A = \left[\begin{array}{ccc}
3 &amp; 1 \\ 1 &amp; 3
\end{array}\right]
\]</span></p>
<p>Bu matris simetrik. Bu tür özel şartlar matrisin özdeğerlerinin de
özel olması anlamına gelir. Mesela simetrik matrislerin tüm
özdeğerlerinin reel sayı olduğunu hemen bilirim. Peki özvektörler?
Birbirlerine dik olurlar. Bir önceki örneği hatırlarsak, <span
class="math inline">\(\left[\begin{array}{cc}1&amp;-1\end{array}\right]\)</span>
ve <span
class="math inline">\(\left[\begin{array}{cc}-1&amp;1\end{array}\right]\)</span>.</p>
<p><span class="math display">\[
\det (A -\lambda I) = \left[\begin{array}{ccc} 3-\lambda &amp; 1 \\ 1
&amp; 3-\lambda
\end{array}\right] =
(3-\lambda)^2 -1 = 0
\]</span></p>
<p><span class="math display">\[ \lambda^2 - 6\lambda + 8 = 0
\]</span></p>
<p>Bu formüldeki <span class="math inline">\(6\)</span> nedir? Matris
izinin eksi hali. Peki 8? O da determinant. Yani 2x2 durumunda sayılar
çok basit şekilde ortaya çıkıyorlar. Neyse, üstteki formülü faktorize
edelim, <span class="math inline">\((\lambda - 4)(\lambda - 2)\)</span>,
yani <span class="math inline">\(\lambda_1 = 4,\lambda_2 =
2\)</span>.</p>
<p>Şimdi özvektörler: Bu vektörler köşegenden 2 ya da 4 çıkartıldığı
zaman ortaya çıkan matrislerin sıfır uzayıdır.</p>
<p><span class="math display">\[
\left[\begin{array}{ccc}
3-4 &amp; 1 \\ 1 &amp; 3-4
\end{array}\right] =
\left[\begin{array}{ccc}
-1 &amp; 1 \\ 1 &amp; -1
\end{array}\right]
\]</span></p>
<p>Bu matris eşsiz mi? Öyle. Bu matrisi <span
class="math inline">\(x_1=\left[\begin{array}{cc} 1 &amp; 1
\end{array}\right]\)</span> ile çarparsam sıfır elde ederim. Diğeri?</p>
<p><span class="math display">\[
\left[\begin{array}{ccc}
3-2 &amp; 1 \\ 1 &amp; 3-2
\end{array}\right] =
\left[\begin{array}{ccc}
1 &amp; 1 \\ 1 &amp; 1
\end{array}\right]
\]</span></p>
<p><span class="math inline">\(x_2 = [1 \ -1]\)</span>. Bu da ikinci
özvektör.</p>
<p>İlginç bir durum, bu sonuç permutasyon matrisinden gelen sonuca çok
benziyor. Fark nerede? Ana matrisin köşegenine 3 eklenmiş, ya da <span
class="math inline">\(A + 3I\)</span> yapılmış. Bunu yapınca özdeğerlere
3 eklemiş oldum. Ama özvektörler hiç değişmeden kaldı.</p>
<p>Daha çetrefil bir örnek görelim. Diyelim ki iki matris <span
class="math inline">\(A,B\)</span>’nin özdeğerlerini biliyorum. <span
class="math inline">\(A+B\)</span>’nin özdeğerleri <span
class="math inline">\(\lambda,\alpha\)</span> nedir? İlk akla gelen
cevap “özdeğerleri toplanır’’ doğru değil. Çünkü</p>
<p><span class="math display">\[ (A+B)x = (\lambda+\alpha)x
\]</span></p>
<p>demiş oluruz, ama bunu derken özvektörler aynı demiş oluruz. Bu doğru
değildir. <span class="math inline">\(A \cdot B\)</span> aynı şekilde.
Bunlar kötü örnekler.</p>
<p>Bir örnek daha yapalım, bu sefer döndürme / rotasyon (rotation)
matrisi. 90 derece döndürme matrisi olsun.</p>
<p>Örnek</p>
<p><span class="math display">\[ Q =  
\left[\begin{array}{ccc}
\cos 90 &amp; -\sin 90 \\
\sin 90 &amp; \cos 90
\end{array}\right]
= \left[\begin{array}{ccc}
0 &amp; -1\\
1  &amp; 0
\end{array}\right]
\]</span></p>
<p>Bu bir dik, dikgen (orthogonal) bir matris. Özdeğerlerin toplamı
sıfır olacak, çünkü iz öyle. Determinant özdeğerlerin çarpımına eşit,
yani bu çarpım 1 olacak.</p>
<p>Fakat bu örnekte bazı şeyler yanlış gidecek. Niye? Düşünelim, hangi
vektör bu matrise verilince, döndürüldükten sonra dışarı aynı yönde
olarak çıkar? Özellikle 90 derece döndürüldükten sonra. Gördüğünüz gibi
problem çıkabilir. Özdeğerler ile de problem var, toplamı 0 olan ama
çarpımı 1 olan nasıl sayılar bulabileceğiz ki?</p>
<p>Fakat bir çare var. Hesaplayalım,</p>
<p><span class="math display">\[ \det(Q - \lambda I) =
\left[\begin{array}{ccc}
-\lambda &amp; -1 \\
1 &amp; -\lambda
\end{array}\right] = \lambda^2 + 1 = 0
\]</span></p>
<p>Özdeğerler nedir? <span class="math inline">\(\lambda_1 = i,
\lambda_2 = -i\)</span>. Bu sayılar kompleks / hayali sayılardır, reel
değillerdir. Bu olabilir. Bir matris, üstte olduğu gibi, tamamen reel
sayılardan oluşabilir, ama özdeğerleri hayali olabilir.</p>
<p>Bu iki hayali sayı birbirinin kopmleks eşleniği (complex conjugate).
Kompleks eşleniğin ne olduğunu hatırlıyoruz herhalde, bir sayının hayali
kısmının işaretini değiştirince onun kompleks eşleniğini elde etmiş
olurum. Üstteki sayılar zaten tamamen hayali bölümden oluşuyor, hiç reel
kısımları yok, o tek kısmın da işaretini değiştirince eşleniği elde
ediyorum.</p>
<p>Eğer matrisim simetrik, ya da “simetriğe yakın’’ olsaydı, üstteki
durum kesinlikle ortaya çıkmazdı. Çünkü kural odur ki, simetrik
matrislerin özdeğerleri reeldir.</p>
<p>Bol bol örnek veriyorum ki tüm olasılıkları görebilelim.</p>
<p>Bir kötü ihtimal daha.</p>
<p><span class="math display">\[ A =
\left[\begin{array}{ccc}
3 &amp; 1 \\ 0 &amp; 3
\end{array}\right]
\]</span></p>
<p>Bu matris üçgensel (triangular). Bu tür matrislerde özdeğerler
köşegenin üzerindedir! Bunu bilmek oldukça faydalıdır. Ama kontrol
edelim,</p>
<p><span class="math display">\[ \det(Q - \lambda I) =
\left[\begin{array}{ccc}
3-\lambda &amp; 1 \\
0 &amp; 3-\lambda
\end{array}\right] = (3-\lambda)(3-\lambda) = 0,
\lambda_1 = 3, \lambda_2 = 3
\]</span></p>
<p>Problem nerede? Problem özvektörlerde. Hatırlayalım,</p>
<p><span class="math display">\[ (A-\lambda I)x = 0\]</span></p>
<p>denklemini çözüyoruz, yani</p>
<p><span class="math display">\[ (A-\lambda I)x =
\left[\begin{array}{cc}
0 &amp; 1 \\
0 &amp; 0
\end{array}\right]
\vec{x}
=
\left[\begin{array}{c}
0 \\ 0
\end{array}\right]
\]</span></p>
<p>Burada <span class="math inline">\(\vec{x}\)</span> sonucunu
arıyorum, bir vektör. Kafadan hemen birinci özvektörü bulabilirim,</p>
<p><span class="math display">\[ x_1 = \left[\begin{array}{c}
1 \\ 0
\end{array}\right] \]</span></p>
<p>Peki ikinci özvektör nedir? Bu vektörün birinciden bağımsız olması
gerekir, unutmayalım. Böyle bir vektör bulabilir miyiz? Bulamayız.
Mümkün değil. Bu sebeple bu örneğe dejenere durum (değenerate case)
denir. İkinci bir bağımsız özvektör yoktur.</p>
<p>Ekler</p>
<p>Alttaki anlatım alternatif bir kaynaktan alınmıştır</p>
<p>Özvektörler, Özdeğerleri Elle Hesaplamak (Eigenvectors,
Eigenvalues)</p>
<p>Özdeğerler ve özvektörler her matrise göre özel vektörlerdir, ki
matris bu özel vektörleri transform ettiğinde / işlediğinde sonuç yine
özvektörün kendisidir, daha doğrusu onun bir sabit (özdeğer) ile
çarpılmış halidir. Yani</p>
<p><span class="math display">\[ Ax = \lambda x \]</span></p>
<p>Tek tarafa geçirelim</p>
<p><span class="math display">\[ Ax - \lambda x = 0 \]</span></p>
<p>Bu noktada <span class="math inline">\(x\)</span>’leri dışarı çekmek
isterdik, fakat bunu yapamayız, çünkü o zaman içeride <span
class="math inline">\(A - \lambda\)</span> kalır ve bu olmaz, çünkü
<span class="math inline">\(A\)</span> bir matris, <span
class="math inline">\(\lambda\)</span> bir tek sayı. Ama <span
class="math inline">\(Ix = x\)</span>’ten hareketle</p>
<p><span class="math display">\[ Ax - \lambda I x = 0 \]</span></p>
<p>diyebiliriz. Şimdi dışarı çekersek</p>
<p><span class="math display">\[ (A - \lambda I) x = 0 \]</span></p>
<p>Bu ifadenin doğru olması için parantez içindeki ifade / matris eşsiz
(singular) olmalıdır. Bunun için ise parantez içinin determinantı sıfır
olmalıdır. Yani</p>
<p><span class="math display">\[ |A - \lambda I| = 0 \]</span></p>
<p>Örnek</p>
<p><span class="math display">\[
A =
\left[\begin{array}{rr}
1 &amp; 4 \\ 3 &amp; 5
\end{array}\right]
\]</span></p>
<p><span class="math display">\[
A - \lambda I =
\left[\begin{array}{rr}
1 &amp; 4 \\ 3 &amp; 5
\end{array}\right] -
\lambda
\left[\begin{array}{rr}
1 &amp; 0 \\ 0 &amp; 1
\end{array}\right]
\]</span></p>
<p><span class="math display">\[
= \left[\begin{array}{rr}
1 - \lambda &amp; 4 \\ 3 &amp; 5-\lambda
\end{array}\right]
\]</span></p>
<p><span class="math display">\[ det(A - \lambda I) =
(1-\lambda)(5-\lambda) - 4 \cdot 3 \]</span></p>
<p>Üstteki denkleme karakteristik denklem (characteristic equation)
denir.</p>
<p><span class="math display">\[ = -7 -6\lambda + \lambda^2
\]</span></p>
<p>Kökleri <span class="math inline">\(\lambda_1 = 7\)</span>, <span
class="math inline">\(\lambda_2 = -1\)</span>.</p>
<p>Her özdeğere tekabül eden özvektörü bulmak istiyorsak, çıkartma
işlemini yapalım</p>
<p><span class="math display">\[
A - \lambda I =
\left[\begin{array}{rr}
1-7 &amp; 4 \\ 3 &amp; 5-7
\end{array}\right] =
\left[\begin{array}{rr}
-6 &amp; 4 \\ 3 &amp; -2
\end{array}\right]
\]</span></p>
<p>Şu formüle dönersek</p>
<p><span class="math display">\[ (A - \lambda I) x = 0 \]</span></p>
<p>Çıkartma sonrası elimize geçen matrisi çarpacak öyle bir <span
class="math inline">\(x\)</span> vektörü arıyoruz ki bu vektörle
çarpınca elimize sıfır (vektörü) geçsin. Yani bu aradığımız <span
class="math inline">\(x\)</span> vektörü <span class="math inline">\((A
- \lambda I)\)</span>’nin sıfır uzayında (nullspace).</p>
<p>2 x 2 boyutundaki böyle ufak bir örnek için <span
class="math inline">\(x\)</span>’i aslında tahmin edebiliriz. Öyle iki
sayı bulalım ki, 1. ve 2. kolonu onlarla ayrı ayrı çarpıp topladığımızda
sonuç sıfır olsun. Her iki kolonun tepesinde -6 ve 4 görüyorum, sadece
bu iki sayının sıfıra toplanması için acaba -6’yı 2 ile 4’ü 3 ile çarpıp
toplasam olur mu? Kolondaki diğer sayılara bakıyoruz, 3 ve -2 için de bu
işe yarıyor. Demek ki özvektörlerden biri</p>
<p><span class="math display">\[ x_1 =
\left[\begin{array}{r}
2 \\ 3
\end{array}\right]
\]</span></p>
<p>Diğeri ise, aynı tekniği kullanarak,</p>
<p><span class="math display">\[ x_2 =
\left[\begin{array}{r}
-2 \\ 1
\end{array}\right]
\]</span></p>
<p>Ekler</p>
<p>Özdeğer/Vektör Hesabında Üst Metot (Power Method)</p>
<p>Diyelim ki bir <span class="math inline">\(A\)</span> matrisinin, ki
<span class="math inline">\(A \in \mathbb{R}^{n \times n}\)</span>,
özdeğerleri <span class="math inline">\(\lambda_1,...,\lambda_n\)</span>
ve özvektörleri <span class="math inline">\(v_1,..,v_n\)</span> olarak
verilmiş. Bu demektir ki her <span
class="math inline">\(i=1,..,n\)</span> için <span
class="math inline">\(Av_i = \lambda_i v_i\)</span>. Farzedelim ki bu
matrisin tüm özvektörleri bir “özbaz (eigenbasis)’’ oluşturuyor ve bu
baz ile <span class="math inline">\(\mathbb{R}^n\)</span>’deki herhangi
bir vektörü temsil edebiliyoruz. Hatırlayalım eğer tekrar eden özdeğer
yok ise (hepsi değişik), normalize edilmiş <span
class="math inline">\(v_i\)</span> vektörleri birimdik (orthonormal) bir
set oluştururlar, <span
class="math inline">\(||v||=1,v_i^Tv_i=1,v_j^Tv_i=0\)</span>
demektir.</p>
<p>Diyelim ki <span class="math inline">\(|\lambda_1| &gt; |\lambda_2|
&gt; .. &gt; |\lambda_n|\)</span>, bu yazıda <span
class="math inline">\(\lambda_1\)</span>’e baskın (dominant) özdeğer
diyeceğiz. Şimdi Herhangi bir <span class="math inline">\(v_0 \in
\mathbb{R}^n\)</span>’i alalım. Üsttekiler ışığında <span
class="math inline">\(\mu_1,..,\mu_n\)</span> olarak öyle katsayılar
olmalıdır ki</p>
<p><span class="math display">\[ v_o = \mu_1v_1 + .. + \mu_nv_n
\]</span></p>
<p>çünkü özvektörler bir baz oluşturuyorlar. Şimdi her iki tarafı soldan
<span class="math inline">\(A\)</span> ile çarpalım, ayrıca <span
class="math inline">\(Av_i = \lambda_iv_i\)</span> eşitliğinden
hareketle üstteki eşitliğin sağ tarafını alıp üçüncü bir eşitlik olarak
en sağda yazalım,</p>
<p><span class="math display">\[ A v_o = \mu_1 A v_1 + .. + \mu_n A v_n
=
\mu_1\lambda_1v_1 + ... + \mu_n\lambda_nv_n
\]</span></p>
<p>Şimdi üstteki ifadeyi <span class="math inline">\(A\)</span> ile bir
daha, hatta birkaç defa çarpalım, diyelim toplam <span
class="math inline">\(m\)</span> kere çarpmış olalım,</p>
<p><span class="math display">\[
A^m v_o = \mu_1 A^m v_1 + .. + \mu_n A^m v_n =
\mu_1\lambda_1^mv_1 + ... + \mu_n\lambda_n^mv_n
\qquad (1)
\]</span></p>
<p>En sağda niye <span class="math inline">\(\lambda_i^m\)</span>
ifadeleri elde ettik? Mesela <span
class="math inline">\(\mu_1\lambda_1v_1\)</span> ifadesi, <span
class="math inline">\(A\)</span> ile bir kere çarpılınca,</p>
<p><span class="math display">\[
\mu_1\lambda_1\underbrace{Av_1}_{\lambda_1v_1} =
\mu_1\lambda_1\lambda_1v_1 =
\mu_1\lambda_1^2v_1
\]</span></p>
<p>olacaktır. Bunu <span class="math inline">\(m\)</span> kere yapınca
(1)’in en sağındaki sonucu elde ederiz.</p>
<p>Şimdi (1)’in en sağındaki eşitliğin içinden <span
class="math inline">\(\lambda_1^m\)</span>’i çıkartalım (1)’ın en
solundaki eşitlik ile yanyana getirelim,</p>
<p><span class="math display">\[
A^m v_o =
\lambda_1^m \bigg(  
\mu_1v_1
+ \mu_n \bigg(\frac{\lambda_2}{\lambda_1}\bigg)^m v_2
+ ...
+ \mu_n \bigg(\frac{\lambda_n}{\lambda_1}\bigg)^m v_n
\bigg)
\]</span></p>
<p>İspatın başında baskın özdeğerin <span
class="math inline">\(\lambda_1\)</span> olduğunu söylemiştik. O
zaman</p>
<p><span class="math display">\[
\bigg| \frac{\lambda_2}{\lambda_1} \bigg| &lt; 1, ...,
\bigg| \frac{\lambda_n}{\lambda_1} \bigg| &lt; 1
\]</span></p>
<p>Bu demektir ki limit koşulu <span class="math inline">\(m \to
\infty\)</span> durumunda</p>
<p><span class="math display">\[
A^m v_o =
\lambda_1^m \bigg(  
\mu_1v_1
\cancelto{0}
{
+ \mu_n \bigg(\frac{\lambda_2}{\lambda_1}\bigg)^m v_2
+ ...
+ \mu_n \bigg(\frac{\lambda_n}{\lambda_1}\bigg)^m v_n
}
\bigg)
\]</span></p>
<p>Yani,</p>
<p><span class="math display">\[
A^m v_o = \lambda_1^m  \mu_1v_1
\]</span></p>
<p>çünkü 1’den küçük olan tüm bölümler, katları alındıkça ve o kat
(<span class="math inline">\(m\)</span>) çok büyüdüğünde sıfıra
giderler. Bu bölümleri içeren tüm terimler yokolur ve geriye üstteki
ifade kalır.</p>
<p>Böylece üst metodunu türetmiş olduk. En son ifade şunu söylüyor,
herhangi bir vektör <span class="math inline">\(v_0\)</span>’i alalım,
ve onu <span class="math inline">\(A\)</span> ile <span
class="math inline">\(m\)</span> kere çarpalım, ve bu durumda elimize
gerçek özvektör <span class="math inline">\(v_1\)</span>’e paralel bir
vektör <span class="math inline">\(\lambda_1^m \mu_1v_1\)</span>
geçecektir (paralel çünkü <span class="math inline">\(v_1\)</span>
değeri tek sayı / skalar <span
class="math inline">\(\lambda^m\mu_1\)</span> ile çarpılmakta). Bu
vektörü normalize ederek bir özvektör sonucu elde edebiliriz.
Unutmayalım, özvektörlerin sadece yönü ile ilgileniyoruz, büyüklükleri
ile ilgilenmiyoruz, eğer <span class="math inline">\(v_1\)</span> bir
özvektör ise, herhangi bir skalar <span class="math inline">\(k\)</span>
için <span class="math inline">\(kv_1\)</span> de bir özvektördür. Ders
başında özvektörlerin “A ile çarpılıp <em>yönünün</em> değişmemesi’’
bağlamında tanımlandığını aklımızda tutalım [2].</p>
<p>Örnek olarak alttaki <span class="math inline">\(A\)</span>’yi
alalım, başlangıç olarak <span
class="math inline">\(v_0=\left[\begin{array}{cc} 1 &amp; 1
\end{array}\right]\)</span></p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>v0 <span class="op">=</span> np.array([<span class="fl">1.</span>,<span class="fl">1.</span>])</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.array([[<span class="fl">13.</span>, <span class="fl">5.</span>], [<span class="fl">2.</span>, <span class="fl">4.</span>]])</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">20</span>): </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    v0 <span class="op">=</span> np.dot(A,v0)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> <span class="st">&#39;v0 =&#39;</span>,v0</span></code></pre></div>
<pre><code>v0 = [  1.14093076e+23   2.28186151e+22]</code></pre>
<p>Sonsuzluk norm’u (infinity norm) ile normalize edersek (sonsuzluk
normu bir vektör içindeki en büyük öğenin alınıp bölümde kullanılmasıyla
yapılan normalizasyondur),</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>v1 <span class="op">=</span> v0 <span class="op">/</span> np.<span class="bu">max</span>(v0)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>v1 <span class="op">=</span> v1.reshape((<span class="dv">2</span>,<span class="dv">1</span>))</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> <span class="st">&#39;v1 =&#39;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> v1</span></code></pre></div>
<pre><code>v1 =
[[ 1. ]
 [ 0.2]]</code></pre>
<p>Kontrol edelim,</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy.linalg <span class="im">as</span> lin</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>U,D <span class="op">=</span> lin.eig(A)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> U</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> D</span></code></pre></div>
<pre><code>[ 14.   3.]
[[ 0.98058068 -0.4472136 ]
 [ 0.19611614  0.89442719]]</code></pre>
<p>Birinci kolona oldukça yakın bir değer elde ettik, ki en büyük
özdeğere tekabül eden özvektör orada.</p>
<p>Peki özdeğerin kendisini nasıl buluruz? Rayleigh Bölümü (Rayleigh
Quotient) formülünü kullanabiliriz. Bu formül, eğer <span
class="math inline">\(x\)</span> bir özvektör ise</p>
<p><span class="math display">\[ \lambda = \frac{x^TAx}{x^Tx}
\]</span></p>
<p>Türetelim,</p>
<p><span class="math display">\[ Ax = \lambda x  \]</span></p>
<p><span class="math display">\[ x^TAx = x^T\lambda x \]</span></p>
<p><span class="math inline">\(\lambda\)</span> bir tek sayı olduğuna
göre sağ taraftan <span class="math inline">\(x^Tx\)</span>’i alıp,
solda bölüm yapabiliriz, ve Rayleigh formülüne erişiriz.</p>
<p><span class="math display">\[ x^TAx / x^Tx = \lambda \]</span></p>
<ol type="1">
<li>özdeğeri hesaplayalım o zaman,</li>
</ol>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> np.dot(np.dot(v1.T,A),v1) <span class="op">/</span> np.dot(v1.T,v1)</span></code></pre></div>
<pre><code>[[ 14.]]</code></pre>
<p>Tüm Özvektörler</p>
<p>En büyük özdeğeri bulmanın yolunu gördük. Diğer özvektörleri nasıl
buluruz? Bunun yöntemlerinden birisi en büyük özdeğer <span
class="math inline">\(\lambda_1\)</span>’i bulduktan sonra onu bir işlem
sonrası en küçük haline getirmek, ve Üst Metotu tekrar kullanarak (artık
en büyük olan) <span class="math inline">\(\lambda_2\)</span>’yi bulmak.
<span class="math inline">\(\lambda_1\)</span>’i en küçük haline
getirmek, özdeğer/vektörü ana matris <span
class="math inline">\(A\)</span>’dan çıkartmak, onu “deflasyon işlemine
tabi tutmak’’ (deflation) olarak biliniyor. Çıkartacağımız değer <span
class="math inline">\(\lambda_1u_1u_1^T\)</span> olacak. İspatı şöyle
gösterelim (normalize edilmiş <span class="math inline">\(v_i\)</span>
özvektörleri şimdi <span class="math inline">\(u_i\)</span> olarak
gösteriyoruz),</p>
<p><span class="math display">\[ (A-\lambda_1u_1u_1^T)u_j =
Au_j-\lambda_1u_1u_1^Tu_1u_j =
\lambda_ju_j - \lambda_1u_1(u_1^Tu_j)
\]</span></p>
<p>Eğer <span class="math inline">\(j=1\)</span> ise</p>
<p><span class="math display">\[  (A-\lambda_1u_1u_1^T)u_1 =
\lambda_1u_1 - \lambda_1u_1(u_1^Tu_1) = 0u_j\]</span></p>
<p>Eğer <span class="math inline">\(j \ne 1\)</span> ise</p>
<p><span class="math display">\[ (A-\lambda_1u_1u_1^T)u_j = \lambda_ju_j
- \lambda_1u_1(u_1^Tu_j) = \lambda_ju_j  \]</span></p>
<p>Yani <span class="math inline">\((A-\lambda_1u_1u_1^T)\)</span>’nin
özvektörleri <span class="math inline">\(A\)</span> ile aynıdır, tek
farkı en büyük olanı 0 haline gelmiştir, ama <span
class="math inline">\(j \ne 1\)</span> için, yani diğer tüm özvektörleri
aynıdır. O zaman deflasyon işleminden sonra ele geçen yeni matris
üzerinde Üst Metotu tekrar kullanırsak artık en büyük olan <span
class="math inline">\(u_2\)</span>’yi buluruz, sonra deflasyonu
tekrarlarız, bir daha Üst Metot işletiriz, bu böyle devam eder.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>lam1 <span class="op">=</span> <span class="fl">14.</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>v0 <span class="op">=</span> np.array([<span class="fl">1.</span>,<span class="fl">1.</span>])</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> A <span class="op">-</span> np.dot(v1,v1.T)<span class="op">*</span>lam1</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> <span class="st">&#39;B&#39;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> B</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">20</span>): </span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    v0 <span class="op">=</span> np.dot(B,v0)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>v2 <span class="op">=</span> v0 <span class="op">/</span> np.<span class="bu">max</span>(v0)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>v2 <span class="op">=</span> v2.reshape((<span class="dv">2</span>,<span class="dv">1</span>))</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> <span class="st">&#39;v2&#39;</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> v2</span></code></pre></div>
<pre><code>B
[[-1.    2.2 ]
 [-0.8   3.44]]
v2
[[ 0.55]
 [ 1.  ]]</code></pre>
<p>Rayleigh Bölümü ile ikinci özdeğeri bulalım,</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> np.dot(np.dot(v2.T,B),v2) <span class="op">/</span> np.dot(v2.T,v2)</span></code></pre></div>
<pre><code>[[ 3.]]</code></pre>
<p>Kaynaklar</p>
<p>[1] Feys, <em>MATH317 EIGHTEENTH TUTORIAL</em>, <a
href="http://www.math.mcgill.ca/feys/documents/tutnotesR18.pdf">http://www.math.mcgill.ca/feys/documents/tutnotesR18.pdf</a></p>
<p>[2] Woolgar, <em>Lab 15-Power Method and Dominant Eigenvalues</em>,
<a
href="http://www.math.ualberta.ca/~ewoolgar/labs/linalg/Lab15.pdf">http://www.math.ualberta.ca/~ewoolgar/labs/linalg/Lab15.pdf</a></p>
<p>[3] Roberts, <em>Computation of matrix eigenvalues and eigenvectors
</em>, <a
href="http://www.robots.ox.ac.uk/~sjrob/Teaching/EngComp/ecl4.pdf">http://www.robots.ox.ac.uk/~sjrob/Teaching/EngComp/ecl4.pdf</a></p>
<p>[4] Murphy, K., <em>CS340: Machine Learning Lecture Notes</em>, <a
href="www.ugrad.cs.ubc.ca/~cs340">www.ugrad.cs.ubc.ca/~cs340</a></p>
<p>[6] Zaki, Maira, <em>Fundamentals of Data Mining Algorithms</em></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
