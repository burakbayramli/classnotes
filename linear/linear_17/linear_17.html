<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>

  <title>Ders 17</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  
  
  
  
</head>
<body>
<h1 id="ders-17">Ders 17</h1>
<p>Bugün dikgenlik (orthogonality) ders dizisinin sonuncusundayız. Dikgen vektörleri, iki tanesini gördük, dikgen altuzayları gördük, ki bunlar satır uzayı ve sıfır uzayı idi, bugün dikgen baz ve dikgen matrisi göreceğiz.</p>
<p>Şimdi birimdik (orthonormal) kelimesinden bahsetmek istiyorum. Bu arada bu derste <span class="math inline">\(q\)</span> harfini dikgen vektörleri temsil etmek için kullanacağım.</p>
<p>Birimdik vektörler</p>
<p><span class="math display">\[
q_i^Tq_j = \left\{ \begin{array}{lll}
0 &amp; \textrm{eğer} &amp; i \ne j \textrm{ ise}\\
1 &amp; \textrm{eğer} &amp; i = j \textrm{ ise}
\end{array} \right.
\]</span></p>
<p>Yani <span class="math inline">\(q\)</span> vektörleri diğer her <span class="math inline">\(q\)</span>'ya (kendisi haricinde) dikgen. Her biri bir diğerine 90 derece dik vektörlerden oluşan bir baz olması doğal bir şey. <span class="math inline">\(q\)</span> vektörleri birim, bu sebeple kendisiyle noktasal çarpımı 1. Birimdik kelimesinin İngilizcesi orthonormal'ın içindeki &quot;normal'' buradan geliyor, normalize edilmiş vektörlerimiz var.</p>
<p>Birimdik baza sahip olmak hesapları basitleştirir, çoğu hesabı iyileştirir, sayısal lineer cebirin çoğunluğu birimdik vektörlerle iş yapmak etrafında kurulmuştur, çünkü onlar aşırı büyümezler, aşırı küçülmezler, kontrol altında iş yapmak mümkün olur.</p>
<p>Bu <span class="math inline">\(q\)</span>'leri <span class="math inline">\(Q\)</span> içine koyacağız. Dersin ikinci kısmında eğer birimdik olmayan bir <span class="math inline">\(A\)</span> matrisim var ise, onu nasıl birimdik yaparım, onu göreceğiz. Şimdi üstteki 1 ve 0 içeren formülü matris olarak yazmak istiyorum.</p>
<p><span class="math display">\[
Q = 
\left[\begin{array}{rrr}
\uparrow &amp;  &amp; \uparrow \\
q_1 &amp; ... &amp;  q_n \\
\downarrow &amp;  &amp; \downarrow 
\end{array}\right]
\]</span></p>
<p>O zaman</p>
<p><span class="math display">\[
Q^TQ = 
\left[\begin{array}{rrr}
\leftarrow &amp; q_1^T &amp; \rightarrow \\
&amp; &amp;  \\
\leftarrow &amp; q_n^T &amp; \rightarrow 
\end{array}\right]
\left[\begin{array}{rrr}
\uparrow &amp;  &amp; \uparrow \\
q_1 &amp; ... &amp;  q_n \\
\downarrow &amp;  &amp; \downarrow 
\end{array}\right] = 
I
\]</span></p>
<p>Eğer <span class="math inline">\(Q\)</span> kare ise, <span class="math inline">\(Q^TQ = I\)</span> bize <span class="math inline">\(Q^T = Q^{-1}\)</span> olduğunu söyler.</p>
<p>Örnek</p>
<p>Her permutasyon matrisi</p>
<p><span class="math display">\[
Q = 
\left[\begin{array}{rrr}
0 &amp; 0 &amp; 1 \\
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 
\end{array}\right]
\]</span></p>
<p>kendi devriği ile çarpılınca, yani</p>
<p><span class="math display">\[
Q^T = 
\left[\begin{array}{rrr}
0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 1 \\
1 &amp; 0 &amp; 0 
\end{array}\right]
\]</span></p>
<p>ile, sonuç <span class="math inline">\(I\)</span> olacaktır. Bir diğer örnek</p>
<p><span class="math display">\[Q = 
\left[\begin{array}{cc}
\cos \theta &amp; -\sin \theta \\
\sin \theta &amp; \cos \theta \\
\end{array}\right]
\]</span></p>
<p>Fakat şu matris,</p>
<p><span class="math display">\[Q = 
\left[\begin{array}{cc}
1 &amp; 1 \\
1 &amp; -1 \\
\end{array}\right]
\]</span></p>
<p>dikgen matris değildir (şimdilik). Her kolonun uzunluğu <span class="math inline">\(\sqrt{2}\)</span>, o zaman tüm matrisi <span class="math inline">\(\sqrt{2}\)</span> ile bölerim,</p>
<p><span class="math display">\[Q = \frac{1}{\sqrt{2}}
\left[\begin{array}{cc}
1 &amp; 1 \\
1 &amp; -1 \\
\end{array}\right]
\]</span></p>
<p>Örnek</p>
<p><span class="math display">\[Q = \frac{ 1}{2}
\left[\begin{array}{rrrr}
1 &amp; 1&amp; 1&amp; 1 \\
1 &amp; -1&amp; 1&amp; -1 \\
1 &amp; 1&amp; -1&amp; -1 \\
1 &amp; -1&amp; -1&amp; 1 
\end{array}\right]
\]</span></p>
<p>Örnek</p>
<p><span class="math display">\[Q = \frac{ 1}{3}
\left[\begin{array}{rr}
1 &amp; -2 \\
2 &amp; -1 \\
2 &amp; 2 
\end{array}\right]
\]</span></p>
<p>Bir kolon daha eklersem</p>
<p><span class="math display">\[Q = \frac{ 1}{3}
\left[\begin{array}{rrr}
1 &amp; -2 &amp; 2\\
2 &amp; -1 &amp; -2 \\
2 &amp; 2 &amp; 1
\end{array}\right]
\]</span></p>
<p>Birimdik vektörler ve özelde Gram-Schmidt ile uğraşırken göreceğiz, sürekli normal vektörlerle uğraştığımız için sürekli uzunluğa bölmeniz gerekir, ve bu sürekli bir karekökü hesabın içine çeker. Üstteki örnek temiz, karekök direk sayı olarak elde edildi.</p>
<p>Dikgen matrisler niye iyidir? Onlar hangi hesapları basitleştirirler? <span class="math inline">\(Q\)</span> ne için kullanılır?</p>
<p>Diyelim ki bir diğer matrisi alıp <span class="math inline">\(Q\)</span>'nun kolon uzayına yansıtmak (projection) istiyorum. Yansıtma formülünü, matrisi <span class="math inline">\(Q\)</span> için yazarsak,</p>
<p><span class="math display">\[P = Q (Q^TQ)^{-1}Q^T\]</span></p>
<p>Formülde <span class="math inline">\(Q\)</span> olmasının bir avantajı, <span class="math inline">\(Q^TQ = I\)</span>, o zaman</p>
<p><span class="math display">\[P = Q Q^T\]</span></p>
<p>Bu yansıtma matrisinin özelliklerini / öğelerini (properties) kontrol edelim. İki tane özellik olması gerekiyor. Eğer kolonlar birimdik ise, ve yansıtma matrisi kare ise, o zaman kolon uzayı nedir? Tüm uzaydır! Birimdik kolonlar o uzayı yaratmak / kapsamak (span) için yeterlidir. Bu uzaydaki her türlü vektörü bu birimdik vektörlerin bir kombinasyonu üzerinen üretebilirsiniz. Peki, tüm uzaya yansıtmak ne demektir? Nasıl bir <span class="math inline">\(P\)</span> tüm uzaya yansıtır? Birim (identity) matrisi. Tüm uzaya yansıtmak hiçbir şeyi değiştirmemek demektir aslında, ve bu değişmezliği yapacak tek yansıtma matrisi <span class="math inline">\(I\)</span>.</p>
<p><span class="math display">\[P = Q Q^T = I \textit{ eğer I kare ise }\]</span></p>
<p>Bir diğer özellik yansıtma matrislerinin simetrik olması. Devriği ile sağdan çarpılmak bir matrisi zaten simetrik yapar, şart <span class="math inline">\(QQ^T\)</span> için geçerlidir. Bu özelliğin sebebi yansıtıp, sonra tekrar yansıtınca, ikinci yansıtmanın değişim yaratmaması. Yani</p>
<p><span class="math display">\[(QQ^T)(QQ^T) = QQ^T\]</span></p>
<p>olmalı. Kontrol edelim,</p>
<p><span class="math display">\[Q(Q^TQ)Q^T = QIQ^T = QQ^T\]</span></p>
<p><span class="math inline">\(Q\)</span>'nun özellikleri bize şu şekilde de yarar. Normal formül nedir?</p>
<p><span class="math display">\[A^TA\hat{x} = A^Tb\]</span></p>
<p><span class="math inline">\(A\)</span> yerine <span class="math inline">\(Q\)</span> ise</p>
<p><span class="math display">\[Q^TQ\hat{x} = Q^Tb\]</span></p>
<p><span class="math inline">\(Q^TQ = I\)</span> olduğuna göre,</p>
<p><span class="math display">\[\hat{x} = Q^Tb\]</span></p>
<p>İşler iyice basitleşti yani. <span class="math inline">\(A\)</span>'li versiyonda sol taraftaki iç çarpımları (inner product) hesaplamak gerekecekti, cebirsel çözüm için uğraşılacaktı, vs. Bunlar <span class="math inline">\(Q\)</span> ile yok. <span class="math inline">\(\hat{x}\)</span>'in <span class="math inline">\(i\)</span>'inci elemanı <span class="math inline">\(q_i^Tb\)</span>, yani</p>
<p><span class="math display">\[\hat{x}_i = q_i^Tb\]</span></p>
<p>Üstteki formülün matematiğin en önemli formüllerinden biri olduğu söylenebilir. Yani elimizde birimdik baz var ise, yansımasının <span class="math inline">\(i\)</span>'inci öğesi yukarıdaki gibidir.</p>
<p>Şimdi dersin ikinci bölümüne gelelim. Diyelim ki elimizde birimdik matris yok, bağımsız vektörler var, onları birimdik yapacağız. Gram-Schmidt burada ortaya çıkıyor. Tabii &quot;birimdik yapmak'' nedir, onu da açıklayalım. Eğer vektör <span class="math inline">\(a,b\)</span> bağımsız vektörleri birbirine dik değilse, onları değişime uğratmadan dik hale getiremeyiz. Birimdikleştirme işlemi vektörleri &quot;eski haline mümkün olduğunca yakın kalmak suretiyle'' dikleştirir ve normalleştirir.</p>
<p>Gram-Schmidt</p>
<p>GS hesabı eliminasyon ile aynı şey değildir, amacımız üçgensel değil, amacımız bir matrisi dikgen, kolonlarını birimdik yapmak. İki vektörümüz var diyelim, <span class="math inline">\(a,b\)</span>. Belki 12 boyutlu bir ortamdalar, belki (alttaki gibi) 2 boyuttalar. Vektörler bağımsız.</p>
<div class="figure">
<img src="17_1.png" />

</div>
<p>Bu iki vektörden <span class="math inline">\(q_1,q_2\)</span> birimdik vektörlerini çıkartmak istiyorum. Ya da, önce dikgen <span class="math inline">\(A,B\)</span>, sonra birimdik <span class="math inline">\(q_1,q_2\)</span> diyelim. Bunun için önce</p>
<p><span class="math display">\[q_1 = \frac{ A}{||A||}, q_2 = \frac{ B}{||B||} \]</span></p>
<p>Aslında <span class="math inline">\(a\)</span>'dan <span class="math inline">\(A\)</span> alınca, o vektörün işi bitmiş kabul edilebilir. Bir yön tamam, ama ilk yön olduğu için onun dikgen hali yeterli. Şimdi ikinci vektör nasıl birimdik olacak, çünkü artık birinciye göre dik olmalı, onu olduğu gibi alamayız.</p>
<div class="figure">
<img src="17_2.png" />

</div>
<p>Aradığımız vektör <span class="math inline">\(b\)</span>'nin <span class="math inline">\(a\)</span>'ya yansıması değil, ona tam dik olan <span class="math inline">\(e\)</span>. Eğer <span class="math inline">\(b\)</span>'nin formülü &quot;<span class="math inline">\(b\)</span>'nin <span class="math inline">\(a\)</span>'ya yansıması, artı <span class="math inline">\(e\)</span>'' ise, o zaman ters yöne gitmek için çıkartma işlemini kullanırız,</p>
<p><span class="math display">\[B = b - [yansıma]\]</span></p>
<p><span class="math inline">\(b\)</span>'nin <span class="math inline">\(a\)</span>'ya yansıması nedir? Yerine koyalım,</p>
<p><span class="math display">\[B = b - \frac{ A^Tb}{A^TA}A\]</span></p>
<p>Bu formül doğru mu? Kontrol edelim, eğer <span class="math inline">\(B\)</span> hakikaten <span class="math inline">\(A\)</span>'ya dikgen bir vektör veriyorsa, o zaman <span class="math inline">\(A^T\)</span> ile çarpılınca sıfır elde etmeliyiz.</p>
<p><span class="math display">\[A^TB = A^T(b - \frac{ A^Tb}{A^TA}A)\]</span></p>
<p><span class="math display">\[= A^Tb - \frac{ A^Tb}{A^TA}A^TA\]</span></p>
<p><span class="math display">\[= A^Tb - A^Tb = 0\]</span></p>
<p>Peki ya iki değil üç tane vektör olsaydı? Yani <span class="math inline">\(A,B\)</span>'ye ek olarak bir de <span class="math inline">\(C\)</span> hesaplamamız gerekiyor.</p>
<div class="figure">
<img src="17_3.png" />

</div>
<p>Bu hesaba şu şekilde bakabiliriz, aynen <span class="math inline">\(B\)</span>'yi bulmak için <span class="math inline">\(b\)</span>'den <span class="math inline">\(a\)</span> yönünde olan yansımasının kısmını çıkarttığımız gibi, <span class="math inline">\(C\)</span>'yi bulmak için <span class="math inline">\(c\)</span>'den <span class="math inline">\(a\)</span> ve <span class="math inline">\(b\)</span> yönünde olan yansımasının kısımlarını çıkartmayı düşünebiliriz.</p>
<p><span class="math display">\[C = c - \frac{ A^Tc}{A^TA}A - \frac{ B^Tc}{B^TB}B\]</span></p>
<p>Yani <span class="math inline">\(C \perp A\)</span>, <span class="math inline">\(C \perp B\)</span>.</p>
<p>Örnek</p>
<p><span class="math display">\[
a = 
\left[\begin{array}{r}
1 \\ 1 \\ 1
\end{array}\right],
b = 
\left[\begin{array}{r}
1 \\ 0 \\ 2
\end{array}\right]
\]</span></p>
<p>Hemen <span class="math inline">\(A = a\)</span> deriz. <span class="math inline">\(B\)</span> nedir?</p>
<p><span class="math display">\[
B = 
\underbrace{
\left[\begin{array}{r}
1 \\ 0 \\ 2
\end{array}\right]}_{b}
-
\frac{ 3}{3}
\underbrace{
\left[\begin{array}{r}
1 \\ 1 \\ 1
\end{array}\right]}_{A}
=
\left[\begin{array}{r}
0 \\ -1 \\ 1
\end{array}\right]
\]</span></p>
<p><span class="math inline">\(Q\)</span>'yu oluşturalım. Unutmayalım, her <span class="math inline">\(q\)</span> birim vektör, normalize olmalı. Problem değil, değerleri üstten alırken her elemanı uzunluğuna böleriz,</p>
<p><span class="math display">\[Q =
\left[\begin{array}{rrr}
\uparrow &amp;  &amp; \uparrow \\
q_1 &amp; ... &amp;  q_n \\
\downarrow &amp;  &amp; \downarrow 
\end{array}\right]
=
\left[\begin{array}{rr}
1/\sqrt{3} &amp; 0 \\
1/\sqrt{3} &amp; -1/\sqrt{2} \\
1/\sqrt{3} &amp; 1/\sqrt{2} 
\end{array}\right]
\]</span></p>
<p>Hatırlarsak ilk halimiz</p>
<p><span class="math display">\[A =
\left[\begin{array}{rr}
1 &amp; 1 \\
1 &amp; 0\\
1 &amp; 2
\end{array}\right]
\]</span></p>
<p>şeklindeydi.</p>
<p><span class="math inline">\(Q\)</span>'nun kolon uzayı ile <span class="math inline">\(A\)</span>'nin kolon uzayı arasındaki bağlantı, fark nedir? Kolon uzayı bir matrisin kolonlarının tüm kombinasyonları ise, 3 boyutlu uzayda iki kolonum var, demek ki kolon uzayı bir düzlem (plane), her iki matris için durum bu. Alaka nerede? İki düzlem de aynı! Tek yaptığım aynı uzayı yaratan ama birbirine dik iki yeni vektör yaratmak oldu. <span class="math inline">\(Q\)</span> vektörlerinden daha memnunum çünkü <span class="math inline">\(Q\)</span> birimdik.</p>
<p>Peki Gram-Schmidt'i Lineer Cebir dilinde nasıl daha temiz sekilde gösteririm? Eliminasyon mesela</p>
<p><span class="math display">\[A = LU\]</span></p>
<p>olarak gösterilir. Gram-Schmidt'in karşılığı nedir? Şudur,</p>
<p><span class="math display">\[A = QR\]</span></p>
<p><span class="math display">\[
\left[\begin{array}{rrr}
\uparrow &amp;  \uparrow \\
a_1 &amp;  a_2 \\
\downarrow &amp;  \downarrow 
\end{array}\right]
=
\left[\begin{array}{rrr}
\uparrow &amp;  \uparrow \\
q_1 &amp;  q_2 \\
\downarrow &amp;  \downarrow 
\end{array}\right]
\left[\begin{array}{rrr}
 &amp;   \\
0 &amp;  
\end{array}\right]
\]</span></p>
<p>Yani <span class="math inline">\(R\)</span> üst üçgensel (lower triangular) bir matristir, sol alt köşe sıfırdır. Niye?</p>
<p><span class="math display">\[
= \left[
\begin{array}{rrr}
\uparrow &amp;  \uparrow \\
q_1 &amp;  q_2 \\
\downarrow &amp;  \downarrow 
\end{array}\right]
\left[\begin{array}{rrr}
a_1^Tq_1 &amp;  * \\
a_1^Tq_2 &amp;  *
\end{array}
\right]
\]</span></p>
<p>Sıfır <span class="math inline">\(a_1^Tq_1\)</span>'dan geliyor. Özetlemek gerekirse, <span class="math inline">\(A\)</span>'yi alıp <span class="math inline">\(Q\)</span>'yu elde ediyoruz, ve bu iki matris arasındaki ilişki üst üçgensel olan <span class="math inline">\(R\)</span> matrisi.</p>
<p>Gram-Schmidt Python kodu altta bulunabilir.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy.linalg <span class="im">as</span> lin

A <span class="op">=</span> np.array([[<span class="fl">3.</span>, <span class="fl">4.</span>],[<span class="fl">5.</span>, <span class="fl">6.</span>]])
m,n <span class="op">=</span> A.shape
R <span class="op">=</span> np.zeros((m,n))
Q <span class="op">=</span> np.zeros((m,n))

<span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):
    v <span class="op">=</span> A[:,j]
    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(j):
        R[i,j] <span class="op">=</span> np.dot(Q[:,i].T,A[:,j])
        v<span class="op">=</span>v<span class="op">-</span>np.dot(R[i,j],Q[:,i])
    R[j,j] <span class="op">=</span> lin.norm(v)
    Q[:,j] <span class="op">=</span> v<span class="op">/</span>R[j,j]
<span class="bu">print</span> Q, R</code></pre></div>
<pre><code>[[ 0.51449576  0.85749293]
 [ 0.85749293 -0.51449576]] [[ 5.83095189  7.20294058]
 [ 0.          0.34299717]]</code></pre>
</body>
</html>
