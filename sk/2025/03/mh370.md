# MH370 Uçağı Nerede?

2014 yılında meydana gelen bu uçak kayıp hikayesini haberlerden
çoğumuz hatırlarız, Malezya'dan kalkış yapan uçak rotasını
değiştirerek kayıplara karıştı. Neler olduğu, uçağın nereye gittiği,
nereye düştüğü hakkında pek çok spekülason yapıldı.

Uçağı bulmak isteyen araştırmacılar pek cok yöntemi kullandı, veri
olarak faydalı olabilecek bazı ipuçlar elde vardı, mesela uçak bir
noktada askeri bir radarla tespit edilmişti, ardından bazı noktalarda
Immarsat uyduları ile iletişime geçtiği için o noktalarda "BTO verisi"
kayıtlarda idi, bunun üzerinden uyduya olan mesafe
hesaplanabiliyordu. Bazıları amatör radyo kullanıcılarının düzenli
olarak birbirlerine gönderdikleri düşük frekanslı WSPR denen
sinyallerdeki kesintilere dayanarak bunu bir tür radar olarak kullanma
fikrine erişti, böylece uçağın rotasını saptamaya uğraştı (Godfrey).

Biz burada örnek olarak Immersat BTO verisini kullanacağız. Veri belli
noktalarda yeri bilinen bir uyduya olan mesafeyi vermektedir. [1]
bağlantısından aldığımız ham veri alttadır,

```python
import pandas as pd
pd.set_option('display.max_columns', None)
df = pd.read_csv('flighta.csv')
df[['Date','Lat','Lon','PingArc']].head(3)
```

```text
Out[1]: 
                      Date       Lat        Lon  PingArc
0  2014-03-07 18:25:27.421  1.562623  64.527615    31.42
1  2014-03-07 19:41:02.906  1.639914  64.514401    29.01
2  2014-03-07 20:41:04.904  1.574644  64.503959    29.67
```

Uçağın uyduya olan mesafesini bilmek tabii işin başlangıcı, mesafe
verisini kullanıp uydu merkezli bir çember çizebiliriz ama uçak bu
çemberin üzerinde herhangi bir yerde olabilir. O zaman hesapsal
kestirme (estimation) teknikleri kullanmak bir çözüm olabilir, uçağın
ortalama hızını biliyoruz, uydu ile saptandığı noktalardaki tarihleri
biliyoruz, o zaman iki ölçüm arası bir mesafe hesaplayabiliriz, tek
bilmediğimiz gidiş yönü (bearing) bilgisidir, iki boyutlu olarak
düşünürsek bize açı bilgisi lazım.

Devam etmeden bir ayrıntı daha, üstteki veri uydunun uçağa olan
yeryüzü mesafesini değil, uydudan direk uçağa olan mesafeyi ölçüyor.
Fakat bizim yeryüzündeki uçak noktasını bulmak için yeryüzündeki
mesafelere ihtiyacımız var.

![](sat1.jpg)

Yani üstteki resimdeki `Dist` verisini `BTOr` hesabına çevirmemiz
lazım, isimlemeyi BTO çemberlerinin yarıçapı kavramını çağrıştırması
için seçtik. Hesap nasıl yapılır? Bize gereken dünya çevresinin / dış
çemberinin bir kısmı, bu kısmın, parçanın ne olduğunu bir acı hesabı
ile bulabiliriz, resimdeki $\alpha$ acısı bu. Bu hesap [2]'de
yapılmış, gereken açılar `PingArc` içinde.

Ayrıca uçağın her ölçüm arasında katettiği mesafe de lazım, bunun için
ölçüm noktaları arasında geçen zamanları hesaplarız, sonra ortalama
880 km/h baz alarak her aralıkta katedilen mesafe hesaplanabilir.

```python
R = 6378
vort = 880
Aort = 9700
df['Date'] = pd.to_datetime(df.Date)
df['Date2'] = df.Date.shift(-1)
df['Elapsed'] = df.apply(lambda x: ((x['Date2'] - x['Date']).total_seconds())/3600,axis=1)
df['BTOr'] = df.apply(lambda x: R*np.deg2rad(x['PingArc']), axis=1)
df[['Date','Elapsed','Lat','Lon','PingArc','BTOr']].head(3)
```

```text
Out[1]: 
                     Date   Elapsed       Lat        Lon  PingArc         BTOr
0 2014-03-07 18:25:27.421  1.259857  1.562623  64.527615    31.42  3497.583272
1 2014-03-07 19:41:02.906  1.000555  1.639914  64.514401    29.01  3229.309062
2 2014-03-07 20:41:04.904  1.006111  1.574644  64.503959    29.67  3302.778348
```

```python
from pygeodesy.sphericalNvector import LatLon
import pandas as pd, numpy as np
from scipy.optimize import minimize

pd.set_option('display.max_columns', None)

#Last Military Radar Contact
#18:22:12 6.65,96.34
d1 = (pd.to_datetime("2014-03-07 18:25:27.421") - \
      pd.to_datetime("2014-03-07 18:22:12.000")).total_seconds()/3600

def cost(pars):
    b1,bearings = pars[0],pars[1:]
    lat,lon = 6.65,96.34
    p1 = LatLon(lat,lon)
    curr = p1.destination (d1 * vort, bearing=b1, radius=R)    
    deltas = []
    for i,row in df.head(len(df) - 1).iterrows(): # skip last row
        p1 = LatLon(row['Lat'],row['Lon'])
        deltacurr = p1.distanceTo(curr) / 1000
        # add diff between ring and distance to sat
        deltas.append(np.abs(deltacurr-row['BTOr']))
        travel = row['Elapsed']*vort
        curr = curr.destination (travel, bearing=bearings[i], radius=R)

    return np.sum(deltas)
    
bearings = np.ones(len(df))*180
opts = {'maxiter': 100, 'verbose': 3}
res = minimize (fun=cost,x0=([220] + list(bearings)),
                method='Nelder-Mead',
                options=opts)
print (res['x'],res['fun'])
```

```text
[198.99332757 197.77683933 192.89800635 188.6371797  188.56380639
 191.33438559 164.3026896  164.84948342] 79.58458472231405
```



```python
from pygeodesy.sphericalNvector import LatLon
import folium

def plot_map(bearings_list,outfile):

    R = 6378
    d1 = (pd.to_datetime("2014-03-07 18:25:27.421") - \
          pd.to_datetime("2014-03-07 18:22:12.000")).total_seconds()/3600    
    b1,bearings = bearings_list[0],bearings_list[1:]
    m = folium.Map(location=[-25, 96], zoom_start=3) 
    lat,lon = 6.65,96.34
    folium.CircleMarker([lat,lon],
                        color='red',
                        fill=True,fillColor='red',
                        popup=folium.Popup("Last Military Radar Contact 18:22:12 ", show=True),
                        radius=4.0).add_to(m)                    
    p1 = LatLon(lat,lon)
    curr = p1.destination (d1 * vort, bearing=b1, radius=R)    
    for i,row in df.iterrows():
        folium.Circle(
            location=[row['Lat'],row['Lon']],
            radius=row['BTOr']*1000,
            color="red",
            weight=1,
            fill_opacity=0.6,
            opacity=1,
            popup="Arc {}".format(i+1)
        ).add_to(m)
        ds = pd.to_datetime(row['Date'])
        ds = ds.strftime('%m/%d %H:%M')
        folium.CircleMarker([curr.lat,curr.lon],
                            color='red',
                            fill=True,fillColor='red',
                            popup=folium.Popup("Arc" + str(i+1) + " " + ds, show=False),
                            radius=4.0).add_to(m)                
        if i==len(df)-1: break
        p1 = LatLon(row['Lat'],row['Lon'])
        deltacurr = p1.distanceTo(curr) / 1000
        travel = row['Elapsed']*vort
        curr = curr.destination (travel, bearing=bearings[i], radius=R)

    m.save(outfile)
    print (curr.lat,curr.lon)

plot_map(res['x'], "mh370_route.html")
```

```text
-39.23901069072979 86.26449624208075
```















Kaynaklar

[1] Wragg, Github, https://github.com/joewragg/MH370

[2] Zweck, https://personal.utdallas.edu/~zweck/Papers/Misc/MH370SIAMReviewSep15.pdf

[3] The Independent, https://www.independent.co.uk/travel/news-and-advice/mh370-radio-signals-theory-bbc-doc-b2508628.html


