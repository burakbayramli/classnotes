# Bağlaşım: Nesneler, Veri Tabanları


Bağlaşım: Nesneler, Veri Tabanları



 İş hayatına danışman/programcı olarak başladığımızdan beri önümüze şöyle bir problem çıkmıştır. Nesnesel bir dil ile yazdığımız  programlarımızı veri tabanına nasıl bağlayacağız?               "İnsanlar bunu niye problem haline getirdi?" diyebilirsiniz. Bunun birkaç sebebi var, ama çoğunun ana teması aynıdır: Programların bakım evresinde daha rahat değiştirebilmek... Zaten tasarım yaparken, ana amaçlarımızdan biri bu olmalıdır: Okunabilen, rahat değistirilebilen kod yazmak. Özet olarak: Yukarıda bahsettiğim arkadaşlarımızın (ve şimdi de benim) ana ilkesi şu idi. Veri tabani mimarisini, Java program  tasarımından mümkün olduğunca uzak tutmak/bağlantısını hafifletmek. Biraz daha açıklayalım.              * Java, nesne tabanlı olduğu için, Java programcıları her şeyi nesne olarak görürler. Mesela Javacılar için, insan.setIsim(yeniIsim) demek, UPDATE INSAN SET ISIM='' demekten daha rahattır. Eğer SQL kodunu Java içine koyarsanız, programın ne yaptığı rahat anlaşılmaz.    * Java kodunuz, veri taban cizelgesine direk bağlantı yapıyorsa, çizelge değişince Java programı değistirmeniz gerekecektir.              Şimdi iki türlü kod parçası vereceğiz. Hangisinin daha rahat veri tabanına erişim sağladığı belli olacaktır.               //// JDBC kullanıyoruz//class VeriKontrol{public void guncellestir(Isci isci, Fabrika fabrika, StringyeniIsim, String yeniSoyad, String yeniFabrika){ Connection c = d.getConnection(); PreparedStatement stmt = c.prepareStatement("UPDATE ISCI set ISIM=?, SOYAD=?, FABRIKA_NO=?"); stmt.setString(1, yeniIsim); stmt.setString(2, yeniSoyad); stmt.setString(3, yeniFabrika);}public void FabrikaCalisanIscileriIsle(String fabrikaNo){ Connection c = d.getConnection(); PreparedStatement stmt = c.prepareStatement("SELECT * FROM ISCI WHERE FABRIKA_NO=?"); stmt.setString(1, id); rs = stmt.executeQuery(); while (rs.next()) {    String id = rs.getString("ISCI_NO");// .. birseyler yap isci ile// ama dikkat edin, elimizde hala Isci nesnesi yok// nesneyi NO kullanarak yaratmamiz lazim. }}}              Eğer nesne/veri baglaşımı dışarıda yapılmış ise, program şöyle olabilirdi.                class VeriKontrol{public void guncellestir(Isci isci, Fabrika yeniFabrika){  // bu iki satiri nesne icinde daha once isletim, sonra  // gerektikce oradan kullanabilirsiniz. Hep yazmaya gerek yok.  PersistenceManagerFactory pmf = JDOFactory.getPersistenceManagerFactory ();  PersistenceManager pm = pmf.getPersistenceManager ();  // kritik yer burasi  fabrika.isciEkle(isci);  pm.guncellestir(isci);}public void FabrikaCalisanIscileriIsle(String fabrikaNo){  // yukaridakinin aynisi  PersistenceManagerFactory pmf = JDOFactory.getPersistenceManagerFactory ();  PersistenceManager pm = pmf.getPersistenceManager ();  // veriyi al  Collection results = null;  // sorgu yarat  q = pm.newQuery (e, "fabrikaNo == " + fabrikaNo);  sonuclar = (Collection)q.execute ();  Iterator sonucTarayici = results.iterator ();  while (sonucTarayici.hasNext ())  {Isci isci = (Isci)sonucTarayici.next ();// isci ile birseyler yap.// isci.getFabrika() diyerek fabrika objesine erismek mumkun// mesela....  }}}              Aradaki fark herhalde belli oluyordur. 2'inci kod parçasının üstün tarafı şurada, sadece nesneler ile haşır neşir oluyoruz ve setDeger, getDeger gibi ifadeler kullanabiliyoruz. Birinci şekilde, bir takım karmakarışık SQL kodunu Java içine koymak gerekiyor, iki dil ile uğrasmak gerekiyor.          Nesne/Tablo Eşleme Programları İçin Aranan Özellikler          Evet, bağlaşım dogru yapılınca Java kodumuz nasıl olacak gördük. Şimdi, bize yardımcı olacak yazılımı tanıyalim. Biraz da tarihçe.               Bağlaşım yazılımlarının tarihi, nesnesel programcılık kadar eskidir. Mesela bazı standardlar 90'li yılların başında ortaya  çıkmıştır: POS (Persistent Object Specification/Kalıcı Nesne Tarifnamesi) OMG adlı gurup tarafından ortaya atılmıştı. Oldukça ses getiren yaklaşımlardan biri olsa da, ne yazik ki ürün desteği olmayınca kağıt üzerinde kaldı, ve tarifname'ye göre geliştirmeye calışanlar hüsrana uğradı. Şahsen tanıdığımız bir arkadaş bu tecrübeden geçti, ve geçtiğine pişman.               Fakat sektör pes etmedi, çünkü nesne içine SQL koymak nesneci programcıların hiç icine bir türlü sinmedi. Fakat bağlaşım hazir olmayınca, herkes kendi mutfağında bir şeyler pişirmek zorunda kaldı. Şahsen, bir projede her nesne için güncelleştir(), sil() ve oku() gibi işlemler yazarak, nesne/tablo bağlantısını bir nevi 'yapay' bir şekilde kurmaya calıştık. (Yukarıdaki yöntemler içinde SQL yazıyorduk).               Ayrıca, nesnesel programcıların veri tabanı kolonlarına (column) Java nesne özellikleri  (attributes) olarak erişme isteği arkasında bir baska itici kuvvet daha var. Internet Sunucu programları için yazılan sayfalar, mesela JSP, JHTML, Struts gibi diller akabinde sayfa içinde bilgiyi, 'nesne' olarak sayfaya bağlamak gerekiyor. Yani, üzerinde setXX, getXX olan türden nesnelerin olması bu tür programlar için şart. Bu da önümüze kanun gibi çıkınca, veri tabanı ve Java aradasındaki bağlantıyı kurmanın gerekliliği iyice ortaya çıkıyor, ve bağlaşım dünyasında hareketlenme de bu yüzden hızlanıyor.               Son çözümlerden önümüzde olanlar:              * JDO (Java Data Objects) yani Java Veri Nesneleri   * EJB 2.0 Kap Kontrollu Kalıcılık/Container Managed Persistence            Yukarıda verilen ikinci örnek, JDO kullanarak yazılmıştır.             İlerideki yazılarımızda, oldukça yayılmaya başlayan JDO teknolojisini yakından tanıyacağız, ve bağlaşım yazılımı seçerken nelere dikkat etmemiz gerekiyor yakından inceleyeceğiz.




