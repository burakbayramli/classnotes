# SQL Nasıl Kullanılmalı


SQL Nasıl Kullanılmalı



Kume kavrami (ilkokuldan hatirladiniz mi?)           Veri tabani programlari, buyuk miktarda veriyi islemek icin yazilmistir. Yaptiklari butun islem, kaybedilmez turden veriyi saklamak, hizli sekilde geri getirmek ve gerigi oldugu zaman filterden gecirip sadece bir bolumunu kullaniciya sunmaktir.               Mesela asagidaki komut,   INSERT INTO MUSTERI VALUES ('Murat', 'Bilisim', 'Adres', 111);   veri tabaniniza VALUES kismindan sonra gelen bolumu, MUSTERI kayitina yazmanizi saglar. Elektrik kesilse de, ekraniniz patlasa da, bu veri bir yere gitmeyecektir. (Hard diskiniz bozulmadigi surece tabii). Eger bu veriyi geri istese idiniz,   SELECT * from MUSTERI WHERE ISIM = 'Murat';   komutunu uygulardiniz.               Simdi size ilginc bir sey aciklayacagim. SQL Veri tabanlari ilkokulda ogrendiginiz kume kavrami ile calisirlar. Hani kesisen kumeler, ek kumeler, vs.. hatirlarsiniz.               Sonucta veri bulmanin en rahat yolu, veriyi bir kume gibi gormek, ve istediginiz elemanlari istenen kume icinde, otekileri disinda gormek uygun olur.               Ve en can alici yere geliyoruz. Veri tabanlari, kume teorisi ile en hizli halde calisirlar. Bundan baska yol varmi ki? diyebilirsiniz. Elbette var. SQL diline sonradan eklenen bu uzatmalar, bazen gerekli olsa bile, genelde kacinilmasi gereken kullanim bicimleri. Bu alternatif metoda 'tekerleme metodu' diyecegiz, otekine kume metodu.            Tekerleme Metodu           Elinizde 1 milyon musteri kayidinin oldugunu dusunun. Diyelim ki, bir program yazmaniz istendi, bu programa gore, her musterinin size masrafi, getirdigi parayi birbirinden cikarip, musterinin size net maliyetini bulup, ayni musteri kayidi uzerinde 'net maliyet' adli yere geri yazmaniz istendi. Bu programi iki sekilde yazabilirsiniz.     --- Tarif kod yaziyoruzBASLA;HER KAYIT ICIN   EGER MUSTERI SEHIR = 'ANKARA' ISE     KAYIDI AC;     NET_MALIYET = MASRAF - MUSTERI_KAR;     MUSTERI.NET_MASRAF = NET_MALIYET.   EGER SON;SONRAKI KAYIDA GEC;               Yukaridaki koda gore, her kayidi teker teker acip, isleyip, tekrar geri yazmaniz gerekecek. Yani her islemi, teker teker yapacaksiniz, teker teker nasil isleyecegini dusuneceksiniz demektir. Yani veri tabanina, isini 'nasil' yapacagini ogretmeye ugrasacaksiniz demektir.               Fakat veri tabanlari, buyuk veri kumeleri uzerinde calismaya alisik degiller mi? Niye nasil yapacagimizi tarif edelim? Ne istedigimizi istesek, gerisini veri tabani yapsa olmaz mi? Iste alternatif yontem:          Kume Metodu          UPDATE MUSTERI SET NET_MASRAF = MASRAF - MUSTERI_KAR WHERE SEHIR = 'ANKARA';              Vay canina, bu daha kisa oldu. Hem de sonucta daha hizli isleyecektir goreceksiniz. Bunun sebebi nedir? Cunku kume teorisini kullandik. Veri tabanlari kumeler ile calismayi severler. Biz yukarida, bir kume tanimladik, 'ne' istedigimizi soyledik, ama nasil yapilacagini soylemedik. Kumemiz, Ankara sehrinde calisan musteriler idi. Bunu yaptiktan sonra, veri tabani arkasina donup veriye bakti, en hizli erisim ve degistirme algoritmasini kendi hesapladi, ve uygun olan en hizli metodu kullanima koydu. Biz veri tabaninin onune engel koymadigimiz icin, bu metod en hizlisi oldu.               Her teknolojinin kullanilmayi sevdigi bir sekil vardir. Bu sekli bulun, boylece teknolojinin cevapladigi sorun tiplerini de bulacaksiniz. Boylece cekic gereken yerde testere kullanmazsiniz, daha tecrubeli, gereken yerde gereken malzemeyi kullanan usta muhendis haline gelirsiniz.




