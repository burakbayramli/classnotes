<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Ders 2</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="ders-2">Ders 2</h1>
<p>Gerçek dünyada çoğu ODE sayısal (numerical) yöntemlerle çözülür.
Bilgisayarınızda bir ODE’yi grafiklettirdiğiniz zaman da aslında arka
planda bilgisayar o denklemi sayısal olarak çözmekte ve sonucu
grafiklettirmektedir. Bir başlangıç değerli (initial value) probleminin
formunu yazalım:</p>
<p><span class="math display">\[
y&#39; = f(x,y)
\]</span></p>
<p><span class="math display">\[
y_1(x_o) = y_o
\]</span></p>
<p>Problemde ilk satır ODE, ikinci satır bu ODE’nin başlangıç değeri,
<span class="math inline">\(x_0\)</span> ve <span
class="math inline">\(y_0\)</span> sabit değerler.</p>
<p>Sayısal olarak (mesela Euler yöntemiyle) bu denklemi çözmek ne
demektir? Alttaki çizime bakalım, <span
class="math inline">\(y_0\)</span>’dan değerinden başlıyoruz, bu noktada
<span class="math inline">\(x_0,y_0\)</span> noktasındaki eğimi <span
class="math inline">\(y&#39;\)</span> ile hesaplıyoruz, ve bu eğim bize
<span class="math inline">\(y\)</span>’nin olacağı bir sonraki yeri
söylüyor. Bu eğim ile yukarı ya da aşağı çıkıyoruz, ve bunu devam
ettiriyoruz, ta ki bir sonuca gelinceye kadar.</p>
<p><img src="2_1.jpg" /></p>
<p>Peki bahsedilen ODE bağlamında bir yere “gitmek’’ ne demektir? Takip
ettiğimiz, cevap olarak odaklandığımız <span
class="math inline">\(y\)</span> fonksiyonudur. Unutmayalım ki bu
fonksiyonun tam hali <span class="math inline">\(y(x)\)</span>, yani
<span class="math inline">\(y\)</span>, <span
class="math inline">\(x\)</span>’in bir fonksiyonu, <span
class="math inline">\(y\)</span>’nin türevi <span
class="math inline">\(y\)</span>’nin <span
class="math inline">\(x\)</span>’e göre türevi demek. Türev eğim
demektir, eğim fonksiyonun o noktadaki kabaca, yaklaşıksal bir yönüdür.
O yönü takıp edersek o fonksiyonu aşağı yukarı takip ediyoruz
demektir.</p>
<p>Grafikte <span class="math inline">\(h\)</span> basamak mesafesi,
yani <span class="math inline">\(x\)</span> üzerinde yaptığımız sabit
zıplama mesafesi. Bu kordinatta hangi aralıkla zıplıyoruz? 0.1 mi, 1 mi,
5 mi? Bunun seçimini biz yapıyoruz.</p>
<p>Euler Denklemleri bir adım için şöyle tanımlıdır:</p>
<p><span class="math display">\[ x_{n+1} = x_n + h \]</span></p>
<p><span class="math display">\[ y_{n+1} = y_n + hA_n \]</span></p>
<p><span class="math display">\[ A_n = f(x_n, y_n) \]</span></p>
<p>Bu basamaklar özyineli (recursive) olarak tanımlanır, bir sonraki
adım, bir önceki adımın değerlerini kullanır.</p>
<p>Örnek</p>
<p><span class="math display">\[ y&#39; = x^2 - y^2 \]</span></p>
<p><span class="math display">\[ y_1(0) = 1 \]</span></p>
<p><span class="math display">\[ h = 0.1 \]</span></p>
<p>Üstteki formül temel (elementary) fonksiyonlar kullanılarak
çözülemez. O yüzden Euler’in yöntemi gibi bir sayısal çözüm burada uygun
olur.</p>
<p><span class="math display">\[
\begin{array}{ccccc}
n &amp; x_n &amp; y_n &amp; A_n &amp; hA_n \\
\hline
0 &amp; 0 &amp; 1 &amp; -1 &amp; -0.1 \\
\hline
1 &amp; .1 &amp; .9 &amp; -.80 &amp; -0.08 \\
\hline
2 &amp; .2 &amp; .82 &amp;  &amp;
\end{array}
\]</span></p>
<p><span class="math inline">\(y\)</span> için eriştiğimiz sonuç .82
değeridir. Şimdi şunu soralım: Bu cevap çok yukarıda mı çok aşağıda bir
cevap mı? Pür sayısal sonuçlarda karşılaşılan bir problem budur, gerçek
cevabı analitik olarak bilmediğimiz için ona ne kadar yaklaşıp
yaklaşmadığımız. Cevabı geometrik olarak verelim. Eğer çözüm bir düz
çizgi olsaydı, Euler metodu her bu çizgi üzerinde hep doğru cevabı
veriyor olurdu.</p>
<p><img src="2_2.jpg" /></p>
<p>Eğer çözüm dışbükey (concave) olsaydı, üstteki gibi Euler metodu çok
aşağı düşecekti. İlk adımda fazla aşağı inecekti, ve sonra bu hatadan
dönemeyecek, hep esas fonksiyona uzak kalacaktı. İçbükey olunca benzer
şekilde, ama fazla yukarıda kalacaktı.</p>
<p>Peki elimizde bir analitik cevap olmadığına göre cevabın düşbükey
(convex) mi içbükey mi (concave) olup olmadığını nereye bakarak
anlayacağız? Calculus tekrar hızır gibi imdada yetişiyor. İkinci türevi
hatırlayalım: Eğer <span class="math inline">\(y&#39;&#39; &gt;
0\)</span> ise birinci türev sürekli artıyor demektir, yani <span
class="math inline">\(y\)</span> dişbükeydir. Eğer <span
class="math inline">\(y&#39;&#39; &lt; 0\)</span> ise tam tersi. Fakat
hala bir problem var, analitik fonksiyon yok ise ikinci türevi nasıl
hesaplayacağız? Cevap: Diferansiyel fonksiyonun kendisini
kullanarak.</p>
<p><span class="math inline">\(y&#39; = x^2 - y^2\)</span>’nin türevini
alırsak,</p>
<p><span class="math inline">\(y&#39;&#39; = 2x - 2yy&#39;\)</span>
sonucunu elde ederiz (türev alırken zincirleme kanununu kullandığımıza
dikkat).</p>
<p>O zaman başlangıç noktası <span class="math inline">\((0,1)\)</span>
de <span class="math inline">\(y&#39;&#39;\)</span> nedir? <span
class="math inline">\(y&#39;(0) = -1\)</span>, <span
class="math inline">\(y&#39;&#39;= 2 \cdot 0 - 2\cdot 1 = 2\)</span>.
Demek ki çözüm başlangıçta dişbükey, ve Euler çözümünü uzun süreli takip
etmezsek çözümün çok altında kalabiliriz.</p>
<p>Tabii ki çözüm bir dış bir iç olarak sürekli değişen, dalgalı bir
yapıda olabilir, bu da mümkün. Burada asıl göstermek istediğimiz
diferansiyel denklemin kendisini kullanarak çözüm hakkında analitik
hiçbir şey bilmeden onun hakkında nasıl bilgi edinebileceğimizi
görmektir.</p>
<p>Hata Analizi</p>
<p><img src="2_3.png" /></p>
<p>Hata analizi Euler’in çözüme ne kadar uzak kaldığının hesabıdır, yani
<span class="math inline">\(e\)</span> sayısını hesaplamaktır. Bu
değerin mutlak değeri (absolute value) kullanılır.</p>
<p>Daha iyi sonuçlar için daha küçük <span
class="math inline">\(h\)</span> basamakları kullanılabilir, o zaman
sonuca daha yakın kalabiliriz. O zaman <span
class="math inline">\(e\)</span>’nin <span
class="math inline">\(h\)</span>’ye bağlı olduğunu söyleyebiliriz.
Formülsel olarak bu ifade suna benzer:</p>
<p><span class="math display">\[
|e \sim c_1 h|
\]</span></p>
<p>Buna ifadeye göre Euler metotu birinci derece bir metottur denir, bu
derecenin ODE’nin derecesiyle alakası yok, <span
class="math inline">\(h\)</span>’nin üstteki formülde hangi üstel formde
olduğuyla alakalı. Birincil derecede bir ilişki mesela basamağı yarısına
indirince hatayı yarısına indirirmek demektir.</p>
<p>Euler metodundan daha bir yöntem bulmak demek, eğimi daha iyi
hesaplayan bir yöntem bulmak demektir. Eğer hatada rol oynayan en önemli
faktör eğim olduğuna göre, daha az hata için daha iyi eğim hesaplamak
mantıklı olacaktır.</p>
<p><img src="2_4.png" /></p>
<p>Daha iyi eğim nasıl hesaplanır? Diyelim ki tek bir zıplama yerine iki
kere zıpladık. Dişbükey durumda birinci zıplamada çok aşağı, ikincide
biraz daha yukarı gidiyor olurduk, o zaman bunların ortalamasını
alırsak, daha iyi bir eğim elde edebilirdik.</p>
<p><span class="math display">\[ x_{n+1} = x_n + h \]</span></p>
<p><span class="math display">\[ \hat{y}_{n+1} = y_n + h A_n
\]</span></p>
<p><span class="math display">\[ B_n = f(x_{n+1},\hat{y}_{n+1})
\]</span></p>
<p><span class="math display">\[ y_{n+1} = y_n + h(\frac{A_n+B_n}{2})
\]</span></p>
<p>Niye şapkalı <span class="math inline">\(y\)</span> yani <span
class="math inline">\(\hat{y}\)</span> kullandık? Çünkü ortalama
hesaplamak için aslında n+1 noktasında geçici bir değer hesaplıyoruz, bu
geçiciliği göstermek için <span class="math inline">\(\hat{y}\)</span>
ifadesini kullandık.</p>
<p>Bu metot Heun, Geliştirilmiş (Improved) Euler, Değiştirilmiş
(Modified) Euler, RK2 gibi isimlerle anılır. RK2 Runga-Kutta’nın
kısaltması, ‘2’ ibaresi bu yöntemin ikinci dereceli bir metot olmasıdır.
Yani</p>
<p><span class="math display">\[ e \sim c_2 h^2 \]</span></p>
<p>Basamağı yarısına indirmek hatayı dörtte birine indirmek demektir. O
zaman niye bu metot her yerde kullanılmıyor? Çünkü RK2 ile eğim iki kere
hesaplanıyor, Euler ile bir kere, yani sayısal kod iki kat daha fazla
çalışmak, yani daha yavaşlamak zorundadır.</p>
<p>RK4 te var, bu dördüncü seviyede bir metot. Eğim şöyle
hesaplanır:</p>
<p><span class="math display">\[ \frac{A_n + 2B_n + 2C_n + D_n}{6}
\]</span></p>
<p>Sayısal Yöntemlerde Bazı Tehlikeli Noktalar</p>
<ol type="1">
<li><p>Hoca ödevde bizim keşfetmemizi istedi</p></li>
<li><p>Şu basit denkleme bakalım: <span class="math inline">\(y&#39; =
y^2\)</span>. Değişkenleri ayıralım ve analitik cevabı <span
class="math inline">\(y=\frac{1}{c}\)</span>. O zaman bu denklemi
sayısal olarak çözerken alttaki grafik takip ediliyor olacak.</p></li>
</ol>
<p><img src="2_5.png" /></p>
<p>Diyelim ki <span class="math inline">\(y(0) = 1\)</span>’den başladık
ve <span class="math inline">\(y(2)\)</span>’i bulacağız. Sağa doğru
yavaş yavaş gidiyoruz ama problem, bu fonksiyon <span
class="math inline">\(y(1)\)</span> değerinde sonsuza gidiyor. Demek ki
adım adım sağa giden sayısal çözüm o noktayı hiçbir zaman aşamayacaktır,
sonsuzlukta kaybolacaktır. Bu tehlikeli noktayı önceden tahmin edemez
miydik? Hayır. Üstteki diferansiyel denklemin her çözümünün kendine has
bir eşsizsel (singularity) noktası vardır ve bundan sadece kendisi
haberdadır.</p>
<p>Ekler</p>
<p>Taylor Açılımı Bağlantıları</p>
<p>Euler yöntemininin çoğu kaynakta ODE sistemini “entegre ettiği’’
söylenir; hakikaten de bir entegrasyon yapıyoruz, yani <span
class="math inline">\(dy\)</span> değişim formülünü <span
class="math inline">\(y\)</span>’ye uygulayarak adım adım ilerliyoruz,
<span class="math inline">\(y\)</span>’nin değerlerini bulmuş oluyoruz,
bu bir entegrasyon işlemidir. Euler fonksiyonu ile analitik
fonksiyonları sayısal entegre etmiş oluyoruz.</p>
<p>Range-Kutta ile atılan adımlar üzerinde oynama yapılarak ilerleme
sağlanmaya uğraşılıyor. Fakat aslında Taylor açılımı kullanarak ta ODE
çözmek mümkün [1, sf. 395]. Bu metot çoğunlukla teşvik edilmiyor çünkü
bazı denklemlerin 2., 3. türevini sembolik olarak almak çok zor. Fakat
otomatik türev ile, bkz [2], bu türevler rahatlıkla alınabilir. Altta
gösterme amaçlı olarak sembolik alınabilen türevli ODE gösteriyoruz.</p>
<p>ODE bir <span class="math inline">\(y(t)&#39; = f(x,y)\)</span>
sistemidir,</p>
<p><span class="math display">\[ y(t)&#39; = t + y , \quad y(1) =
2\]</span></p>
<p>Bu sistemin çözümü biliniyor,</p>
<p><span class="math display">\[ y(t) = -t -1 + 4e^{-1}e^t\]</span></p>
<p>Eğer çözüm bilinmeseydi, sayısal olarak çözmek gerekecekti. <span
class="math inline">\(a\)</span> yakınında <span
class="math inline">\(g(x)\)</span>’in Taylor açılımını analitik olarak
biliyoruz,</p>
<p><span class="math display">\[ g(x) = g(a) + g&#39;(a)(x-a) +
g&#39;&#39;(a) \frac{(x-a)^2}{2}\]</span></p>
<p>Eğer <span class="math inline">\(x\)</span>’i <span
class="math inline">\(h\)</span> adım atarak <span
class="math inline">\(a\)</span>’den gelinen nokta olarak
belirtirsek</p>
<p><span class="math display">\[ x=a+h\]</span></p>
<p><span class="math display">\[ g(a+h) = g(a) + g&#39;(a)h +
g&#39;&#39;(a)\frac{h^2}{2}\]</span></p>
<p>Bu açılım özyineli bir hesabı ima ediyor; yani <span
class="math inline">\(h\)</span> adımı sonrasında elde edilen yeni <span
class="math inline">\(g\)</span>’nin bir önceki adımdaki değerler ile
nasıl bağlantılı olduğunu gösteriyor. O zaman <span
class="math inline">\(g\)</span> yerine üstteki <span
class="math inline">\(f\)</span> tanımını geçirirsek,</p>
<p><span class="math display">\[ y_{k+1} = y_k + h \frac{d}{dt}
f(t_k,y_l) + \frac{h^2}{2} \frac{d^2}{dt} f(t_k,y_l)\]</span></p>
<p><span class="math display">\[  = y_k + hf(t_k,y_k) + \frac{h^2}{2}
\frac{d}{dt} f(t_k,y_l)\]</span></p>
<p>Aslında Euler yöntemi olarak bilinen yöntem üstteki formülde ilk iki
terimin tutulup gerisinin atılmasıyla elde edilmiştir. O zaman daha iyi
hesap için üstteki tüm terimleri (hatta açılımı devam ettirerek daha
bile fazlasını) kullanabilirdik. 3. terimdeki diferansiyel hesabı için,
tam diferansiyel (total derivative) tanımından,</p>
<p><span class="math display">\[
df = \frac{\partial f}{\partial t} dt + \frac{\partial f}{\partial y} dy
\]</span></p>
<p>Yani</p>
<p><span class="math display">\[
\frac{df}{dt} = \frac{\partial f}{\partial t} +
\frac{\partial f}{\partial y} \frac{dy}{dt}
\]</span></p>
<p><span class="math inline">\(y&#39;(t)=dy/dt\)</span> olduğuna göre
<span class="math inline">\(t + y\)</span>’ye eşittir, onu üstte yerine
koyarız, kısmi türevleri de hesapladıktan sonra,</p>
<p><span class="math display">\[
\frac{df}{dt} =  1 + t + y
\]</span></p>
<p>O zaman</p>
<p><span class="math display">\[  = y_k + hf(t_k,y_k) + \frac{h^2}{2} (1
+ t_k + y_k) \]</span></p>
<p>İlk önce normal Euler gösterelim,</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>y1 <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> t <span class="op">=</span> <span class="fl">1.</span><span class="op">;</span> N <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> h <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>vals <span class="op">=</span> []</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N): </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    yreal <span class="op">=</span> <span class="op">-</span>t<span class="op">-</span><span class="dv">1</span><span class="op">+</span><span class="dv">4</span><span class="op">*</span>(<span class="fl">1.</span><span class="op">/</span>np.e)<span class="op">*</span>np.exp(t)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    vals.append([t, y1, yreal])</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    y1 <span class="op">=</span> y1 <span class="op">+</span> (t <span class="op">+</span> y1)<span class="op">*</span>h</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> t <span class="op">+</span> h</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(vals)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>df.columns <span class="op">=</span> [<span class="st">&#39;t&#39;</span>,<span class="st">&#39;euler&#39;</span>, <span class="st">&#39;analitik&#39;</span>]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.set_index(<span class="st">&#39;t&#39;</span>)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (df)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>df.plot()</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;2_6.png&#39;</span>)</span></code></pre></div>
<pre><code>      euler  analitik
t                    
1.0  2.0000  2.000000
1.1  2.3000  2.320684
1.2  2.6400  2.685611
1.3  3.0240  3.099435
1.4  3.4564  3.567299</code></pre>
<p><img src="2_6.png" /></p>
<p>Oldukça büyük bir sapma var. Şimdi tüm Taylor terimlerini
kullanalım,</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>y2 <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> t <span class="op">=</span> <span class="fl">1.</span><span class="op">;</span> N <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> h <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>vals <span class="op">=</span> []</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N): </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    yreal <span class="op">=</span> <span class="op">-</span>t<span class="op">-</span><span class="dv">1</span><span class="op">+</span><span class="dv">4</span><span class="op">*</span>(<span class="fl">1.</span><span class="op">/</span>np.e)<span class="op">*</span>np.exp(t)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    vals.append([t, y2, yreal])</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    y2 <span class="op">=</span> y2 <span class="op">+</span> (t <span class="op">+</span> y2)<span class="op">*</span>h <span class="op">+</span> (<span class="dv">1</span><span class="op">+</span>t<span class="op">+</span>y2)<span class="op">*</span>(h<span class="op">**</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> t <span class="op">+</span> h</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(vals)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>df.columns <span class="op">=</span> [<span class="st">&#39;t&#39;</span>,<span class="st">&#39;taylor&#39;</span>, <span class="st">&#39;analitik&#39;</span>]</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.set_index(<span class="st">&#39;t&#39;</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (df)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>df.plot()</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;2_7.png&#39;</span>)</span></code></pre></div>
<pre><code>       taylor  analitik
t                      
1.0  2.000000  2.000000
1.1  2.320000  2.320684
1.2  2.684100  2.685611
1.3  3.096931  3.099435
1.4  3.563608  3.567299</code></pre>
<p><img src="2_7.png" /></p>
<p>Runge-Kutta</p>
<p>Taylor Serileri ile hesap yapmanın bir dezavantajı var, hesaplanan
fonksiyonun ikinci, üçüncü ve daha yüksek türevlerinin analitik olarak
elde edilebilmesi gerekiyor. Bu hesap her zaman kolay elde
edilmeyebilir. Runge-Kutta metotu daha yüksek türevlerin yerine farklı
<span class="math inline">\(f\)</span> hesaplarının bir şekilde
ağırlıklarını alarak aynı sonuç erişiyor [3, sf. 282]. RK yönteminin
hata payı Taylor yöntemine eşittir, daha doğrusu RK2 ikinci derece
sonrası terimleri atılmış Taylor yaklaşıksallamasına eşittir, RK4 aynı
şekilde dördücü derece için.</p>
<p>RK yaklaşımını direk Taylor serilerinden türetmek mümkün, RK4 için
gereken dördüncü derece ve üstü cebirsel türetim olarak oldukca
çetrefilli, fakat bir fikir vermesi açısından ikinci derece için gereken
türetimi burada göstereceğiz.</p>
<p>Yine Taylor serilerinden başlayalım, eldeki bir diferansiyel
denklem</p>
<p><span class="math display">\[
y&#39; = f(x,y)
\]</span></p>
<p>için [4, sf. 713],</p>
<p><span class="math display">\[
y_{i+1} = y_i + f(x_i,y_i) h + \frac{f&#39;(x_i,y_i)}{2!} h^2 + ...
\qquad (1)
\]</span></p>
<p>ya da</p>
<p><span class="math display">\[
y_{i+1} = y_i + y&#39;_i h + \frac{y_i&#39;&#39;}{2!} h^2 + ..
\]</span></p>
<p>olduğunu biliyoruz. İkinci derece Runge-Kutta için deriz ki üstteki
formüldeki <span class="math inline">\(y_i\)</span> sonrası <span
class="math inline">\(f\)</span> bazında bir formül olacak, türev
içermeyecek [4, sf. 730],</p>
<p><span class="math display">\[
y_{i+1} = y_i + (a_1 k_1 + a_2 k_2) h
\qquad (2)
\]</span></p>
<p>ki</p>
<p><span class="math display">\[
k_1 = (x_i,y_i), \quad k_2 = f(x_i+p_1 h, y_i + q_{11}k_1h)
\]</span></p>
<p>Dikkat değerler <span
class="math inline">\(a_1,a_2,p_1,q_{11}\)</span> katsayıdır, onların ne
olduğunu bulmamız gerekiyor. Bunun için <span
class="math inline">\(k_2\)</span>’nin Taylor Serisi açılımını yapıp
birleşik formülün ana Taylor serisi açılımıyla olan benzerliklerine
bakıp katsayıları bu benzerlik üzerinden bulmaya çalışacağız.</p>
<p>Ana Taylor serisi açılımının başlangıç noktası (1), tabi bir <span
class="math inline">\(f&#39;(x_i,y_i)\)</span> türevi var, bu türevi
Zincirleme Kanunu ile açacağız, genel formda bu kanun</p>
<p><span class="math display">\[
f&#39;(x_i,y_i) = \frac{\partial f(x,y)}{\partial x} +
\frac{\partial f(x,y)}{\partial y} \frac{\mathrm{d} y}{\mathrm{d} x}
\]</span></p>
<p>Üstteki formülü (1) içine sokarsak,</p>
<p><span class="math display">\[
y_{i+1} = y_i + f(x_i,y_i) h +
\left( \frac{\partial f(x,y)}{\partial y} \frac{\mathrm{d} y}{\mathrm{d}
x}  \right) \frac{h^2}{2}
\qquad (3)
\]</span></p>
<p>Şimdi <span class="math inline">\(k_2\)</span>’nin açılımına gelelim,
burada iki değişkenli Taylor açılımı gerekli, bu açılım genel formda
şöyle gider,</p>
<p><span class="math display">\[
g(x+r,y+s) = g(x,y) + r \frac{\partial g}{\partial x} + s \frac{\partial
g}{\partial y} + ...
\]</span></p>
<p>Uygulanırsa,</p>
<p><span class="math display">\[
f(x_i+p_1 h, y_i + q_{11}k_1h) = f(x_i,y_i) +
p_1 h \frac{\partial f}{\partial x} +
q_{11} k_1 h \frac{\partial f}{\partial y} + ...
\]</span></p>
<p>Bu ifadeyi (2) içindeki <span class="math inline">\(k_2\)</span>’ye
sokalım, <span class="math inline">\(k_1\)</span> tanımını da
kullanalım, ve (2)’yi bu şekilde tekrar yazalım,</p>
<p><span class="math display">\[
y_{i+1} = y_i + a_1 h f(x_i,y_i) + a_2 h f(x_i,y_i) +
a_2 p_1 h^2 \frac{\partial f}{\partial x} +
a_2 q_{11} h^2 f(x_i,y_i) \frac{\partial f}{\partial y} + ..
\]</span></p>
<p><span class="math inline">\(h\)</span> ve <span
class="math inline">\(h^2\)</span> bazlı terimleri toplayıp ayrı gruplar
halinde yazarsak, ve nokta noktalı bölümü atalım,</p>
<p><span class="math display">\[
y_{i+1} = y_i + [a_1 f(x_i,y_i) + a_2 f(x_i,y_i)] h +
\left[a_2 p_1 \frac{\partial f}{\partial x} +
a_2 q_{11} f(x_i,y_i) \frac{\partial f}{\partial y}
\right] h^2
\]</span></p>
<p>Şimdi üstteki son formül ile (3) karşılaştırması yapalım, bu iki
denklemin eşit olması için ne gerekir? Şunlar,</p>
<p><span class="math display">\[
a_1 + a_2 = 1
\]</span></p>
<p><span class="math display">\[
a_2 p_1 = \frac{1}{2}
\]</span></p>
<p><span class="math display">\[
a_2 q_{11} = \frac{1}{2}
\]</span></p>
<p>Bu denklemleri çözersek ve sabitleri bulursak bize gereken türevsiz,
<span class="math inline">\(f\)</span>’nin ağırlıklanmış halini
kullanarak çözüm yapabiliriz. Fakat bir problem var, elde 3 denklem ama
4 bilinmeyen var, özgün bir çözüm bulmak mümkün değil. Şöyle bir çözüm
olabilir, eğer bir sabite bir değeri kendimiz atarsak, geri kalanları
ona göre bulabiliriz. Diyelim ki <span class="math inline">\(a_2 =
1/2\)</span> dedik, o zaman <span class="math inline">\(a_1 =
1/2\)</span> ve <span class="math inline">\(p_1 = q_{11} = 1\)</span>.
Bu bize Heun metodu denen yaklaşımı verir,</p>
<p><span class="math display">\[
y_{i+1} = y_i + \left( \frac{1}{2} k_1 + \frac{1}{2} k_2 \right) h
\]</span></p>
<p>ki</p>
<p><span class="math display">\[
k_1 = f(x_i,y_i)
\]</span></p>
<p><span class="math display">\[
k_2 = f(x_i + h, y_i + k_1 h)
\]</span></p>
<p>Örnek</p>
<p>Alttaki denklemi Heun yaklaşımı ile çözelim,</p>
<p><span class="math display">\[
y&#39; = -2x^3 + 12x^2 - 20x + 8.5
\]</span></p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>yreal <span class="op">=</span> [<span class="dv">1</span>, <span class="fl">3.21875</span>, <span class="dv">3</span>, <span class="fl">2.21875</span>, <span class="dv">2</span>, <span class="fl">2.71875</span>, <span class="dv">4</span>, <span class="fl">4.71875</span>, <span class="dv">3</span>]</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x,y): <span class="cf">return</span> <span class="op">-</span><span class="dv">2</span><span class="op">*</span>(x<span class="op">**</span><span class="dv">3</span>) <span class="op">+</span> <span class="dv">12</span><span class="op">*</span>(x<span class="op">**</span><span class="dv">2</span>) <span class="op">-</span> <span class="dv">20</span><span class="op">*</span>x <span class="op">+</span> <span class="fl">8.5</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">4</span>,<span class="dv">9</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>yrk <span class="op">=</span> np.zeros(<span class="bu">len</span>(x))</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>yrk[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="bu">len</span>(yreal)):</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    k1 <span class="op">=</span> f(x[i<span class="op">-</span><span class="dv">1</span>],<span class="va">None</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    k2 <span class="op">=</span> f(x[i],<span class="va">None</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    yrk[i] <span class="op">=</span> yrk[i<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> <span class="fl">0.5</span><span class="op">*</span> (k1 <span class="op">+</span> k2)<span class="op">*</span>h</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>plt.plot(x,yreal)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>plt.plot(x,yrk)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>plt.legend([<span class="st">u&#39;Gerçek&#39;</span>,<span class="st">&#39;RK2&#39;</span>])</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;2_8.jpg&#39;</span>)</span></code></pre></div>
<p><img src="2_8.jpg" /></p>
<p>RK4</p>
<p>En popüler Runge-Kutta metotu dördüncü derecedir, aynen ikinci
derecede olduğu gibi sonsuz tane çeşidi olabilir (hatırlarsak RK2 ile
bir sabite değeri biz atadık, farklı atamalar için farklı RK çeşitleri
elde edilebilir), fakat alttaki form en yaygın kullanılan formdur [4,
sf. 735].</p>
<p><span class="math display">\[
y_{i+1} = y_i + \frac{1}{6} (k_1 + k_2 + k_3 + k4) h
\]</span></p>
<p>ki</p>
<p><span class="math display">\[
k_1 = f(x_i,y_i)
\]</span></p>
<p><span class="math display">\[
k_2 = f \left( x_i + \frac{1}{2} h, y_i + \frac{1}{2}k_1 h  \right)
\]</span></p>
<p><span class="math display">\[
k_3 = f \left( k_i + \frac{1}{2} h, y_i + \frac{1}{2}k_2 h  \right)
\]</span></p>
<p><span class="math display">\[
k_4 = f(x_i+h, y_i + k_3 h)
\]</span></p>
<p>Şimdi Runge-Kutta dördüncü derece çözüm yaklaşımını bir örnekte
görelim.</p>
<p>Sarkaç Problemi</p>
<p>Bağlantı noktasında sürtünme içerebilecek basit bir şarkacın hareket
denklemleri [5, sf. 842],</p>
<p><span class="math display">\[
\ddot{\theta} + b\dot{\theta}  c\sin(\theta) = 0,
\quad
t \ge 0, \theta(0)=\theta_0,
\quad
\dot{\theta} = \dot{\theta}_0
\qquad (1)
\]</span></p>
<p>olarak verilebilir. Bu denklemi ODE sistemi olarak çözmek için yeni
değişken tanımları üzerinden onu iki parçaya ayırıyoruz,</p>
<p><span class="math display">\[
\vec{x} = x =
\left[\begin{array}{ccc}
    x_1 \\ x_2
\end{array}\right] =
\left[\begin{array}{c}
    \theta \\ \dot{\theta}
\end{array} \right],
\quad
f(t,x) = \left[\begin{array}{c}
\dot{\theta} \\ -b \dot{\theta} - c\sin\theta
\end{array} \right]
\]</span></p>
<p>Bu tanımlarla <span class="math inline">\(\dot{x}\)</span>
ifadesi</p>
<p><span class="math display">\[
\dot{x} = \left[
  \begin{array}{c} \dot{\theta} \\ \ddot{\theta} \end{array}
\right]
\]</span></p>
<p>haline gelir, ve <span class="math inline">\(\dot{x} =
f(t,x)\)</span> matris denkleminde</p>
<p><span class="math display">\[
\left[\begin{array}{c} \dot{\theta} \\ \ddot{\theta} \end{array}\right]=
\left[\begin{array}{c} \dot{\theta} \\ -b \dot{\theta} - c\sin\theta
\end{array}\right]
\]</span></p>
<p>alt satıra odaklanırsak, orada (1) denklemine geri gidebileceğimizi
görebiliriz.</p>
<p>Sayısal çözüme gelirsek, benzer bir problemin çözümünü [6]’de
işlemiştik. O derste bir paket çağrısı olan <code>odeint</code>
kullanılmıştı, bu paketin entegrasyonu nasıl yaptığından
bahsedilmemişti. Şimdi daha detaylandıralım, <code>odeint</code> kodu iç
mantığında dördünce derece Runge-Kutta çözümü kullanır, yani RK4
yaklaşımını. RK4 formülleri üstte verildi, [5, sf. 803] üzerinden bir
daha paylaşalım,</p>
<p><span class="math display">\[
k_1 = h f(t_i, y_i)
\]</span></p>
<p><span class="math display">\[
k_2 = h f(t_i + h/2, y_i + k_1/2)
\]</span></p>
<p><span class="math display">\[
k_3 = h f(t_i + h/2, y_i + k_2/2)
\]</span></p>
<p><span class="math display">\[
k_4 = h f(t_i + h, y_i + k_3)
\]</span></p>
<p><span class="math display">\[
y_{i+1} = y_i + (k_1 + 2 k_2 + 2 k_3 + k_4) / 6
\]</span></p>
<p>ki başlangıç değerleri <span class="math inline">\(y_0 =
(\theta_0,\dot{\theta}_0)\)</span> olmak üzere. Çözmek istediğimiz
sistemde sürtünme yok, yani <span class="math inline">\(b=0\)</span>,
geri kalan değerler <span class="math inline">\(c=1\)</span>, <span
class="math inline">\(\theta_0=0.1\)</span>, <span
class="math inline">\(\dot{\theta}_0 = 1.0\)</span>.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">256</span><span class="op">;</span> theta0 <span class="op">=</span> <span class="fl">0.1</span><span class="op">;</span> dtheta0 <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span> h <span class="op">=</span> <span class="fl">0.1</span><span class="op">;</span> c <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>theta_values <span class="op">=</span> np.zeros(n)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    K1theta <span class="op">=</span> h <span class="op">*</span> dtheta0</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    K1dtheta <span class="op">=</span> <span class="op">-</span>h <span class="op">*</span> c <span class="op">*</span> np.sin(theta0)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    theta1 <span class="op">=</span> theta0 <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> K1theta</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    dtheta1 <span class="op">=</span> dtheta0 <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> K1dtheta <span class="co"># b=0, bir terim yokoldu burada</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    K2theta <span class="op">=</span> h <span class="op">*</span> dtheta1</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    K2dtheta <span class="op">=</span> <span class="op">-</span>h <span class="op">*</span> c <span class="op">*</span> np.sin(theta1)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    theta1 <span class="op">=</span> theta0 <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> K2theta</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    dtheta1 <span class="op">=</span> dtheta0 <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> K2dtheta</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    K3theta <span class="op">=</span> h <span class="op">*</span> dtheta1</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    K3dtheta <span class="op">=</span> <span class="op">-</span>h <span class="op">*</span> c <span class="op">*</span> np.sin(theta1)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    theta1 <span class="op">=</span> theta0 <span class="op">+</span> K3theta</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    dtheta1 <span class="op">=</span> dtheta0 <span class="op">+</span> K3dtheta</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    K4theta <span class="op">=</span> h <span class="op">*</span> dtheta1</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    K4dtheta <span class="op">=</span> <span class="op">-</span>h <span class="op">*</span> c <span class="op">*</span> np.sin(theta1)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    theta1 <span class="op">=</span> theta0 <span class="op">+</span> (K1theta <span class="op">+</span> <span class="fl">2.0</span> <span class="op">*</span> K2theta <span class="op">+</span> <span class="fl">2.0</span> <span class="op">*</span> K3theta <span class="op">+</span> K4theta) <span class="op">/</span> <span class="fl">6.0</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    dtheta1 <span class="op">=</span> dtheta0 <span class="op">+</span> (K1dtheta <span class="op">+</span> <span class="fl">2.0</span> <span class="op">*</span> K2dtheta <span class="op">+</span> <span class="fl">2.0</span> <span class="op">*</span> K3dtheta <span class="op">+</span> K4dtheta) <span class="op">/</span> <span class="fl">6.0</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    theta_values[i] <span class="op">=</span> theta1</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    theta0 <span class="op">=</span> theta1</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    dtheta0 <span class="op">=</span> dtheta1</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="op">-</span><span class="fl">1.20</span>,<span class="fl">1.20</span>)</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(n), theta_values)</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;phy_005_basics_06_01.jpg&#39;</span>)</span></code></pre></div>
<p><img src="phy_005_basics_06_01.jpg" /></p>
<p>Çözümün üstteki grafiği şarkacın (dikey eksene göre olan) açılarının
zamana göre grafiğini gösteriyor. Metot stabil gözüküyor, açıda azalma
ya da patlama olmadı, <span class="math inline">\(b=0\)</span> şartını
koştuğumuz için bunun hesaba yansıması iyi oldu, sürtünme yoksa sönüm
(damping) görülmemeliydi.</p>
<p>Kaynaklar</p>
<p>[1] Ackleh, <em>Classical and Modern Numerical Analysis
Theory</em></p>
<p>[2] Bayramlı, Bilgisayar Bilim, Yapay Zeka, <em>Otomatik Türev
Almak</em></p>
<p>[3] Faires, <em>Numerical Analysis, 9th Ed</em></p>
<p>[4] Canale, <em>Numerical Methods for Engineers, 7th Ed</em></p>
<p>[5] Eberly, <em>Game Physics 2nd Ed</em></p>
<p>[6] Bayramlı, <em>Gayrı-Lineer Dinamik ve Kaos Ders 1</em></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
