<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  
  
  
  
</head>
<body>
<h1 id="matematiksel-modelleme">Matematiksel Modelleme</h1>
<p>Babil medeniyetinden dikkatli ölçmeyi ve gözlem yapmayı öğrenen eski Yunanlılar, tabiatı, mantıklı analiz dizisi ile anlamaya uğraştılar. Aristo'nun oldukça inandırıcı olan söylemlerinden biri olan, &quot;dünya düz değildir&quot;'den esinlenen günün diğer felsefecileri, &quot;o zaman dünyanın çapı nedir?&quot; gibi sorular ile uğraşmaya başladılar. Hayret verici olan bir gelişme, Eratostenes'in bu ölçüyü oldukça yakın olarak bulmasıdır, hem de yaşadığı şehir olan İskenderiye'den dışarı ayak bile basmadan! Kullanılan yöntem bazı kestirmeler ve temel alınan birkaç varsayım içeriyordu. Dünya mükemmel bir küredir (olmasa da onun hesabı için bu uygundu), güneşin ışınları birbirine paralel olarak yol alır, Syene şehri İskenderiye'nin 5000 stadya (bir ölçü birimir) kadar güneyde yer alır, vs.. Bu varsayımlardan yola çıkarak, Erotostenes bir matematiksel dünya yarattı ve bu dünya üzerinde geometri'nin uygulanabilir olduğunu gördü!</p>
<div class="figure">
<img src="top_dusuyor_pizza_kulesi.jpg" />

</div>
<p>Günümüzde, aynen Yunanlı bilginlerin yaptığı gibi, bilim adamları etrafımızdaki dünyayı daha pragmatik bir seviyede anlayabilmek ve akabinde teknik sorulara çözüm bulabilmek için, etrafımızdaki dünyayı matematiksel terimlerle temsil etmeye devam ediyorlar. Gerçeği matematiksel bir dil ile 'taklit etmeye' yardım eden bu işlem ve düşünce şekline, matematiksel modelleme adı veriliyor.</p>
<p>Bir problemi matematiksel terimler kullanarak göstermenin bazı yararları var. İlki, altında olduğumuz şartları öne sürmemizi ve tanımlamamız için bizi zorlaması, ki bu güzel bir şey. Gerçek dünyada olmakta olan problemler çetrefilli olduklarından, hangi değişkenlerin çözümümüz için önemli, hangisinin önemsiz olduğunu daha matematiksel uygulama başlamadan kararlaştırmak önemli. Bu seçim yapıldıktan sonra, genelde bazı kanunlar ve kuramlar kuruluyor ve bu varsayımlar, modelimizin idealleştirilmiş hali adı altında irdelenmeye başlanıyor.</p>
<p>Matematik'in en önemli yararı, mantıksal sonuçlara varabilmek için elimizdeki varsayımlardan başlayarak bu formülleri değişimden geçirmemize yardım eden temel teknikler vermesi. Böylece elimize analiz yapabilmemiz için sağlam bir temel geçiyor, aradığımız sonucun ne olduğunu baştan tam kestirmesek bile, bu modelleme işlemi bize yolda yardım edecek araçlar sağlıyor.</p>
<p>Ayrıca matematiğin, bilgisayarlar tarafından sayısal cevaplar alınabileceği bir ortam sağlaması da önemli bir avantaj.</p>
<p>Etkili matematiksel modeller kurmak oldukça yetenek isteyen bir iş, tasavvur ve tarafsız irdeleyebilme kabiliyeti gerektiriyor. Daha önceden kurulmuş olan öteki modelleri örnek olarak incelemek, modelleme sürecinin nasıl bir şey olduğunu hissetmek için yararlı olabilir. Revaçta modellemeyi öğreten çok güzel kitaplar ve makaleler var. Bu yazımızda bizim odaklanacağımız, birinci derecen türevsel denklem içeren matematik modelleri olacak. İzleyeceğimiz modelleme işleminin ana hatları şöyle olacak.</p>
<p>Problemi Formüllere Dök</p>
<p>Bu safhada amacımız bir formülü kurmak. Böylece cevabın matematiksel olarak 'bulunabileceğini' umuyoruz. Tabii bu işlem hem matematiği hem de problem alanını bilmemizi gerektiyor. Bu seviyede, matematikçi olmasa bile problem alanında uzman olanlar kimseler ile konuşmanız yararlı olabilir. Ayrıca problem alanını anlatan eserleri okumanız iyi olacaktır.</p>
<p>Modeli Geliştir</p>
<p>Burada yapılacak iki şey var. İlk önce hangi değişkenler önemli, hangiler değil ona karar vermeniz gerekiyor. Önemli olanların arasından, bazıları bağımlı bazıları bağımsız değişken olarak tanımlanacaklar. Önemsiz değişkenleri şöyle farketmeniz mümkün; modellenen süreç üzerinde hiç etkisi olmayan değişkenler sizin için önemli değildir ve atılabilir. Mesela, binadan aşağı düşen bir topun hareketini incelemek istiyorsanız, topun hangi renkte olduğu modeliniz için önemsizdir.</p>
<p>Bağımsız değişkenler modeli etkileyebilecek, modele giriş olarak verilebilecek değerlerden seçilir. Yere düşen cisim için, cismin şekli, kütlesi, başlangıç noktası, başlangıç hızı, ve hangi zamanda bırakıldığı bu tür bağımsız değişkenlerdendir. Bağımlı değişkenler, adı üzerinde, değerleri bağımsız değişkenlere bağlı olan fakat, gene de model için önemli olan değişkenlerdir. Yere düşen cisim için bunlar hız, katledilen mesafe, yere çarpma zamanı gibi değişkenler bağımlı değişkenler arasında sayılabilir.</p>
<p>İkinci yapmak gereken şey, bu değişkenler arasındaki bağlantıları bulmak (mesela birinci derece türevsel denklem kurarak). Bunu yapmak problem alanı hakkında bilgi ve vizyon gerektirir. Taslak bir modelle başlanabilir, ve testler sonucunda modeli rafine etmek mümkündür. Mesela yukarıdaki örnek için başlangıçta sürtünme kuvvetini hesaba katmayabiliriz, fakat ileride daha net sonuçlar için sürtünmeyi modele eklemek gerekebilir.</p>
<p>Modeli Test Et</p>
<p>Modeli hemen test verileri ile 'doğrulamaya' uğraşmadan önce, şunlara tekrar göz atalım.</p>
<ul>
<li>Varsayımlar akla yatkın mı?</li>
<li>Denklemler birim değerlerini doğru kullanıyor mu? (Mesela kuvvet değerlerini, hız değeri ile toplamak yanlış olur)</li>
<li>Model iç yapısı bakımından tutarlı mı? Yani, modeli oluşturan denklemler birbiri ile çatışma halinde mi?</li>
<li>Elimizde olan denklemler çözüm verebilecek nitelikte mi?</li>
<li>Çözümü bulmak, elimizdeki denklemler ile ne kadar zor olacak?</li>
<li>Çözüm, incelediğimiz probleme yardım edecek türden olacak mı?</li>
</ul>
<p>Nüfus Artış Modeli</p>
<p>Bir ülkenin nüfus artışını nasıl tahmin edebiliriz? Eğer bir gurubun nüfus artışını tahmin etmek istiyorsak, bu gurubu her dış etkiden uzak izole bir kapalı kutu halinde düşünebiliriz. Bu kutu mesela biyolojide Petri tabağı denen bir ortam, ya da günlük hayatta bir ada olarak tanımlanabilecek bir ortam olabilir. Böylece nüfus artışını izole bir şekilde 'tek odada' incelememiz mümkün olacak.</p>
<p>Diyelim ki, <span class="math inline">\(p(t)\)</span>, <span class="math inline">\(t\)</span> zamanında ölçülecek olan nüfusu veriyor olsun. Şimdi çoğalma (doğum) ve azalma (ölüm) hızlarını hesaplayalım.</p>
<p>Örnek olarak şöyle düşünelim, bir bakteri kendini ikiye bölerek çoğalır. Bizim modelimiz için de, büyüme hızının, o anki mevcut nüfusa oranlı olduğunu varsayalım. Bu varsayım bakterilerin büyüme şekli ile tutarlı. Büyüyecek yer ve yeteri kadar yiyecek olduğu sürece, bakteriler büyüyeceğini biliyoruz. Bir diğer varsayım da şöyle olsun, ölüm oranı sıfır. (Unutmayalım ki, hücre bölünmesinde ebeveyn hücre ölmez, iki hücre haline gelir). Yani bakteri nüfusu için bir model şöyle olabilir.</p>
<p><span class="math display">\[ \frac{dp}{dt} = k_1p\]</span></p>
<p><span class="math display">\[ p(0) = p_0 \]</span></p>
<p><span class="math inline">\(k_1 &gt; 0\)</span> olarak tasavvur edeceğiz. <span class="math inline">\(k_1\)</span> büyüme oranı 'sabitidir'. <span class="math inline">\(p_0\)</span>, nüfusun <span class="math inline">\(t = 0\)</span> (yani başlangıçtaki) sayısıdır. Şimdi bakterilerden, insan nüfusuna gelelim. İnsan nüfusu için hiç ölmeme varsayımı tabii ki yanlış! Fakat, insanların sadece doğal sebeplerden olduğunu varsayarsak, ölüm oranının da o anki nüfus sayısına orantılı olduğunu düşünebiliriz. Bu yüzden, ilk denklemi değiştirip, şu hale getiriyoruz.</p>
<p><span class="math display">\[ \frac{dp}{dt} = k_1p - k_2p = (k_1-k_2)p = kp\]</span></p>
<p><span class="math inline">\(k_2\)</span> olarak nitelenen sabit, ölüm oranı olarak temsil edildi. <span class="math inline">\(k_1\)</span>'in her zaman <span class="math inline">\(k_2\)</span>'den büyük olduğunu farzedersek, asâgıdaki model çıkar.</p>
<p><span class="math display">\[ \frac{dp}{dt} = kp \]</span></p>
<p><span class="math display">\[ p(0) = p_0 \]</span></p>
<p>Birçok k sabiti kullanılmış olması aklınızı karıştırmasın. Doğum ve ölüm oranlamaları değişik sabitler gerektiyor, ama önemli olan bir 'sabit' kullanıldığını farketmek. Sonuçta demeye çalıştığımız nüfus ile nüfus büyümesi arasında doğrusal bir bağlantı olması. Sabite ihtiyacamız da buradan geliyor.</p>
<p>Elimize geçen son formül, ünlü bir formüldür, Maltezyen ya da nüfus artışının üstel (exponential) kanunu olarak bilinir. Denklem ayırılabilir olduğu için, işlemden geçirip p fonksiyonunu bulmak mümkün.</p>
<p><span class="math display">\[ \frac{dp}{dt} = kp, p(0) = p_0 \]</span></p>
<p><span class="math display">\[ \frac{dp}{p} = kdt \]</span></p>
<p><span class="math display">\[ \int \frac{dp}{p} = \int k \mathrm{d} t\]</span></p>
<p><span class="math display">\[ ln p = kt + C \]</span></p>
<p><span class="math display">\[ p = e^Ce^{kt} \]</span></p>
<p><span class="math display">\[ e^C = C_1 \]</span></p>
<p><span class="math display">\[ p = C_1e^{kt} \]</span></p>
<p>Maltezyen modelini test etmek için, Amerika'nın nüfus artış verisini kullanabiliriz.</p>
<pre><code>Sene Nufus Maltezyen Lojistik

1770 3.93 3.93  3.3
1800 5.31 5.19  5.30
1810 7.24 6.84  7.13
1820 9.64 9.03  9.58
1830 12.87 11.92  12.82
1840 17.07 15.73  17.07
1850 23.19 20.76  22.60
1860 31.44 27.39  29.70
1870 39.82 36.15  38.65
1880 50.16 47.70  49.69
1890 62.95 62.95  62.95
1900 75.99 83.07  78.37
1910 91.97 109.63  95.64
1920 105.71 144.67  114.21
1930 122.87 190.91  133.28
1940 131.67 251.94  152.00
1950 151.33 332.47  169.56
1960 179.32 438.75  185.35
1970 203.21 579.00  199.01
1980 226.50 764.08  210.46
1990 249.63 1008.32  219.77
2000 ? 1330.63  227.19</code></pre>
<p>Örnek 1</p>
<p>Eğer t = 0 değeri için 1790 senesini alırsak, son formüle göre şöyle p(t) formülü nasıl bulunabilir?</p>
<p><span class="math display">\[ p(t) = (3.93)e^{kt} \]</span></p>
<p><span class="math display">\[ p(100) = 62.95 = (3.93)e^{100k} \]</span></p>
<p><span class="math display">\[ k = \frac{ln(62.95)-ln(3.93)}{100} \approx 0.027737 \]</span></p>
<p><span class="math display">\[ p(t) = (3.93)e^{(0.027737)t} \]</span></p>
<p><span class="math inline">\(p(t)\)</span>'yi bulduk. Yukarıda ki verilerden formülü kontrol edersek, Maltezyen tahmini 1900 tarihine kadar tuttuğunu görürüz. Fakat 1900'den sonra tahmin edilen nüfusun çok fazla, bu yüzden modelin işlemediğini görüyoruz.</p>
<p>Acaba model niye her zaman için işlemedi? Düşünelim. Model, nüfus çok arttıktan sonra bozulmaya başladığına göre, nüfus fazlalığı ile alakalı, ve bizim modele almadığımız bir faktör var demektir.</p>
<p>Maltezyen modeli, sadece doğal sebeplerden olan ölümü göz önüne almıştı. Öteki ölüm sebepleri de önemli olabilir, mesela yiyecek darlığından olan ölümler, yeterli sağlık malzemesi olmaması, ilaç yokluğundan olan ölümler, bulaşıcı hastalılar ya da suç işleyen insanlar yüzünden ölenler olabilir.</p>
<p>Bu tür faktörler insanlar arasında etkileşim gerektirdiği ve belli kaynaklara olan yarışma sırasında vuku bulan ölme durumlerı olduğu için, modele, ikili ilişkilerin de dikkate alındığı bir şekilde genişletmemiz gerekiyor. Yani, p sayısındaki bir nüfus için, p(p - 1) kadar ikili ilişki olduğunu düşünürsek, o zaman bu ikili ilişki ve yarış sonucundaki ölüm oranını şu şekilde modelleyebiliriz.</p>
<p><span class="math display">\[ \frac{dp}{dt} = ap - bp^2 \]</span></p>
<p>Burada <span class="math inline">\(p\)</span> ve <span class="math inline">\(p^2\)</span> ifadelerinin katsayıları, sabitleri değişik, çünkü bir sabit normal doğum ölümü, diğeri ise kaynaklara olan yarıştaki ölümler seçildi.</p>
<p>Şimdi biraz notasyon değişikliği, Cebirsel işlemleri kolaylaştırmak için sabitlerde biraz oynama yapacağız. <span class="math inline">\(a = k\)</span>, ve <span class="math inline">\(b = k/K\)</span> diyelim.</p>
<p><span class="math display">\[ kp - \frac{k}{K}p^2 = \frac{dp}{dt} \]</span></p>
<p><span class="math display">\[ kp (1 - \frac{p}{K}) = \frac{dp}{dt} \]</span></p>
<p>Değişken ayırma (seperation of variables) yöntemini kullanırsak</p>
<p><span class="math display">\[ \frac{dp}{p(1-p/K)}  = k \ dt\]</span></p>
<p>İki tarafın da entegralini alalım</p>
<p><span class="math display">\[ \int \frac{dp}{p(1-p/K)}  = \int k \mathrm{d} t\]</span></p>
<p><span class="math display">\[ \int \frac{1}{p(1-p/K)}dp  = \int k \mathrm{d} t\]</span></p>
<p>Eşitliğin sol tarafında entegralin içindeki ifadede hem bölüm, hem böleni <span class="math inline">\(K\)</span> ile çarparsak</p>
<p><span class="math display">\[ = \frac{K}{p(K-p)} \]</span></p>
<p>Bunun üzerinde kısmi kesirler yöntemini (partial fractions method) kullanabiliriz, özellikle bölümdeki çarpanların toplamının bölümde olduğu durumlarda, ki bizim örneğimizde bu <span class="math inline">\(p + K - p = K\)</span>, bu ifadeyi ayırmak çok kolay, kısmi kesirlerin bölümü hemen 1 olabilir</p>
<p><span class="math display">\[ = \frac{1}{p}  + \frac{1}{K-p}\]</span></p>
<p>Entegralde yerine koyalım</p>
<p><span class="math display">\[ \int \frac{1}{p}  + \frac{1}{K-p} \mathrm{d} p  = \int k \mathrm{d} t\]</span></p>
<p><span class="math display">\[ \int \frac{dp}{p} + \int \frac{dp}{K-p} = \int k \mathrm{d} t \]</span></p>
<p><span class="math display">\[ ln|p| - ln|K-p| = kt + C \]</span></p>
<p><span class="math display">\[ ln \bigg| \frac{p}{K-p}\bigg|  = kt + C\]</span></p>
<p><span class="math display">\[ ln \bigg| \frac{K-p}{p}\bigg|  = -kt - C\]</span></p>
<p>İki tarafı <span class="math inline">\(e\)</span> bazında hesaplarsak</p>
<p><span class="math display">\[ \bigg| \frac{K-p}{p}\bigg| = e^{-kt - C} \]</span></p>
<p>Eğer <span class="math inline">\(A = \pm e^{-C}\)</span> alırsak</p>
<p><span class="math display">\[ \frac{K-p}{p} = A e^{-kt }  
\qquad (1)
\]</span></p>
<p><span class="math display">\[ \frac{K}{p} - 1 = Ae^{-kt} \]</span></p>
<p><span class="math display">\[ \frac{K}{p}  = 1 + Ae^{-kt} \]</span></p>
<p><span class="math display">\[ \frac{p}{K}  = \frac{1}{ 1 + Ae^{-kt}}\]</span></p>
<p><span class="math display">\[ p(t) = \frac{K}{ 1 + Ae^{-kt}} \]</span></p>
<p>Final formüle eriştik.</p>
<p>Peki <span class="math inline">\(A\)</span> nedir? Eğer (1) ifadesine <span class="math inline">\(t=0\)</span> verirsek</p>
<p><span class="math display">\[ \frac{K-p(0)}{p(0)} = A e^{k \cdot 0} = A\]</span></p>
<p><span class="math inline">\(p(0) = p_0\)</span> diyelim</p>
<p><span class="math display">\[  \frac{K-p_0}{p_0} = A \]</span></p>
<p>Bu denklemin tahminleri çok daha iyi işleyecektir.</p>
<p>Elde ettiğimiz <span class="math inline">\(p(t)\)</span> fonksiyonunu grafiklediğimiz zaman çıktı suna benzeyecektir.</p>
<div class="figure">
<img src="hill.png" />

</div>
<p>Elde edilen şekilde bir 'S' görüntüsünde, bu fonksiyona &quot;S eğrisi'' adı verildiği de oluyor. Bir diğer isim &quot;Hill fonksiyonu''.</p>
<p>Veri Uydurmak</p>
<p>Hill fonksiyonunu sayısal yöntemler kullanarak tarihi veriye uydurarak, sabitlerini hesaplatmak mümkündür. Scipy paketindeki <code>scipy.optimize.leastsq</code> fonksiyonu bu işi yapabilir. Uydurmanın işlemesi için önce bir <code>f</code> tanımlanır, daha sonra bu fonksiyonun gerçek veri ile arasındaki hatayı tanımlayan bir fonksiyon verilir. Bu iki fonksiyon üzerinden veri uydurması yapılacaktır.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># US population prediction, Logistic growth, Hill function</span>
<span class="co"># Amerika nufus artisi, lojistik denklem</span>

<span class="im">from</span> scipy <span class="im">import</span> optimize

<span class="kw">def</span> f(t,A,k,K):
    <span class="cf">return</span> K <span class="op">/</span> (<span class="dv">1</span><span class="op">+</span>A<span class="op">*</span>np.exp(<span class="op">-</span>k<span class="op">*</span>t))    

<span class="kw">def</span> resid(p, y, t):
    A,k,K <span class="op">=</span> p
    <span class="cf">return</span> y <span class="op">-</span> f(t,A,k,K)

t, x1 <span class="op">=</span> np.loadtxt(<span class="st">&#39;us.txt&#39;</span>, unpack<span class="op">=</span><span class="va">True</span>)
t <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">10</span>,<span class="bu">len</span>(t))

A0,k0,K0 <span class="op">=</span> <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>

[A,k,K], flag  <span class="op">=</span> optimize.leastsq(resid, [A0,k0,K0], args<span class="op">=</span>(x1, t))

<span class="bu">print</span> flag, A, k, K
    
plt.plot(t, x1, <span class="st">&#39;ro&#39;</span>)
plt.hold(<span class="va">True</span>)            
t <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">20</span>,<span class="bu">len</span>(t))    
plt.plot(t, f(t,A,k,K), <span class="st">&#39;go&#39;</span>)    
plt.savefig(<span class="st">&#39;us.png&#39;</span>)</code></pre></div>
<pre><code>1 43.0658055581 0.427360301123 394.758729112</code></pre>
<p>Program işletildikten sonra grafik basılacak. Grafikte kırmızı noktalar gerçek veri, yeşil noktalar ise uyumu yapılmış fonksiyonun gelecek yıllar için gösterdiği tahmindir.</p>
<div class="figure">
<img src="us.png" />

</div>
<p>Sonuç</p>
<p>Bu yazıda hem model kurmanın ve türevsel denklemlerin yararlarını gördük. Türevsel denklem kurarken düşünülmesi gereken, <span class="math inline">\(dp/dt\)</span> görünce 'oran' düşünmek, yani akla 'değişim' getirmek. Tabii daha türevleri daha detaylı anlayabilmek için (ispatı ile birlikte) limitlerin kuramı yararlı olur, fakat unutmayalım ki limitlerin ispatı için yetişinceye kadar yüzyıllar geçmişti! Calculus'un tam ispatı daha gelmeden, mühendisler ve bilim adamları türevleri ve entegralleri kullanıyorlardı.</p>
<p>Calculus, dinamik olan sistemler için kullanılır, yani değişmekte olan sistemler için gereklidirler. Calculus'un tarihinin fizik ile yakın alakası bundandır.</p>
<p>Kaynaklar</p>
<p>[1] Lerma, <em>Math 214-2 Integral Calculus Lecture Notes</em> <a href="http://www.math.northwestern.edu/~mlerma/courses/math214-2-03f" class="uri">http://www.math.northwestern.edu/~mlerma/courses/math214-2-03f</a></p>
<p>[2] Chan, <em>Scientific Scripting with Python for Computational Immunology</em></p>
</body>
</html>
