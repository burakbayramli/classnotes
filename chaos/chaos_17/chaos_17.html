<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Ders 17</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="ders-17">Ders 17</h1>
<p>Önceki derste Lorenz sisteminin bulunması kolay özelliklerinden
bahsettik, bu derste biraz daha çetrefil olanlarını, ve özellikle kaos
çıkma olasılığını inceleyeceğiz. Hatırlarsak Rayleigh parametresi <span
class="math inline">\(r &lt; 1\)</span> ise iddia etmiştim ki tüm gidiş
yolları sonuşurda (asymptotically) orijine yaklaşır. Bu iddiayı
ispatlayacak tekniğimiz yoktu, bu derste global sonuçlara erişmek için
bir teknik göstereceğim.</p>
<p>Eğer sönüm yeterince büyükse <span class="math inline">\(t \to
\infty\)</span> iken tüm gidiş yolları orijine yaklaşır, orijinin
“global olarak stabil’’ olduğunu söyleyebiliriz. Global stabilliğin
tersi yerel stabillik, bunu lineerizasyon üzerinden <span
class="math inline">\(r &lt; 1\)</span> için önceki derste görmüştük.
Orijin global olarak stabil ise o zaman her şey orijine gidiyor
demektir, stabil limit çevrimlerine, kaosa gitmiyorlar, başka hiçbir
çekici yok.</p>
<p>İspat nasıl olacak? İspatın taslağı şöyle; önce bir <span
class="math inline">\(V(x,y,z) = \frac{1}{\sigma} x^2 + y^2 +
z^2\)</span> tanımla. Peki bu fonksiyonu nereden buldum, çok bariz
değil. Bu tür fonksiyonları bulmak biraz sanat işidir bu arada, onlara
Lyapunov fonksiyonu deniyor. Lyapunov fonksiyonlarını içinde sürtünme,
sönüm, yitirgenlik olan bir sistemdeki enerji fonksiyonlarına
benzetebiliriz. Klasik bir mekanik sistemdeki toplam enerjiyi yazarız
mesela, ama sürtünme vardır, ve enerji tekdüze (monotonic) şekilde
azalmaya başlar. <span class="math inline">\(V\)</span>’nin böyle bir
fonksiyon olmasını istiyoruz, zaman geçtikçe tekdüze şekilde azalmalı,
ve bu azalış sayesinde <span class="math inline">\(x,y,z\)</span>’nin
orijine yaklaşması gerektiğini ispatlayacağız.</p>
<p>Geometrik açıdan bakalım olaya; <span
class="math inline">\(V\)</span> neredeyse standart bir hesap olan
karelerin toplamına benziyor, $ x^2 + y^2 + z^2$ neredeyse, tek fark
başta <span class="math inline">\(1/\sigma\)</span> var. Eğer <span
class="math inline">\(1/\sigma\)</span> formülde olmasaydı her sabit
<span class="math inline">\(V\)</span> için bu formül bir küre
tanımlıyor olurdu. Ama <span class="math inline">\(1/\sigma\)</span>
formülde olduğu için <span class="math inline">\(V\)</span>’nin kesit
seviyeleri (level set) elipsoid, daha doğrusu farklı <span
class="math inline">\(V\)</span>’ler için elimizde eşmerkezli
elipsoidler var. Taslaksak olarak çizelim,</p>
<p><img src="17_02.png" /></p>
<p>Göstereceğiz ki herhangi bir elipsoid üzerindeki <span
class="math inline">\(V\)</span> değerinden başlanınca (altta başlangıç
yeşil noktası) zaman geçtikçe daha da ufak <span
class="math inline">\(V\)</span> değerlerine gidiliyor, ve sonuç olarak
orijine yaklaşılıyor.</p>
<p><img src="17_03.png" /></p>
<p>Soru</p>
<p>Kesit seviyesi ne demektir?</p>
<p>Cevap</p>
<p><span class="math inline">\(V\)</span>’nin sabite eşit olduğu durum,
bazen kontur ismi de veriliyor.</p>
<p>Soru</p>
<p>Neyin orijine gittiğini anlamadım, gidiş yolları mı, elipsoid’ler
mi?</p>
<p>Cevap</p>
<p>Orijine giden <span class="math inline">\(x,y,z\)</span>. <span
class="math inline">\(V\)</span> üzerinden tanımladığımız elipsoidler
bir yere gitmiyor, onlar bize yardımcı bir araç sadece, onun sayesinde
orijine gidişi “şu anda hangi <span class="math inline">\(V\)</span>,
hangi elipsoid içindeyiz’’ sorusuna çevirmiş olduk.</p>
<p>Devam edelim, fikir şu: <span class="math inline">\(\frac{\mathrm{d}
V}{\mathrm{d} t}\)</span>’yi, yani değişim hızını hesapla, ve bu hızın
sıfırdan küçük olduğunu göster, eğer <span class="math inline">\(r &lt;
1\)</span> ise (bu faraziyeye ihtiyacımız olacak), ve orijinde değilsek.
Orijinde olmamamız önemli çünkü eğer tam orijin üzerindeysek,
hatırlarsak orijin bir sabit nokta, ve sabit noktada <span
class="math inline">\(V\)</span> azalmaz, orada <span
class="math inline">\(\frac{\mathrm{d} V}{\mathrm{d} t}=0\)</span>
olur.</p>
<p>Şimdi <span class="math inline">\(\frac{\mathrm{d} V}{\mathrm{d}
t}\)</span>’yi hesaplayalım, <span class="math inline">\(V\)</span>’yi
üsteki gibi niye seçtiğimizi şimdi daha iyi anlayacağız belki, çünkü
türevi alırken tanımladığımız <span class="math inline">\(V\)</span>’nin
faydalı olacak özellikleri var. Bir de <span
class="math inline">\(\frac{1}{2} \frac{\mathrm{d} V}{\mathrm{d}
t}\)</span>’yi hesaplayalım çünkü <span class="math inline">\(V\)</span>
içindeki kareler türev sonrası aşağı inip katsayı 2 haline gelecek,
onları iptal etmek için <span class="math inline">\(1/2\)</span> ile
baştan çarpalım.</p>
<p><span class="math display">\[
\frac{1}{2} \frac{\mathrm{d} V}{\mathrm{d} t} =
\frac{x\dot{x}}{\sigma} + y\dot{y} + z\dot{z}
\]</span></p>
<p>Niye ilk terimde <span
class="math inline">\(\frac{x\dot{x}}{\sigma}\)</span> elde ettik?
Zincirleme Kanununu unutmayalım, <span
class="math inline">\(t\)</span>’ye göre türev alıyoruz, fakat <span
class="math inline">\(x\)</span>, <span
class="math inline">\(t\)</span>’nin bir fonksiyonu, bu sebeple <span
class="math inline">\(x^2\)</span> türevi önce <span
class="math inline">\(2x\)</span> veriyor, sonra <span
class="math inline">\(x\)</span>’in <span
class="math inline">\(t\)</span>’ye göre türevi <span
class="math inline">\(\dot{x}\)</span> ile çarpıyoruz. Şimdi Lorenz
denklemlerine bakarak <span
class="math inline">\(\dot{x},\dot{y},\dot{z}\)</span>’nin değerlerini
üstteki formüle sokalım. Lorenz denklemleri neydi?</p>
<p><span class="math display">\[ \dot{x} = \sigma (y - x)\]</span></p>
<p><span class="math display">\[ \dot{y} = rx - y - xz \]</span></p>
<p><span class="math display">\[ \dot{z} = xy - bz \]</span></p>
<p>Bu arada 1. formüldeki <span class="math inline">\(\sigma\)</span>’ya
dikkat, zaten bu sebeple Lyapunov fonksiyonuna bir <span
class="math inline">\(\sigma\)</span> koyduk ki şimdi yapacağımız yerine
geçirme işleminden sonra <span class="math inline">\(\sigma\)</span>’lar
iptal olabilsin.</p>
<p><span class="math display">\[ = (yx - x^2) + (ryx - y^2 - xzy) + (zxy
- bz^2)  \]</span></p>
<p>İptal olabilecek bazı terimler var, mesela,</p>
<p><span class="math display">\[ = (yx - x^2) + (ryx - y^2 -
\cancel{xzy}) + (\cancel{zxy} - bz^2)  \]</span></p>
<p><span class="math display">\[ = (r+1)xy -x^2 -y^2 - bz^2
\]</span></p>
<p>Bu son ifadeye bakalım, onun kesinlikle negatif olacağından emin
miyiz? Terim terim bakarken tam emin olamıyoruz, <span
class="math inline">\(b,r\)</span> pozitif, <span
class="math inline">\(-bz^2\)</span> sıfır ya da negatif, <span
class="math inline">\(-x^2,-y^2\)</span> aynı şekilde. Fakat <span
class="math inline">\((r+1)xy\)</span> terimi problem çıkartabilir gibi
duruyor, eğer <span class="math inline">\(x,y\)</span> aynı işarete
sahipse o zaman bu terim pozitif olur. Yani ilk bakışta üstteki ifade
“negatif kesin’’ gibi durmuyor (lineer cebirden terminoloji kullanmak
gerekirse), fakat aslında öyle. Kareyi tamamlama (completing the square)
işlemini uygulayınca bu açık bir şekilde görülecek.</p>
<p><span class="math display">\[
=
- \bigg[ x - \frac{r+1}{2}y \bigg]^2
- \bigg( 1-\bigg(\frac{r+1}{2}\bigg)^2 \bigg)y^2
- bz^2
\]</span></p>
<p>Üstteki ifadeyi açınca iki üstteki ifadeyi elde ettiğimiz
görülebilir. Bu son ifade gerçi daha arap saçı gibi duruyor ama bence
onun negatif kesin olduğunu görmek daha kolay. İlk büyük terimde
“negatif bir şeyin karesi’’ var, kare her zaman pozitif verir, onun
negatifi her zaman negatif olur. İkinci büyük terimde <span
class="math inline">\((\frac{r+1}{2})^2\)</span>’ye bakalım, <span
class="math inline">\(r &lt; 1\)</span> demiştik, o zaman bölünende
2’den küçük bir değer var, yani <span
class="math inline">\(\frac{r+1}{2} &lt; 1\)</span> olacak, karesini
alınca hala 1’den küçük, o değeri 1’den çıkartınca her zaman pozitif.
Yani ikinci büyük terimde <span class="math inline">\(y^2\)</span>
önünde pozitif bir değer var, çünkü <span
class="math inline">\(r&lt;1\)</span>. O zaman ilk büyük terimde
negatif, ikinci büyük terimde pozitif bir şeyin negatifi çarpı pozitif
<span class="math inline">\(y^2\)</span>, ve üçüncü terimde <span
class="math inline">\(-b\)</span> her zaman negatif, çarpı <span
class="math inline">\(z^2\)</span> her zaman pozitif, yani üçüncü terim
de negatif. O zaman üstteki hesap her zaman <span
class="math inline">\(\le 0\)</span>.</p>
<p>Pekala, <span class="math inline">\(\frac{1}{2} \frac{\mathrm{d}
V}{\mathrm{d} t}\)</span>’in pozitif olmadığını gösterdik. Peki sıfır
olabilir mi? Düşünelim, negatifi alınmış bir şeylerin karesinin
toplamının sıfır olabilmesi için o toplamdaki (negatif olan) her terimin
ayrı ayrı sıfır olması gerekir. Değil mi? Biri pozitif biri negatif
olsaydı o zaman biri bir diğerine götürür vs. gibi şeylerle ilgilenmemiz
gerekecekti, ama tüm terimlerin negatif olduğunu biliyoruz, o zaman
sıfıra eşitlik için hepsinin ayrı ayrı sıfır olması gerekir. Bakıyoruz
<span class="math inline">\(y^2,z^2\)</span>’nin katsayıları sıfır
olması mümkün değil, o zaman bu terimlerde sıfırlık için <span
class="math inline">\(y,z\)</span>’nin sıfır olması gerekir. Aynı
şekilde birinci terimde <span class="math inline">\(x,y\)</span> sıfır
olmalı. Demek ki üstteki ifadenin sıfır olması için tüm <span
class="math inline">\(x,y,z\)</span> değişkenleri sıfır olmalı, bu
orijinde olunduğu durum.</p>
<p>Baştaki iddiamıza dönelim, eğer orijinde değilsek, <span
class="math inline">\(r&lt;1\)</span> ise <span
class="math inline">\(\frac{1}{2} \frac{\mathrm{d} V}{\mathrm{d}
t}\)</span> kesin negatif, yani ardı ardına gelen elipsoidlerin hepsi
birbirinden küçük. O zaman, <span class="math inline">\(V\)</span>’nin
alt sınırı sıfır olduğuna göre, ve <span
class="math inline">\(V\)</span> tekdüze şekilde azaldığı için <span
class="math inline">\(V(x(t),y(t),z(t)) \to 0\)</span> olmalıdır. <span
class="math inline">\(V\)</span>’nin sıfır olduğu tek nokta da <span
class="math inline">\(x,y,z\)</span> sıfır olduğu noktada olduğu için
<span class="math inline">\(t \to \infty\)</span> iken gidiş yolu
orijine gidiyor demektir.</p>
<p>Soru</p>
<p>Bu Lyapunov fonksiyonunu nasıl buldunuz?</p>
<p>Cevap</p>
<p>Bu işin sanat kısmı işte, aynen Dulac yöntemindeki <span
class="math inline">\(g\)</span>’yi bulmak gibi. Uygulamalı Matematikte
halen pek çok çözülmemiş problem var, çünkü onlar için hala düzgün bir
Lyapunov fonksiyonu bulunamadı. Mesela türbülansta boruda akışı
düşünürsek, belli bir Reynolds sayısının, mesela 800 gibi, altında tek
stabil çözümün yaprak tipi (laminar) çözüm olduğu düşünülüyor. Yani
sistemde yaprak tipi olan global bir çekici var, ama hala kimse bunu
kesin olarak ispatlayamadı. Kabaca bunun doğru olduğunu biliyoruz, ama o
Lyapunov fonksiyonunu bulamadığımız için kesin ispatı yapamıyoruz.</p>
<p>Devam edelim, şu <span class="math inline">\(r &lt; 1\)</span> olan
sıkıcı alandan çıkalım artık, <span class="math inline">\(r &gt;
1\)</span> olunca ne oluyor ona bakalım. Önceki derste <span
class="math inline">\(r&gt;1\)</span> olunca orijinde bir eğer var
demiştik, ayrıca iki yeni sabit noktayı bulmuştuk, onlara <span
class="math inline">\(C^-\)</span> ve <span
class="math inline">\(C^+\)</span> ismi vermiştik. Bu iki yeni sabit
nokta <span class="math inline">\(r=1\)</span> olduğunda orijinde ortaya
çıkıyordu, bu noktalar su çarkının herhangi bir yönde kalıcı dönüşüne
tekabül ediyordu, ya da bu modelin temsil ettiği taşınım hücresinin
varlığına.</p>
<p>Bu konumlar stabil mi? Evet, en azından ilk başta. Bunun hesabını
size ödev olarak veriyorum. Ödevde onların lineersel olarak stabil
olduğunu bulacaksınız, bu sonuca özdeğerleri hesaplayarak varmak
gerekiyor, ya da bu üç boyutlu sistemde o özdeğerler için belli koşullar
hesaplayarak.. Neyse bu noktaların <span class="math inline">\(1 &lt; r
&lt; r_{hopf}\)</span> için lineersel stabil olduğunu bulacaksınız, ki
<span class="math inline">\(r_{hopf} =
\sigma(\frac{\sigma+b+3}{\sigma-b-1})\)</span>. Hopf ismini kullandım
çünkü göreceğiz ki bu sayıda bir Hopf çatallaşması ortaya çıkıyor. Bu
sonucu türetirken ayrıca bölenin pozitif olduğunu farz etmeniz gerekiyor
yani <span class="math inline">\(\sigma &gt; b + 1\)</span>. Lorenz’in
makalesini hatırlarsak <span
class="math inline">\(\sigma=10,b=8/3\)</span>. <span
class="math inline">\(r_{hopf}\)</span>’in aşağı yukarı <span
class="math inline">\(24.74\)</span> çıkması lazım, yani 1 ile bu değer
arasında bu noktanın sabit olduğu oldukça büyük bir bölge var.</p>
<p>Peki <span class="math inline">\(r &gt; r_{hopf}\)</span> olduğu
zaman ne olacak? Bu Hopf’in ne tür olduğuna bağlı. Hopf çatallaşmasında
bir limit çevrimi yaratılır ama bu stabil bir çevrim midir, ki bu
durumda Hopf süperkritiktir, yoksa gayrı-stabil midir ki bu durumda
çevrim <span class="math inline">\(r_{hopf}\)</span> altında oradaydı ve
gayrı-stabil durumdaydı? Bir tahmininiz var mı?</p>
<p>Bir tahmine göre <span class="math inline">\(C^-,C^+\)</span>
çevresinde ufak, stabil birer limit çevrimi var, iki tane çünkü
hatırlarsak çözümler simetrik çift halinde geliyor - fakat bu tahmin
doğru değil, standart Lorenz parametre değerleri için çatallaşma
altkritik (subcritical). Hatırlarsak altkritik tehlikeli bir şey, 13.
derste bunu anlatırken uçak kanatlarından bahsetmiştim, kollarımı filan
sallamıştım, tehlikeli çünkü yakında hiçbir çekici yok. Tahmin bir yana,
hesabın kendisi aslında zor bir hesap. Uzun yıllar bu alanda çalışanlar
burada alt mı süper mi kritiklik olduğundan emin değildi, elde bir ispat
yoktu, ta ki Marsden ve McCracken tarafından ispat yapılana kadar
[2].</p>
<p>Altkritiklik mevcudiyet ne demek? Ortada bir altkritik çatallaşma
olduğuna göre gidiş yolları uzaktaki bir çekiciye atlayacak demektir. Bu
çatallaşmayı tehlikeli yapan da bu zaten, kesintisiz, sürekli olmayan
bir davranış var ortada. Bizim örneğimizde bu zıplayış <span
class="math inline">\(C^-,C^+\)</span> çekicileri dışında bir şey
olacak. Bu şey nedir?</p>
<p>Hatırlarsak imkansızları eleyen ve geriye kalan, her ne kadar olası
olmasa da, doğru cevaptır diyen Sherlock Holmes felsefesini takip
ediyoruz, burada şimdiye kadar elediklerimiz neler?</p>
<p><img src="17_04.png" /></p>
<p><span class="math inline">\(r=1\)</span>’de çatallaşma oluyor
demiştik, sonra gidiyor gidiyoruz, ta ki <span
class="math inline">\(r_{hopf}\)</span>’a (resimde <span
class="math inline">\(r_H\)</span>) gelinceye kadar, bu noktada ispat
etmeden iddia etmiştim ki burada altkritik Hopf çatallaşmaları var, yani
o noktada geriye doğru bükülen gayrı-stabil çevrimler var. Onları da
resimde göstermeye uğraştık. Bu arada, o geriye doğru bükülen kapların
gidip gidip orijine gittiğini hayal edenler olabilir, ve bu hakikaten
oluyor, standart Lorenz parametreleri çevresindeki bazı değerler için
yanlış hatırlamıyorsam, 13 ya da 14 etrafında, o gayrı-stabil çevrimler
o kadar büyüyor ki uçları bir homoklinik çatallaşma üzerinden orijine
dokunuyor. Bu olduğunda “çanak-çömlek patlıyor’’, her şey alt-üst
oluyor, bazıları bu hale homoklinik patlama ismi veriyor, çok yanlış bir
isim değil. Lorenz sistemi hakkında bir kitap yazıldı [3], orada yazar
bu durumdan detayıyla bahsediyor. Lorenz’in kendisi bu durumu
bilmiyordu, yeni keşfedilen bir şey, ama o da <span
class="math inline">\(r\)</span>’yi büyüttükçe ve <span
class="math inline">\(r_{hopf}\)</span> sonrası her şeyin gayrı-stabil
olduğunu görüyordu. <span class="math inline">\(C^-,C^+\)</span>,
orijin, herşey gayrı-stabilliğe gidiyor.</p>
<p>Peki gidiş yolları nasıl davranır bu durumda? Belki sonsuzluğa
kaçtılar! Tüm sistem o kadar gayrı-stabil durumda ki belki aşırı
büyüdüler / patladılar. Aslında bu mümkün değil, bu başka bir ödevin
konusu (çok zor değil). Gidiş yolları sonsuza gider mi? Hayır. İspat
için büyük bir küre tasarlarsınız ki öyle ki onun dışındaki tüm gidiş
yolları küreye doğru gitmeli, ve içine girmeli, ve hiç dışarı
çıkamamalı. Yani ortada bir kapan bölgesi (trapping region) var. Her şey
nihayetinde bir büyük küre içinde yakalanıyor. Lorenz de bu ispatı
makalesinde yapmıştı.</p>
<p>O zaman sonsuza gidiş yok, etrafta hiç çekici yok. Bir diğer ihtimal
ne olabilir? Bir stabil limit çevrimi mi? İlla <span
class="math inline">\(C^-\)</span>, ya da <span
class="math inline">\(C^+\)</span>’dan çatallaşmış olması gerekmez,
belki hiç yoktan ortaya çıkan bir stabil limit çevrimi var, çevrimlerin
eğri düğüm çatallaşması durumunda olduğu gibi..? Bu kavisli bir soru.
Lorenz makalesinde öne sürdüğü sistemde stabil limit çevrimi olmadığını
iddia etti, kullandığı argümanı sonra işleyeceğiz, ama argüman
inandırıcı idi.</p>
<p>Ne kaldı? Stabil limit çevrimi yok, ama belki sonuşurda bir değişmez
(invariant) torusa yaklaşıyoruz? Torus üzerinde periyotalımsı bir
hareket var, periyotalımsılıktan bahsetmiştik. Fakat bu da imkansız, bu
argüman oldukca basit. Değişmez torus derken bir kez o torusta
başlayınca onun üzerinde kalıyorsunuz demek istiyorum. Bu mümkün değil
çünkü eğer ortada bir değişmez torus var ise bu torusun hacmini
düşünelim. Burada katı / som (solid) bir iç torus var, dış yüzey
değişmez dedik, o zaman içteki hacim de değişmez olacaktır. Ve bu mümkün
değil çünkü biliyoruz ki Lorenz sistemindeki herhangi bir bölge üstel
bir şekilde küçülüyor. O zaman değişmez bir torus olamaz çünkü bu
küçülen bölge durumunu ihlal eder.</p>
<p>Bu noktada bildiğimiz her şeyi eledik. Lorenz de bu noktaya geldi, ve
sonra differansiyel denklemleri sayısal entegre ederek [yani sistemi
simüle ederek] neler olduğunu anlamaya uğraştı. Simülasyonu şurada
görebilirsiniz [4]. Video Lorenz’in ünlü bir başlangıç şartında noktadan
sonra birkaç sayıyı attıktan sonra sistemin tamamen farklı şekilde
davrandığı durumu gösteriyor, ki kaosun “başlangıç şartlarına hassas
bağımlılığı’’ burada görülebiliyor.</p>
<p>Lorenz ODE Denklemlerinin Sayısal Olarak Çözümü [1]</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.integrate <span class="im">import</span> odeint</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rhs(u,t,beta,rho,sigma):</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    x,y,z <span class="op">=</span> u</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [sigma<span class="op">*</span>(y<span class="op">-</span>x), rho<span class="op">*</span>x<span class="op">-</span>y<span class="op">-</span>x<span class="op">*</span>z, x<span class="op">*</span>y<span class="op">-</span>beta<span class="op">*</span>z]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>sigma<span class="op">=</span><span class="fl">10.0</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>beta<span class="op">=</span><span class="fl">8.0</span><span class="op">/</span><span class="fl">3.0</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>rho1<span class="op">=</span><span class="fl">29.0</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>rho2<span class="op">=</span><span class="fl">28.8</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>u01<span class="op">=</span>[<span class="fl">1.0</span>,<span class="fl">1.0</span>,<span class="fl">1.0</span>]</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>u02<span class="op">=</span>[<span class="fl">1.0</span>,<span class="fl">1.0</span>,<span class="fl">1.0</span>]</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>t<span class="op">=</span>np.linspace(<span class="fl">0.0</span>,<span class="fl">50.0</span>,<span class="dv">10001</span>)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>u1<span class="op">=</span>odeint(rhs,u01,t,args<span class="op">=</span>(beta,rho1,sigma))</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>u2<span class="op">=</span>odeint(rhs,u02,t,args<span class="op">=</span>(beta,rho2,sigma))</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>x1,y1,z1<span class="op">=</span>u1[:, <span class="dv">0</span>],u1[:, <span class="dv">1</span>],u1[:, <span class="dv">2</span>]</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>x2,y2,z2<span class="op">=</span>u2[:, <span class="dv">0</span>],u2[:, <span class="dv">1</span>],u2[:, <span class="dv">2</span>]</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpl_toolkits.mplot3d <span class="im">import</span> Axes3D</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>fig<span class="op">=</span>plt.figure()</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>ax<span class="op">=</span>Axes3D(fig)</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>ax.plot(x1,y1,z1,<span class="st">&#39;b-&#39;</span>)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>ax.plot(x2,y2,z2,<span class="st">&#39;r:&#39;</span>)</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">&#39;x&#39;</span>)</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">&#39;y&#39;</span>)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>ax.set_zlabel(<span class="st">&#39;z&#39;</span>)</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">&#39;Lorenz denklemleri, rho = </span><span class="sc">%g</span><span class="st">, </span><span class="sc">%g</span><span class="st">&#39;</span> <span class="op">%</span> (rho1,rho2))</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;17_01.png&#39;</span>)</span></code></pre></div>
<p><img src="17_01.png" /></p>
<p>Soru</p>
<p>Lorenz modelini niye / nasıl keşfetti?</p>
<p>Cevap</p>
<p>1960’lı yıllarda bilim çevrelerinde ciddi bir tartışma vardı, hava
tahmini nasıl yapılır? Üç metot öne sürülmüştü, biri örüntü / kalıp
tanıma (pattern matching) ile. Dün sıcaklık 20 derece ise, tarihte 20
derece olan diğer günleri bul, bu günlerden ertesi günde ne olduğunu
raporla. Basitleştiriyorum ama, aşağı yukarı fikir bu. İkinci yöntem
lineer regresyon ile, komşu eyaletlerin, dün, önceki gün,
vs. değişkenlerini al, o yer ile bir regresyona sok, katsayı değerlerini
hesapla, sonra o katsayılar ile yeni bir gün, yer için tahmin üret.</p>
<p>Üçüncüsü pür fiziksel olarak olaya yaklaşmak, sıvı akışını biliyoruz,
termodinamik kanunlarını biliyoruz, bu yöntemleri havaya uygula, basınca
bak, kısmi differansiyel denklemleri bul, sayısal entegrasyon ile ne
olacağını hesapla. Üçüncü yöntemin problemi o günkü bilgisayarların
hesap için yeterince kuvvetli olmaması idi.</p>
<p>Lorenz gördüğümüz gibi bir differansiyel denklem sistemi kullandı, ki
bu üçüncü yöntem, fakat ilginç olan Lorenz aslında 1. ve 2. yöntemlerin
hangisinin daha iyi olduğunu anlamak amacıyla iklim gibi davranan bir
“suni iklim’’e ihtiyacı olduğu için denklemlerini yazdı. Çünkü o zaman
bu iklimi istediği gibi / şekilde işletip testlerini onun üzerinde
yapabilecekti. Bazıları Lorenz’in rasgele bu denklemleri bulduğunu
söylüyor ama bu doğru değil. O bu denklemleri kasıtlı bir şekilde,
deterministik ve tahmin edilmesi zor olacak şekilde seçti. Bir
arkadaşına söylemiş, taşınımda o tür bir denklem olduğunu biliyormuş
zaten, ama bu sistem 12 denklemli bir sistem, Lorenz onları azalta
azalta özünü temsil eden 3 denkleme getiriyor, ve Lorenz denklemleri
oradan geliyor; çünkü onun amacı deterministik ama periyotsal olmayan
bir şey tasarlamak.</p>
<p>Lorenz Çekicisi</p>
<p><img src="17_05.png" /></p>
<p>İki gidiş yolu düşünelim, aralarındaki fark başlangıçta çok az, <span
class="math inline">\(\delta_0\)</span> olsun. Zaman geçtikçe aralarında
<span class="math inline">\(\delta\)</span> vektörü kadar fark olsun.
Resimde <span class="math inline">\(\underline{\delta}\)</span>’yi
vektörün büyüklüğünü temsil için kullandım. Lorenz çekicisi için <span
class="math inline">\(t\)</span> zaman sonrası fark sayısal
deneylerde,</p>
<p><span class="math display">\[ \delta(t) \approx \delta_0 e^{\lambda
t}\]</span></p>
<p>olarak bulunmuştur. Standart Lorenz parametreleri için <span
class="math inline">\(\lambda = 0.9\)</span> çıkacak (bu da sayısal
deneylerle bulundu). Video’daki bilgisayar grafiğinde alttaki gibi bir
şekil vardı hatırlarsak,</p>
<p><img src="17_06.png" /></p>
<p>Bu grafik bol inişli çıkışlı bir grafik, benim iddiam eğer grafiği
kabaca temsil eden bir çizgi çizersek o çizginin eğimi 0.9 olur. Bu net
sayıyı çok ta ciddiye almaya gerek yok, ama bir pozitif <span
class="math inline">\(\lambda\)</span> olduğu bariz. Yani gidiş yolları
üstel hızda birbirinde ayrılıyor. Sonra ayrım bitiyor tabii [üstteki
grafikteki düz bölge] çünkü gidiş yollarının çekicinin ölçeğinden daha
fazla birbirlerinden ayrılması mümkün değil.</p>
<p><span class="math inline">\(\lambda\)</span> parametresi Lyapunov
üsteli (exponent) denen bir kavramı temsil ediyor. Tabii <span
class="math inline">\(n\)</span> boyutlu bir sistem için <span
class="math inline">\(n\)</span> tane Lyapunov üsteli olur, bu sadece en
büyüğü. İnsanlar bir Lyapunov üstelinden bahsederken aslında bunu
kastediyorlar, en büyük olanını. Ama net bir zihinde canlandırma için
gidiş yolunda bir nokta düşünelim, ve onun etrafında <span
class="math inline">\(n\)</span> boyutlu bir belirsizlik küresi
düşünelim. Zaman geçtikçe o küre bir elipsoid’e dönüşür, ve bu
elipsoid’in en büyük ekseni, yani en hızlı üstel ayrıma sebep olan
eksen, <span class="math inline">\(e^{\lambda t}\)</span> hızında
büyüyen eksen olacaktır.</p>
<p>Bir sistemin pozitif Lyapunov üstele sahip olması kaosun
işaretidir.</p>
<p>“Başlangıç şartlarına olan hassas bağlantı’’ demiştik, başlangıçta
yapılan ufak değişiklikler zaman geçtikçe üstel hızda değişime sebep
oluyordu. Bunu söylemek sistemin pozitif Lyapunov üsteline sahip
olduğunu söylemek ile aynı şey.</p>
<p>Bunun tahmin için önemi ne? Diyelim ki bir tolerans <span
class="math inline">\(a\)</span> sonrası sistemizi tahmin edilemez kabul
ediyoruz, yani <span class="math inline">\(\delta &gt; a\)</span> olduğu
durum. O zaman <span class="math inline">\(\delta_0 e^{\lambda t} =
a\)</span>’yi çözmek (<span class="math inline">\(t\)</span>’yi bulmak
için) bize temel kavramsal bir formül sunmuş oluyor.</p>
<p><span class="math display">\[ t \approx \frac{1}{\lambda} \ln \bigg(
\frac{a}{\delta_0}\bigg) \]</span></p>
<p><span class="math inline">\(t\)</span> tahminlerin işleyeceği zaman
noktası, ondan sonra tahmin mümkün değil, ona “tahmin ufku
(predictability horizon)’’ diyelim, ya da Lyapunov zamanı. Bu zamanın
<span class="math inline">\(1/\lambda\)</span> derecesinde olduğuna
dikkat. Mesela güneş sisteminin <span
class="math inline">\(1/\lambda\)</span>’sı 5 milyon yıl [gezegen
hareketleri oldukca tahmin edilir, ama zaman ölçeğini doğru seçince
orada bile kaos var]. Ama şimdi”bir dakika formülde logaritma var’’ diye
düşünenler olabilir. Uygulamalı Matematiğin iyi bilinen kulağa küpe
kurallarından biri logaritmaların derecesi 1 civarı olması. Bir sayının
logarıtma üzerinden etki yaratması için çok büyük olması gerekir, mesela
Avagadro’nun sayısı, 10 üzeri 23 değil mi, bu dehşet büyük bir sayı.
Fakat bu sayının log’unu alınca sadece 23 olur, ki o sayıda 1’den çok
büyük sayılmaz.</p>
<p>Yani birisi diyebilir ki “bu kabul edilemez, havayı <span
class="math inline">\(1/\lambda\)</span>’ya oranlı değil, <span
class="math inline">\(10 \lambda\)</span>’ya oranlı tahmin edebilmek
istiyoruz’’, yani şu an [mesela] yaptığımız tahminin 10 katına çıkmak
istiyoruz. Formül diyor ki o hedefe erişmek için <span
class="math inline">\(\delta_0\)</span>’yı müthiş ufaltmak lazım. Ne
kadar? <span class="math inline">\(10^{10}\)</span> kadar! Başlangıç
şartlarına olan hassas bağlantı bu işte. Kaotik sistemlerde başlangıç
ölçümlerinde aşırı ilerleme yapmadan tahmin ufkunu büyütmek çok zor.</p>
<p>Kaynaklar</p>
<p>[1] Saha, <em>42 Problems in Scientific Computing</em>, <a
href="http://www.physik.uzh.ch/~psaha/teach/42probs.pdf">http://www.physik.uzh.ch/~psaha/teach/42probs.pdf</a></p>
<p>[2] Marsden, <em>The Hopf Bifurcation and Its Applications</em></p>
<p>[3] Sparrow, <em>The Lorenz Equations: ifurcations, Chaos, and
Strange Attractors</em></p>
<p>[4] Strogatz, Lecture, <a
href="https://youtu.be/gscKcPAm-H0?t=2529">https://youtu.be/gscKcPAm-H0?t=2529</a></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
