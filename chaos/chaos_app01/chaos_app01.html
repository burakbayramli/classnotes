<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>

  <title>Ay'a Gidelim, Düzlemsel, Dairesel Kısıtlanmış 3-Cisim Problemi (Planar Restricted Circular 3-Body Problem)</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  
  
  
  
</head>
<body>
<h1 id="aya-gidelim-düzlemsel-dairesel-kısıtlanmış-3-cisim-problemi-planar-restricted-circular-3-body-problem">Ay'a Gidelim, Düzlemsel, Dairesel Kısıtlanmış 3-Cisim Problemi (Planar Restricted Circular 3-Body Problem)</h1>
<p>Ay'a gidebilmek için kütlelerin uzayda birbirini nasıl etkilediğini, birbirleriyle olan çekimlerini incelemek gerekiyor. ABD Nasa'nın Apollo programı aya gidebilmek için bu tür hesapları yapmak zorundaydı. Önce basit formdan başlayalım, iki cisim problemi.</p>
<p>İki Cisim Problemi</p>
<p>Uzayda iki cisim olduğunu düşünelim, bunlar iki gezegen olabilir,birisi <span class="math inline">\(m_1\)</span> kütlesine sahip ve <span class="math inline">\(\vec{x}_1\)</span>'de, diğer <span class="math inline">\(m_2\)</span> kütlesine sahip ve <span class="math inline">\(\vec{x}_2\)</span>'de.</p>
<div class="figure">
<img src="chaos_app01_03.png" />

</div>
<p>Böyle bir sistemde 2. kütlenin 1. üzerindeki çekim kuvvetinin</p>
<p><span class="math display">\[ 
\vec{F}_1 = 
\frac{G m_1 m_2 (\vec{x}_2-\vec{x}_1)  }{ | \vec{x}_2 - \vec{x}_1|^3  }
\]</span></p>
<p>olduğunu Newton Kanunu'nundan biliyoruz [5]. Ters yönden bakarsak 1. kütlenin 2. üzerindeki etkisi</p>
<p><span class="math display">\[ 
\vec{F}_2 = 
\frac{G m_1 m_2 (\vec{x}_1-\vec{x}_2)  }{ | \vec{x}_1 - \vec{x}_2|^3  }
\]</span></p>
<p>ki <span class="math inline">\(G\)</span> yerçekim sabiti. Newton'un ikinci kanunu <span class="math inline">\(F=ma\)</span>'yi kullanırsak, daha doğrusu onun formunu, <span class="math inline">\(\vec{F} = m \vec{a}\)</span> kullanarak üstteki iki formülü tekrar yazabiliriz. <span class="math inline">\(\vec{x}_1\)</span> ve <span class="math inline">\(\vec{x}_2\)</span>'in ivmesi (formüldeki <span class="math inline">\(\vec{a}\)</span>)) <span class="math inline">\(\ddot{\vec{x}}_1\)</span>, <span class="math inline">\(\ddot{\vec{x}}_2\)</span> olacaktır, mesela 1. cisim için</p>
<p><span class="math display">\[ \vec{F}_1=  m_1 \ddot{\vec{x}}_1 \]</span></p>
<p><span class="math inline">\(\vec{F}_1\)</span> için üstteki formülü yerine geçirip <span class="math inline">\(m_1\)</span> iptali yapınca</p>
<p><span class="math display">\[ \ddot{\vec{x}}_1  = \frac{G m_2 (\vec{x}_2-\vec{x}_1)  }{ | \vec{x}_2 - \vec{x}_1|^3  }\]</span></p>
<p>Aynı şekilde 2. cisim için</p>
<p><span class="math display">\[ \ddot{\vec{x}}_2  = \frac{G m_1 (\vec{x}_1-\vec{x}_2)  }{ | \vec{x}_1 - \vec{x}_2|^3  }\]</span></p>
<p>Sayısal çözüm için <span class="math inline">\(\dot{\vec{x}}_1 = v_1\)</span>, <span class="math inline">\(\dot{\vec{x}}_2 = v_2\)</span>, tanımları yapılabilir, böylece <span class="math inline">\(\dot{v}_1 = \ddot{\vec{x}}_1\)</span> olur, vs. detaylar için [6].</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> scipy.integrate <span class="im">import</span> odeint
<span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt
<span class="im">import</span> numpy <span class="im">as</span> np

m1 <span class="op">=</span> <span class="dv">1</span>
m2 <span class="op">=</span> <span class="dv">1</span>

<span class="kw">def</span> twobody(state, t):
    x1 <span class="op">=</span> np.array([state[<span class="dv">0</span>], state[<span class="dv">1</span>], state[<span class="dv">2</span>]])
    v1 <span class="op">=</span> np.array([state[<span class="dv">3</span>], state[<span class="dv">4</span>], state[<span class="dv">5</span>]])
    x2 <span class="op">=</span> np.array([state[<span class="dv">6</span>], state[<span class="dv">7</span>], state[<span class="dv">8</span>]])
    v2 <span class="op">=</span> np.array([state[<span class="dv">9</span>], state[<span class="dv">10</span>], state[<span class="dv">11</span>]])

    r <span class="op">=</span> x2<span class="op">-</span>x1
    r <span class="op">=</span> np.sqrt(np.<span class="bu">sum</span>(r<span class="op">*</span>r))

    x1d <span class="op">=</span> v1
    v1d <span class="op">=</span> m2<span class="op">*</span>(x2<span class="op">-</span>x1)<span class="op">/</span>(r<span class="op">*</span>r<span class="op">*</span>r)
    x2d <span class="op">=</span> v2
    v2d <span class="op">=</span> m1<span class="op">*</span>(x1<span class="op">-</span>x2)<span class="op">/</span>(r<span class="op">*</span>r<span class="op">*</span>r)

    <span class="cf">return</span> [x1d[<span class="dv">0</span>],x1d[<span class="dv">1</span>],x1d[<span class="dv">2</span>],v1d[<span class="dv">0</span>],v1d[<span class="dv">1</span>],v1d[<span class="dv">2</span>],<span class="op">\</span>
            x2d[<span class="dv">0</span>],x2d[<span class="dv">1</span>],x2d[<span class="dv">2</span>],v2d[<span class="dv">0</span>],v2d[<span class="dv">1</span>],v2d[<span class="dv">2</span>]]

state0 <span class="op">=</span> [<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>,<span class="op">\</span>
          <span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>,<span class="op">\</span>
          <span class="fl">1.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>,<span class="op">\</span>
          <span class="fl">0.0</span>, <span class="fl">1.0</span>, <span class="fl">0.0</span>]

t <span class="op">=</span> np.arange(<span class="fl">0.0</span>,<span class="fl">100.0</span>, <span class="fl">0.01</span>)
state <span class="op">=</span> odeint(twobody, state0, t)

<span class="im">from</span> mpl_toolkits.mplot3d <span class="im">import</span> Axes3D
fig <span class="op">=</span> plt.figure()
ax <span class="op">=</span> fig.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)
ax.plot(state[:,<span class="dv">6</span>]<span class="op">-</span>state[:,<span class="dv">0</span>], state[:,<span class="dv">7</span>]<span class="op">-</span>state[:,<span class="dv">1</span>], state[:,<span class="dv">8</span>]<span class="op">-</span>state[:,<span class="dv">2</span>])
ax.set_xlabel(<span class="st">&#39;x&#39;</span>)
ax.set_ylabel(<span class="st">&#39;y&#39;</span>)
ax.set_zlabel(<span class="st">&#39;z&#39;</span>)
plt.savefig(<span class="st">&#39;chaos_app01_01.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="chaos_app01_01.png" />

</div>
<p>Not: Üstte iki cisim problemini hesapsal olarak çözdük [6]. Bu problemin analitik çözümü de vardır, detaylar için [5].</p>
<p>Üstteki sonuç şunu söylüyor, başlangıç şartlarının uygun olduğu durumda (belli bir hıza sahip olununca birbirilerinden olan mesafe yeterli ise) iki cisim birbirlerinin (ya da ağırlık merkezlerinin) etrafında dönerler.</p>
<p>Kısıtlanmış 3-Cisim Problemi</p>
<p>3-cisim probleminde, mesela bir güneş, dünya, ay sisteminin analitik çözümü yoktur. Bu problemin kısa bir hikayesi 1. derste işlendi. Kısıtlanmış formda mesela bir dünya, ay, uzay gemisi sisteminde 3. cisim olan uzay gemisinin çok küçük olduğu için diğer iki cisim üzerinde etkisinin yok sayılabileceği varsayılır. Diğer kısıtlamalarla problem daha da basitleştirilir, mesela iki cismin dairesel yörüngede sabit hızda, ve aynı düzlemde döndüğü varsayılabilir, sonra eksen değişimi tekniği ile eksenin o hızda döndürülerek iki cismin hep aynı yerde kalması sağlanır, böylece tek hareket eden 3. cismin gidiş hesabı kolaylaşır. Tabii bu sistemin de analitik çözümü yoktur, hesapsal tekniklere başvurmak gerekir.</p>
<p>Baştan başlayalım, 1. ve 2. cisim üzerindeki kuvvet önemli değil, büyük iki cismin üçüncü cisim üzerindeki çekimi önemli, O zaman sadece 3. cisim için</p>
<p><span class="math display">\[ 
\ddot{\vec{x}}_3 =  
\frac{G m_1 (\vec{x}_1-\vec{x}_3)  }{ | \vec{x}_1 - \vec{x}_3|^3  } + 
\frac{G m_2 (\vec{x}_2-\vec{x}_3)  }{ | \vec{x}_2 - \vec{x}_3|^3  } 
\]</span></p>
<p>Bir diğer basitleştirme yörüngenin elips değil dairesel olması. O zaman Kepler'in Teorisi üzerinden bu iki cismin sabit hızda döndüğü farzedilebilir.</p>
<p>Şimdi bir kordinat sistemi yaratalım öyle ki <span class="math inline">\(\vec{x}_1,\vec{x}_2\)</span> her zaman <span class="math inline">\(y=0\)</span> üzerinde kalsınlar. Bunun için önce <span class="math inline">\(m_1,m_2\)</span>'nin pozisyonlarını kutupsal kordinatta gösteririz.</p>
<p><span class="math display">\[ 
\vec{x}_1 = \left[\begin{array}{r}
-r_1 \cos (\frac{2\pi t}{\tau}) \\
-r_1 \sin (\frac{2\pi t}{\tau})
\end{array}\right]
\]</span></p>
<p><span class="math display">\[ 
\vec{x}_2 = \left[\begin{array}{r}
\frac{m_1}{m_2} r_2 \cos ( \frac{2\pi t}{\tau} )\\
\frac{m_1}{m_2} r_2 \sin ( \frac{2\pi t}{\tau} )
\end{array}\right]
\]</span></p>
<p>ki <span class="math inline">\(r_1,r_2\)</span> sırasıyla <span class="math inline">\(m_1,m_2\)</span>'nin orijinden olan uzaklığı ve <span class="math inline">\(\tau\)</span> bir dönüşün ne kadar zaman aldığı (periyot büyüklüğü). İki kütlenin ağırlık merkezini orijin olarak atamak istiyoruz, ki <span class="math inline">\(r_2 = \frac{m_1}{m_2}r_1\)</span> olsun. Ayrıca basitlik amaçıyla <span class="math inline">\(r=r_1\)</span> diyelim. Şimdi iki cismin dönüşüne oranla kordinat sistemini döndürürsek bu cisimlerin sürekli <span class="math inline">\(y=0\)</span>'da kalmasını garanti edebiliriz, böylece sadece üçüncü cismin hareketine odaklanabiliriz, kordinatı döndürmesi <span class="math inline">\(-\frac{2\pi t}{\tau}\)</span> açısıyla olacak, bu döndürme / rotasyon matrisine <span class="math inline">\(R\)</span> diyelim,</p>
<p><span class="math display">\[ 
R(t) = \left[\begin{array}{rr}
\cos(\frac{2\pi t}{\tau}) &amp; \sin(\frac{2\pi t}{\tau}) \\
-\sin(\frac{2\pi t}{\tau}) &amp; \cos(\frac{2\pi t}{\tau}) 
\end{array}\right]
\]</span></p>
<p>Genel olarak iki boyutta <span class="math inline">\(\theta\)</span> kadar döndürme yapmak için alttaki gibi bir bir matris kullanabileceğimizi biliyoruz,</p>
<p><span class="math display">\[ R_\theta = \left[\begin{array}{rr}
\cos \theta &amp; -\sin \theta \\
\sin \theta &amp; \cos \theta
\end{array}\right] \]</span></p>
<p>Not: Eksi açıyla döndürülme yapıldığı için <span class="math inline">\(\sin\)</span> işaretleri değişmiş, <span class="math inline">\(-\sin(\theta) = \sin(-\theta)\)</span>), ama <span class="math inline">\(\cos(\theta) = \cos(-\theta)\)</span> olduğu için orada değişim yok.</p>
<p>Devam edelim, bu yeni sistemde <span class="math inline">\(\vec{x}_1,\vec{x}_2\)</span>'i hesaplarsak,</p>
<p><span class="math display">\[ \vec{x}_{1r} = R \vec{x}_1 = \left[\begin{array}{c}-r \\ 0\end{array}\right]\]</span></p>
<p><span class="math display">\[ \vec{x}_{2r} = R \vec{x}_2 = \left[\begin{array}{c}\frac{m_1}{m_2}r \\ 0\end{array}\right]\]</span></p>
<p>İstediğimiz sonucu elde ettiğimizi görüyoruz. Şimdi <span class="math inline">\(R\)</span>'yi bir <span class="math inline">\(\ddot{x}_{3r}\)</span> denklemi elde etmekte kullanabiliriz.</p>
<p><span class="math display">\[ \vec{x}_{3r} = R \vec{x}_3 \]</span></p>
<p><span class="math display">\[ \dot{\vec{x}}_{3r} = \dot{R} \vec{x}_3 + R \dot{\vec{x}}_3\]</span></p>
<p><span class="math display">\[ \ddot{x}_{3r} = \ddot{R}\vec{x}_3 + 2\dot{R}\dot{\vec{x}}_3 + R \ddot{\vec{x}}_3  \]</span></p>
<p><span class="math display">\[ = 
\left( \frac{4\pi^2}{\tau^2} - \frac{Gm_1}{r_{13}} - \frac{Gm_2}{r_{23}} \right)\vec{x}_{3r}+
4\pi \left[\begin{array}{rrr}0 &amp; 1 \\ -1 &amp; 0\end{array}\right] \dot{\vec{x}}_3+
\frac{Gm_1}{r_{13}} \vec{x}_{1r} +
\frac{Gm_2}{r_{23}}
\]</span></p>
<p><span class="math inline">\(r_{13}\)</span> büyüklüğü <span class="math inline">\(m_1,m_3\)</span> arasındaki mesafe, <span class="math inline">\(r_{23}\)</span> ise <span class="math inline">\(m_2,m_3\)</span> arasındaki. Bu denklemi kullanarak bir 1. derece diferansiyel denklem sistemi yaratabiliriz, <span class="math inline">\(x,y,u,v\)</span> değişkenlerini kullanarak, öyle ki <span class="math inline">\(x,y\)</span> <span class="math inline">\(\vec{x}_3\)</span>'un öğeleri olsun, <span class="math inline">\(u,v\)</span> ise bu öğelerin hızları olsun. Bu öğeleri <span class="math inline">\(\vec{x}_1\)</span> ve <span class="math inline">\(\vec{x}_2\)</span>'yi de temsil etmek için kullanınca alttaki sonucu elde ederiz,</p>
<p><span class="math display">\[ \dot{x} = u\]</span></p>
<p><span class="math display">\[ \dot{y} = v \]</span></p>
<p><span class="math display">\[ \dot{u} = 
\frac{4\pi^2}{\tau^2}x +  (-r-x)\frac{Gm_1}{r_{13^2}} +
\frac{m_1}{m_2}r-x) \frac{Gm_2}{r_{23}^2} +  \frac{4\pi}{\tau}v
\]</span></p>
<p><span class="math display">\[ \dot{v} =
\frac{4\pi^2}{\tau^2}y -y \frac{Gm_1}{r_{13}^3}-
y \frac{Gm_2}{r_{23}^3}-\frac{4\pi}{\tau}u
\]</span></p>
<p>ki <span class="math inline">\(r_{13} = \sqrt{(1-\mu+x)^2+y^2}\)</span> ve <span class="math inline">\(r_{23} = \sqrt{(-\mu+x)^2+y^2}\)</span>. Ayrıca <span class="math inline">\(r=1-\mu\)</span>.</p>
<p>Zaman, kütle ve uzaklık birimlerini değiştirirsek öyle ki <span class="math inline">\(G=1\)</span>, <span class="math inline">\(m_1+m_2=1\)</span>, ve <span class="math inline">\(r(1+\frac{m_1}{m_2})=1\)</span> olsun, <span class="math inline">\(m_1 = 1-m_1\)</span> olduğu için <span class="math inline">\(m_1\)</span>'e <span class="math inline">\(\mu\)</span> deriz,</p>
<p><span class="math display">\[ \dot{x} = u\]</span></p>
<p><span class="math display">\[ \dot{y} = v \]</span></p>
<p><span class="math display">\[ \dot{u} = x + (\mu - 1 - x ) \frac{\mu}{r_{13}^3} + 
   (\mu-x)\frac{1-\mu}{r_{23}^3} + 2v 
\]</span></p>
<p><span class="math display">\[ \dot{v} = y - y \frac{\mu}{r_{13}^3} - y \frac{1-\mu}{r_{23}^3}-2u\]</span></p>
<div class="figure">
<img src="chaos_app01_04.png" />

</div>
<p>Not: 3. cisim üçüncü boyutta gösteriliyor fakat altındaki düzlem üzerinde aslında.</p>
<p>Problem formülasyonunu [4]'e uyumlu şekilde tekrar tanımlarsak,</p>
<p><span class="math display">\[ 
y_1&#39;&#39; = y_1 + 2y_2&#39; - \mu_2 \frac{y_1+\mu_1}{D_1} - \mu_1 \frac{y_1-\mu_2}{D_2}
\]</span></p>
<p><span class="math display">\[ 
y_2&#39;&#39; = y_2 - 2y_1&#39; - \mu_2 \frac{y_2}{D_1} -\mu_1 \frac{y_2}{D_2}
\]</span></p>
<p><span class="math display">\[\mu_1 = \frac{m_1}{m_1+m_2}\]</span></p>
<p><span class="math display">\[\mu_2 = 1-\mu_1\]</span></p>
<p><span class="math display">\[ D_1 = ((y_1+\mu_1)^2 + y_2^2 )^{3/2}\]</span></p>
<p><span class="math display">\[ D_2 = ((y_1-\mu_2)^2 + y_2^2 )^{3/2}\]</span></p>
<p>Alttaki başlangıç değerleri bir periyodik yörünge ortaya çıkartıyor,</p>
<p><span class="math inline">\(y_1(0) = 0.994\)</span>, <span class="math inline">\(y_1&#39;(0)=0\)</span>, <span class="math inline">\(y_2&#39;(0) = -2.0015851063790825224053786222\)</span></p>
<p>Bu değerler nasıl bulunmuş? Periyodiklikten hareketle mesela <span class="math inline">\(x(t)\)</span>'in periyot sonunda <span class="math inline">\(x(T)\)</span>'de yine aynı değere gelmesi bir sınır değeri olarak kabul edilebilir, <span class="math inline">\(y_1(0),y_1&#39;(0)\)</span>'in bilindiğini farzedelim, <span class="math inline">\(y_2&#39;(0)\)</span> bilinmiyor. Böylece iki noktalı sınır değer (two-point boundary value problem) çözülebilir (Sekant yöntemi ile), ve başlangıç değerleri bulunur [4]. Bulununca son başlangıç değerleri ile ODE entegre edilir ve tüm gidişat bulunur. Okuyucuya ödev olabilir [8]'e bakılıp kodlama yapılabilir.</p>
<p>Alttaki kod [3]'u baz almıştır,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> scipy <span class="im">as</span> sp
<span class="im">from</span> scipy.integrate.odepack <span class="im">import</span> odeint

<span class="kw">def</span> rhs(u,t):
    y1,y2,y3,y4 <span class="op">=</span> u
    a<span class="op">=</span><span class="fl">0.012277471</span><span class="op">;</span> b<span class="op">=</span><span class="fl">1.0</span><span class="op">-</span>a<span class="op">;</span>    
    D1<span class="op">=</span>((y1<span class="op">+</span>a)<span class="op">**</span><span class="dv">2</span><span class="op">+</span>y2<span class="op">**</span><span class="dv">2</span>)<span class="op">**</span>(<span class="fl">3.0</span><span class="op">/</span><span class="dv">2</span>)<span class="op">;</span>
    D2<span class="op">=</span>((y1<span class="op">-</span>b)<span class="op">**</span><span class="dv">2</span><span class="op">+</span>y2<span class="op">**</span><span class="dv">2</span>)<span class="op">**</span>(<span class="fl">3.0</span><span class="op">/</span><span class="dv">2</span>)<span class="op">;</span>
    res <span class="op">=</span> [y3,<span class="op">\</span>
           y4,<span class="op">\</span>
           y1<span class="fl">+2.0</span><span class="op">*</span>y4<span class="op">-</span>b<span class="op">*</span>(y1<span class="op">+</span>a)<span class="op">/</span>D1<span class="op">-</span>a<span class="op">*</span>(y1<span class="op">-</span>b)<span class="op">/</span>D2, <span class="op">\</span>
           y2<span class="fl">-2.0</span><span class="op">*</span>y3<span class="op">-</span>b<span class="op">*</span>y2<span class="op">/</span>D1<span class="op">-</span>a<span class="op">*</span>y2<span class="op">/</span>D2
           ]

    <span class="cf">return</span> res

t<span class="op">=</span>np.linspace(<span class="fl">0.0</span>,<span class="fl">17.06521656015796</span>,<span class="fl">10000.0</span>)
res<span class="op">=</span>odeint(rhs,[<span class="fl">0.994</span>,<span class="fl">0.0</span>,<span class="fl">0.0</span>,<span class="op">-</span><span class="fl">2.00158510637908</span>],t)
y1r,y2r,y3r,y4r<span class="op">=</span>res[:, <span class="dv">0</span>],res[:, <span class="dv">1</span>],res[:, <span class="dv">2</span>],res[:, <span class="dv">3</span>]
plt.plot(y1r,y2r)
plt.plot(<span class="dv">0</span>,<span class="dv">0</span>,<span class="st">&#39;o&#39;</span>)
plt.plot(<span class="dv">1</span>,<span class="dv">0</span>,<span class="st">&#39;o&#39;</span>)
plt.text(<span class="fl">0.1</span>,<span class="fl">0.1</span>, <span class="st">u&#39;Dünya&#39;)</span>
<span class="st">plt.text(1.0,0.1, u&#39;</span>Ay<span class="st">&#39;)</span>
<span class="st">plt.savefig(&#39;</span>chaos_app01_02.png<span class="st">&#39;)</span></code></pre></div>
<div class="figure">
<img src="chaos_app01_02.png" />

</div>
<p>Üstteki yola onu keşfeden bilimciye atfen Arenstorf Yörüngesi adı veriliyor. Başlangıç şartlarına göre bu şekilde pek çok gidiş yolu mümkün. Arenstorf bir matematikçidir ve ABD Apollo programında uzun süre danışman olarak çalışmıştır. Arenstorf'un üstteki ve pek çok diğer mümkün yörüngeyi sayısal hesaplama yöntemleri ile bulduğu biliniyor.</p>
<p>Bir diğer mümkün gidiş yolu [7] altta,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">res<span class="op">=</span>odeint(rhs,[<span class="fl">1.2</span>,<span class="fl">0.0</span>,<span class="fl">0.0</span>,<span class="op">-</span><span class="fl">1.049357510</span>],t)
y1r,y2r,y3r,y4r<span class="op">=</span>res[:, <span class="dv">0</span>],res[:, <span class="dv">1</span>],res[:, <span class="dv">2</span>],res[:, <span class="dv">3</span>]
plt.plot(y1r,y2r)
plt.plot(<span class="dv">0</span>,<span class="dv">0</span>,<span class="st">&#39;o&#39;</span>)
plt.plot(<span class="dv">1</span>,<span class="dv">0</span>,<span class="st">&#39;o&#39;</span>)
plt.text(<span class="fl">0.1</span>,<span class="fl">0.1</span>, <span class="st">u&#39;Dünya&#39;)</span>
<span class="st">plt.text(1.0,0.1, u&#39;</span>Ay<span class="st">&#39;)</span>
<span class="st">plt.savefig(&#39;</span>chaos_app01_05.png<span class="st">&#39;)</span></code></pre></div>
<div class="figure">
<img src="chaos_app01_05.png" />

</div>
<p>Lagrange Noktaları</p>
<p>Eğer ODE sistemini oluşturan denklemlerde türevlerin sıfır olduğu noktaları bulursak bunlar bize sistemin sabit noktalarını verir, uzay yolculuğunda bu noktalara Lagrange noktaları deniyor. Bu noktalara gidip uzay aracını &quot;park etmek'' mümkün, ve bir noktadan diğerine giderek seyahat planlanabiliyor, ya da mesela ay yolculuğunun ilk kısmı bir Lagrange noktasına gitmek, hazırlanmak, ve ikinci aşama planını bu noktadan başlayarak yapmak mümkün olabiliyor.</p>
<p>Kaynaklar</p>
<p>[1] Stack Exchange, <em>Restricted Three-Body Problem</em>, <a href="http://math.stackexchange.com/questions/54735/restricted-three-body-problem" class="uri">http://math.stackexchange.com/questions/54735/restricted-three-body-problem</a></p>
<p>[2] Szebehely, <em>Theory of Orbits</em></p>
<p>[3] Gander, <em>Scientific Computing An Introduction using Maple and MATLAB</em></p>
<p>[4] Prado, <em>Orbital Maneuvers Between the Lagrangian Points and the Primaries in the Earth-Sun System</em></p>
<p>[5] Mitchell, <em>The Restricted 3-Body Problem: A Mission to L4</em>, <a href="https://math.ksu.edu/research/reu/results2011_files/rebeccaspaper.pdf" class="uri">https://math.ksu.edu/research/reu/results2011_files/rebeccaspaper.pdf</a></p>
<p>[6] Pilant, <em>Welcome to Math 614 Dynamical Systems and Chaos</em>, <a href="http://www.math.tamu.edu/~mpilant/math614/twobody.pdf" class="uri">http://www.math.tamu.edu/~mpilant/math614/twobody.pdf</a></p>
<p>[7] Soetaert, <em>Solving Differential Equations in R</em></p>
<p>[8] Bayramlı, Hesapsal Bilim <em>İki Nokta Sınır Değerli Problemler</em></p>
</body>
</html>
