<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Ders 10</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="ders-10">Ders 10</h1>
<p>Şimdiye kadar limit çevrimleri ve kapalı yörüngeleri elemeyi gördük,
Dulac’ın Kriteri’ni işledik, Poincare-Bendixon Teorisi’ni işledik. Bu
derste kapalı yörüngelere bakmaya devam edeceğiz, ama çok ünlü bir
sistemde, ki bu sistem alanımızın oluşmasında kritik bir rol oynadı, Van
der Pol Titreşiri. Sistem şöyle,</p>
<p><span class="math display">\[ \ddot{x} + \mu\dot{x} (x^2-1) + x = 0
\qquad (1)\]</span></p>
<p>Van der Pol, daha doğrusu Balthazar van der Pol Hollandalı bir
elektrik mühendisi idi, 1920, 30’lu yıllarda zannediyorum, ve ABD’de
Bell Labaratuarı’nda çalışıyordu. O zamanlar radyonun ilk günleri, ve
radyo ilk çıktığı zaman en ileri teknoloji sayılıyor, ve bu yeni buluş
içinde gelecekte karşımıza yarıiletken (semiconductor), transistör
olarak çıkacak fikirlerin başlangıcını görüyoruz [yarıiletkenlar
bilgisayar teknolojisinin temel taşıdır]. Belki aranızda müzikle
uğraşanlar varsa vakum tüplerini duymuştur, onları hala bugün bile
kullanan varmış diye duyuyorum, değil mi … [öğrencilerden biri gitar
amplikasyonu için kullananlar var hocam diyor]. Evet, işte gitar
amplifikasyonu için kullanıyorlar, çünkü ses daha organik, daha az
dijital gibi geliyor kulağa değil mi? Evet.</p>
<p>Ben küçükken hatırlıyorum, bizim televizyonumuzda bu tüp teknolojisi
vardı. TV ikide bir bozulurdu, artık olmuyor böyle şeyler tabii, ve
tamirci gelirdi ve adam yanında o koca tüplerden getirirdi. Televizyonun
arkasına bakınca tüpten gelen o ışığı görüyordunuz. Eski günlerde
teknoloji böyleydi. İşte Van der Pol [üstte gördüğümüz gibi] bu vakum
tüpleri için çok basit bir model ortaya koydu.</p>
<p>Modelin basit harmonik titreşire çok benzediğini görebiliyoruz. Eğer
ilk ve son terimi alsaydık o zaman aynı basit harmonik titreşir olurdu.
Fiziğe Giriş’te işlenen LC devreleri, ileten (inductor) ve kapasitörlü
(capacitor) içeren devreleri bilen varsa, o altyapı ile basit harmonik
titreşi elde ediyoruz. Ama Van der Pol sisteminde ortada çıkıntılık
yapan gayrı lineer bir terim var, vakum tüplerindeki gayrı lineerliği
modelleyen de bu. O ek terim bir sürü ek çetrefiliğe yol açıyor, bir
gayrı lineer sönüm (damping) ekliyor mesela. Çoğunlukla sönümü “bir
sabit çarpı <span class="math inline">\(\dot{x}\)</span>’’ şeklinde
görmeye alışığız, üstteki formülde bir de <span
class="math inline">\(x^2-1\)</span> ile çarpım var. Dikkat edersek
<span class="math inline">\(x^2-1\)</span>’in işareti <span
class="math inline">\(x\)</span>’in 1’den küçük ya da büyük olmasına
göre eksi ya da artı olabilir, o zaman <span
class="math inline">\(x\)</span> 1’den büyük olduğunda elimize
bildiğimiz çürüme, sönüm geçer, salınımlar yavaşça yokolur, genlikleri
(amplitude) azalır. Ama <span class="math inline">\(x\)</span> 1’den
küçük ise o zaman negatif sönüm elde edilir, bu pek tanıdık bir kavram
olmayabilir herkes için, negatif sönüm bir tür pompalamadır (pumping),
yani dışarıdan enerji eklemektir. O zaman zamana göre salınımları
düşünürsek, pozitif sönüm ile başladık diyelim, salınım azalır azalır,
sonra <span class="math inline">\(x\)</span> küçülünce sönüm tersine
döner ve pompalama başlar, salınımlar tekrar büyür. Beklentimiz bu
sistemin belli bir genlikte belli bir salınıma yaklaşması, ve hakikaten
bu oluyor, bu derste nasıl bir salınıma gidildiğinin hesabını
göreceğiz.</p>
<p>İspatlayabiliriz ki <span class="math inline">\(\mu &gt; 0\)</span>
için <span class="math inline">\(\exists !\)</span> stabil limit çevrimi
(<span class="math inline">\(\exists !\)</span> işareti özgün olarak
mevcut demek). Sadece kapalı yörünge değil, özellikle limit çevrimi var
ve limit çevrimi stabil. Bu mevcudiyet ispatlanabilir, ama çok saç
yoldurucu, ispat için gereken kapan bölgesini (trapping region)
oluşturmak oldukça zor, bir önceki dersteki örnekten daha zor. Bu konuya
girmeyeceğim, fakat kitabımda ispatların bulunacağı referanslar var. Biz
bu sistemi limitleri üzerinden inceleyeceğiz, ilki <span
class="math inline">\(\mu &gt;&gt; 1\)</span> limiti üzerinden, yani
<span class="math inline">\(\mu\)</span> çok, çok büyük olacak, bu da
çok çok büyük gayrı lineerlik demektir. Diğer limit <span
class="math inline">\(\mu\)</span> çok küçük iken, <span
class="math inline">\(\mu &lt;&lt; 1\)</span>, ve mesela sarsım teorisi
(perturbation theory), ya da başka bir yaklaşım ile neler olduğunu
anlamaya çalışacağız.</p>
<p>Kitabımın 7.5 bölümünde işlenen durum <span class="math inline">\(\mu
&gt;&gt; 1\)</span> için; bu kuvvetli gayrı lineerlik durumunda ortaya
çıkan şeye rahatlama titreşiri (relaxation oscillator) ismi veriliyor.
Çözümde oldukça zor bir değişken değişimi yapacağız, bu değişime Lienord
Transformasyonu adı veriliyor, transformasyonun güzel tarafı <span
class="math inline">\(\mu &gt;&gt; 1\)</span> iken, yani artarken limit
çevriminin sabit bir şekle doğru evrilmesini, yaklaşmasına sebep oluyor.
<span class="math inline">\(\mu\)</span> değişirken limit çevrimi
değişecekti, bunu biliyoruz; Lienord Transformasyon numarası ile
çevrimin belli bir sabit şekle doğru değişeceğini garantilemiş oluyoruz.
Bu analizlerimize kolaylık sağlıyor, ayrıca sistemde bir limit çevrimi
olduğunu da ispatlamış oluyor, çünkü evrileceği şekilden onu hemen
görebiliyoruz.</p>
<p><span class="math display">\[ \ddot{x} + \mu \dot{x}(x^2-1) =
\frac{d}{dt} \big( \dot{x} + \mu (\frac{1}{3} x^3 - x) \big)
\]</span></p>
<p>Üstteki eşitliğin sol tarafına baktık, ve onu daha basit nasıl
yazabiliriz diye düşündük, ve farkettik ki o ifade direk bir
diferansiyelin işleminin sonucu, bu işlemi eşitliğin sağ tarafına
koyduk. Bu eşitlik bize güzel bir değişken değişiminin mümkün olacağını
gösteriyor; büyük parantezdeki herşeye <span
class="math inline">\(W\)</span>, küçükteki herşeye <span
class="math inline">\(F(x)\)</span> diyebiliriz.</p>
<p>Not: Bu değişken değişimi daha önce yaptıklarımızdan biraz farklı,
daha önce ikinci dereceden, içinde <span
class="math inline">\(\ddot{x}\)</span> olan bir sistemde değişken <span
class="math inline">\(y = \dot{x}\)</span> yapıyorduk. Bu gösterdiğimiz
o türden bir transformasyon değil, daha karmaşık. Sadece <span
class="math inline">\(W=\dot{x}\)</span> demiyoruz, büyük parantezdeki
herşey <span class="math inline">\(W\)</span> diyoruz. Standart
transformasyonu yapsaydık o zaman analiz çok daha zor olurdu, <span
class="math inline">\(\mu\)</span> değişirken limit çevrimi habire
şeklini değiştirirdi (upuzun ince bir şerit haline geliyor). Bu bize
analizde yardım etmezdi.</p>
<p>Devam edelim, <span class="math inline">\(\dot{W} = -x\)</span> olur,
bunu (1)’i tekrar düzenleyerek hemen görebiliyoruz. Sistemin tamamı,</p>
<p><span class="math display">\[ \dot{x} = W - \mu F(x) \]</span></p>
<p><span class="math display">\[ \dot{W} = -x \]</span></p>
<p>Problemi faz düzleminde analiz edeceğiz. Daha önce gördük ki mesela
kapan bölgelere bakarken durağan eğrilere (nullclines) bakmak iyi.</p>
<p><span class="math inline">\(W = \mu F(x)\)</span> iken <span
class="math inline">\(\dot{x} = 0\)</span> olur.</p>
<p><img src="10_01.png" /></p>
<p>Eğri üzerinde <span class="math inline">\(\dot{x} = 0\)</span>, yani
orada vektör alanı tam dik. İlk başta oraya iki tane dik çizgi
çizmiştim, yön bilgisi için <span
class="math inline">\(\dot{W}\)</span>’ya bakmak lazım, <span
class="math inline">\(x\)</span> pozitif iken <span
class="math inline">\(\dot{W}\)</span> negatif, negatif iken pozitif.
Küpsel eğri üzerinde diğer bazı hesaplar üstteki resimde görülüyor. Sol
bölümdeki tepe noktasından bir sağa bir düz çizgi çektim ve eğriyi
kestiği noktaya <span class="math inline">\(A\)</span> dedim, o bölümde
dip noktasına ise <span class="math inline">\(B\)</span> dedim. Bu
noktalarla niye ilgilendiğimi birazdan anlatacağım.</p>
<p>Dikkat ederseniz <span class="math inline">\(x\)</span> kordinatları
1 ölçeğinde, <span class="math inline">\(W\)</span> kordinatlarının
içinde <span class="math inline">\(\mu\)</span> var. Hatırlayalım <span
class="math inline">\(\mu\)</span> aşırı büyük, milyarlar vs
seviyesinde. Bu grafikte kavramsal bir garipliğe yol açıyor, dikey
eksende değerler aşırı büyük, yatay eksende çok küçük. Tekrar ölçeklemek
iyi bir fikir olabilir, çoğunlukla bu bu dengesizlik tercih edilen bir
şey değil, <span class="math inline">\(\mu\)</span> sonsuzluğa giderken
resmin bundan etkilenmemesini istiyoruz. Ölçekleme için <span
class="math inline">\(y = \frac{W}{\mu}\)</span> dersek <span
class="math inline">\(\mu &gt;&gt; 1\)</span> iken <span
class="math inline">\(y \sim O(1)\)</span> olur, yani yeni ölçeklenmiş
değişken <span class="math inline">\(y\)</span> 1 derecesinde, ona
oranlı olur. Yeni sistem</p>
<p><span class="math display">\[ \dot{x} = \mu(y -  F(x)) \]</span></p>
<p><span class="math display">\[ \dot{y} = -\frac{1}{\mu} x
\]</span></p>
<p><span class="math inline">\(\mu\)</span>’nun çok büyük olduğunu
unutmayalım, o zaman <span class="math inline">\(\dot{x} \sim
O(\mu)\)</span> çok büyük, <span class="math inline">\(\dot{y} \sim
O(\frac{1}{\mu})\)</span> çok küçüktür (bir de <span
class="math inline">\(x&gt;0\)</span> iken <span
class="math inline">\(\dot{y} &lt; 0\)</span>). Bu demektir ki gidiş
yolları ışık hızında sadece sağa doğru gidiyorlar. Çünkü <span
class="math inline">\(\dot{x}\)</span> çok büyük, dikey yönde ufak bir
adım atılırken yatay yönde aşırı hızda bir adım atılıyor. Bu resmi
çizmek kolay. Üst sağda bir noktadan başladığımızı düşünelim, hemen küt
diye eğriye gidiş olacak, çünkü müthiş bir yatay hız var,</p>
<p><img src="10_03.png" /></p>
<p>Ama eğriye gelince orada aşağı bir dikey gidiş var, o biraz takip
edilecek, ama sonra yine eğriye dönülerek eğri boyunca aşağı inilecek.
“Ama eğriyi geçip sağa doğru devam edemez miyim?’’ diye düşünenler
olabilir, ama unutmayalım, sağ alt köşede de aşırı yüksek hızda sola
doğru bir”rüzgar’’ esiyor.</p>
<p>Sağ alttaki dip noktasına vardığımızda en dipte artık eğriye
yapışmamıza gerek yok, ve rüzgar hala sola esiyor, bu sefer küt diye
eğrinin sol alt köşesindeki parçasına doğru yatay geçiş yapıyoruz. Bu
arada eğri boyunca yukarı ya da aşağı gidiş kağnı hızında, çünkü o yönde
gidiş <span class="math inline">\(1/\mu\)</span>’ye oranlı.</p>
<p><img src="10_02.png" /></p>
<p>Peki tüm bu sisteme niye rahatlama titreşiri deniyor? Galiba bu
sistemi insanlar hayal ederken deprem gibi bir olayı düşündüler,
depremde iki yeraltı tabakası birbirine yavaş yavaş sürtünüp durur, ama
birdenbire bir şey kopar, ve çok hızlı zaman ölçeğindde bir deprem
ortaya çıkar. Bir sürü stres çok az zamanda ortaya çıkar. “Rahatlama’’
bu tür bir rahatlama.</p>
<p>Üstteki resme bakarsak orada bir limit çevrimi olduğunu görüyoruz.
Üst sağ çeyrekteki noktadan başlamıştık hatırlarsak ve hemen çevrime
geçmiştik. O geçiş bir kere olunca artık hep orada kalınır, dönüp
durulur.</p>
<p>Soru</p>
<p>Niye o noktadan başlayıp sağdaki eğriye geçince eğrinin sağından
aşağı inildi, solundan inilmedi?</p>
<p>Cevap</p>
<p><span class="math inline">\(\dot{x}\)</span>’in formülünden cevabı
bulabiliriz; <span class="math inline">\(\dot{x} = \mu
(y-F(x))\)</span>, o zaman sadece ve sadece <span
class="math inline">\(y &lt; F(x)\)</span> ise <span
class="math inline">\(\dot{x}\)</span> olabilir. Bu diyor ki eğrinin sağ
parçasında aşağı inerken sola gidiyorsunuz, sola gitmenin de tek yolu
eğer <span class="math inline">\(y\)</span> <span
class="math inline">\(F(x)\)</span>’in altında ise.</p>
<p>Eğer <span class="math inline">\(x,t\)</span> üzerinde dalga formunu
grafiklemek istersek,</p>
<p><img src="10_04.png" /></p>
<p>2’den yavaş zaman ölçeğinde aşağı iniliyor, 1’e gelinince pat diye
aşağı iniş, bu o kadar hızlı oluyor ki üstteki grafikte dikey gözüküyor,
sonra yine yavaşça yukarı çıkış ve hızlı çıkış, vs. Bu dalga formuna
testere dişi dalgası (sawtooth wave) deniyor.</p>
<p>Periyot hesabı nasıl yapardık? Bu dalga formu kendini hangi aralıkta
tekrar ediyor? Dikkat edersek zaman bağlamında baskın olanlar yavaş
gidişler, dikey iniş çıkışlar değil. Bunu dikkate alarak bir kestirme
hesap yapabiliriz. <span class="math inline">\(y\)</span> hızını
düşünürsek çoğunlukla <span class="math inline">\(1/\mu\)</span>’ya
oranlı. Ana grafiğe tekrar dönersek,</p>
<p><img src="10_05.png" /></p>
<p>alt sağ bölümdeki eğri parçasında mesela, 1’e oranlı bir mesafe
katedildi, hız <span class="math inline">\(1/\mu\)</span>’ya oranlı, yol
bölü zaman oranı çarpı zaman yoldur, yol için tersi yönde gideriz ve
<span class="math inline">\(\mu\)</span> buluruz.</p>
<p><img src="10_06.png" /></p>
<p>Zıplamalar <span class="math inline">\(O(1/\mu)\)</span> sürüyor, çok
ufak. O zaman periyotun <span class="math inline">\(\mu\)</span>’ya
oranlı yani çok büyük bir sayı olduğunu görebiliyoruz. <span
class="math inline">\(T = O(\mu)\)</span>.</p>
<p>Bu periyot hesabı yaklaşıksal bir hesap tabii; onu düzeltmek, daha
kesinleşirmek için <span class="math inline">\(\mu\)</span>’yi çarpan
katsayıyı hesaplayabiliriz, bunun bir yolu var. Düzeltme tabii ki
zıplamalardan gelmiyor, başka bir zaman ölçeği var, bu zaman ölçeğinde
ana grafikte dipte ve üstteki köşeleri dönerken bir yavaşlama oluyor,
özellikle alt sağ çeyrekteki dönüş. Kitabımda oldukça şaşalı bir sonuşur
hesabına referans veriyorum, dönüş zamanı Airy Fonksiyonu denen bir
yöntemle hesaplanıyor, ki sonuşurluk hakkında bir ders alsanız bunu
nasıl yapacağınızı öğrenirdiniz. Üniversitemizde böyle bir ders
veriyorduk ama uzun bir süredir bu dersi vermiyoruz, ben arada sırada bu
tekniği öğretiyorum ama.</p>
<p>Neyse; baskın terimi hesaplamaya uğraşalım. Periyot yaklaşık olarak
<span class="math inline">\(A\)</span>’dan <span
class="math inline">\(B\)</span>’ye gitmek için geçen zamanın iki katı.
Bu gidiş sırasında aşağı yukarı durağan eğri üzerindeyiz, biraz, <span
class="math inline">\(O(1/\mu)\)</span> kadar sapmışız belki, ama
durağan eğrideyiz. Yani <span class="math inline">\(W \approx \mu
F(x)\)</span> bilgisini kullanabiliriz. Nasıl?</p>
<p><span class="math display">\[ T = 2 \int_{t_A}^{t_B} \mathrm{d} t
\]</span></p>
<p>Bunu biraz daha akıllıca bir şekilde yazabiliriz. <span
class="math inline">\(t\)</span>’ye erişimimiz yok, ama <span
class="math inline">\(x\)</span>’i biliyoruz. <span
class="math inline">\(x\)</span> ilgilendiğimiz zaman aralığında 2’den
1’e gidiyor. O zaman üstteki entegrali <span
class="math inline">\(x\)</span> bazlı yaparsak,</p>
<p><span class="math display">\[ = 2\int_{2}^{1} \frac{\mathrm{d}
t}{\mathrm{d} W} \frac{\mathrm{d} W}{\mathrm{d} x} \mathrm{d} x
\]</span></p>
<p>Leibniz’in notasyonunun sihri sayesinde üstteki kısmi türevler iptal
olurdu, geriye <span class="math inline">\(\mathrm{d} t\)</span>
kalırdı, yani iki üstteki entegrale erişirdik. Asıl amacımız bildiğimiz
değerler üzerinden hesap tabii, ve üstteki kısmi türevleri
biliyoruz.</p>
<p>İlk terim <span class="math inline">\(1 / \dot{W}\)</span> ile aynı,
ve</p>
<p><span class="math display">\[ \dot{W} = -x \]</span></p>
<p>olduğuna göre,</p>
<p><span class="math display">\[ \frac{1}{\dot{W}} =
-\frac{1}{x}\]</span></p>
<p>olur. Diğer terim</p>
<p><span class="math display">\[ \frac{\mathrm{d} W}{\mathrm{d} x}
\approx
\frac{\mathrm{d}}{\mathrm{d} x} \bigg( \mu F(x) \bigg)
= \mu F&#39;(x)
\]</span></p>
<p><span class="math display">\[ = \mu \frac{\mathrm{d}}{\mathrm{d} x}
\big( \frac{x^3}{3} - x \big) \]</span></p>
<p><span class="math display">\[ = \mu (x^2 -1) \]</span></p>
<p>Tüm bunları birleştirirsek,</p>
<p><span class="math display">\[ T \approx 2 \int_{2}^{1} -\frac{1}{x}
\mu (x^2-1) \mathrm{d} x  \]</span></p>
<p>Entegrali hesaplarız, ayrıca hesap sırasını 2,1 yerine 1,2 yaparsak
eksi ile çarpmış oluruz,</p>
<p><span class="math display">\[ = 2\mu (\frac{1}{2}x^2 - \ln x)
\Big|_{1}^{2} \]</span></p>
<p><span class="math display">\[ = 2\mu (\frac{3}{2} - \ln 2 ) = O(\mu)
\]</span></p>
<p>Soru</p>
<p>Niye <span class="math inline">\(W \approx \mu F(x)\)</span> ?</p>
<p>Cevap</p>
<p>Çünkü <span class="math inline">\(A\)</span> ve <span
class="math inline">\(B\)</span> arasında görülen eğri üzerindeyim, ve
<span class="math inline">\(W\)</span> kordinatı baz alınırsa bu eğri
<span class="math inline">\(W = \mu F(x)\)</span>.</p>
<p>Soru</p>
<p>Bu <span class="math inline">\(\dot{x}\)</span> yaklaşıksal olarak
sıfır mı demektir?</p>
<p>Cevap</p>
<p>[Hoca biraz düşündü] Hmm.. evet, öyle denebilir, ama bunu söylemek
biraz derme çatma olur. Aşağı inerken <span
class="math inline">\(x\)</span> bazında çok az yer değişimi olduğu
doğru, ama sizin dediğiniz gibi söylemek pek uygun değil.</p>
<p>Devam edelim; <span class="math inline">\(\mu &lt;&lt; 1\)</span>
icin,</p>
<p>Van der Pol - Zayıf Gayri Lineer Durum</p>
<p>Analizin bu kısmı derslerimizin geri kalanından biraz farklı.
Birazdan kullanacağımız matematik, modelleme bağlamında daha
alışılagelir türden olacak, formüller olacak, bir sürü formüller, o
formülleri manipüle edeceğiz, vs. Pek geometrik değil yani. Kimileri
bundan daha çok hoşlanıyor olabilir.</p>
<p>Bir <span class="math inline">\(\epsilon\)</span> tanımlayalım, bu
çoğunlukla yapılır, <span class="math inline">\(0 \le \epsilon \le
1\)</span>. Şimdi,</p>
<p><span class="math display">\[ \ddot{x} + x + \epsilon \dot{x}(x^2 -
1) = 0 \]</span></p>
<p><span class="math inline">\(\ddot{x}\)</span>’un önünde frekans
terimi yok. Niye? Çünkü zaman birimini belli bir şekilde olmaya
zorluyoruz ki doğal frekansları 1 olsun. Genellikte kayıp olmadan bunu
yapmak mümkün.</p>
<p>Bu formülden ne beklemeliyiz? Kabaca bu sorunun cevabını başta vermek
iyi olur. <span class="math inline">\(\epsilon = 0\)</span> olunca
elimize basit harmonik titreşir geçer. Bu durumda tüm yörüngelerin
dairesel olacağını biliyoruz [eliptik değil], çünkü herşeyin ölçeği buna
göre ayarlı, periyot <span class="math inline">\(2\pi\)</span>. Ve
istenirse zaman başlangıcı güzel bir şekilde seçilince, alttaki formül
mümkün olur,</p>
<p><span class="math display">\[ x(t) = A \cos t \]</span></p>
<p>ki <span class="math inline">\(A\)</span> bir sabit. Kosinüs
salınımlarının genliği sabittir.</p>
<p>Peki eğer gayrı lineer sönüm <span
class="math inline">\(\epsilon\)</span>’u değiştirirsek ne olur? Bu
durumda tüm vektör alanında <span
class="math inline">\(\epsilon\)</span> kadar bir değişim yaratmış
olurduk. Vektörleri temsil eden okları düşünürsek, belli bir yönü
gösteriyorlar, <span class="math inline">\(\epsilon\)</span> değişimi
sonrası bu oklarda ufak bir sarsım yaratmış olduk, 1’in milyarda biri
kadar bir büyüklükte <span class="math inline">\(x\)</span>’leri ve
<span class="math inline">\(y\)</span>’leri değişti. Yani ufak <span
class="math inline">\(\epsilon\)</span> için vektör alanı üzerinde öyle
fazla bir değişim yaratmadık, ve tüm yörüngelerin çembersel olmasını
bekleriz, hala periyot <span class="math inline">\(2\pi\)</span>. Peki
limit çevrimini nasıl buluruz?</p>
<ol type="1">
<li>Metot (Kaba)</li>
</ol>
<p>Eğer fizikçi ya da mühendis gibi düşünürsek basit harmonik titreşirde
enerjinin muhafaza edildiğini görüyoruz, o zaman bir tur attığımızda
enerji değişmemiş olacaktır, büyüklük <span class="math inline">\(\Delta
E\)</span>’ye bakarız. İçinde <span
class="math inline">\(\epsilon\)</span> olan sistemde tabii ki
unutmayalım bazen sistem pompalanıyor, bazen sönüme tabi oluyor. Ve
düşünürdünüz ki limit çevriminde, ki kendini tekrar eden bir sistem bu,
pompalanan enerji kaybedilen enerjiye eşit olmalı. Limit çevrimliliğin
şartı bu. Genliği baz alan bu mantık zinciri ile çevrimin kendisi
hakkında bir hesap yapabileceğiz. Çevrimin üzerinde <span
class="math inline">\(\Delta E = 0\)</span>, diğer gidiş yollarında
çevrimin dışında ya da içinde olup olmamalarına göre ya <span
class="math inline">\(\Delta E &gt; 0\)</span>, ya da <span
class="math inline">\(\Delta E&lt;0\)</span>.</p>
<p>Bu sezgiden hareketle, sönümsüz titreşirin enerjisi nedir? Temel
fizikten, ve üstteki ölçekten hareketle enerji kinetik artı potansiyel
enerji,</p>
<p><span class="math display">\[ E = \frac{1}{2}x^2 +
\frac{1}{2}\dot{x}^2 \]</span></p>
<p>Zamana oranlı değişim</p>
<p><span class="math display">\[ \frac{\mathrm{d} E}{\mathrm{d} t} =
x\dot{x} + \dot{x}\ddot{x} \]</span></p>
<p><span class="math display">\[ = \dot{x}(x + \ddot{x}) \]</span></p>
<p>Van der Pol sistemine referans yaparak,</p>
<p><span class="math display">\[ = \dot{x} (-\epsilon \dot{x} (x^2-1))
\]</span></p>
<p>Şimdi diyelim ki <span class="math inline">\(x = A\cos t\)</span>.
Daha önce de böyle bir tanım yapmıştım ama önceki gerçekti, şimdi
yaklaşıksallama için kullanıyorum. Yani vektör alanına <span
class="math inline">\(\epsilon\)</span> kadar bir değişik getiriyorum,
ve sonucun hala <span class="math inline">\(x = A\cos t\)</span> gibi
olmasını bekliyorum, daha doğrusu <span class="math inline">\(x = A\cos
t + O(\epsilon)\)</span> gibi olmasını. <span
class="math inline">\(O(\epsilon)\)</span>’in büyüklüğünü sonradan
Sarsım Teorisi ile hesaplayabiliriz. <span
class="math inline">\(A\)</span> sonradan hesaplanacak bir sabit, onu
hesaplayacağız. Yani tek ilgilendiğimiz çevrim, hangi <span
class="math inline">\(A\)</span> ile çember üzerindeki enerji değişimi
sıfır olur. Çevrim üzerinde bir turda enerji değişimi,</p>
<p><span class="math display">\[
\Delta E - \int_{0}^{T} \frac{\mathrm{d} E}{\mathrm{d} t} \mathrm{d} t =
-\epsilon \int_{0}^{2T +O(\epsilon)} A^2 \sin^2 t(A^2\cos^2 t - 1)
\mathrm{d} t + O(\epsilon^2)
\]</span></p>
<p>çünkü <span class="math inline">\(\dot{x} = -A\sin t +
O(\epsilon)\)</span>.</p>
<p>Niye <span class="math inline">\(O(\epsilon^2)\)</span>? Çünkü dönüm
sırasında bazı hatalar yapılıyor, üstteki entegrale bakarsak <span
class="math inline">\(-\epsilon\)</span> ile bir çarpım var, ayrıca üst
sınır <span class="math inline">\(+O(\epsilon)\)</span> içeriyor, bu
ikisinin çarpımı karesellik getirir, ayrıca entegral içinde de karesel
ifadeler var. Yani bir dönüşte yapılabilecek en fazla hata <span
class="math inline">\(O(\epsilon^2)\)</span>, bu sebeple <span
class="math inline">\(+O(\epsilon^2)\)</span> kadar bir düzeltme
ekliyoruz. Tabii bu karesel hatayı entegrale terim olarak ekleyince üst
sınırda belirtmeye gerek yok [hoca üst sınırı siliyor],</p>
<p><span class="math display">\[ = -\epsilon \int_{0}^{2T} A^2 \sin^2
t(A^2\cos^2 t - 1) \mathrm{d} t + O(\epsilon^2) \]</span></p>
<p>Cebirsel işlemleri atlıyorum, <span class="math inline">\(\sin^2,
\cos^2\)</span>’in entegrali nasıl alınıyor bunu bilmek lazım, ama
sonuç</p>
<p><span class="math display">\[ \Delta E = -\epsilon
\bigg[
A^2 \underbrace{&lt;\sin^2 t \cos^2&gt;}_{1/8} 2\pi - A^2
\underbrace{&lt;\sin^2 t&gt;}_{1/2} 2\pi
\bigg]
\]</span></p>
<p><span class="math inline">\(&lt;&gt;\)</span> operatör “averaj
almak’’ demek, elektrik mühendislerine üstteki ifadeler tanıdık
gelebilir, bunlar”DC terimleri’’, bir turda o terimlerin ortalamasının
ne olduğu bilinir. Devam edelim, nihai sonuç,</p>
<p><span class="math display">\[ = -2\pi \epsilon A^2
(\frac{A^2}{8}-\frac{1}{2}) + O(\epsilon^2) \]</span></p>
<p>Sorumuz neydi? Üstteki ifade ne zaman sıfır olur, hangi <span
class="math inline">\(A\)</span> ile çevrim etrafında bir kez dönünce
enerjide hiç net değişim olmaz? Üstteki ifadedeki parantez içini sıfır
yapan durum neyse o;</p>
<p><span class="math display">\[ \frac{A^2}{8}-\frac{1}{2} = 0
\Rightarrow \frac{A^2}{8} = \frac{1}{2}
\Rightarrow A^2 = 4 \Rightarrow A = 2
\]</span></p>
<p>2 sonucunu bulduk; bu ünlü bir sayı, ufak <span
class="math inline">\(\epsilon\)</span> için Van der Pol titreşirlerinin
limit çevriminin genliği 2’dir, yani</p>
<p><span class="math display">\[ x(t) = 2 \cos t + O(\epsilon)
\]</span></p>
<p>Bu demektir ufak <span class="math inline">\(\epsilon\)</span> için
ki Van der Pol dalga formunu grafiklesek bir kosinüs dalgasına benzer,
ama genliği her zaman 2’dir.</p>
<p>Bir sonraki derste üstteki ifadenin stabil olduğunu bulmayı, ve biraz
önce işlediğimiz kaba yöntemden daha iyi bir yöntemi göstereceğim, bu
metota Averajlama Teorisi deniyor. Daha önce görmediyseniz hoşunuza
gidecek zannediyorum.</p>
<p>Örnek 7.1.2 [Kitap]</p>
<p>Van der Pol titresirini sayısal olarak çözelim,</p>
<p><span class="math display">\[ \ddot{x} + \mu\dot{x} (x^2-1) + x = 0
\qquad (1)\]</span></p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> integrate</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.integrate <span class="im">import</span> ode, odeint</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>fig0 <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">10</span>))</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>ax0 <span class="op">=</span> plt.subplot2grid((<span class="dv">2</span>,<span class="dv">2</span>), (<span class="dv">0</span>,<span class="dv">0</span>))</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>ax1 <span class="op">=</span> plt.subplot2grid((<span class="dv">2</span>,<span class="dv">2</span>), (<span class="dv">1</span>,<span class="dv">1</span>))</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>ax2 <span class="op">=</span> plt.subplot2grid((<span class="dv">2</span>,<span class="dv">2</span>), (<span class="dv">1</span>,<span class="dv">0</span>))<span class="co">#, colspan=2)</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>ax3 <span class="op">=</span> plt.subplot2grid((<span class="dv">2</span>,<span class="dv">2</span>), (<span class="dv">0</span>,<span class="dv">1</span>))</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>xx0 <span class="op">=</span> np.array([<span class="op">-</span><span class="fl">0.5</span>, <span class="dv">0</span>])</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>s<span class="op">=</span><span class="fl">1.5</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> odef(xx, t, s<span class="op">=</span>s):</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array([xx[<span class="dv">1</span>], <span class="op">-</span>s<span class="op">*</span>(xx[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span><span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>xx[<span class="dv">1</span>]<span class="op">-</span>xx[<span class="dv">0</span>]])</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">30</span>, <span class="dv">500</span>)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>ys <span class="op">=</span> odeint(odef, xx0, t, args<span class="op">=</span>(s,))</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>ax0.axis(<span class="st">&#39;equal&#39;</span>)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>ax0.set_title(<span class="st">&#39;$\ddot</span><span class="sc">{x}</span><span class="st"> = \mu \dot</span><span class="sc">{x}</span><span class="st">(x^2 - 1) - x$ Entegrali&#39;</span>, size<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>ax0.plot(ys[:,<span class="dv">0</span>],ys[:,<span class="dv">1</span>],<span class="st">&#39;b,&#39;</span>,label<span class="op">=</span><span class="st">&#39;$x_0 = (</span><span class="sc">{0}</span><span class="st">,</span><span class="sc">{1}</span><span class="st">)$ with $\mu = </span><span class="sc">{2}</span><span class="st">$&#39;</span>.<span class="bu">format</span>(xx0[<span class="dv">0</span>],xx0[<span class="dv">1</span>],s))</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>ax0.set_xlabel(<span class="st">&#39;$x$&#39;</span>, size<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>ax0.set_ylabel(<span class="vs">r&#39;$\dot</span><span class="sc">{x}</span><span class="vs">$&#39;</span>,size<span class="op">=</span><span class="dv">14</span> )</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>ax0.set_facecolor(plt.cm.gray(<span class="fl">.95</span>))</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>ax0.grid(<span class="va">True</span>)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>ax0.legend()</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>x1,y1 <span class="op">=</span> np.linspace(<span class="op">-</span><span class="fl">3.5</span>,<span class="fl">3.5</span>,<span class="dv">200</span>),np.linspace(<span class="op">-</span><span class="fl">3.5</span>,<span class="fl">3.5</span>,<span class="dv">200</span>)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>X,Y <span class="op">=</span> np.meshgrid(x1,y1 )</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> Y <span class="op">-</span> s<span class="op">*</span>(X<span class="op">**</span><span class="dv">3</span><span class="op">/</span><span class="dv">3</span><span class="op">-</span>X)</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> <span class="op">-</span>X</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> [[<span class="op">-</span><span class="fl">.5</span>,<span class="dv">0</span>]]</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>ax3.set_title(<span class="st">&#39;$\mu$ = </span><span class="sc">{0}</span><span class="st"> with $x_0$ = (</span><span class="sc">{1}</span><span class="st">, </span><span class="sc">{2}</span><span class="st">)&#39;</span>.<span class="bu">format</span>(s,start[<span class="dv">0</span>][<span class="dv">0</span>],start[<span class="dv">0</span>][<span class="dv">1</span>]), size<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>ax3.set_ylabel(<span class="vs">r&#39;$y = \frac</span><span class="sc">{w}</span><span class="vs">{\mu}$&#39;</span>,size<span class="op">=</span><span class="dv">14</span> )</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>ax3.set_facecolor(plt.cm.gray(<span class="fl">.95</span>))</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>strm <span class="op">=</span> ax3.streamplot( X,Y,U, V, linewidth<span class="op">=</span><span class="fl">.3</span>)</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>strmS <span class="op">=</span> ax3.streamplot(x1,y1, U, V, start_points<span class="op">=</span>start, color<span class="op">=</span><span class="st">&quot;crimson&quot;</span>, linewidth<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>F_x <span class="op">=</span> s<span class="op">*</span>(x1<span class="op">**</span><span class="dv">3</span><span class="op">/</span><span class="dv">3</span> <span class="op">-</span>x1) <span class="co">#p.215</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>U3 <span class="op">=</span> Y <span class="op">-</span> s<span class="op">*</span>(X<span class="op">**</span><span class="dv">3</span><span class="op">/</span><span class="dv">3</span> <span class="op">-</span> X)</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>V3 <span class="op">=</span> <span class="op">-</span>X</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="vs">r&#39;$y = \frac{x^3}</span><span class="sc">{3}</span><span class="vs"> - x$ Duragan Egrileri (Nullclines)&#39;</span>, size<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>ax1.plot(x1, F_x, <span class="st">&#39;r&#39;</span>, lw<span class="op">=</span><span class="fl">.5</span>,label<span class="op">=</span><span class="st">&#39;Nullcline&#39;</span>)</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>ax1.annotate(<span class="vs">r&#39;($-1, \frac</span><span class="sc">{2}{3}</span><span class="vs"> \mu$)&#39;</span>,</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>            xy<span class="op">=</span>(<span class="op">-</span><span class="dv">1</span>,<span class="dv">2</span><span class="op">/</span><span class="dv">3</span><span class="op">*</span>s),</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>            xytext<span class="op">=</span>(<span class="op">-</span><span class="fl">1.5</span>, <span class="dv">1</span><span class="op">*</span>s),</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>            arrowprops<span class="op">=</span><span class="bu">dict</span>(facecolor<span class="op">=</span><span class="st">&#39;black&#39;</span>, width <span class="op">=</span> <span class="fl">.2</span>,headwidth<span class="op">=</span> <span class="dv">2</span>, headlength<span class="op">=</span><span class="dv">3</span>,shrink<span class="op">=</span><span class="fl">0.05</span>))</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>ax1.annotate(<span class="vs">r&#39;($1, \frac{-2}</span><span class="sc">{3}</span><span class="vs"> \mu$)&#39;</span>,</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>            xy<span class="op">=</span>(<span class="dv">1</span>,<span class="op">-</span><span class="dv">2</span><span class="op">/</span><span class="dv">3</span><span class="op">*</span>s),</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>            xytext<span class="op">=</span>(<span class="fl">.5</span>,<span class="op">-</span><span class="dv">1</span><span class="op">*</span>s),</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>            arrowprops<span class="op">=</span><span class="bu">dict</span>(facecolor<span class="op">=</span><span class="st">&#39;black&#39;</span>, width <span class="op">=</span> <span class="fl">.2</span>,headwidth<span class="op">=</span> <span class="dv">2</span>, headlength<span class="op">=</span><span class="dv">3</span>,shrink<span class="op">=</span><span class="fl">0.05</span>))</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>strm <span class="op">=</span> ax1.quiver( X[::<span class="dv">5</span>,::<span class="dv">5</span>],Y[::<span class="dv">5</span>,::<span class="dv">5</span>],U3[::<span class="dv">5</span>,::<span class="dv">5</span>], V3[::<span class="dv">5</span>,::<span class="dv">5</span>],color<span class="op">=</span><span class="st">&#39;g&#39;</span>,alpha<span class="op">=</span><span class="fl">.5</span>,scale_units<span class="op">=</span><span class="st">&#39;inches&#39;</span>,scale<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>ax1.set_xlabel(<span class="st">&#39;$x$&#39;</span>, size<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>ax1.set_ylabel(<span class="vs">r&#39;$y(x)$&#39;</span>,size<span class="op">=</span><span class="dv">14</span> )</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>ax1.set_facecolor(plt.cm.gray(<span class="fl">.95</span>))</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>ax1.set_xlim(<span class="op">-</span><span class="fl">2.2</span>,<span class="fl">2.2</span>)</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>ax1.set_ylim(<span class="op">-</span><span class="fl">2.2</span>,<span class="fl">2.2</span>)</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>ax1.legend()</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>ax1.grid(<span class="va">True</span>)</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>ax2.plot(t,ys[:,<span class="dv">0</span>], <span class="st">&#39;g,&#39;</span>,lw<span class="op">=</span><span class="fl">.3</span>, label<span class="op">=</span><span class="st">&#39;$x$ (distance) over time&#39;</span>)</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>ax2.plot(t,ys[:,<span class="dv">1</span>], <span class="st">&#39;b,&#39;</span>,lw<span class="op">=</span><span class="fl">.3</span>, label<span class="op">=</span><span class="st">&#39;$\dot</span><span class="sc">{x}</span><span class="st">$ (velocity) over time&#39;</span>)</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>ax2.set_xlabel(<span class="st">&#39;$t$&#39;</span>, size<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>ax2.set_ylabel(<span class="vs">r&#39;$f(t)$&#39;</span>,size<span class="op">=</span><span class="dv">14</span> )</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>ax2.legend()</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>ax2.grid(<span class="va">True</span>)</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>ax2.set_facecolor(plt.cm.gray(<span class="fl">.95</span>))</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;10_07.png&#39;</span>)</span></code></pre></div>
<p><img src="10_07.png" /></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
