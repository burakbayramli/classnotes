<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>

  <title>Steve Keen Özel Sektör Modeli, İkinci Form</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  
  
  
  
</head>
<body>
<h1 id="steve-keen-özel-sektör-modeli-ikinci-form">Steve Keen Özel Sektör Modeli, İkinci Form</h1>
<p>Bu yazıda bir önceki yazıda baktığımız borç temell modeli sıfırdan türetmeye uğraşacağız. Sonuç olarak gayrı-lineer sonuçlar verebilecek bir ODE sistemi elde edeceğiz, bu sistemin, bu ders notlarında pek çok kez gördüğümüz gibi sabit noktaları olacaktır, bu noktalardan ekonomik olarak anlamı olan bir tanesine bakacağız. Ardından sayısal olarak sistemi çözüp iki farklı başlangıç noktasına göre gidişatın neye benzediğini göreceğiz.</p>
<p>Yan tanımlar, bazıları yeni, bazıları önceki yazıdan tekrar,</p>
<p><span class="math inline">\(\alpha\)</span>: üretkenliğin büyüme oranı, <span class="math inline">\(\frac{\mathrm{d} a}{\mathrm{d} t} = \alpha a\)</span></p>
<p><span class="math inline">\(\beta\)</span>: nüfusun büyüme oranı, <span class="math inline">\(\frac{\mathrm{d} N}{\mathrm{d} t} = \beta N\)</span></p>
<p><span class="math inline">\(w\)</span>: İşçi kazanç oranı (kişi başına gelir), tüm maaşlar <span class="math inline">\(W = w \cdot L\)</span>. Değişken <span class="math inline">\(w\)</span>'ye birim emek için elde edilen gelir ismi de verilebilir.</p>
<p><span class="math inline">\(L = Y/a\)</span>: Ne kadar üretim olduğunu üretkenliğe bölersek istihdam elde ederiz. Ya da tersten bakarsak istihdam seviyesi üretkenlik üzerinden üretimi belirler.</p>
<p>Sermaye <span class="math inline">\(K\)</span> bir hızlandırıcı / sabit <span class="math inline">\(v\)</span> üzerinden üretime <span class="math inline">\(Y\)</span>'ye <span class="math inline">\(K = v \cdot Y\)</span> ile bağlı.</p>
<p><span class="math inline">\(\dot{w} = \Phi(\lambda) \cdot w\)</span>: İşçi kazanç oranındaki değişim istihdam oranının gayrı-lineer bir fonksiyonu, çoğunlukla burada Philips eğrisi kullanılır, mesela <span class="math inline">\(\Phi(\lambda) = \frac{\phi_1}{(1-\lambda)^2}-\phi_0\)</span></p>
<p><span class="math inline">\(\omega\)</span> ekonomideki işçi ücretleri oranı, <span class="math inline">\(\omega=\frac{w\cdot L}{a \cdot L} = \frac{w}{a}\)</span></p>
<p>Kâr <span class="math inline">\(\Pi = (1-\omega-rd)Y\)</span>, yani üretimden işçi ücretlerini ve borç geri ödemesini (faiz) çıkartırsak, kalan net kâr.</p>
<p><span class="math inline">\(\dot{K} = I - \delta K =\kappa(1 - \omega - rd) Y - \delta K\)</span>: Yatırım şirketin kârı <span class="math inline">\(1 - \omega - rd\)</span>'nin bir gayrı lineer fonksiyonu (çarpı mevcut üretim), daha fazla kârın daha fazla yatırım isteğine sebep olacağını burada modelliyoruz. Sermaye seviyesi degisimine amortisman <span class="math inline">\(\delta K\)</span> da uyguluyoruz. <span class="math inline">\(\kappa(x)\)</span> meselâ <span class="math inline">\(\kappa(x) = \kappa_0 + \kappa_1 \exp(\kappa_2 x)\)</span>.</p>
<p><span class="math inline">\(\frac{\mathrm{d} D}{\mathrm{d} t} = \dot{D} = I - \Pi\)</span>: İstenen yatırım seviyesi ve eldeki kâr arasındaki fark borç miktarı <span class="math inline">\(D\)</span>'de artışa sebep olur.</p>
<p>Şimdi alttaki ana tanımları yapalım [1]. Bu tanımlar modelin temelini oluşturacak ve eğer doğru tanımlarsa bizi doğru tahminlere taşıyacaklar.</p>
<ol style="list-style-type: decimal">
<li><p>Üretimdeki işçi ücret payı, tüm işçi ücret ödemeleri <span class="math inline">\(W\)</span> bölü gayrı-safi yurtiçi hasıla (GSYH) <span class="math inline">\(Y\)</span>'ye eşittir. <span class="math inline">\(\omega = W/Y\)</span>.</p></li>
<li><p>Özel (kişi, şirket) borcun GSMH'ye oranı, borç <span class="math inline">\(D\)</span> bölü GSYH <span class="math inline">\(Y\)</span>. <span class="math inline">\(d=D/Y\)</span>.</p></li>
<li><p>İstihdam oranı iş sahibi olan kişi sayısı <span class="math inline">\(L\)</span> bölü tüm nüfus <span class="math inline">\(N\)</span>'ye eşittir. <span class="math inline">\(\lambda = L/N\)</span>.</p></li>
</ol>
<p>Şimdi üstteki üç tanımın zamana göre türevini alalım. Bu tanımlar doğru olduğuna göre (biz tanımladık) onların dinamik hali de doğru olmalıdır. Log türev alma tekniğini kullanacağız yine,</p>
<ol style="list-style-type: decimal">
<li>Eğer ücret artışları işçi verimlilik artışından büyük ise üretimdeki işçi ücret payı büyür. Yani</li>
</ol>
<p><span class="math display">\[ \frac{\dot{\omega}}{\omega} = \frac{\dot{W}}{W} - \frac{\dot{Y}}{Y} \]</span></p>
<ol start="2" style="list-style-type: decimal">
<li>Eğer borç oranı ekonomik büyüme oranından daha hızlı büyüyorsa özel borcun GSYH'ye oranı artar. Yani,</li>
</ol>
<p><span class="math display">\[ \frac{\dot{d}}{d} = \frac{\dot{D}}{D} - \frac{\dot{Y}}{Y} \]</span></p>
<ol start="3" style="list-style-type: decimal">
<li>Eğer gerçek (enflasyon düzeltilmesi yapılmış) ekonomik büyüme (yüzde), nüfus artış oranı + işçi verimlilik artış oranını geçiyorsa, istihdam oranı (yüzdesi) artar (alttaki başlangıç, türetimin gittiği nokta tanımla uyuyor, altta görülecek).</li>
</ol>
<p><span class="math display">\[ \frac{\dot{\lambda}}{\lambda} =  \frac{\dot{L}}{L} - \frac{\dot{N}}{N} \]</span></p>
<p>Şimdi bu türevleri kullanarak bir ODE sistemine ulaşmaya uğraşalım [2].</p>
<ol style="list-style-type: decimal">
<li>tanımı alalım ve açalım,</li>
</ol>
<p><span class="math display">\[  = \frac{\dot{w}}{w} + \frac{\dot{L}}{L} - \frac{\dot{Y}}{Y} \]</span></p>
<p><span class="math display">\[  = \frac{\dot{w}}{w} + \frac{\dot{L}}{L} - \frac{\dot{L}}{L} - \alpha \]</span></p>
<p><span class="math display">\[ \frac{\dot{\omega}}{\omega} = \frac{\dot{w}}{w} - \alpha = \Phi(\lambda)-\alpha\]</span></p>
<ol start="2" style="list-style-type: decimal">
<li>tanımı açalım,</li>
</ol>
<p><span class="math display">\[ \dot{D} = I - \Pi = \kappa(1 - \omega - rd) Y - (1-\omega-rd)Y \]</span></p>
<p>Hatırlarsak <span class="math inline">\(D/Y = d\)</span>, yani <span class="math inline">\(D = Yd\)</span>, <span class="math inline">\(\dot{D}/D\)</span> için <span class="math inline">\(D=Yd\)</span> ile böleriz,</p>
<p><span class="math display">\[ 
\frac{\dot{D}}{D} = \frac{ \kappa(1 - \omega - rd)}{d} 
- \frac{(1-\omega-rd)}{d}
\]</span></p>
<p><span class="math display">\[ 
= \frac{ \kappa(1 - \omega - rd) - (1-\omega-rd) }{d} 
\]</span></p>
<p>Şimdi <span class="math inline">\(\dot{Y}/Y\)</span> hesabı yapalım, <span class="math inline">\(\dot{Y}/Y = \dot{K}/K\)</span> olduğu için,</p>
<p><span class="math display">\[ 
\dot{Y}/Y = \dot{K}/K = \frac{\kappa(1 - \omega - rd) Y - \delta K}{K}
\]</span></p>
<p><span class="math display">\[ 
 = \frac{\kappa(1 - \omega - rd) }{v}- \delta 
\qquad (1)
\]</span></p>
<p>O zaman</p>
<p><span class="math display">\[  
\frac{\dot{D}}{D} - \frac{\dot{Y}}{Y} =
\frac{ \kappa(1 - \omega - rd) - (1-\omega-rd) }{d} 
- \frac{\kappa(1 - \omega - rd) }{v} + \delta
\]</span></p>
<ol start="3" style="list-style-type: decimal">
<li>tanımı açalım,</li>
</ol>
<p><span class="math display">\[  =  \frac{\dot{L}}{L} - \frac{\dot{a}}{a} = \frac{\dot{L}}{L} - \beta \]</span></p>
<p><span class="math display">\[ Y = L \cdot a \]</span></p>
<p><span class="math display">\[ 
\frac{\dot{Y}}{Y} = \frac{\dot{L}}{L} + \frac{\dot{a}}{a}
= \frac{\dot{L}}{L} + \alpha
\]</span></p>
<p><span class="math display">\[ \frac{\dot{\lambda}}{\lambda} = \frac{\dot{Y}}{Y} - \alpha - \beta \]</span></p>
<p>Biraz önce (1)'de bulduğumuz <span class="math inline">\(\dot{Y}/Y\)</span> sonucunu kullanalım,</p>
<p><span class="math display">\[ 
\frac{\dot{\lambda}}{\lambda} = 
\frac{\kappa(1-\omega-rd)}{v} - \alpha - \beta - \delta
\]</span></p>
<p>Sonuç olarak şu ODE denklem sistemine erişiyoruz,</p>
<p><span class="math display">\[ 
\dot{\omega} = \omega [ \Phi(\lambda)-\alpha ] 
\qquad (2)
\]</span></p>
<p><span class="math display">\[ 
\dot{\lambda}=  \lambda \bigg[ 
\frac{\kappa(1-\omega-rd)}{v} - \alpha - \beta - \delta
\bigg]
\qquad (3)
\]</span></p>
<p><span class="math display">\[ 
\dot{d} = d \bigg[
r - \frac{\kappa(1-\omega-rd)}{v} + \alpha 
\bigg] + \kappa(1-\omega-rd) - (1-\omega)
\qquad (4)
\]</span></p>
<p>Stabil Noktalar</p>
<p>Birazdan yapılacak hesaplar için gerekli bazı sabitleri tanımlayalım,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">alpha <span class="op">=</span> <span class="fl">0.025</span>
beta <span class="op">=</span> <span class="fl">0.02</span>
delta <span class="op">=</span> <span class="fl">0.01</span>
v <span class="op">=</span> <span class="fl">3.0</span>
k0 <span class="op">=</span> <span class="fl">-0.0065</span>
k1 <span class="op">=</span> np.exp(<span class="op">-</span><span class="fl">5.0</span>)
k2 <span class="op">=</span> <span class="fl">20.0</span>
r <span class="op">=</span> <span class="fl">0.03</span>
phi0 <span class="op">=</span> <span class="fl">0.04</span> <span class="op">/</span> (<span class="fl">1.0</span><span class="op">-</span>(<span class="fl">0.04</span><span class="op">**</span><span class="dv">2</span>))
phi1 <span class="op">=</span> <span class="fl">0.04</span><span class="op">**</span><span class="fl">3.0</span> <span class="op">/</span> (<span class="fl">1.0</span><span class="op">-</span>(<span class="fl">0.04</span><span class="op">**</span><span class="dv">2</span>))

<span class="kw">def</span> kappa(x,k0,k1,k2): <span class="cf">return</span> k0 <span class="op">+</span> (k1<span class="op">*</span>np.exp(k2<span class="op">*</span>x))

<span class="kw">def</span> philips(lam,phi0,phi1): <span class="cf">return</span> ( (phi1 <span class="op">/</span> (<span class="fl">1.0</span><span class="op">-</span>lam)<span class="op">**</span><span class="dv">2</span>) <span class="op">-</span> phi0)</code></pre></div>
<p>ODE sistemindeki tüm türevlerin sıfır olması için <span class="math inline">\((0,0,0)\)</span> seçilebilir, fakat bu aşırı basit (trivial) çözümdür, ekonomik olarak anlamı yoktur. Daha anlamlı bir sabit nokta için (2)'deki türevin sıfır olması için <span class="math inline">\(\Phi(\lambda)=\alpha\)</span> olmalıdır, ya da <span class="math inline">\(\lambda=\Phi^{-1}(\alpha)\)</span>. Yani bir <span class="math inline">\(\Phi\)</span>'nin tersini arıyoruz, öyle ki <span class="math inline">\(\Phi^{-1}(\Phi(\lambda)) = \lambda\)</span> olsun. <span class="math inline">\(\Phi\)</span> neydi?</p>
<p><span class="math display">\[ \Phi(\lambda) = \alpha = \frac{\phi_1}{(1-\lambda)^2}-\phi_0\]</span></p>
<p>Fonksiyonun tersini bulmak için bir karesel denklem şeklinde düzenleyelim,</p>
<p><span class="math display">\[ \alpha + \phi_0 = \frac{\phi_1}{(1-\lambda)^2}\]</span></p>
<p><span class="math display">\[   (1-\lambda)^2 = \frac{\phi_1}{ \alpha + \phi_0} \]</span></p>
<p><span class="math display">\[  \lambda^2 - 2\lambda + 1 - \frac{\phi_1}{ \alpha + \phi_0} =0\]</span></p>
<p>Bu standart bir karesel denklem, köklerini bulalım,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">res <span class="op">=</span> np.roots([<span class="dv">1</span>, <span class="dv">-2</span>, <span class="dv">1</span><span class="op">-</span>(phi1<span class="op">/</span>(alpha<span class="op">+</span>phi0))   ])
lambda1 <span class="op">=</span> res[<span class="dv">1</span>]
<span class="bu">print</span> res</code></pre></div>
<pre><code>[ 1.03138824  0.96861176]</code></pre>
<p><span class="math inline">\(\lambda &lt; 1.0\)</span> olması gerektiği için aradığımız ikinci sonuç, yani [2]'de bahsedilen <span class="math inline">\(\overline{\lambda}_1 = 0.9686\)</span> değeri.</p>
<ol start="3" style="list-style-type: decimal">
<li>denkleminde türevi sıfıra eşitleriz ve basit olmayan çözüm için</li>
</ol>
<p><span class="math display">\[ 
\kappa(1-\omega-rd)= v (\alpha + \beta + \delta) 
\qquad (5)
\]</span></p>
<p>ile başlarız. Yine ters alma operasyonu uygularsak,</p>
<p><span class="math display">\[ \overline{\pi}_1 = 1-\omega-rd= \kappa^{-1}(v (\alpha - \beta - \delta)) \]</span></p>
<p><span class="math inline">\(\overline{\pi}_1\)</span> tanımını yaptık takibi rahat olsun diye.</p>
<p>Önce <span class="math inline">\(\overline{\pi}_1\)</span> hesabı. <span class="math inline">\(\kappa\)</span>'nin tersi lazım,</p>
<p><span class="math display">\[ \kappa^{-1} = \frac{1}{\kappa_2} \log \bigg( \frac{\kappa(x) - \kappa_0 }{\kappa_1}\bigg)\]</span></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">tmp <span class="op">=</span> v<span class="op">*</span>(alpha<span class="op">+</span>beta<span class="op">+</span>delta) <span class="op">-</span> k0
pi1 <span class="op">=</span> <span class="fl">1.0</span><span class="op">/</span>k2 <span class="op">*</span> np.log(np.<span class="bu">abs</span>(tmp<span class="op">/</span>k1))
<span class="bu">print</span> <span class="st">&#39;pi1&#39;</span>, pi1</code></pre></div>
<pre><code>pi1 0.161841399381</code></pre>
<p><span class="math inline">\(\overline{\omega}_1\)</span> için (5)'i tekrar düzenleyelim,</p>
<p><span class="math display">\[ d = \frac{1-\overline{\pi}_1-\omega}{r} \]</span></p>
<p>Şimdi bu <span class="math inline">\(d\)</span>'yi (4) içine sokalım,</p>
<p><span class="math display">\[ 
0 =  \frac{1-\overline{\pi}_1-\omega}{r} \bigg[
r - \frac{v (\alpha + \beta + \delta)}{v} + \delta
\bigg] + v (\alpha + \beta + \delta)- 1+\omega
\]</span></p>
<p><span class="math display">\[ 
-\omega =  \bigg(\frac{1}{r}-\frac{\overline{\pi}_1}{r}-\frac{\omega}{r}\bigg) \bigg(
r - \alpha - \beta 
\bigg) + v (\alpha + \beta + \delta)- 1
\]</span></p>
<p><span class="math display">\[ 
-\omega =
\bigg(\frac{1}{r}-\frac{\overline{\pi}_1}{r}-\frac{\omega}{r}\bigg)c_1 +
c_2 - 1
\]</span></p>
<p><span class="math display">\[ 
-\omega = \frac{c_1}{r}-\frac{c_1\overline{\pi}_1}{r}-\frac{c_1 \omega}{r}  +c_2 - 1
\]</span></p>
<p><span class="math display">\[ 
\omega(\frac{c_1 }{r} -1) = \frac{c_1}{r}-\frac{c_1 \overline{\pi}_1}{r} +c_2 - 1
\]</span></p>
<p><span class="math display">\[ 
\omega(\frac{c_1-r }{r}) = \frac{c_1 - c_1 \overline{\pi}_1 + rc_2 - r}{r}
\]</span></p>
<p><span class="math display">\[ 
\overline{\omega}_1 = \frac{c_1 - c_1\overline{\pi}_1 + rc_2 - r}{c_1 - r}
\]</span></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">c1 <span class="op">=</span> r<span class="op">-</span>alpha<span class="op">-</span>beta
c2 <span class="op">=</span> v<span class="op">*</span>(alpha<span class="op">+</span>beta<span class="op">+</span>delta)
omega1 <span class="op">=</span> (c1 <span class="op">-</span> c1<span class="op">*</span>pi1<span class="op">+</span>r<span class="op">*</span>c2<span class="op">-</span>r) <span class="op">/</span> (c1<span class="op">-</span>r)
<span class="bu">print</span> omega1</code></pre></div>
<pre><code>0.836052866873</code></pre>
<p><span class="math inline">\(d\)</span> için <span class="math inline">\(\overline{\pi}_1\)</span> formülünden başlarız, ve artık bildiğimiz değerleri yerine koyarız</p>
<p><span class="math display">\[ \overline{\pi}_1 = 1-\omega-rd =&gt; 
d = (1-\overline{\omega}_1 -\overline{\pi}_1) / r \]</span></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">d1 <span class="op">=</span>  (<span class="dv">1</span><span class="op">-</span>omega1<span class="op">-</span>pi1) <span class="op">/</span> r
<span class="bu">print</span> d1</code></pre></div>
<pre><code>0.0701911248667</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">fp1 <span class="op">=</span> (lambda1,omega1,d1)
<span class="bu">print</span> <span class="st">&#39;sabit nokta&#39;</span>, np.<span class="bu">round</span>(fp1,<span class="dv">4</span>)</code></pre></div>
<pre><code>sabit nokta [ 0.9686  0.8361  0.0702]</code></pre>
<p>Bu değerler istihdam, işçi ücretlerinin GSYH içindeki payı, ve özel borç oranının sabit noktadaki değerlerini gösteriyor. Bu değerleri verilen parametreler ışığında ekonomik olarak &quot;optimal'' olarak görebiliriz. [2]'de bu değerlerin stabilite ne kadar yakınında kalınması gerektiği gösterilmiş.</p>
<p>Şimdi ODE sistemini sayısal olarak çözelim,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> scipy <span class="im">as</span> sp
<span class="im">from</span> scipy.integrate.odepack <span class="im">import</span> odeint

<span class="kw">def</span> rhs(u,t,alpha,beta,delta,r,k0,k1,k2,v,phi0,phi1):
    omega, lam, d, a, N <span class="op">=</span> u
    tmp <span class="op">=</span> kappa(<span class="fl">1.0</span><span class="op">-</span>omega<span class="op">-</span>r<span class="op">*</span>d,k0,k1,k2) 
    res <span class="op">=</span> [omega<span class="op">*</span>(philips(lam,phi0,phi1)<span class="op">-</span>alpha), <span class="op">\</span>
           lam<span class="op">*</span>(tmp<span class="op">/</span>v <span class="op">-</span> alpha <span class="op">-</span> beta <span class="op">-</span> delta), <span class="op">\</span>
           d <span class="op">*</span> ( r <span class="op">-</span> tmp<span class="op">/</span>v <span class="op">+</span> alpha ) <span class="op">+</span> tmp <span class="op">-</span> (<span class="fl">1.0</span><span class="op">-</span>omega), <span class="op">\</span>
           alpha<span class="op">*</span>a, <span class="op">\</span>
           beta<span class="op">*</span>N]
    <span class="cf">return</span> res           </code></pre></div>
<p>İki senaryoyu deneyelim, biri üstte bulduğumuz sabit noktaya yakın bir yerden, diğeri uzak bir yerden başlamak.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">omega0 <span class="op">=</span> <span class="fl">0.80</span>
lam0 <span class="op">=</span> <span class="fl">0.80</span>
d0 <span class="op">=</span> <span class="fl">0.1</span>
a0 <span class="op">=</span> <span class="fl">0.5</span>
N0 <span class="op">=</span> <span class="fl">300.</span>

t<span class="op">=</span>np.linspace(<span class="fl">0.0</span>,<span class="fl">300.0</span>,<span class="fl">10000.0</span>)
args <span class="op">=</span> (alpha,beta,delta,r,k0,k1,k2,v,phi0,phi1)
res<span class="op">=</span>odeint(rhs,[omega0, lam0, d0, a0, N0],t,args<span class="op">=</span>args)
omega1, lam1, d1, a1, N1<span class="op">=</span>res[:, <span class="dv">0</span>],res[:, <span class="dv">1</span>],res[:, <span class="dv">2</span>],res[:, <span class="dv">3</span>],res[:, <span class="dv">4</span>]

Y <span class="op">=</span> lam1<span class="op">*</span>N1

plt.figure()
plt.plot(t,omega1)
plt.ylabel(<span class="st">&#39;Omega&#39;</span>)
plt.savefig(<span class="st">&#39;chaos_app03_01.png&#39;</span>)
plt.figure()
plt.plot(t,lam1)
plt.ylabel(<span class="st">&#39;Lambda&#39;</span>)
plt.savefig(<span class="st">&#39;chaos_app03_02.png&#39;</span>)
plt.figure()
plt.plot(t,d1)
plt.ylabel(<span class="st">&#39;d&#39;</span>)
plt.savefig(<span class="st">&#39;chaos_app03_03.png&#39;</span>)
plt.figure()
plt.plot(t,Y)
plt.ylabel(<span class="st">&#39;Y&#39;</span>)
plt.savefig(<span class="st">&#39;chaos_app03_04.png&#39;</span>)</code></pre></div>
<p><img src="chaos_app03_01.png" /> <img src="chaos_app03_02.png" /> <img src="chaos_app03_03.png" /> <img src="chaos_app03_04.png" /></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">omega0 <span class="op">=</span> <span class="fl">0.70</span>
lam0 <span class="op">=</span> <span class="fl">0.70</span>
d0 <span class="op">=</span> <span class="fl">0.1</span>
a0 <span class="op">=</span> <span class="fl">0.5</span>
N0 <span class="op">=</span> <span class="fl">300.</span>

t<span class="op">=</span>np.linspace(<span class="fl">0.0</span>,<span class="fl">300.0</span>,<span class="fl">1000.0</span>)
args <span class="op">=</span> (alpha,beta,delta,r,k0,k1,k2,v,phi0,phi1)
res<span class="op">=</span>odeint(rhs,[omega0, lam0, d0, a0, N0],t,args<span class="op">=</span>args)
omega2, lam2, d2, a2, N2<span class="op">=</span>res[:, <span class="dv">0</span>],res[:, <span class="dv">1</span>],res[:, <span class="dv">2</span>],res[:, <span class="dv">3</span>],res[:, <span class="dv">4</span>]

Y <span class="op">=</span> lam2<span class="op">*</span>N2

plt.figure()
plt.plot(t,omega2)
plt.ylabel(<span class="st">&#39;Omega&#39;</span>)
plt.savefig(<span class="st">&#39;chaos_app03_05.png&#39;</span>)
plt.figure()
plt.plot(t,lam2)
plt.ylabel(<span class="st">&#39;Lambda&#39;</span>)
plt.savefig(<span class="st">&#39;chaos_app03_06.png&#39;</span>)
plt.figure()
plt.plot(t,d2)
plt.ylabel(<span class="st">&#39;d&#39;</span>)
plt.savefig(<span class="st">&#39;chaos_app03_07.png&#39;</span>)
plt.figure()
plt.plot(t,Y)
plt.ylabel(<span class="st">&#39;Y&#39;</span>)
plt.savefig(<span class="st">&#39;chaos_app03_08.png&#39;</span>)</code></pre></div>
<p><img src="chaos_app03_05.png" /> <img src="chaos_app03_06.png" /> <img src="chaos_app03_07.png" /> <img src="chaos_app03_08.png" /></p>
<p>Görüldüğü gibi ilk senaro bizi stabiliteye taşıyor, diğeri ekonomik çöküşe. Çöküş noktasında işsizlik, üretim sıfır, özel borç sonsuz seviyede. Bu çöküşe gidişin ne kadar kolay olduğunu gördük, sabit noktadan çok fazla uzaklaşmadık, ama sistem batışa gitti. Eğer modelin ana temeline inanıyorsak söylediklerine de inanmak gerekir, serbest piyasa kurulduğu şekliyle temel olarak krizlere açıktır. Bunu zaten gerçek dünyada da görüyoruz, her 10 senede bir ekonomide kriz oluyor.</p>
<p>Sabit noktanın ne anlama geldiğini sözel olarak belirtmek gerekirse, [0.9686 0.8361 0.0702] demek istihdam oranı 96%, gelir dağılımındaki maaşların (yani orta sınıfın kazandığı, çünkü onlar gelirlerini maaştan elde ediyorlar) payı 83%, borç oranının 7% olması demektir (<span class="math inline">\(v\)</span> sabitini arttırınca borçluluk oranı daha fazla olabiliyor, fakat diğerlerinde pek değişim yok). O zaman krizleri azaltmak demek istihdam teşviki, ve kazançların artması, borçluğun azalması demektir. Şu anda Amerika'da seviyeler alttadır,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pandas <span class="im">as</span> pd
df <span class="op">=</span> pd.read_csv(<span class="st">&#39;gdp.csv&#39;</span>,parse_dates<span class="op">=</span><span class="va">True</span>)
df.columns <span class="op">=</span> [<span class="st">&#39;date&#39;</span>,<span class="st">&#39;W&#39;</span>,<span class="st">&#39;GDP&#39;</span>,<span class="st">&#39;house_debt&#39;</span>,<span class="st">&#39;corp_debt&#39;</span>,<span class="st">&#39;N&#39;</span>,<span class="st">&#39;emp&#39;</span>]
df <span class="op">=</span> df.dropna()
df <span class="op">=</span> df.set_index(<span class="st">&#39;date&#39;</span>)
df.loc[:,<span class="st">&#39;N&#39;</span>] <span class="op">=</span> df[<span class="st">&#39;N&#39;</span>] <span class="op">/</span> <span class="fl">1000000.</span>
df.loc[:,<span class="st">&#39;W&#39;</span>] <span class="op">=</span> df[<span class="st">&#39;W&#39;</span>] <span class="op">/</span> <span class="fl">1000.</span>
df.loc[:,<span class="st">&#39;GDP&#39;</span>] <span class="op">=</span> df[<span class="st">&#39;GDP&#39;</span>] <span class="op">/</span> <span class="fl">1000.</span>
df.loc[:,<span class="st">&#39;corp_debt&#39;</span>] <span class="op">=</span> df[<span class="st">&#39;corp_debt&#39;</span>] <span class="op">/</span> <span class="fl">1000000.</span>
df.loc[:,<span class="st">&#39;house_debt&#39;</span>] <span class="op">=</span> df[<span class="st">&#39;house_debt&#39;</span>] <span class="op">/</span> <span class="fl">1000.</span>
df[<span class="st">&#39;wage_share&#39;</span>] <span class="op">=</span> df.W <span class="op">/</span> df.GDP
df[<span class="st">&#39;debt_share&#39;</span>] <span class="op">=</span> (df.corp_debt <span class="op">+</span> df.house_debt) <span class="op">/</span> df.GDP
<span class="bu">print</span> df[[<span class="st">&#39;emp&#39;</span>,<span class="st">&#39;wage_share&#39;</span>,<span class="st">&#39;debt_share&#39;</span>]].tail(<span class="dv">1</span>)</code></pre></div>
<pre><code>             emp  wage_share  debt_share
date                                    
2016-01-01  81.2    0.441951    1.089282</code></pre>
<p>Gelir seviyesi olması gerekenin yarısında, borçluluk çok yüksek, istihdam düşük.</p>
<p>Kaynaklar</p>
<p>[1] Keen, <em>On Macroeconomic modelling</em>, <a href="http://www.profstevekeen.com/crisis/models" class="uri">http://www.profstevekeen.com/crisis/models</a></p>
<p>[2] Grasselli, <em>An analysis of the Keen model for credit expansion, asset price bubbles and financial fragility</em>,<a href="https://ms.mcmaster.ca/~grasselli/GrasselliCostaLima_MAFE_online.pdf" class="uri">https://ms.mcmaster.ca/~grasselli/GrasselliCostaLima_MAFE_online.pdf</a></p>
</body>
</html>
