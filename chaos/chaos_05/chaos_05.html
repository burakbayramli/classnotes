<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>

  <title>Ders 5</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  
  
  
  
</head>
<body>
<h1 id="ders-5">Ders 5</h1>
<p>Artık iki boyutlu sistemlere geçme zamanı geldi. Bu konuyu uzun bir süre işleyeceğiz, ve en basit iki boyutlu sistemle ise başlayalım; çünkü tahmin edebileceğiniz üzere işleyebileceğimiz pek çok farklı iki boyutlu yüzey var. Düzlem (plane) bunlardan sadece biri. İlk işleyeceğimiz konu bu olacak, ama silindir, küre yüzeyleri de var; bu tür gayrı-lineer sistemler doğada pek çok yerde görülebiliyor.</p>
<p>Başlangıcı faz düzlem analiziyle (phase plane analysis) yapalım. Sistem şuna benzeyecek,</p>
<p><span class="math display">\[ \dot{x} = f(x,y) \]</span></p>
<p><span class="math display">\[ \dot{y} = g(x,y) \]</span></p>
<p><span class="math inline">\(f,g\)</span> tipik olarak gayrı lineer fonksiyonlar olur. Notasyon <span class="math inline">\((x,y) \in \mathbb{R}^2\)</span>. <span class="math inline">\((\dot{x},\dot{y})\)</span> çifti bir hız vektörü olarak düşünülür. Hız derken mekanikteki hızdan bahsetmiyorum, faz uzayındaki yapay bir hız bu. Eğer <span class="math inline">\(x,y\)</span> bir yersel kordinatı temsil ediyor olsaydı, <span class="math inline">\((\dot{x},\dot{y})\)</span> o zaman mekanik hızı temsil ediyor olurdu. Ama <span class="math inline">\(x,y\)</span> bir nüfus, ya da kimyasal maddlerin konsantrasyonu gibi pek çok farklı ölçüm olabilir.</p>
<p>Grafiksel olarak faz düzlemi,</p>
<div class="figure">
<img src="05_01.png" />

</div>
<p><span class="math inline">\(x,y\)</span> noktasından çıkan bir vektör o noktadaki hızı vektörsel olarak temsil ediyor. Eğer o <span class="math inline">\(x,y\)</span>'de olsaydık, bir sonraki gittiğimiz yer vektörün diğer ucu olacaktır. Tabii o noktada da bir başka vektör olurdu, sonra o vektörü takip ederdik, vs, bu böyle devam ederdi. Sürekli vektörleri takip ederek bir gidiş yolu üzerinde (trajectory) hareket ediyor olurduk.</p>
<p>Bazen sistemi şu formda göstermek daha faydalı oluyor,</p>
<p><span class="math display">\[ \dot{\underline{x}} =
\left[\begin{array}{r} x \\ y\end{array}\right]
\]</span></p>
<p><span class="math display">\[ \dot{\underline{x}} = \underline{f}(\underline{x}) \]</span></p>
<p><span class="math inline">\(f,g\)</span>'nin pürüzsüzlüğü hakkında birkaç şey söyleyelim. Daha önce vurguladığım gibi bu derste aşırı seçici olmadığımız bir konu abartılı teorik gereklilikler; mesela <span class="math inline">\(f,g\)</span>'nin yeterince pürüzsüz olduğunu farz ediyoruz, yani ODE'nin çözümleri var ve bu çözümler özgün demiş oluyoruz. Bizim için yeterli bu şartı şöyle ifade edebiliriz: Eğer <span class="math inline">\(\underline{f}\)</span> ardı ardına türevi alınabilir bir fonksiyon ise (yani <span class="math inline">\(\underline{f}\)</span> ve onun türevleri sürekli ise), o zaman ardı ardına türevi alınabilir bir vektör alanımız var demektir, ve bu da herhangi bir başlangı noktası için <span class="math inline">\(\underline{x}(t)\)</span> çözümleri mevcut ve özgün anlamına gelir.</p>
<p>Gidiş yolu kelimesini kullandım, çözüm spesifik bir gidiş yoludur,</p>
<div class="figure">
<img src="05_02.png" />

</div>
<p>Üstte görüldüğü gibi. Bir başlangıç noktasından bir vektörü takip ederim, oradan bir diğerini, ve faz düzleminde üstteki gibi bir gidiş yolu <span class="math inline">\(x(t)\)</span> ortaya çıkar. Bu bir çözümdür.</p>
<p>Ama tekrar vurgulayayım, bu derste üstteki gibi bir çözümün <em>yapısını</em> anlamaya uğraşıyoruz, bunu sistem denklemklerini direk çözmeden yapmaya uğraşıyoruz. Bazı argümanlar geliştirerek çözümün şeklini görmek istiyoruz.</p>
<p>Mevcudiyet ve özgünlük şartının doğal bir sonucu var, bu ilginç bir durum ve şartın kendisinden bariz olarak görülemeyebilir. Bu önemli bir kavram ve takip eden anlatımlarda merkezi bir yeri var. Bu sonuç şudur; eğer çözümler özgün ise, gidiş yolları birbiriyle kesişemezler. Yani faz portrelerini çizerken şöyle bir şekil görmemiz mümkün değildir,</p>
<div class="figure">
<img src="05_03.png" />

</div>
<p>Bu mümkünsüzlüğün sebebini anlamak için herhangi bir hayali kesişme noktasında isek bir sonraki gidişatın ne olacağını düşünmek yeterli. Öyle bir durumda kesişme noktasından sonra iki tane farklı gelecek (gidiş yönü) olurdu, ve bu iki seçenek varlığı çözümlerin özgünlüğü prensibine aykırıdır.</p>
<p>Diğer yandan gidiş yolları sabit noktalarda birbirine yaklaşabilir, alttaki gibi bir şekil mümkündür,</p>
<div class="figure">
<img src="05_04.png" />

</div>
<p>Son iki ifade arasında çelişki yok. Üstteki bir sabit nokta, ve o noktada isek, orada kalırız (sabit nokta nihayetinde), ve ona doğru işaret eden gidiş yolları sabit noktaya dokunmuyor aslında, sadece ona yaklaşıyorlar. Eh, tamam, sonsuz zamanda dokunuyorlar, ama herhangi bir sonlu (finite) zaman içinde dokunma yok.</p>
<p>Unutmadan, iki boyutlu durumda sabit noktaların oluşmasının şartı bir <span class="math inline">\(x,y\)</span> noktası için hem <span class="math inline">\(\dot{x}=0\)</span>, hem de <span class="math inline">\(\dot{y}=0\)</span> olmasıdır. Ya da vektör notasyonu ile <span class="math inline">\(\underline{f}(\underline{x}^\ast)=\underline{0}\)</span>. Eşitliğin sağındakine dikkat, bu bir &quot;sıfır vektörü'', içinde sadece sıfır değerleri var.</p>
<p>Gidiş yollarının kesişmeme şartının topolojik sonuçlarına bir bakalım. Diyelim ki elimizde kapalı bir yörünge (closed orbit) var, <span class="math inline">\(\mathbb{R}^2\)</span> için olsun,</p>
<div class="figure">
<img src="05_05.png" />

</div>
<p>Bir noktadan başlanıyor, ama gidiş yolu gide gide tekrar kendisine dönüyor. Bu tür bir yol diferansiyel denklemlerin dönemsel bir çözümü olduğunu gösterir. Şimdi dışarıdan döngüye yaklaşan bir gidiş yolu düşünelim (üstteki resimde yine), yol döngünün içine &quot;giremez''; o zaman özgünlük prensibi ihlal edilmiş olur. Hadi birleşim olduğunu varsayalım, ve birleşim sonrası bir noktadan zamanı geri saralım; birleşme anında zaman hangi gidiş yoluna sapacak? Bu bir çelişki ortaya çıkartır. Yani bir döngünün varlığı iki boyutta diğer gidiş yolları için ciddi bazı kısıtlamalara sebep oluyor.</p>
<p><span class="math inline">\(\mathbb{R}^3\)</span>'te gidiş yolları birleşebilir, çünkü üç boyutta bir döngü uzayda bir ayrım yaratamaz, ve bu durum bazı şartlarda kaos ortaya çıkartır. İki boyutta kaos olması mümkün değildir. Hatırlarsak, tek boyutta yapılabilecekler çok basitti, sabit noktaya, ya da sonsuzluğa doğru akıyor her şey. İki boyutta sabit noktaya, ya da dönemsel bir yörüngeye gidilebilir.. farklı biraz daha egzotik şeyler de mümkün, fakat kaos mümkün değil. Üç boyutta kaos olabilir, zaten üç boyut kaosun ilk ortaya çıkabileceği yer.</p>
<p>Önümüzdeki bir kaç dersteki amacımız verili bir <span class="math inline">\(\dot{\underline{x}}=\underline{f}(\underline{x})\)</span> sistemi için faz portresini (grafiğini) çizmek, bunu niteliksel olarak farklı olan tüm gidiş yollarının göstererek yapmak, sabit noktaları, stabilitesi, ve muhtemel kapalı yörüngeler hakkında yine niteliksel bilgi toplamak. Bunu iki boyutta sabit nokta etrafında lineerizasyon kullanarak yapacağız. Tek boyutta sistemi olduğu gibi analiz etmek kolaydı fakat iki boyutta bu biraz daha zor.</p>
<p>Sistemlerimizi</p>
<p><span class="math display">\[
\dot{\underline{x}} = A \underline{x}
\]</span></p>
<p>olarak yazacağız. Bu konunun standart diline atıf yapmak gerekirse, &quot;sabit katsayılı, homojen lineer sistemler''e bakacağız. <span class="math inline">\(A\)</span> bir sabit katsayılar matrisi, ve sayılar reel. Bu tür sistemlerde orijin her zaman bir sabit noktadır, <span class="math inline">\(\underline{x}^\ast = \underline{0}\)</span>, kontrolü kolay - sıfır vektörü <span class="math inline">\(A\)</span> ile çarparız, ve sonuç sıfır. Tabii tüm faz portresini ve diğer sabit noktaları da bulmak istiyoruz.</p>
<p>Faz portresi <span class="math inline">\(A\)</span>'nin özdeğerleri ve özvektörleri üzerinden tanımlıdır, ki özdeğer / vektörlerin lineer cebir derslerinde öğretilmesinin önemli bir sebebi de budur, çünkü onlar sayesinde lineer diferansiyel denklemleri çözebilirsiniz.</p>
<p>Bu tekniği işlerken görmek için ilk önce sistemin özel bir çözümünü ararız. Fizikçiler böyle yaklaşırlar bu tür problemlere, genel çözümü aramak yerine, bakılan çözümler düzlem üzerindeki bir çizgi üzerinde olan çözümlere kısıtlanır. <span class="math inline">\(\underline{x}(t) = \underline{v}\)</span> türünde çözümleri arayalım, <span class="math inline">\(\underline{v}\)</span> bir sabit vektör, ve bir yöne işaret ediyor.</p>
<div class="figure">
<img src="05_06.png" />

</div>
<p>Bu arada gösterilen gidiş yolu sabit hızda olmayabilir, bazen hızlanıp, bazen yavaşlayabilir, ama direk çizgide gider.</p>
<p>Çözüm sadece bir sabit olamaz muhakkak, bir zaman bağlantısı da ekleyelim,</p>
<p><span class="math display">\[
\underline{x}(t) = \underline{v} e ^{\lambda t}
\]</span></p>
<p>Diferansiyel denklemleri bilenler üstel fonksiyonun burada doğru bir seçim olduğunu bilirler.</p>
<p>Türev ve zincir kuralını uygularsak,</p>
<p><span class="math display">\[
\dot{\underline{x}} = \underline{v} \lambda e ^{\lambda t} 
\]</span></p>
<p>Daha önceki eşitlikten hareketle,</p>
<p><span class="math display">\[
= A \underline{x} = A \big( \underline{v} e ^{\lambda t} \big)
\]</span></p>
<p>Lineerlik üzerinden <span class="math inline">\(e ^{\lambda t}\)</span>'yi dışarı çekebiliriz,</p>
<p><span class="math display">\[
= e ^{\lambda t} A \underline{v}
\]</span></p>
<p>Üstteki formülde <span class="math inline">\(e^{\lambda t}\)</span> var, üç üstteki formülde de var, o zaman üstteki türdeki çözümler mevcut olacaktır eğer <span class="math inline">\(A \underline{v}=\lambda\underline{v}\)</span> şartına uyan bir <span class="math inline">\(\underline{v}\)</span> ve <span class="math inline">\(\lambda\)</span> bulabilirsek. Ve farketmiş olabilirsiniz, bu şart (formül) özdeğer / vektörlerin tanımlayıcı formülüdür, <span class="math inline">\(\underline{v}\)</span> özvektör, <span class="math inline">\(\lambda\)</span> özdeğer olmak üzere.</p>
<p><span class="math inline">\(\underline{v},\lambda\)</span> mevcut ise düz çizgi çözümlerimizi bulabiliriz, peki mevcut olduklarını nasıl tespit ederiz? Cevap lineer cebir üzerinden onları hesaplamaya uğraşmakla verilebilir. <span class="math inline">\(\lambda\)</span> için <span class="math inline">\(\det (A - \lambda I) = 0\)</span> çözülür, bizim ufak matris için</p>
<p><span class="math display">\[
0 = \left[\begin{array}{rr}
a-\lambda &amp; b \\ c &amp; d-\lambda
\end{array}\right]
\]</span></p>
<p><span class="math display">\[ 
= \lambda^2 - \tau \lambda + \Delta 
\qquad (1) 
\]</span></p>
<p>Üstte daha ileride bolca kullanacağım notasyonu tanıştırmış oldum bir yandan. <span class="math inline">\(\tau\)</span> matrisin izi'dir (trace), yani matrisin köşegenindeki öğelerin toplamıdır. <span class="math inline">\(\Delta\)</span> ise matris determinantı olacaktır,</p>
<p><span class="math display">\[ \tau = \mathrm{tr} A = a + d\]</span></p>
<p><span class="math display">\[ \Delta = \det A = ad - bc \]</span></p>
<p>Karesel formülü kullanarak (1)'i çözebiliriz,</p>
<p><span class="math display">\[ \lambda_{1,2} = \frac{\tau \pm \sqrt{\tau^2-4\Delta}}{2} \]</span></p>
<p><span class="math display">\[ \tau = \lambda_1 + \lambda_2 \]</span></p>
<p><span class="math display">\[ \Delta = \lambda_1 \lambda_2 \]</span></p>
<p>Şimdi <span class="math inline">\(\lambda\)</span>'lara bağlı olarak faz portelerinin nasıl görüneceğine bakalım. Aslında özdeğer / vektörleri hesaplamadan direk iz ve determinanta bakmak bize çok şey söyler.</p>
<p><span class="math inline">\(\dot{\underline{x}}= A \underline{x}\)</span>, <span class="math inline">\(x \in \mathbb{R}^2\)</span> İçin Sabit Noktaların Sınıflandırılması</p>
<p>Durum 1) Eğer Noktaları (Saddle Points)</p>
<p>Bu noktaları anında bulmak mümkün çünkü negatif determinantı olan onlar. Yani matrisimiz için determinantı hesaplarsak ve <span class="math inline">\(\Delta &lt; 0\)</span> çıkarsa, iş bitti demektir. Elde bir eğer noktası var. Bu da mesela <span class="math inline">\(\lambda_1 &gt; 0\)</span>, <span class="math inline">\(\lambda_2&lt;0\)</span> anlamına gelir, ve her iki değer birbirinden farklıdır (distinct), işaretleri birbirinin zıttı.</p>
<p>Lineer cebirde güzel bir teori var, bu teori der ki eğer iki farklı özdeğer elde edersek, onlara tekabül eden özvektörler birbirinden bağımsızdır. Bu illa ki birbirlerine dikgen anlamına gelmez, sadece aynı çizgi üzerinde değiller demektir.</p>
<div class="figure">
<img src="05_07.png" />

</div>
<p>Çizersek mesela vektörler üstteki gibi olabilirdi; bu çizgiler iki özvektörün kapsamıdır (span), yani her vektörün mümkün tüm tek sayılar ile çarpılmış hali - aynı çizgide gösterince üstteki iki çizgiyi elde edebilirdik.</p>
<p>Şimdi genel çözümü yazarız, bu çözüm iki çözümün üst üste konmuş hali olacaktır.</p>
<p><span class="math display">\[
\underline{x}(t) =
c_1 e^{\lambda_1 t} \underline{v}_1 +
c_2 e^{\lambda_2 t} \underline{v}_2
\]</span></p>
<p><span class="math inline">\(c_1,c_2\)</span> herhangi birer sabittir. Bu ifade tanıdık gelmiştir herhalde, genel çözüm &quot;özçözümlerin'' lineer bir kombinasyonudur.</p>
<p>Bunlar üstteki resmimiz için ne anlama geliyor? Mesela bir çizgi üzerindeysek ve orada <span class="math inline">\(\lambda_1 &gt; 0\)</span> ise, orijinden uzaklaşacak şekilde hareket ediyoruz,</p>
<div class="figure">
<img src="05_08.png" />

</div>
<p>Orijindeki sabit noktanın gayrı stabil olduğunu görüyoruz. Fakat diğer &quot;özyön'' için <span class="math inline">\(\lambda &lt; 0\)</span>, bu üstel bir çürüme var demektir,</p>
<div class="figure">
<img src="05_09.png" />

</div>
<p>Olanlar eğer noktası tanımına tam uygun, bir sabit noktaya hem giden hem de ondan kaçan gidiş yolları var. Diğer düz olmayan gidiş yolları da üsttekine uyumlu olarak şu şekilde olurdu,</p>
<div class="figure">
<img src="05_10.png" />

</div>
<p>Kıvrımlı gidiş yollarını doldururken negatif ve pozitif sonsuzluğa giderken görülecek davranışı düşünürüz, mesela üst sağ kısmında yukarı giden eğri üst sağ yukarı doğru giden düz çizgiye yaklaşır, sonuşur (asymptotic) davranışı budur.</p>
<p>Çizgilerden 1.'sine stabil özyön, 2.'sine gayrı stabil özyön ismi de verilir.</p>
<p>Durum 2) Çeken (ve İten) Sabit Noktalar</p>
<p>Altta sadece çeken noktaları göstereceğim - iten durum topolojik olarak aynı, tek fark okların terse çevirilmiş olması. Çeken noktaları karakterize eden bir özellik <span class="math inline">\(\Delta &gt; 0\)</span>, <span class="math inline">\(\tau &lt; 0\)</span>. İtenler için ise <span class="math inline">\(\Delta &gt; 0\)</span>, <span class="math inline">\(\tau &gt; 0\)</span>.</p>
<p>Bazı alt durumlar var,</p>
<p>Durum 2a) Düğümler (Nodes)</p>
<p>Düğümleri kontrol eden karekök mevcudiyetidir, eğer bir karekök var ise, bir düğüm var demektir, yani <span class="math inline">\(\tau^2 - 4\Delta &gt; 0\)</span> ise. Bu durumda her iki <span class="math inline">\(\lambda\)</span> reel olurdu, işaretleri de aynı olurdu.</p>
<p>Başka bir durumu görelim. Diyelim ki <span class="math inline">\(\lambda_1 &lt; \lambda_2 &lt; 0\)</span>, ve <span class="math inline">\(\underline{v}_1\)</span>, <span class="math inline">\(\underline{v}_2\)</span> hala bağımsız.</p>
<div class="figure">
<img src="05_11.png" />

</div>
<p>Yine iki özyön var ama bu sefer gidiş stabil noktaya doğru. Dikkat gösterilen çizgiler <span class="math inline">\(\underline{v}_1\)</span>, <span class="math inline">\(\underline{v}_2\)</span> vektörlerinin kendisi değil, onların her türlü tek sayısal çarpımdan gelen katlarından oluşan bir uzay, yani &quot;özuzay''.</p>
<p><span class="math inline">\(\lambda_1\)</span> daha negatif demiştik, o zaman <span class="math inline">\(\underline{v}_1\)</span>'in çürümesi daha hızlı (fast decay) olacaktır, <span class="math inline">\(\underline{v}_2\)</span> daha yavaş (slow decay) olacaktır. Diger eğrileri de eklersek,</p>
<div class="figure">
<img src="05_12.png" />

</div>
<p>Üstteki resim stabil bir noktaya yakın olduğumuzdaki hali gösteriyor.</p>
<p>Bir noktayı daha vurgulamak isterim, belki resimden bariz anlaşılmamıştır; <span class="math inline">\(t\to\infty\)</span> tipik gidiş yolları yavaş yola teğet olacak şekilde <span class="math inline">\(x^\ast\)</span>'ya yaklaşır. Eğer zamanı geri sararsam, <span class="math inline">\(t\to-\infty\)</span> iken, bu ters gidiş hızlı yöne paralel olur.</p>
<p>Durum 2b) Sarmallar (Spirals)</p>
<p>Bu durumda <span class="math inline">\(\Delta &gt; 0\)</span>, ve nagatif iz <span class="math inline">\(\tau &lt; 0\)</span>, onları çeken (attracting) hale getiren bu. <span class="math inline">\(\tau^2 - 4\Delta &lt; 0\)</span> olur, o zaman kökler, <span class="math inline">\(\lambda\)</span>'lar, kompleks, ve özdeğerler reel olmayacak. Faz portresi için kompleks özvektörlerle ilgilenmiyoruz, portrede sadece reel özvektörler görünür. Özdeğerler birbirinin kompleks eşleniği olarak tabii ki belli ve birbirinden ayrıdır (distinct), <span class="math inline">\(\lambda = \mu \pm i\omega\)</span> formunda gösterelim onları.</p>
<p><span class="math inline">\(\mu,\omega\)</span>'nin güzel fiziksel yorumlaması yapılabiliyor. <span class="math inline">\(\mu &lt; 0\)</span> durumu çürüme oranını kontrol ediyor, <span class="math inline">\(\omega\)</span> ise sarmalın dönme oranını temsil ediyor. Eğer <span class="math inline">\(x(t)\)</span> çözümlerini yazarsak, lıneer cebir bize <span class="math inline">\(\underline{x}\)</span>'in her bileşeni <span class="math inline">\(e^{\mu t} \cos \omega t\)</span> ve <span class="math inline">\(e^{\mu t} \sin \omega t\)</span>'nin bir lineer kombinasyonu. Bu şekildeki formüller eğer önceden sönümlü harmonik titreşirler (damped harmonic oscillator) konusunu öğrendiyseniz tanıdık gelecektir. Üstel terimle çürüme var, ve <span class="math inline">\(\sin\)</span> ya da <span class="math inline">\(\cos\)</span> üzerinden salınım terimi var. O zaman sarmallar sonumlu titreşirler geometrik karşılığıdır.</p>
<p><span class="math inline">\(x,y\)</span> düzleminde tipik bir gidiş yolu suna benzer,</p>
<div class="figure">
<img src="05_13.png" />

</div>
<p>Görüntüde bir sarmal var, isim ondan seçilmiş zaten. Alttan bir gidiş yolu daha katılabilir,</p>
<div class="figure">
<img src="05_14.png" />

</div>
<p>İnsanların çoğu zaman aklına &quot;sarmalın hangi yöne döndüğünü nasıl bileceğim?'' sorusu geliyor. Üstte çizdiğim şekil saat yönü bir dönüşü gösteriyor, bunu nereden biliyordum? Bu bilgi <span class="math inline">\(\tau,\Delta\)</span> ya da <span class="math inline">\(\lambda\)</span>'dan gelmiyor, vektör alanına bakmak lazım. Tavsiyem tek bir vektörü hesaplamak,</p>
<div class="figure">
<img src="05_15.png" />

</div>
<p>Üst sağda görüldüğü gibi, ve o vektörün yönüne bakmak. O yön hangisi ise dönüşün o yönde olduğu anlaşılabilir.</p>
<p>Soru</p>
<p>Stabil, gayrı-stabil düğümlerin olduğu gibi stabil ya da gayrı-stabil sarmallar da olabilir mi?</p>
<p>Cevap</p>
<p>Evet, okların yönünü değiştirerek bunu elde ederiz, mesela biraz önceki örnekte</p>
<div class="figure">
<img src="05_16.png" />

</div>
<p>Bu gayrı-stabil bir sarmal. Eğer <span class="math inline">\(x,y\)</span> eksenlerine tekabül eden <span class="math inline">\(x,t\)</span> zaman serisini çıkartacak olsam, alt sağdaki grafik olurdu - büyüyen bir salınım.</p>
<p>Soru</p>
<p>Sarmalı yuvarlak bir şekilde çizdiniz, şekil gerçekten böyle mi?</p>
<p>Cevap</p>
<p>Güzel soru, aslında sarmalı daha eliptik bir şekilde çizmek lazım, mesela üstten daha basık bir yuvarlak.</p>
<p>Devam edelim; sarmalların özel bir hali <span class="math inline">\(\mu = 0\)</span> olduğu zamandır. Bu durumda neler olduğuna bakalım,</p>
<p>Durum 3) Merkez (Center)</p>
<p>Bu durumda <span class="math inline">\(\Delta &gt; 0\)</span>, <span class="math inline">\(\tau = 0\)</span> ve <span class="math inline">\(\lambda = \pm i\omega\)</span>, yani pür hayali. Merkez halinde her gidiş yolu kapalı, tipik bir resim şuna benzer,</p>
<div class="figure">
<img src="05_17.png" />

</div>
<p>Gidiş yollarının hepsi aynı yöne işaret ediyor.</p>
<p>Merkez'in en iyi bilinen örneklerinden biri, sönümsüz basit harmonik titreşirlerin faz portresini çizince bu şekil çıkar, <span class="math inline">\(\ddot{x} + x = 0\)</span> sistemini bir faz düzlem resmine çevirince mesela. Bu sistemin resminde tam çemberler olur. Çizelim,</p>
<p><span class="math display">\[ y = \dot{x} \]</span></p>
<p>olsun,</p>
<p><span class="math display">\[ \dot{x} = y \]</span></p>
<p>O zaman</p>
<p><span class="math display">\[ \dot{y} = -x \]</span></p>
<p>İlk önce eksenlerden çıkan okları çizeriz, onları taslaklamak kolay, ardından birkaç tane diğer yerlerden ekleriz,</p>
<div class="figure">
<img src="05_18.png" />

</div>
<p>Soru</p>
<p>Gidiş yolları bir sabit noktaya yaklaşır mı?</p>
<p>Cevap</p>
<p>Hayır, her gidiş yolu kapalı, yani gidip gidip kendilerine dönüyorlar. Orijinde bir sabit nokta var, fakat diğer tüm gidiş yolları onun etrafında bir kapalı yörüngede.</p>
<p>Bu örnek mükemmel periyotsal hareketi gösterdi, hatta her başlangıç şartı için periyot olan bir örnek görmüş olduk. Gayrı-lineer sistemlerde bu çoğunlukla ortaya çıkmaz, eğer muhafaza edilen enerji gibi ek bir özellik ortada yoksa yani. Fakat bu tür lineer sistemlerde üstteki görüntü rahat bir şekilde ortaya çıkabiliyor.</p>
<p>Durum 4)</p>
<p>Bu çok acaip bir durum. Eğer <span class="math inline">\(\Delta = 0\)</span> ise o zaman matrisin determinantı sıfır demektir, ve sabit nokta bulmak için <span class="math inline">\(A \underline{x} = 0\)</span>'i çözmeye uğraşırken bir özgün çözüm bulamayız. Mümkün çözümü oluşturan tüm sabit noktalar bir çizgi, hatta bir düzlem oluşturacaklardır. Düzlem, yani o düzlemdeki her nokta sabit - bu çok sıkıcı bir dinamik sistem. <span class="math inline">\(\dot{\underline{x}}=0\)</span>. Nerede olursan ol, hiç hareket edemiyorsun. Bu sistemin analizi çok kolay (!). Çizgide sabit noktalar belki biraz daha ilginç, alttaki gibi bir durum olabilir mesela,</p>
<div class="figure">
<img src="05_19.png" />

</div>
<p>Çok yaygın olmasa da ortaya çıkabiliyor. Üstteki duruma &quot;<span class="math inline">\(\underline{0}\)</span>'da izole olmayan sabit nokta durumu'' ismi verilir, çünkü orijinin yakınında diğer sabit noktalar var.</p>
<p>Bir durum daha var, onların üzerinde çok durmayacağım çünkü pratikte karşımıza çok çıkmıyorlar. <span class="math inline">\(\tau^2 - 4\Delta = 0\)</span> durumu bu, onun için kitabıma [1] danışabilirsiniz. Burada tekrarlanan kökler var, ve dejenere düğümler ortaya çıkabiliyor. Her yön bir özyön oluyor, ve mesela tüm gidiş yolları düz bir şekilde tek bir sabit noktaya akıyorlar, bir yıldız şekli oluşturuyorlar. Ya da tek bir özyön var, mesela</p>
<p><span class="math display">\[ \left[\begin{array}{rr}
\lambda &amp; 1 \\ 0 &amp; \lambda
\end{array}\right] \]</span></p>
<p>matrisinin özvektör / değerleri bunu verir. Kontrol edebilirsiniz, üstteki matrisin iki değil sadece bir tane özyönü var. Alttaki resimde üst sağda yıldız, alt sağda tek özyön durumu gösteriliyor. Mekanik bağlamında bu durum kritik sönümlüdür (critically damped).</p>
<div class="figure">
<img src="05_21.png" />

</div>
<p>Büyük bitiş anına geldik. İşlediğimiz tüm farklı durumları akılda tutmak biraz zor, alttaki diyagram belki yardımcı olabilir. Eksenler <span class="math inline">\(\tau,\Delta\)</span>. Bu eksenler üzerinden <span class="math inline">\(\tau^2 - 4\Delta = 0\)</span>'i çizeriz, bu bir yana yatık paraboldur, ve aynı zamanda farklı durumları birbirinden ayıran bir sınır çizgisidir.</p>
<div class="figure">
<img src="05_20.png" />

</div>
<p>Orijinde düzlem sabit noktaları (plane of fixed points) var, <span class="math inline">\(\tau\)</span> ekseninin tamamı çizgi üzerinde sabit noktalar (line of fixed points).</p>
<p>Örnek 5.1.2 [2]</p>
<p>Lineer sistem <span class="math inline">\(\dot{x} = Ax\)</span>'i çözün ki <span class="math inline">\(A = \left[\begin{array}{rr}a&amp;0\\0&amp;-1\end{array}\right]\)</span>. Faz portrelerini <span class="math inline">\(a\)</span>, <span class="math inline">\(-\infty\)</span> ile <span class="math inline">\(\infty\)</span> arasında giderkenki halini çizin.</p>
<p>Çözüm</p>
<p><span class="math display">\[ 
\left[\begin{array}{r}
\dot{x} \\ \dot{y} 
\end{array}\right]
=
\left[\begin{array}{rr}
a &amp; 0 \\ 0 &amp; -1
\end{array}\right]
\left[\begin{array}{r}
x \\ y
\end{array}\right]
\]</span></p>
<p>Matris çarpımı</p>
<p><span class="math display">\[ \dot{x} = ax\]</span></p>
<p><span class="math display">\[ \dot{y} = -y\]</span></p>
<p>sonucunu veriyor. Demek ki bu iki denklem bağlantısız (uncoupled), <span class="math inline">\(x\)</span> denkleminde <span class="math inline">\(y\)</span> yök, ve tersi de doğru. O zaman bu sistem ayrı ayrı çözülebilir,</p>
<p><span class="math display">\[ x(t) = x_0 e^{at}\]</span></p>
<p><span class="math display">\[ y(t) = y_o e^{-t}\]</span></p>
<p>Farklı <span class="math inline">\(a\)</span>'lar için faz portreleri alttadır,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np
<span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt
x,y <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">10</span>,<span class="dv">10</span>,<span class="dv">100</span>),np.linspace(<span class="op">-</span><span class="dv">10</span>,<span class="dv">10</span>,<span class="dv">100</span>)
X,Y <span class="op">=</span> np.meshgrid(x,y)

<span class="kw">def</span> plot_g(a, fout):
   <span class="co">#a = -.5</span>
   U <span class="op">=</span> a<span class="op">*</span>X
   V <span class="op">=</span> <span class="op">-</span>Y
   speed <span class="op">=</span> np.sqrt(U<span class="op">*</span>U <span class="op">+</span> V<span class="op">*</span>V)
   start <span class="op">=</span> [[<span class="dv">2</span>,.<span class="dv">75</span>]]
   fig0, ax0 <span class="op">=</span> plt.subplots()
   strm <span class="op">=</span> ax0.streamplot(x,y, U, V, color<span class="op">=</span>(.<span class="dv">75</span>,.<span class="dv">90</span>,.<span class="dv">93</span>), linewidth<span class="op">=</span>.<span class="dv">5</span>)
   strmS <span class="op">=</span> ax0.streamplot(x,y, U, V, start_points<span class="op">=</span>start, color<span class="op">=</span><span class="st">&quot;crimson&quot;</span>, linewidth<span class="op">=</span><span class="dv">1</span>)
   ax0.set_xlabel(<span class="vs">r&#39;$ \dot</span><span class="sc">{x}</span><span class="vs"> $&#39;</span>,size<span class="op">=</span><span class="dv">14</span>)
   ax0.set_ylabel(<span class="vs">r&#39;$ \dot</span><span class="sc">{v}</span><span class="vs"> $&#39;</span>,size<span class="op">=</span><span class="dv">14</span> )
   ax0.text(<span class="op">-</span><span class="dv">5</span>,<span class="dv">5</span>,<span class="st">&#39;a = </span><span class="sc">{0}</span><span class="st">&#39;</span>.<span class="bu">format</span>(a))
   plt.savefig(fout)

plot_g(<span class="op">-</span><span class="fl">2.0</span>, <span class="st">&#39;05_22.png&#39;</span>)
plot_g(<span class="op">-</span><span class="fl">1.0</span>, <span class="st">&#39;05_23.png&#39;</span>)
plot_g(<span class="op">-</span><span class="fl">0.5</span>, <span class="st">&#39;05_24.png&#39;</span>)
plot_g(<span class="fl">0.0</span>, <span class="st">&#39;05_25.png&#39;</span>)
plot_g(<span class="fl">1.0</span>, <span class="st">&#39;05_26.png&#39;</span>)</code></pre></div>
<p><img src="05_22.png" /> <img src="05_23.png" /></p>
<p><img src="05_23.png" /> <img src="05_25.png" /></p>
<div class="figure">
<img src="05_26.png" />

</div>
<p>Örnek 5.2.1 [2]</p>
<p><span class="math inline">\(\dot{x} = x + y\)</span>, <span class="math inline">\(\dot{y} = 4x-2y\)</span> problemini çözün, başlangıç şartları <span class="math inline">\((x_0,y_0) = (2,-3)\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np
<span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt

a<span class="op">=</span><span class="dv">1</span><span class="op">;</span>b<span class="op">=</span><span class="dv">1</span><span class="op">;</span>c<span class="op">=</span><span class="dv">4</span><span class="op">;</span>d<span class="op">=-</span><span class="dv">2</span><span class="op">;</span>s1<span class="op">=</span><span class="dv">2</span><span class="op">;</span>s2<span class="op">=-</span><span class="dv">3</span>
x,y <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">10</span>,<span class="dv">10</span>,<span class="dv">100</span>),np.linspace(<span class="op">-</span><span class="dv">10</span>,<span class="dv">10</span>,<span class="dv">100</span>)
X,Y <span class="op">=</span> np.meshgrid(x,y)
A <span class="op">=</span> np.array([[a,b],[c,d]])

U <span class="op">=</span> A[<span class="dv">0</span>,<span class="dv">0</span>]<span class="op">*</span>X <span class="op">+</span>A[<span class="dv">0</span>,<span class="dv">1</span>]<span class="op">*</span>Y
V <span class="op">=</span> A[<span class="dv">1</span>,<span class="dv">0</span>]<span class="op">*</span>X <span class="op">+</span> A[<span class="dv">1</span>,<span class="dv">1</span>]<span class="op">*</span>Y

w,v <span class="op">=</span> np.linalg.eig(A)
v <span class="op">=</span> np.<span class="bu">round</span>(v,<span class="dv">2</span>)
w <span class="op">=</span> np.<span class="bu">round</span>(w,<span class="dv">2</span>)
eigvects <span class="op">=</span> np.dot(A,v)

speed <span class="op">=</span> np.sqrt(U<span class="op">*</span>U <span class="op">+</span> V<span class="op">*</span>V)

start <span class="op">=</span> [[s1,s2]]

fig0, ax0 <span class="op">=</span> plt.subplots(<span class="dv">1</span>,<span class="dv">1</span>,figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">8</span>))
ax0.set_aspect(<span class="st">&#39;equal&#39;</span>)
strm <span class="op">=</span> ax0.streamplot(x,y, U, V, color<span class="op">=</span>(.<span class="dv">75</span>,.<span class="dv">90</span>,.<span class="dv">93</span>), linewidth<span class="op">=</span>.<span class="dv">5</span>)
strmS <span class="op">=</span> ax0.streamplot(x,y, U, V, start_points<span class="op">=</span>start, color<span class="op">=</span><span class="st">&quot;crimson&quot;</span>, linewidth<span class="op">=</span><span class="dv">1</span>)
ax0.plot(start[<span class="dv">0</span>][<span class="dv">0</span>],start[<span class="dv">0</span>][<span class="dv">1</span>],<span class="st">&#39;go&#39;</span>)
ax0.set_xlim(<span class="op">-</span><span class="dv">10</span>,<span class="dv">10</span>)
ax0.set_ylim(<span class="op">-</span><span class="dv">10</span>,<span class="dv">10</span>)
ax0.plot(x,eigvects[<span class="dv">1</span>,<span class="dv">0</span>]<span class="op">/</span>eigvects[<span class="dv">0</span>,<span class="dv">0</span>]<span class="op">*</span>x,<span class="st">&#39;b&#39;</span>,alpha<span class="op">=</span>.<span class="dv">7</span>)
ax0.plot(x,eigvects[<span class="dv">1</span>,<span class="dv">1</span>]<span class="op">/</span>eigvects[<span class="dv">0</span>,<span class="dv">1</span>]<span class="op">*</span>x,<span class="st">&#39;b&#39;</span>,alpha<span class="op">=</span>.<span class="dv">7</span>)
ax0.set_xlabel(<span class="vs">r&#39;$ \dot</span><span class="sc">{x}</span><span class="vs"> $&#39;</span>,size<span class="op">=</span><span class="dv">14</span>)
ax0.set_ylabel(<span class="vs">r&#39;$ \dot</span><span class="sc">{y}</span><span class="vs"> $&#39;</span>,size<span class="op">=</span><span class="dv">14</span> )
ax0.text(<span class="op">-</span><span class="dv">9</span>,<span class="dv">8</span>,<span class="vs">r&#39;$\dot</span><span class="sc">{0}</span><span class="vs">$ = </span><span class="sc">{1}</span><span class="vs">x + </span><span class="sc">{2}</span><span class="vs">y&#39;</span>.<span class="bu">format</span>(<span class="st">&#39;x&#39;</span>,A[<span class="dv">0</span>,<span class="dv">0</span>],A[<span class="dv">0</span>,<span class="dv">1</span>]))
ax0.text(<span class="op">-</span><span class="dv">9</span>,<span class="dv">7</span>,<span class="st">&#39;$\dot</span><span class="sc">{0}</span><span class="st">$ = </span><span class="sc">{1}</span><span class="st">x +</span><span class="sc">{2}</span><span class="st"> y&#39;</span>.<span class="bu">format</span>(<span class="st">&#39;y&#39;</span>,A[<span class="dv">1</span>,<span class="dv">0</span>],A[<span class="dv">1</span>,<span class="dv">1</span>]))
ax0.text(<span class="op">-</span><span class="dv">9</span>,<span class="dv">6</span>,<span class="vs">r&#39;$(x_0,y_0)$ = (</span><span class="sc">{0}</span><span class="vs">, </span><span class="sc">{1}</span><span class="vs">)&#39;</span>.<span class="bu">format</span>(start[<span class="dv">0</span>][<span class="dv">0</span>],start[<span class="dv">0</span>][<span class="dv">1</span>]))
ax0.text(<span class="op">-</span><span class="dv">9</span>,<span class="dv">5</span>,<span class="st">&#39;$\lambda$ = </span><span class="sc">{0}</span><span class="st">, </span><span class="sc">{1}</span><span class="st"> &#39;</span>.<span class="bu">format</span>(w[<span class="dv">0</span>],w[<span class="dv">1</span>]))
ax0.text(<span class="op">-</span><span class="dv">9</span>,<span class="dv">4</span>,<span class="st">&#39;Eigenvectors = </span><span class="sc">{0}</span><span class="st">, </span><span class="sc">{1}</span><span class="st">&#39;</span>.<span class="bu">format</span>(v[<span class="dv">0</span>].T,v[<span class="dv">1</span>].T))
ax0.text(<span class="op">-</span><span class="dv">9</span>,<span class="op">-</span><span class="dv">9</span>,<span class="st">&#39;General solution = c_1</span><span class="sc">{0}</span><span class="st">e^(</span><span class="sc">{1}</span><span class="st">t) + c_2</span><span class="sc">{2}</span><span class="st">e^(</span><span class="sc">{3}</span><span class="st">t)$&#39;</span>.<span class="bu">format</span>(v[<span class="dv">0</span>],w[<span class="dv">0</span>],v[<span class="dv">1</span>],w[<span class="dv">1</span>]))
plt.grid()
plt.savefig(<span class="st">&#39;05_27.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="05_27.png" />

</div>
<p>Kaynaklar</p>
<p>[1] Strogatz, <em>Nonlinear Dynamics and Chaos</em></p>
</body>
</html>
