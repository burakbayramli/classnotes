<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Döndürme (Rotation) - 1</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="döndürme-rotation---1">Döndürme (Rotation) - 1</h1>
<p>Herhangi bir boyutta döndürme işlemi, yani bir noktayı ya da bir vektörün yönünü değiştirmek lineer cebirsel bir matris çarpım işlemi üzerinden hesaplanabilir. Daha önce [2]'de gördüğümüz baz değiştirme tekniği burada da geçerli. Baz değiştirme de iki boyutta <span class="math inline">\(i\)</span>,<span class="math inline">\(j\)</span>, ya da <span class="math inline">\([\begin{array}{cc} 0 &amp; 1 \end{array}]\)</span> ve <span class="math inline">\([\begin{array}{cc} 1 &amp; 0 \end{array}]\)</span> vektörlerinin yeni bir yöne işaret etmesi ve bu değişim sırasında ilk uzaydaki şeklin bu değişimle beraber değişmesi olarak görülebilir. Bu yeni bazı kolonlarında taşıyan şey ise bir nevi döndürme matrisi <span class="math inline">\(R\)</span>'dir.</p>
<p>Not: Bu matrisin her zaman dikgen olacağını görmek zor değil, çünkü yamultma, kesme olmadan, direk <span class="math inline">\(i,j,k\)</span> baz vektörlerini belli bir şekilde yeni yerlere taşıyoruz, bu taşıma sonucunda tabii ki yeni yerlerinde de bu baz vektörler birbirine dik olacaktır, ve onları içeren döndürme matrisi de ortonormal, dikgen halde olacaktır.</p>
<p>Eğer bir vektörü 90 derece saat yönü tersine döndürmek isteseydik, yeni baz nasıl olurdu? <span class="math inline">\(i\)</span>'yi kaldırıp tam yukarı işaret ettirmek lazım, o zaman <span class="math inline">\([\begin{array}{cc} 0 &amp; 1 \end{array}]^T\)</span>, <span class="math inline">\(j\)</span> ise aynı şekilde sola yatırılmalı, <span class="math inline">\([\begin{array}{cc} -1 &amp; 0 \end{array}]\)</span>. Rotasyon matrisi,</p>
<p><span class="math display">\[
R = \left[\begin{array}{rr}
0 &amp; -1 \\ 1 &amp; 0
\end{array}\right]
\]</span></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">v <span class="op">=</span> np.array([<span class="dv">1</span>,<span class="dv">1</span>])
plt.quiver(<span class="dv">0</span>,<span class="dv">0</span>,v[<span class="dv">0</span>],v[<span class="dv">1</span>],scale<span class="op">=</span><span class="dv">5</span>)
R <span class="op">=</span> np.array([[<span class="dv">0</span>, <span class="dv">-1</span>],[<span class="dv">1</span>,<span class="dv">0</span>]])
vnew <span class="op">=</span> np.dot(R, v)
plt.quiver(<span class="dv">0</span>,<span class="dv">0</span>,vnew[<span class="dv">0</span>],vnew[<span class="dv">1</span>],scale<span class="op">=</span><span class="dv">5</span>,color<span class="op">=</span><span class="st">&#39;red&#39;</span>)
plt.xlim(<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>)
plt.ylim(<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>)
plt.grid(<span class="va">True</span>)
plt.savefig(<span class="st">&#39;phy_072_rot_04.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="phy_072_rot_04.png" />

</div>
<p>Doksan derece dönüş görülüyor.</p>
<p>Peki doksan derece değil <span class="math inline">\(\theta\)</span> kadar bir saat yönü tersi döndürüşü nasıl temsil edilebilirdi? Yine bazın nereye gittiğine bakıyoruz,</p>
<div class="figure">
<img src="phy_072_rot_03.png" />

</div>
<p>Eğer <span class="math inline">\(i\)</span>'yi kaldırıp <span class="math inline">\(i&#39;\)</span> haline getirirsek bu yeni vektörün <span class="math inline">\([\cos\theta,\sin\theta]\)</span> durumuna gelmesi, <span class="math inline">\(j\)</span>'yi döndürüp <span class="math inline">\(j&#39;\)</span> yapınca <span class="math inline">\([-\sin\theta,\cos\theta]\)</span> haline gelmesi demektir. Dönüş matrisi,</p>
<p><span class="math display">\[
R = \left[\begin{array}{rr}
\cos\theta &amp; -\sin\theta \\
\sin\theta &amp; \cos\theta
\end{array}\right]
\]</span></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">theta <span class="op">=</span> np.deg2rad(<span class="dv">20</span>)
v <span class="op">=</span> np.array([<span class="dv">1</span>,<span class="dv">1</span>])
plt.quiver(<span class="dv">0</span>,<span class="dv">0</span>,v[<span class="dv">0</span>],v[<span class="dv">1</span>],scale<span class="op">=</span><span class="dv">5</span>)
R <span class="op">=</span> np.array([[np.cos(theta), <span class="op">-</span>np.sin(theta)],[np.sin(theta),np.cos(theta)]])
vnew <span class="op">=</span> np.dot(R, v)
plt.quiver(<span class="dv">0</span>,<span class="dv">0</span>,vnew[<span class="dv">0</span>],vnew[<span class="dv">1</span>],scale<span class="op">=</span><span class="dv">5</span>,color<span class="op">=</span><span class="st">&#39;red&#39;</span>)
plt.xlim(<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>)
plt.ylim(<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>)
plt.grid(<span class="va">True</span>)
plt.savefig(<span class="st">&#39;phy_072_rot_05.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="phy_072_rot_05.png" />

</div>
<p>Euler Açıları (Euler Angles)</p>
<p>Bir katı gövdenin, ya da aerodinamik simülasyonda uçağın, bir arabanın hangi yöne baktığını (orientation) temsil etmek için Euler açıları yaygın şekilde kullanılır. Bu açılar herhangi bir, ne kadar çetrefil olursa olsun dönüşün, peşpeşe, her eksen etrafında uygulanabilecek üç tane ardı ardına yapılan döndürme ile temsil edilebileceğinden hareketle bulunmuştur. Mesela altta ardı ardına YXZ eksenleri üzerinde yapılan döndürme gösteriliyor.</p>
<div class="figure">
<img src="phy_072_rot_06.png" />

</div>
<p>Genelde kullanım kalıbı ZYX ya da ZXZ üzerinden yapılır. Altta ZXZ örneğini göreceğiz. Herhangi bir eksen etrafındaki dönüş tek bir dönüş matrisi ile gösterilebilir, mesela Z etrafındaki <span class="math inline">\(\phi\)</span> kadar bir dönüş <span class="math inline">\(D\)</span> matrisinde olsun [1, sf 153],</p>
<p><span class="math display">\[
D = \left[\begin{array}{rrr}
\cos \phi &amp; \sin\phi &amp; 0 \\
-\sin \phi &amp; \cos\phi &amp; 0 \\
0 &amp; 0 &amp; 1
\end{array}\right]
\]</span></p>
<p>O zaman <span class="math inline">\(z\)</span> ekseni etrafındaki bir dönüş</p>
<p><span class="math display">\[
\bar{x}&#39; = D \bar{x}
\]</span></p>
<p>yani <span class="math inline">\(\bar{x} = [x, y, z]\)</span> döndürülerek <span class="math inline">\(\bar{x}&#39; = [x&#39;, y&#39;, z&#39;]\)</span> elde edildi.</p>
<p>Şimdi <span class="math inline">\(x&#39;\)</span> ekseni etrafında <span class="math inline">\(\theta\)</span> kadar döndürüyoruz, bunu <span class="math inline">\(C\)</span> ile yapalım,</p>
<p><span class="math display">\[
C = \left[\begin{array}{rrr}
1 &amp; 0 &amp; 0 \\
0 &amp; \cos\theta &amp; \sin\theta \\
0 &amp; -\sin\theta &amp; \cos\theta
\end{array}\right]
\]</span></p>
<p><span class="math display">\[
\bar{x}&#39;&#39; = C \bar{x}&#39;
\]</span></p>
<p>Ve son olarak <span class="math inline">\(\bar{x}&#39;&#39; = [x&#39;&#39;,y&#39;&#39;,z&#39;&#39;]\)</span> içindeki <span class="math inline">\(z&#39;&#39;\)</span> etrafında <span class="math inline">\(\psi\)</span> kadar döndürüyoruz, bunu <span class="math inline">\(B\)</span> ile yapalım,</p>
<p><span class="math display">\[
B = \left[\begin{array}{rrr}
\cos \psi &amp; \sin\psi &amp; 0 \\
-\sin \psi &amp; \cos\psi &amp; 0 \\
0 &amp; 0 &amp; 1
\end{array}\right]
\]</span></p>
<p><span class="math display">\[
\bar{x}_f = B \bar{x}&#39;&#39;
\]</span></p>
<p>Tüm bu matris çarpımlarını tek bir satırda</p>
<p><span class="math display">\[
\bar{x}_f =  B C D \bar{x}
\]</span></p>
<p>ile yapabilirdik, ya da</p>
<p><span class="math display">\[
\bar{x}_f =  A \bar{x}
\]</span></p>
<p>olarak ki <span class="math inline">\(A = BCD\)</span> olmak üzere.. Bu <span class="math inline">\(A\)</span> matrisinin içeriği neye benzerdi? Cebirsel olarak <span class="math inline">\(BCD\)</span> çarpımını gerçekleştirince,</p>
<p><span class="math display">\[
A = \left[\begin{array}{ccc}
\cos\psi\cos\phi-\cos\theta\sin\phi\sin\psi &amp;
\cos\psi\sin\phi + \cos\theta\cos\phi\sin\psi &amp;
\sin\psi\sin\theta \\
-\sin\psi\cos\phi-\cos\theta\sin\phi\cos\psi &amp;
-\sin\psi\sin\phi + \cos\theta\cos\phi\cos\psi &amp;
\cos\psi\sin\theta \\
\sin\theta \sin\phi &amp;
-\sin\theta\cos\phi &amp;
\cos\theta
\end{array}\right]
\]</span></p>
<p>Not: dikkat edelim, eksenlerde ardı ardına yapılan rotasyonların birleşimi sırabağımsız değil, mesela alttaki iki döndürme, aynı temel döndürmeleri yapıyor olsalar da farklı sıralarda yaptıkları için farklı sonuçları veriyorlar,</p>
<div class="figure">
<img src="phy_072_rot_01.png" />

</div>
<div class="figure">
<img src="phy_072_rot_02.png" />

</div>
<p>Tabii üstteki durum lineer cebirin mantığı ile uyumlu, çünkü matris çarpımı da sırabağımsız değildir.</p>
<p>Paket</p>
<p>Kütüphane <code>scipy</code> içinde faydalı kodlar var, mesela <code>scipy.spatial.transform</code> içinde,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> scipy.spatial.transform <span class="im">import</span> Rotation <span class="im">as</span> R

r <span class="op">=</span> R.from_euler(<span class="st">&#39;zyx&#39;</span>, [<span class="dv">90</span>, <span class="dv">45</span>, <span class="dv">30</span>], degrees<span class="op">=</span><span class="va">True</span>)
<span class="bu">print</span> (np.<span class="bu">round</span>(r.as_matrix(),<span class="dv">2</span>))</code></pre></div>
<pre><code>[[ 0.   -0.71  0.71]
 [ 0.87 -0.35 -0.35]
 [ 0.5   0.61  0.61]]</code></pre>
<p>Rodriguez Matrisleri</p>
<p>Genel olarak rotasyon bir eksen ve o eksen etrafındaki bir açı olarak gösterilebilir,</p>
<div class="figure">
<img src="phy_072_rot_08.png" />

</div>
<p>Ya da rotasyon eksenini <span class="math inline">\(\hat{n}\)</span> olarak gösterelim, ve dönüşün o eksene dikgen olan bir düzlem üzerinde olduğunu düşünelim [4, sf. 37],</p>
<div class="figure">
<img src="phy_072_rot_07.png" />

</div>
<p>Yani <span class="math inline">\(v\)</span> vektörü, <span class="math inline">\(\hat{n}\)</span> etrafında <span class="math inline">\(\theta\)</span> kadar dönüp <span class="math inline">\(u\)</span> olacak. <span class="math inline">\(\hat{n}\)</span> birim vektör, ve dikgen olduğu düzlemi tanımlamak için kullanılıyor.</p>
<p><span class="math inline">\(v\)</span>'nin dönüşten etkilenmeyen bileşeni <span class="math inline">\(v_\parallel\)</span>'yi hesaplamak için <span class="math inline">\(v\)</span>'nin <span class="math inline">\(\hat{n}\)</span> üzerine olan yansımasını (projection) hesaplayabiliriz. Yansıtma formülü, bkz [5],</p>
<p><span class="math display">\[ v_\parallel =  \frac{\hat{n}\hat{n}^T}{\hat{n}^T\hat{n}} v 
= (\hat{n}\hat{n}^T) v
\]</span></p>
<p>Peki <span class="math inline">\(v\)</span>'nin düzlem üzerindeki yansıması <span class="math inline">\(v_\perp\)</span> nedir? Resme göre <span class="math inline">\(v = v_\perp + v_\parallel\)</span> olduğuna göre ve üstteki formülü yerine koyunca,</p>
<p><span class="math display">\[ v_\perp = v - v_\parallel 
= v - (\hat{n}\hat{n}^T) v 
= (I - \hat{n}\hat{n}^T) v
\]</span></p>
<p>Burada <span class="math inline">\(v_\perp\)</span>'in 90 derece çevrilmiş hali <span class="math inline">\(v_x\)</span> nedir? Aslında bu <span class="math inline">\(\hat{n} \times v\)</span> olmalı, sağ el kuralıyla bu görülebilir. Eğer <span class="math inline">\(N\)</span> matrisini <span class="math inline">\(\hat{n}\)</span>'i baz alan bir eksi bakışımlı matris olarak alırsak,</p>
<p><span class="math display">\[ v_x = \hat{n} \times v = Nv \]</span></p>
<p>ki <span class="math inline">\(\hat{n}\)</span> öğeleri <span class="math inline">\(\hat{n}_x,\hat{n}_y,\hat{n}_z\)</span> olacak şekilde</p>
<p><span class="math display">\[ 
N = \left[\begin{array}{rrr}
0 &amp; -\hat{n}_x  &amp; \hat{n}_y \\
\hat{n}_z &amp; 0 &amp; -\hat{n}_x \\
-\hat{n}_y &amp; \hat{n}_z &amp; 0
\end{array}\right]
\]</span></p>
<p>Eğer <span class="math inline">\(v_\perp\)</span>'u tekrar saat yönü tersinde 90 derece döndürmek istesek, tekrar aynı çarpımı yapardık,</p>
<p><span class="math display">\[ v_{xx} = \hat{n} \times v_x =  N  v_x = N \cdot N v = N^2v = -v_\perp
\]</span></p>
<p>çünkü <span class="math inline">\(v_{xx} = -v_\perp\)</span>. Şimdi tekrar <span class="math inline">\(v_\parallel = v - v_\perp\)</span> formülüne dönelim,</p>
<p><span class="math display">\[ v_\parallel = v - v_\perp = v + v_{xx} = v + N^2v  = (I+N^2)v \]</span></p>
<p>Eğer <span class="math inline">\(u_\perp\)</span>'u <span class="math inline">\(v_\perp\)</span> ve <span class="math inline">\(v_x\)</span> üzerinden tanımlamak istersek, önce <span class="math inline">\(u_\perp\)</span>'un <span class="math inline">\(v_\perp\)</span> vektörünün <span class="math inline">\(\theta\)</span> kadar döndürülmüş hali olduğu bilgisini kullanabiliriz.</p>
<p>Bu dönme işlemi iki boyuttadır (yani aynı düzlem üzerinde) o zaman standart rotasyon matrisi yeterli,</p>
<p><span class="math display">\[ 
u_\perp = R_\theta \cdot v_\perp = 
\left[\begin{array}{rrr}
\cos \theta &amp; -\sin \theta \\
\sin \theta &amp; \cos \theta
\end{array}\right]
\left[\begin{array}{rrr}
v_\perp^1 \\
v_\perp^2
\end{array}\right] = 
\left[\begin{array}{rrr}
v_\perp^1 \cos \theta  - v_\perp^2 \sin \theta \\
v_\perp^2 \cos \theta  + v_\perp^1 \sin \theta  
\end{array}\right]
\]</span></p>
<p><span class="math display">\[ =
\cos \theta
\left[\begin{array}{rrr}
v_\perp^1  \\
v_\perp^2   
\end{array}\right] 
+ 
\sin \theta
\left[\begin{array}{rrr}
 - v_\perp^2  \\
 + v_\perp^1  
\end{array}\right] 
\]</span></p>
<p>Dikkat, <span class="math inline">\(\sin \theta\)</span> ile çarpılan vektör, aynı zamanda <span class="math inline">\(v_\perp\)</span>'un 90 derece döndürülmüş hali. Kontrol edelim, <span class="math inline">\(\theta = 90\)</span>'lik rotasyon matrisi üzerinden,</p>
<p><span class="math display">\[ 
\left[\begin{array}{rrr}
0 &amp; -1 \\ 1 &amp; 0
\end{array}\right]
\left[\begin{array}{rrr}
v_\perp^1 \\
v_\perp^2
\end{array}\right] = 
\left[\begin{array}{rrr}
-v_\perp^2 \\
v_\perp^1
\end{array}\right]
\]</span></p>
<p>Doğrulandı. Ayrıca önceden biliyoruz ki <span class="math inline">\(v_\perp\)</span>'u 90 derece döndürerek <span class="math inline">\(v_x\)</span>'i elde etmiştik. O zaman iki üstteki formül</p>
<p><span class="math display">\[ u_\perp = \cos \theta v_\perp + \sin \theta v_x \]</span></p>
<p>olarak gösterilebilir. Daha önce hesapladığımız <span class="math inline">\(v_\perp\)</span> ve <span class="math inline">\(v_x\)</span>'i yerlerine koyarsak,</p>
<p><span class="math display">\[ = \sin \theta Nv - \cos \theta N^2 v \]</span></p>
<p><span class="math display">\[ u_\perp = (\sin \theta N - \cos \theta N^2) v \]</span></p>
<p>Hepsini bir araya koyarsak,</p>
<p><span class="math display">\[ u = u_\perp + v_\parallel \]</span></p>
<p><span class="math display">\[ = ( \sin \theta N - \cos \theta N^2 + I + N^2)v  \]</span></p>
<p><span class="math display">\[ = \big( I + \sin \theta N - (1-\cos \theta) N^2 \big) v  \]</span></p>
<p>Yani bir eksen <span class="math inline">\(\hat{n}\)</span> etrafında <span class="math inline">\(\theta\)</span> kadar dönüşü bir matris olarak yazabiliriz ki bu matrisin formülü şu şekilde olur,</p>
<p><span class="math display">\[ R(\hat{n},\theta) =  I + \sin \theta N - (1-\cos \theta) N^2 \]</span></p>
<p>ki bu Rodriguez formülüdür.</p>
<p>Altta <span class="math inline">\((-1/3,2/3,2/3)\)</span> ekseni etrafında 70 derece dönüş birkaç farklı açıdan gösteriliyor.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> skew(a):
   <span class="cf">return</span> np.array([[<span class="dv">0</span>,<span class="op">-</span>a[<span class="dv">2</span>],a[<span class="dv">1</span>]],[a[<span class="dv">2</span>],<span class="dv">0</span>,<span class="op">-</span>a[<span class="dv">0</span>]],[<span class="op">-</span>a[<span class="dv">1</span>],a[<span class="dv">0</span>],<span class="dv">0</span>]])

o <span class="op">=</span> np.array([<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>])
v <span class="op">=</span> np.array([<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>])
n <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span><span class="op">/</span><span class="fl">3.</span>,<span class="dv">2</span><span class="op">/</span><span class="fl">3.</span>,<span class="dv">2</span><span class="op">/</span><span class="fl">3.</span>]
   
theta <span class="op">=</span> np.deg2rad(<span class="dv">70</span>)
N <span class="op">=</span> skew.skew(n)
R <span class="op">=</span> np.eye(<span class="dv">3</span>) <span class="op">+</span> np.sin(theta) <span class="op">*</span> N <span class="op">-</span> (<span class="dv">1</span><span class="op">-</span>np.cos(theta))<span class="op">*</span>N<span class="op">**</span><span class="dv">2</span>
<span class="bu">print</span> R
vr <span class="op">=</span> np.dot(R,v)
<span class="bu">print</span> vr</code></pre></div>
<pre><code>[[ 1.         -0.91889724  0.33402626]
 [ 0.33402626  1.          0.240122  ]
 [-0.91889724 -0.38633975  1.        ]]
[ 1.24538705  4.72244477 -0.91571096]</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> mpl_toolkits.mplot3d <span class="im">import</span> Axes3D
<span class="im">import</span> plot3d
fig <span class="op">=</span> plt.figure()
ax <span class="op">=</span> Axes3D(fig)
plot3d.plot_vector(fig, o, v)
ax.hold(<span class="va">True</span>)
plot3d.plot_vector(fig, o, vr, <span class="st">&#39;cyan&#39;</span>)
ax.hold(<span class="va">True</span>)
plot3d.plot_vector(fig, o, <span class="dv">3</span><span class="op">*</span>np.array(n), <span class="st">&#39;red&#39;</span>)
ax.hold(<span class="va">True</span>)
plot3d.plot_plane(ax, o, n, size<span class="op">=</span><span class="dv">3</span>)
ax.view_init(elev<span class="op">=</span><span class="fl">40.</span>, azim<span class="op">=</span><span class="dv">10</span>)
plt.savefig(<span class="st">&#39;vision_02_01.png&#39;</span>)
ax.view_init(elev<span class="op">=</span><span class="fl">30.</span>, azim<span class="op">=</span><span class="dv">40</span>)
plt.savefig(<span class="st">&#39;vision_02_02.png&#39;</span>)
ax.view_init(elev<span class="op">=</span><span class="fl">40.</span>, azim<span class="op">=</span><span class="dv">50</span>)
plt.savefig(<span class="st">&#39;vision_02_03.png&#39;</span>)
ax.view_init(elev<span class="op">=</span><span class="fl">50.</span>, azim<span class="op">=</span><span class="dv">80</span>)
plt.savefig(<span class="st">&#39;vision_02_04.png&#39;</span>)</code></pre></div>
<p><img src="vision_02_01.png" /> <img src="vision_02_02.png" /></p>
<p><img src="vision_02_03.png" /> <img src="vision_02_04.png" /></p>
<p>Kaynaklar</p>
<p>[1] Safko, <em>Classical Mechanics</em></p>
<p>[2] Bayramlı, <em>Lineer Cebir, Giris</em></p>
<p>[3] Widnall, <em>16.07 Dynamics</em></p>
<p>[4] Sastry, <em>An Invitation to 3-D Vision</em></p>
<p>[5] Bayramlı, Lineer Cebir, <em>Ders 15</em></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
