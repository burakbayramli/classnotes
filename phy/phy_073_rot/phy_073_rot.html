<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Döndürme (Rotation) - 2</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="döndürme-rotation---2">Döndürme (Rotation) - 2</h1>
<p>Herhangi Bir Eksen (Vektör) Etrafında Dönüş</p>
<p>Daha öne Rodriguez yöntemi ile yaptığımız döndürme yaklaşımını bir başka teknikle göstereceğiz. Bulmak istediğimiz <span class="math inline">\(\vec{n}\)</span> etrafında <span class="math inline">\(\theta\)</span> dönüşü yaptıracak bir matris, yani öyle bir matris <span class="math inline">\(R(\vec{n},\theta)\)</span> arıyoruz ki bu matrisle <span class="math inline">\(\vec{v}\)</span> vektörünü sağdan çarpınca <span class="math inline">\(\vec{v}&#39;\)</span> elde edilecek ve bu yeni vektör <span class="math inline">\(\vec{v}\)</span> vektörünün <span class="math inline">\(\vec{n}\)</span> etrafında <span class="math inline">\(\theta\)</span> kadar dönmüş hali olacak [1, sf. 142]. Yazının geri kalanında <span class="math inline">\(\vec{v} = v\)</span>, <span class="math inline">\(\vec{n} = n\)</span>..</p>
<p><span class="math display">\[
v&#39; = v R(n,\theta)
\]</span></p>
<p><span class="math inline">\(R(n,\theta)\)</span> matrisini türetmek için önce <span class="math inline">\(v&#39;\)</span> vektörünü <span class="math inline">\(v,n,\theta\)</span> bazında temsil etmeyi görelim. Ana fikir problemi <span class="math inline">\(n\)</span>'ye dik olan düzlem üzerinde çözmek, ki bu şekilde 3 boyutlu problemi 2 boyutlu bir probleme indirgemiş oluyoruz. İndirgeme için <span class="math inline">\(v\)</span> vektörünü iki <span class="math inline">\(v_\parallel\)</span> ve <span class="math inline">\(v_\perp\)</span> vektörüne ayıracağız, öyle ki <span class="math inline">\(v = v_\parallel + v_\perp\)</span>. Sonra bu ki vektörü ayrıca döndüreceğiz ve böylece onların toplamları da dönmüş olacak, yani <span class="math inline">\(v&#39; = v&#39;_\parallel + v&#39;_\perp\)</span>. Buraya kadar gördüklerimiz Rodriguez yaklaşımına benziyor.</p>
<div class="figure">
<img src="phy_073_rot_01.jpg" />

</div>
<p>Tekniğin iyi tarafı <span class="math inline">\(v_\parallel\)</span> vektörü <span class="math inline">\(n\)</span> vektörüne paralel olduğu için <span class="math inline">\(n\)</span> etrafında dönüşten etkilenmez, o zaman sadece <span class="math inline">\(v_\perp\)</span> vektörünü döndürmek yeterlidir, böylece <span class="math inline">\(v&#39; = v_\parallel + v&#39;_\perp\)</span> hesaplanabilir.</p>
<p>Hesap için şu adımları takip ediyoruz,</p>
<ul>
<li><span class="math inline">\(v_\parallel\)</span> vektörü <span class="math inline">\(v\)</span> nin <span class="math inline">\(n\)</span> ye paralel olan şeklidir, ya da <span class="math inline">\(v\)</span> vektörünün <span class="math inline">\(n\)</span> üzerinde yansıtılmış halidir [2], bu formülün <span class="math inline">\(v_\parallel = (v \cdot n) n\)</span> olduğunu biliyoruz.</li>
<li><span class="math inline">\(v_\perp\)</span> vektörü <span class="math inline">\(v\)</span> nin <span class="math inline">\(n\)</span> ye dik olan kısmıdır. <span class="math inline">\(v = v_\parallel + v_\perp\)</span> olduğu için <span class="math inline">\(v_\perp = v - v_\parallel\)</span>.</li>
<li>Üstteki şekilde <span class="math inline">\(w\)</span> vektörü var, bu vektör <span class="math inline">\(v_\perp\)</span> ve <span class="math inline">\(v_\parallel\)</span> ile diktir, ve uzunluğu <span class="math inline">\(v_\perp\)</span> ile aynıdır. Bu vektör <span class="math inline">\(v_\perp\)</span> vektörünü 90 derece döndürerek elde edilebilir. Bu sebeple <span class="math inline">\(w = n \times v_\perp\)</span>.</li>
</ul>
<p>Bu vektörlerle nasıl <span class="math inline">\(v&#39;\)</span> hesaplayacağız? Dikkat edersek <span class="math inline">\(w\)</span> ve <span class="math inline">\(v_\perp\)</span> bir 2D kordinate uzayı oluşturuyor. <span class="math inline">\(v&#39;_\perp\)</span> vektörü <span class="math inline">\(v&#39;\)</span> yi bu uzayda <span class="math inline">\(\theta\)</span> kadar döndürerek elde edilebilir. Bu dönüşün formülünün</p>
<p><span class="math display">\[
v&#39;_\perp = \cos \theta v_\perp + \sin \theta w
\]</span></p>
<p>olduğunu biliyoruz (ispatı bu anlatım ardından paylaşılıyor).</p>
<p>Şimdi eldeki formüllere bakalım:</p>
<p><span class="math display">\[
v_\parallel = (v \cdot n) n
\]</span></p>
<p><span class="math display">\[
v_\perp = v - v_\parallel
\]</span></p>
<p><span class="math display">\[
= v - (v \cdot n) n
\]</span></p>
<p><span class="math display">\[
w = n \times v_\perp
\]</span></p>
<p><span class="math display">\[
= n \times (v - v_\parallel)
\]</span></p>
<p><span class="math display">\[
= n \times v - n \times v_\parallel
\]</span></p>
<p><span class="math inline">\(n\)</span> ve <span class="math inline">\(v_\parallel\)</span> birbirine paralel olduğu için çapraz çarpımları sıfırdır,</p>
<p><span class="math display">\[
= n \times v - 0 
\]</span></p>
<p><span class="math display">\[
w = n \times v
\]</span></p>
<p><span class="math display">\[
v&#39;_\perp = \cos \theta v_\perp + \sin \theta w
\]</span></p>
<p><span class="math display">\[
= \cos \theta (v - (v \cdot n) n) + \sin \theta (n \times v)
\]</span></p>
<p>Üstteki değeri <span class="math inline">\(v&#39;\)</span> formülü içine sokalım,</p>
<p><span class="math display">\[
v&#39; = v&#39;_\perp + v_\parallel
\]</span></p>
<p><span class="math display">\[
v&#39; = \cos \theta (v - (v \cdot n) n) + \sin \theta (n \times v) + (v \cdot n) n
\qquad (1)
\]</span></p>
<p>Eğer (1) formülünü matris formunda göstermek istiyorsak, baz vektörleri <span class="math inline">\([\begin{array}{ccc} 1 &amp; 0 &amp; 0 \end{array}]^T\)</span>, <span class="math inline">\([\begin{array}{ccc} 0 &amp; 1 &amp; 0 \end{array}]^T\)</span>, <span class="math inline">\([\begin{array}{ccc} 0 &amp; 0 &amp; 1 \end{array}]^T\)</span> teker teker (1) ile çarpıp sonuçları bir diğer 3 x 3 matrisin kolonlarına yazabiliriz [1, sf. 143][1, sf. 757], böylece alttaki matrisi elde ederiz,</p>
<p><span class="math display">\[
\scriptsize
R(n,\theta) =
\left[\begin{array}{ccc}
n_x^2(1-\cos\theta)+\cos\theta &amp; n_x n_y (1-\cos\theta)+n_x \sin\theta &amp; n_x n_z (1-\cos\theta)-n_x\sin\theta\\
n_x n_y (1-\cos\theta)-n_z\sin\theta &amp; n_y^2(1-\cos\theta)+\cos\theta &amp; n_y n_z (1-\cos\theta)n_x\sin\theta\\
n_x n_z (1-\cos\theta)+n_y \sin\theta &amp; n_y n_z (1-\cos\theta)-n_x \sin\theta &amp; n_z^2 (1-\cos\theta)+\cos\theta
\end{array}\right]
\qquad (2)
\]</span></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> sys<span class="op">;</span> sys.path.append(<span class="st">&#39;../phy_072_rot&#39;</span>)
<span class="im">from</span> mpl_toolkits.mplot3d <span class="im">import</span> Axes3D
<span class="im">import</span> plot3d

<span class="kw">def</span> rotate(v, n, theta):
    <span class="cf">return</span> np.cos(theta) <span class="op">*</span> ( v <span class="op">-</span> np.dot(v,n) ) <span class="op">+</span> <span class="op">\</span>
           np.sin(theta)<span class="op">*</span> np.cross(n,v) <span class="op">+</span> <span class="op">\</span>
           np.dot(v,n)<span class="op">*</span>n
 
o1 <span class="op">=</span> np.array([<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>])
v1 <span class="op">=</span> np.array([<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>])
n1 <span class="op">=</span> np.array([<span class="op">-</span><span class="dv">1</span><span class="op">/</span><span class="fl">3.</span>,<span class="dv">2</span><span class="op">/</span><span class="fl">3.</span>,<span class="dv">2</span><span class="op">/</span><span class="fl">3.</span>])

theta <span class="op">=</span> np.deg2rad(<span class="dv">20</span>)

v1r <span class="op">=</span> rotate(v1, n1, theta)

fig <span class="op">=</span> plt.figure()
ax <span class="op">=</span> Axes3D(fig)
plot3d.plot_vector(fig, o1, v1)
plot3d.plot_vector(fig, o1, v1r, <span class="st">&#39;cyan&#39;</span>)
plot3d.plot_vector(fig, o1, <span class="dv">3</span><span class="op">*</span>np.array(n1), <span class="st">&#39;red&#39;</span>)
plot3d.plot_plane(ax, o1, n1, size<span class="op">=</span><span class="dv">3</span>)
ax.view_init(elev<span class="op">=</span><span class="fl">40.</span>, azim<span class="op">=</span><span class="dv">10</span>)
plt.savefig(<span class="st">&#39;phy_073_rot_02.jpg&#39;</span>)</code></pre></div>
<div class="figure">
<img src="phy_073_rot_02.jpg" />

</div>
<p>Teori</p>
<p>3D A,B vektörleri birbirine dikgen ve bir 2D uzay yaratıyorlar, ki sanki A vektörü <span class="math inline">\(x\)</span> ekseni, B ise <span class="math inline">\(y\)</span> ekseni. A vektörünün <span class="math inline">\(\theta\)</span> açısı kadar döndürülmesi <span class="math inline">\(Y = \cos \theta A + \sin \theta B\)</span> vektörünü verir (üstteki problemde <span class="math inline">\(A = v_\perp\)</span>, <span class="math inline">\(B = w\)</span>).</p>
<p>İspat</p>
<p>A ve B 3D uzayında bir 2D düzlemi kapsayan iki dikgen vektör ise, A ve B'yi bu 2D düzlem için baz vektörleri olarak düşünebiliriz. A ve B tarafından kapsanan düzlemdeki herhangi bir X vektörü, A ve B'nin bir doğrusal birleşimi olarak ifade edilebilir:</p>
<p><span class="math inline">\(X = x_A A + x_B B\)</span></p>
<p>Burada, <span class="math inline">\(x_A\)</span> ve <span class="math inline">\(x_B\)</span>, X'in A ve B doğrultularındaki bileşenleridir.</p>
<p>A vektörü için, {A, B} bazındaki temsili, A doğrultusundaki bileşenin 1 ve B doğrultusundaki bileşenin 0 olduğu durumdur. Yani, A'yı bu 2D baz sisteminde &quot;x ekseni&quot; ve B'yi &quot;y ekseni&quot; olarak düşünebiliriz, burada A'nın &quot;koordinatları&quot; (1, 0) olur.</p>
<p>Şimdi, A vektörünü A ve B'nin kapsadığı düzlem içinde <span class="math inline">\(\theta\)</span> açısı kadar döndürelim. Ortaya çıkan vektöre Y diyelim. Standart bir 2D Kartezyen koordinat sisteminde, koordinatları <span class="math inline">\((x, y)\)</span> olan bir vektör <span class="math inline">\(\theta\)</span> açısı kadar saat yönünün tersine döndürüldüğünde, yeni koordinatları <span class="math inline">\((x&#39;, y&#39;)\)</span> şu şekilde bulunur:</p>
<p><span class="math inline">\(x&#39; = x \cos \theta - y \sin \theta\)</span></p>
<p><span class="math inline">\(y&#39; = x \sin \theta + y \cos \theta\)</span></p>
<p>Bizim durumumuzda, A vektörünün {A, B} bazındaki başlangıç &quot;koordinatları&quot; <span class="math inline">\((1, 0)\)</span>'dır. A'yı <span class="math inline">\(\theta\)</span> kadar döndürdüğümüzde, ortaya çıkan Y vektörünün {A, B} bazındaki yeni &quot;koordinatları&quot;, <span class="math inline">\((y_A, y_B)\)</span>, <span class="math inline">\((x, y) = (1, 0)\)</span> kullanılarak 2D döndürme formülleriyle bulunabilir:</p>
<p><span class="math inline">\(y_A = 1 \cdot \cos \theta - 0 \cdot \sin \theta = \cos \theta\)</span></p>
<p><span class="math inline">\(y_B = 1 \cdot \sin \theta + 0 \cdot \cos \theta = \sin \theta\)</span></p>
<p>Dolayısıyla, döndürülen Y vektörünün {A, B} bazındaki bileşenleri, A doğrultusunda <span class="math inline">\(\cos \theta\)</span> ve B doğrultusunda <span class="math inline">\(\sin \theta\)</span> olur.</p>
<p>Şimdi Y vektörünü, bu bileşenleri kullanarak baz vektörler A ve B'nin doğrusal birleşimi olarak yazabiliriz:</p>
<p><span class="math inline">\(Y = y_A A + y_B B\)</span></p>
<p><span class="math inline">\(Y = \cos \theta A + \sin \theta B\)</span></p>
<p>Bu, A vektörünün A ve B'nin kapsadığı 2D düzlem içinde <span class="math inline">\(\theta\)</span> açısı kadar döndürülmesinin <span class="math inline">\(Y = \cos \theta A + \sin \theta B\)</span> vektörünü verdiğini kanıtlar. Bu, bir 2D Kartezyen düzlemde x eksenindeki <span class="math inline">\((1, 0)\)</span> vektörünün <span class="math inline">\(\theta\)</span> kadar döndürüldüğünde <span class="math inline">\((\cos \theta, \sin \theta)\)</span>'ye dönmesiyle benzerdir. A ve B vektörleri, 3D uzayında bu 2D dönüşüm için eksenleri sağlar.</p>
<p>Dörtlü Grup / Kuaterniyon (Quaternions)</p>
<p>Bir vektörü, fiziksel objeyi döndürmek için çok faydalı bir diğer kavram kuaterniyon kavramı. Kuaterniyon matematiği hayali (imaginery, complex) sayıları baz alan bir cebir sistemidir, William Hamilton tarafından keşfedilmiştir. Bir kuaterniyon sayı dört reel sayı ve üç tane hayali sayı içerir,</p>
<p><span class="math display">\[
q = [\begin{array}{cccc} w &amp; x &amp; y &amp; z \end{array}]
\]</span></p>
<p>olarak yazılabilir, ki son üç sayı hayalidir, ya da</p>
<p><span class="math display">\[
q = w + i x + j y + k z
\]</span></p>
<p>Görüldüğü gibi bu cebirin olabilmesi için sadece <span class="math inline">\(i\)</span> değil, ek olarak <span class="math inline">\(j,k\)</span> hayali sayıları sisteme ekleniyor, ve önkabul olarak şu ifade ileri sürülüyor [1, sf. 247],</p>
<p><span class="math display">\[
i^2 = j^2 = k^2 = ijk = -1
\]</span></p>
<p>Üstteki ifadelerden geri kalan eşitlikler türetilebilir [4, sf. 170], mesela</p>
<p><span class="math display">\[
ijk = -1 = k^2 \Rightarrow ij = k
\]</span></p>
<p>Ayrıca <span class="math inline">\(ij = -ji\)</span>, yani sırabağımsızlık yoktur.</p>
<p>Tüm önverili ve türetilmiş ifadeleri biraraya koyarsak,</p>
<p><span class="math display">\[
i^2 = j^2 = k^2 = ijk = -1
\]</span></p>
<p><span class="math display">\[
ij = -ji = k
\]</span></p>
<p><span class="math display">\[
jk = -kj = i
\]</span></p>
<p><span class="math display">\[
ki = -ik = j
\]</span></p>
<p>Üsttekilere Hamilton'un kurallları adı veriliyor.</p>
<p>Eşlenik (conjugate) hesabı bir <span class="math inline">\(q\)</span> için <span class="math inline">\(q^{\ast}\)</span> olarak gösterilir, hayali olan kısmın negatiflenmesi ile elde edilir, yani</p>
<p><span class="math display">\[
q^{\ast} = [\begin{array}{cccc} w &amp; -x &amp; -y &amp; -z \end{array}]
\]</span></p>
<p>Tersi (inverse) işlemi ise eşleniğin büyüklüğe bölünmüş halidir,</p>
<p><span class="math display">\[
q^{-1} = \frac{q^{\ast}}{|| q ||}
\]</span></p>
<p>Kuaterniyon çarpımı mesela <span class="math inline">\(q_1,q_2\)</span> arasında, parantez içi dört sayının çarpım ve toplamsal açılımı yapılıp üstteki kurallar uygulanarak elde edilebilir [1, sf. 773],</p>
<p><span class="math display">\[
q_1 = w_1 + x_1 i + y_1 j + z_1 k
\]</span></p>
<p><span class="math display">\[
q_2 = w_2 + x_2 i + y_2 j + z_2 k 
\]</span></p>
<span class="math display">\[\begin{align*}
q_1 q_2 =
w_1 w_2 + w_1 x_2 i + w_1 y_2 j + w_1 z_2 k + \\
x_1 w_2 i + x_1 x_2 i^2 + x_1 y_2 ij x_1 z_2 ik + \\
y_1 w_2 j + y_1 x_2 ji + y_1 y_2 j^2 + y_1 z_2 jk + \\
z_1 w_2 k + z_1 x_2 ki + z_1 y_2 kj + z_1 z_2 k^2
\end{align*}\]</span>
<span class="math display">\[\begin{align*}
= w_1 w_2 + w_1 x_2 i + w_1 y_2 j + w_1 z_2 k + \\
x_1 w_2 i + x_1 x_2 (-1) + x_1 y_2 k + x_1 z_2 (-j) + \\
y_1 w_2 j + y_1 x_2 (-k) y_1 y_2 (-1) + y_1 z_2 (i) + \\
z_1 w_2 k + z_1 x_2 j + z_1 y_2 (-i) + z_1 z_2 (-1)
\end{align*}\]</span>
<p>Nihai çarpım denklemi</p>
<span class="math display">\[\begin{align*}
= w_1 w_2 - x_1 x_2 - y_1 y_2 - z_1 z_2 + \\
(w_1 x_2 + x_1 w_2 + y_1 z_2 - z_1 y_2 + \\
(w_1 y_2 + y_1 w_2 + z_1 x_2 - x_1 z_2) j + \\
(w_1 z_2 + z_1 w_2 + x_1 y_2 - y_1 x_2) k
\end{align*}\]</span>
<p>Ve nihayet döndürme işleminin nasıl yapılacağına geliyoruz, <span class="math inline">\(n\)</span> vektörü etrafında bir <span class="math inline">\(p\)</span> noktasına <span class="math inline">\(\theta\)</span> dönüşü yaptırabilmek için bir şu şekilde bir kuaterniyon yaratıyoruz,</p>
<p><span class="math display">\[
q = [\begin{array}{cccc}
    \cos(\theta/2) &amp;
    \sin(\theta/2) n_x &amp;
    \sin(\theta/2) n_y &amp;
    \sin(\theta/2) n_z \end{array}]
\]</span></p>
<p><span class="math inline">\(p\)</span> noktasını skala değeri 0 olan bir diğer kuaterniyon olarak yazıyoruz,</p>
<p><span class="math display">\[
p = [\begin{array}{cccc} 0 &amp; p_x &amp; p_y &amp; p_z \end{array}]
\]</span></p>
<p>Ve şu şekilde bir çarpım yapıyoruz,</p>
<p><span class="math display">\[
p&#39; = q p q^{-1}
\]</span></p>
<p>Kod üzerinde görelim [3],</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> math

<span class="kw">def</span> q_mult(q1, q2):
    w1, x1, y1, z1 <span class="op">=</span> q1
    w2, x2, y2, z2 <span class="op">=</span> q2
    w <span class="op">=</span> w1 <span class="op">*</span> w2 <span class="op">-</span> x1 <span class="op">*</span> x2 <span class="op">-</span> y1 <span class="op">*</span> y2 <span class="op">-</span> z1 <span class="op">*</span> z2
    x <span class="op">=</span> w1 <span class="op">*</span> x2 <span class="op">+</span> x1 <span class="op">*</span> w2 <span class="op">+</span> y1 <span class="op">*</span> z2 <span class="op">-</span> z1 <span class="op">*</span> y2
    y <span class="op">=</span> w1 <span class="op">*</span> y2 <span class="op">+</span> y1 <span class="op">*</span> w2 <span class="op">+</span> z1 <span class="op">*</span> x2 <span class="op">-</span> x1 <span class="op">*</span> z2
    z <span class="op">=</span> w1 <span class="op">*</span> z2 <span class="op">+</span> z1 <span class="op">*</span> w2 <span class="op">+</span> x1 <span class="op">*</span> y2 <span class="op">-</span> y1 <span class="op">*</span> x2
    <span class="cf">return</span> w, x, y, z

<span class="kw">def</span> q_conjugate(q):
    w, x, y, z <span class="op">=</span> q
    <span class="cf">return</span> (w, <span class="op">-</span>x, <span class="op">-</span>y, <span class="op">-</span>z)

<span class="kw">def</span> normalize(v, tolerance<span class="op">=</span><span class="fl">0.00001</span>):
    mag2 <span class="op">=</span> <span class="bu">sum</span>(n <span class="op">*</span> n <span class="cf">for</span> n <span class="kw">in</span> v)
    <span class="cf">if</span> <span class="bu">abs</span>(mag2 <span class="op">-</span> <span class="fl">1.0</span>) <span class="op">&gt;</span> tolerance:
        mag <span class="op">=</span> math.sqrt(mag2)
        v <span class="op">=</span> <span class="bu">tuple</span>(n <span class="op">/</span> mag <span class="cf">for</span> n <span class="kw">in</span> v)
    <span class="cf">return</span> v

<span class="kw">def</span> axisangle_to_q(v, theta):
    v <span class="op">=</span> normalize(v)
    x, y, z <span class="op">=</span> v
    theta <span class="op">/=</span> <span class="dv">2</span>
    w <span class="op">=</span> math.cos(theta)
    x <span class="op">=</span> x <span class="op">*</span> math.sin(theta)
    y <span class="op">=</span> y <span class="op">*</span> math.sin(theta)
    z <span class="op">=</span> z <span class="op">*</span> math.sin(theta)
    <span class="cf">return</span> w, x, y, z

<span class="kw">def</span> rotate(q1, v1):
    q2 <span class="op">=</span> (<span class="fl">0.0</span>,) <span class="op">+</span> v1
    tmp1 <span class="op">=</span> q_mult(q1, q2)
    tmp2 <span class="op">=</span> q_conjugate(q1)
    <span class="cf">return</span> q_mult(tmp1, tmp2)[<span class="dv">1</span>:]
    </code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">o1 <span class="op">=</span> (<span class="fl">5.0</span>,<span class="fl">5.0</span>,<span class="fl">5.0</span>)
v1 <span class="op">=</span> (<span class="fl">3.0</span>,<span class="fl">3.0</span>,<span class="fl">3.0</span>)
n1 <span class="op">=</span> (<span class="op">-</span><span class="dv">1</span><span class="op">/</span><span class="fl">3.</span>,<span class="dv">2</span><span class="op">/</span><span class="fl">3.</span>,<span class="dv">2</span><span class="op">/</span><span class="fl">3.</span>)

theta <span class="op">=</span> np.deg2rad(<span class="dv">30</span>)

r1 <span class="op">=</span> axisangle_to_q(n1, theta)
v1r <span class="op">=</span> rotate(r1, v1)

fig <span class="op">=</span> plt.figure()
ax <span class="op">=</span> Axes3D(fig)
plot3d.plot_vector(fig, o1, v1)
plot3d.plot_vector(fig, o1, v1r, <span class="st">&#39;cyan&#39;</span>)
plot3d.plot_vector(fig, o1, <span class="dv">3</span><span class="op">*</span>np.array(n1), <span class="st">&#39;red&#39;</span>)
plot3d.plot_plane(ax, o1, n1, size<span class="op">=</span><span class="dv">3</span>)
ax.view_init(elev<span class="op">=</span><span class="fl">10.</span>, azim<span class="op">=</span><span class="dv">50</span>)
plt.savefig(<span class="st">&#39;phy_073_rot_03.jpg&#39;</span>)</code></pre></div>
<div class="figure">
<img src="phy_073_rot_03.jpg" />

</div>
<p>Farklı bir açıdan daha bakalım, bazen kamera bakış yönüne göre sonuç tam belli olmayabiliyor. Etrafında dönüş yapılan <span class="math inline">\(n\)</span> vektörü direk <span class="math inline">\(y\)</span> eksenine bakıyor olsun, kamerayı o yöne koyalım ve 90 derece dönüş yapalım,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">o2 <span class="op">=</span> (<span class="fl">5.0</span>,<span class="fl">5.0</span>,<span class="fl">5.0</span>)
v2 <span class="op">=</span> (<span class="fl">3.0</span>,<span class="fl">3.0</span>,<span class="fl">3.0</span>)
n2 <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>)

theta <span class="op">=</span> np.deg2rad(<span class="dv">90</span>)

r2 <span class="op">=</span> axisangle_to_q(n2, theta)
v2r <span class="op">=</span> rotate(r2, v2)

fig <span class="op">=</span> plt.figure()
ax <span class="op">=</span> Axes3D(fig)
plot3d.plot_vector(fig, o2, v2)
plot3d.plot_vector(fig, o2, v2r, <span class="st">&#39;cyan&#39;</span>)
plot3d.plot_vector(fig, o2, <span class="dv">3</span><span class="op">*</span>np.array(n2), <span class="st">&#39;red&#39;</span>)
plot3d.plot_plane(ax, o2, n2, size<span class="op">=</span><span class="dv">3</span>)
ax.view_init(elev<span class="op">=</span><span class="fl">0.</span>, azim<span class="op">=</span><span class="dv">90</span>)
plt.savefig(<span class="st">&#39;phy_073_rot_04.jpg&#39;</span>)</code></pre></div>
<div class="figure">
<img src="phy_073_rot_04.jpg" />

</div>
<p>Kuaterniyon hesabının rotasyon yaptığının belki de bir diğer ispatı <span class="math inline">\(q v q^{-1}\)</span> hesabını (2) formundaki rotasyon matrisı formatında gösterebilmek. (2) matrisindeki her hücreyi teker teker alıp onu <span class="math inline">\(n_x,n_y,n_z,\theta\)</span> değişkenlerinden <span class="math inline">\(w,x,y,z\)</span> kuaterniyon değişkenlerine tercüme edebilirsek, ve bu matrisin döndürme yaptığını görürsek bir tür ispat elde etmiş olabiliriz, detaylar için [1,sf. 282].</p>
<p>Farklı Teorik Yaklaşım</p>
<p>Buraya kadar güzel, fakat Hamilton'un sunduğu şekildeki teoride bazı boşluklar var, mesela <span class="math inline">\(ijk = -1\)</span> önkabulü biraz zorlanmış gibi geliyor, daha doğrusu rasgele (arbitrary) seçilmiş gibi. Bir şey denenmiş ve işlediği görülünce kullanılmaya devam edilmiş. Fakat bir önkabul olsa da bu ifadenin, ve ek hayali sayılar <span class="math inline">\(j,k\)</span> seçimlerinin daha baz bir temelden geliyor olmaları iyi olurdu.</p>
<p>[5] bağlantısında bu tür açıklamalar görüyoruz. Bunlardan biri der ki <span class="math inline">\(i,j,k\)</span> aslında <span class="math inline">\(\mathbb{R}^4\)</span> uzayında birer <em>bazdır</em>,</p>
<p><span class="math display">\[
i = \left[\begin{array}{cccc}
0 &amp; 1 &amp; 0 &amp; 0 \\ -1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; -1 &amp; 0 
\end{array}\right], \quad 
j = \left[\begin{array}{cccc}
0 &amp; 0 &amp; 0 &amp; -1 \\ 0 &amp; 0 &amp; -1 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0 &amp; 0 
\end{array}\right], \quad
k = \left[\begin{array}{cccc}
0 &amp; 0 &amp; -1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ 1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; -1 &amp; 0 &amp; 0 
\end{array}\right]
\]</span></p>
<p>Ve Hamilton kuralları bu baz üzerinden hesaplanabilir,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">i <span class="op">=</span> np.array([[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>],[<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>]])
j <span class="op">=</span> np.array([[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>],[<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]])
k <span class="op">=</span> np.array([[<span class="dv">0</span>,<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>]])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">np.dot(i,i)</code></pre></div>
<pre><code>Out[1]: 
array([[-1,  0,  0,  0],
       [ 0, -1,  0,  0],
       [ 0,  0, -1,  0],
       [ 0,  0,  0, -1]])</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">np.dot(j,j)</code></pre></div>
<pre><code>Out[1]: 
array([[-1,  0,  0,  0],
       [ 0, -1,  0,  0],
       [ 0,  0, -1,  0],
       [ 0,  0,  0, -1]])</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">np.dot(k,k)</code></pre></div>
<pre><code>Out[1]: 
array([[-1,  0,  0,  0],
       [ 0, -1,  0,  0],
       [ 0,  0, -1,  0],
       [ 0,  0,  0, -1]])</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">i.dot(j).dot(k)</code></pre></div>
<pre><code>Out[1]: 
array([[-1,  0,  0,  0],
       [ 0, -1,  0,  0],
       [ 0,  0, -1,  0],
       [ 0,  0,  0, -1]])</code></pre>
<p>Çarpımlarda elde edilen sonucun eksi birim (identity) matris olduğuna dikkat, yani <span class="math inline">\(jk = -1\)</span> yerine <span class="math inline">\(JK = -I\)</span> elde ediyoruz ki <span class="math inline">\(I\)</span> standart notasyonda birim matristir (paylaşılan bağlantıda farklı sembol <span class="math inline">\(U\)</span> kullanılmış çünkü <span class="math inline">\(I\)</span> matrisi <span class="math inline">\(i\)</span>'nin bazı olarak kullanılıyor, semboller karışıklık yaratmasın).</p>
<p>Bu yaklaşım rasgele bir <span class="math inline">\(ijk=-1\)</span> seçiminden ziyade problemi bir baz seçimi haline dönüştürüyor, ki Lineer Cebir'de baz seçimi her zaman yapılır, bir transformasyon olduğunda &quot;yeni baz nedir?'' diye sorarız, bu daha anlaşılır bir kavramdır.</p>
<p>[1, sf. 264]'te kuaterniyon ve matris cebiri bağlantısı daha ileri götürülüyor, ve niye <span class="math inline">\(\theta\)</span> yerine <span class="math inline">\(\theta / 2\)</span> kullanılmış olabileceği açıklanıyor. Bu açıklamaya göre hiç kuaterniyon cebirine girmeden direk kuaterniyon sayılarına tekabül eden matrisler ile temel lineer cebir işlemleri yaparak aynı sonuca erişmek mümkündür.</p>
<p>Paketler</p>
<p>[6] bağlantısında faydalı bazı kodlar var, onu <code>euclid.py</code> içinde bu dizine kaydettik, kullanım örnekleri,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> euclid

q1 <span class="op">=</span> euclid.Quaternion(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>)
q1</code></pre></div>
<pre><code>Out[1]: Quaternion(real=1.00, imag=&lt;1.00, 1.00, 1.00&gt;)</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">q1.conjugated()</code></pre></div>
<pre><code>Out[1]: Quaternion(real=1.00, imag=&lt;-1.00, -1.00, -1.00&gt;)</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">q2 <span class="op">=</span> euclid.Quaternion(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">4</span>)
q1 <span class="op">*</span> q2</code></pre></div>
<pre><code>Out[1]: Quaternion(real=-8.00, imag=&lt;4.00, 4.00, 8.00&gt;)</code></pre>
<p>Kaynaklar</p>
<p>[1] Dunn, <em>3D Math Primer for Graphics and Game Development</em></p>
<p>[2] Bayramlı, <em>Lineer Cebir - Giriş</em></p>
<p>[3] Stackoverflow, <a href="https://stackoverflow.com/questions/4870393/rotating-coordinate-system-via-a-quaternion/42180896#42180896" class="uri">https://stackoverflow.com/questions/4870393/rotating-coordinate-system-via-a-quaternion/42180896#42180896</a></p>
<p>[4] Millington, <em>Game Physics Engine Development</em></p>
<p>[5] Wolfram Mathworld, <a href="https://mathworld.wolfram.com/Quaternion.html" class="uri">https://mathworld.wolfram.com/Quaternion.html</a></p>
<p>[6] Ezag, PyEuclid, <a href="https://github.com/ezag/pyeuclid" class="uri">https://github.com/ezag/pyeuclid</a></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
