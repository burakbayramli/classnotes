<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Döndürme (Rotation) - 2</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="döndürme-rotation---2">Döndürme (Rotation) - 2</h1>
<p>Herhangi Bir Eksen (Vektör) Etrafında Dönüş</p>
<p>Daha öne Rodriguez yöntemi ile yaptığımız döndürme yaklaşımını bir
başka teknikle göstereceğiz. Bulmak istediğimiz <span
class="math inline">\(\vec{n}\)</span> etrafında <span
class="math inline">\(\theta\)</span> dönüşü yaptıracak bir matris, yani
öyle bir matris <span class="math inline">\(R(\vec{n},\theta)\)</span>
arıyoruz ki bu matrisle <span class="math inline">\(\vec{v}\)</span>
vektörünü sağdan çarpınca <span
class="math inline">\(\vec{v}&#39;\)</span> elde edilecek ve bu yeni
vektör <span class="math inline">\(\vec{v}\)</span> vektörünün <span
class="math inline">\(\vec{n}\)</span> etrafında <span
class="math inline">\(\theta\)</span> kadar dönmüş hali olacak [1, sf.
142]. Yazının geri kalanında <span class="math inline">\(\vec{v} =
v\)</span>, <span class="math inline">\(\vec{n} = n\)</span>..</p>
<p><span class="math display">\[
v&#39; = v R(n,\theta)
\]</span></p>
<p><span class="math inline">\(R(n,\theta)\)</span> matrisini türetmek
için önce <span class="math inline">\(v&#39;\)</span> vektörünü <span
class="math inline">\(v,n,\theta\)</span> bazında temsil etmeyi görelim.
Ana fikir problemi <span class="math inline">\(n\)</span>’ye dik olan
düzlem üzerinde çözmek, ki bu şekilde 3 boyutlu problemi 2 boyutlu bir
probleme indirgemiş oluyoruz. İndirgeme için <span
class="math inline">\(v\)</span> vektörünü iki <span
class="math inline">\(v_\parallel\)</span> ve <span
class="math inline">\(v_\perp\)</span> vektörüne ayıracağız, öyle ki
<span class="math inline">\(v = v_\parallel + v_\perp\)</span>. Sonra bu
ki vektörü ayrıca döndüreceğiz ve böylece onların toplamları da dönmüş
olacak, yani <span class="math inline">\(v&#39; = v&#39;_\parallel +
v&#39;_\perp\)</span>. Buraya kadar gördüklerimiz Rodriguez yaklaşımına
benziyor.</p>
<p><img src="phy_073_rot_01.jpg" /></p>
<p>Tekniğin iyi tarafı <span class="math inline">\(v_\parallel\)</span>
vektörü <span class="math inline">\(n\)</span> vektörüne paralel olduğu
için <span class="math inline">\(n\)</span> etrafında dönüşten
etkilenmez, o zaman sadece <span class="math inline">\(v_\perp\)</span>
vektörünü döndürmek yeterlidir, böylece <span
class="math inline">\(v&#39; = v_\parallel + v&#39;_\perp\)</span>
hesaplanabilir.</p>
<p>Hesap için şu adımları takip ediyoruz,</p>
<ul>
<li><span class="math inline">\(v_\parallel\)</span> vektörü <span
class="math inline">\(v\)</span> nin <span
class="math inline">\(n\)</span> ye paralel olan şeklidir, ya da <span
class="math inline">\(v\)</span> vektörünün <span
class="math inline">\(n\)</span> üzerinde yansıtılmış halidir [2], bu
formülün <span class="math inline">\(v_\parallel = (v \cdot n)
n\)</span> olduğunu biliyoruz.</li>
<li><span class="math inline">\(v_\perp\)</span> vektörü <span
class="math inline">\(v\)</span> nin <span
class="math inline">\(n\)</span> ye dik olan kısmıdır. <span
class="math inline">\(v = v_\parallel + v_\perp\)</span> olduğu için
<span class="math inline">\(v_\perp = v - v_\parallel\)</span>.</li>
<li>Üstteki şekilde <span class="math inline">\(w\)</span> vektörü var,
bu vektör <span class="math inline">\(v_\perp\)</span> ve <span
class="math inline">\(v_\parallel\)</span> ile diktir, ve uzunluğu <span
class="math inline">\(v_\perp\)</span> ile aynıdır. Bu vektör <span
class="math inline">\(v_\perp\)</span> vektörünü 90 derece döndürerek
elde edilebilir. Bu sebeple <span class="math inline">\(w = n \times
v_\perp\)</span>.</li>
</ul>
<p>Bu vektörlerle nasıl <span class="math inline">\(v&#39;\)</span>
hesaplayacağız? Dikkat edersek <span class="math inline">\(w\)</span> ve
<span class="math inline">\(v_\perp\)</span> bir 2D kordinate uzayı
oluşturuyor. <span class="math inline">\(v&#39;_\perp\)</span> vektörü
<span class="math inline">\(v&#39;\)</span> yi bu uzayda <span
class="math inline">\(\theta\)</span> kadar döndürerek elde edilebilir.
Bu dönüşün formülünün</p>
<p><span class="math display">\[
v&#39;_\perp = \cos \theta v_\perp + \sin \theta w
\]</span></p>
<p>olduğunu biliyoruz (ispatı bu anlatım ardından paylaşılıyor).</p>
<p>Şimdi eldeki formüllere bakalım:</p>
<p><span class="math display">\[
v_\parallel = (v \cdot n) n
\]</span></p>
<p><span class="math display">\[
v_\perp = v - v_\parallel
\]</span></p>
<p><span class="math display">\[
= v - (v \cdot n) n
\]</span></p>
<p><span class="math display">\[
w = n \times v_\perp
\]</span></p>
<p><span class="math display">\[
= n \times (v - v_\parallel)
\]</span></p>
<p><span class="math display">\[
= n \times v - n \times v_\parallel
\]</span></p>
<p><span class="math inline">\(n\)</span> ve <span
class="math inline">\(v_\parallel\)</span> birbirine paralel olduğu için
çapraz çarpımları sıfırdır,</p>
<p><span class="math display">\[
= n \times v - 0
\]</span></p>
<p><span class="math display">\[
w = n \times v
\]</span></p>
<p><span class="math display">\[
v&#39;_\perp = \cos \theta v_\perp + \sin \theta w
\]</span></p>
<p><span class="math display">\[
= \cos \theta (v - (v \cdot n) n) + \sin \theta (n \times v)
\]</span></p>
<p>Üstteki değeri <span class="math inline">\(v&#39;\)</span> formülü
içine sokalım,</p>
<p><span class="math display">\[
v&#39; = v&#39;_\perp + v_\parallel
\]</span></p>
<p><span class="math display">\[
v&#39; = \cos \theta (v - (v \cdot n) n) + \sin \theta (n \times v) + (v
\cdot n) n
\qquad (5)
\]</span></p>
<p>Eğer (5) formülünü matris formunda göstermek istiyorsak, baz
vektörleri <span class="math inline">\([\begin{array}{ccc} 1 &amp; 0
&amp; 0 \end{array}]^T\)</span>, <span
class="math inline">\([\begin{array}{ccc} 0 &amp; 1 &amp; 0
\end{array}]^T\)</span>, <span class="math inline">\([\begin{array}{ccc}
0 &amp; 0 &amp; 1 \end{array}]^T\)</span> teker teker (5) ile çarpıp
sonuçları bir diğer 3 x 3 matrisin kolonlarına yazabiliriz [1, sf.
143][1, sf. 757], böylece alttaki matrisi elde ederiz,</p>
<p><span class="math display">\[
\scriptsize
R(n,\theta) =
\left[\begin{array}{ccc}
n_x^2(1-\cos\theta)+\cos\theta &amp; n_x n_y (1-\cos\theta)+n_x
\sin\theta &amp; n_x n_z (1-\cos\theta)-n_x\sin\theta\\
n_x n_y (1-\cos\theta)-n_z\sin\theta &amp;
n_y^2(1-\cos\theta)+\cos\theta &amp; n_y n_z
(1-\cos\theta)n_x\sin\theta\\
n_x n_z (1-\cos\theta)+n_y \sin\theta &amp; n_y n_z (1-\cos\theta)-n_x
\sin\theta &amp; n_z^2 (1-\cos\theta)+\cos\theta
\end{array}\right]
\qquad (2)
\]</span></p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys<span class="op">;</span> sys.path.append(<span class="st">&#39;../phy_072_rot&#39;</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpl_toolkits.mplot3d <span class="im">import</span> Axes3D</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> plot3d</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rotate(v, n, theta):</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.cos(theta) <span class="op">*</span> ( v <span class="op">-</span> np.dot(v,n) ) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>           np.sin(theta)<span class="op">*</span> np.cross(n,v) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>           np.dot(v,n)<span class="op">*</span>n</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>o1 <span class="op">=</span> np.array([<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>])</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>v1 <span class="op">=</span> np.array([<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>])</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>n1 <span class="op">=</span> np.array([<span class="op">-</span><span class="dv">1</span><span class="op">/</span><span class="fl">3.</span>,<span class="dv">2</span><span class="op">/</span><span class="fl">3.</span>,<span class="dv">2</span><span class="op">/</span><span class="fl">3.</span>])</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>theta <span class="op">=</span> np.deg2rad(<span class="dv">20</span>)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>v1r <span class="op">=</span> rotate(v1, n1, theta)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, subplot_kw<span class="op">=</span>{<span class="st">&#39;projection&#39;</span>: <span class="st">&#39;3d&#39;</span>})</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>plot3d.plot_vector(ax, o1, v1)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>plot3d.plot_vector(ax, o1, v1r, <span class="st">&#39;cyan&#39;</span>)</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>plot3d.plot_vector(ax, o1, <span class="dv">3</span><span class="op">*</span>np.array(n1), <span class="st">&#39;red&#39;</span>)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>plot3d.plot_plane(ax, o1, n1, size<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>ax.view_init(elev<span class="op">=</span><span class="fl">40.</span>, azim<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;phy_073_rot_02.jpg&#39;</span>)</span></code></pre></div>
<p><img src="phy_073_rot_02.jpg" /></p>
<p>Teori</p>
<p>3D A,B vektörleri birbirine dikgen ve bir 2D uzay yaratıyorlar, ki
sanki A vektörü <span class="math inline">\(x\)</span> ekseni, B ise
<span class="math inline">\(y\)</span> ekseni. A vektörünün <span
class="math inline">\(\theta\)</span> açısı kadar döndürülmesi <span
class="math inline">\(Y = \cos \theta A + \sin \theta B\)</span>
vektörünü verir (üstteki problemde <span class="math inline">\(A =
v_\perp\)</span>, <span class="math inline">\(B = w\)</span>).</p>
<p>İspat</p>
<p>A ve B 3D uzayında bir 2D düzlemi kapsayan iki dikgen vektör ise, A
ve B’yi bu 2D düzlem için baz vektörleri olarak düşünebiliriz. A ve B
tarafından kapsanan düzlemdeki herhangi bir X vektörü, A ve B’nin bir
doğrusal birleşimi olarak ifade edilebilir:</p>
<p><span class="math inline">\(X = x_A A + x_B B\)</span></p>
<p>Burada, <span class="math inline">\(x_A\)</span> ve <span
class="math inline">\(x_B\)</span>, X’in A ve B doğrultularındaki
bileşenleridir.</p>
<p>A vektörü için, {A, B} bazındaki temsili, A doğrultusundaki bileşenin
1 ve B doğrultusundaki bileşenin 0 olduğu durumdur. Yani, A’yı bu 2D baz
sisteminde “x ekseni” ve B’yi “y ekseni” olarak düşünebiliriz, burada
A’nın “koordinatları” (1, 0) olur.</p>
<p>Şimdi, A vektörünü A ve B’nin kapsadığı düzlem içinde <span
class="math inline">\(\theta\)</span> açısı kadar döndürelim. Ortaya
çıkan vektöre Y diyelim. Standart bir 2D Kartezyen koordinat sisteminde,
koordinatları <span class="math inline">\((x, y)\)</span> olan bir
vektör <span class="math inline">\(\theta\)</span> açısı kadar saat
yönünün tersine döndürüldüğünde, yeni koordinatları <span
class="math inline">\((x&#39;, y&#39;)\)</span> şu şekilde bulunur:</p>
<p><span class="math inline">\(x&#39; = x \cos \theta - y \sin
\theta\)</span></p>
<p><span class="math inline">\(y&#39; = x \sin \theta + y \cos
\theta\)</span></p>
<p>Bizim durumumuzda, A vektörünün {A, B} bazındaki başlangıç
“koordinatları” <span class="math inline">\((1, 0)\)</span>’dır. A’yı
<span class="math inline">\(\theta\)</span> kadar döndürdüğümüzde,
ortaya çıkan Y vektörünün {A, B} bazındaki yeni “koordinatları”, <span
class="math inline">\((y_A, y_B)\)</span>, <span
class="math inline">\((x, y) = (1, 0)\)</span> kullanılarak 2D döndürme
formülleriyle bulunabilir:</p>
<p><span class="math inline">\(y_A = 1 \cdot \cos \theta - 0 \cdot \sin
\theta = \cos \theta\)</span></p>
<p><span class="math inline">\(y_B = 1 \cdot \sin \theta + 0 \cdot \cos
\theta = \sin \theta\)</span></p>
<p>Dolayısıyla, döndürülen Y vektörünün {A, B} bazındaki bileşenleri, A
doğrultusunda <span class="math inline">\(\cos \theta\)</span> ve B
doğrultusunda <span class="math inline">\(\sin \theta\)</span> olur.</p>
<p>Şimdi Y vektörünü, bu bileşenleri kullanarak baz vektörler A ve B’nin
doğrusal birleşimi olarak yazabiliriz:</p>
<p><span class="math inline">\(Y = y_A A + y_B B\)</span></p>
<p><span class="math inline">\(Y = \cos \theta A + \sin \theta
B\)</span></p>
<p>Bu, A vektörünün A ve B’nin kapsadığı 2D düzlem içinde <span
class="math inline">\(\theta\)</span> açısı kadar döndürülmesinin <span
class="math inline">\(Y = \cos \theta A + \sin \theta B\)</span>
vektörünü verdiğini kanıtlar. Bu, bir 2D Kartezyen düzlemde x
eksenindeki <span class="math inline">\((1, 0)\)</span> vektörünün <span
class="math inline">\(\theta\)</span> kadar döndürüldüğünde <span
class="math inline">\((\cos \theta, \sin \theta)\)</span>’ye dönmesiyle
benzerdir. A ve B vektörleri, 3D uzayında bu 2D dönüşüm için eksenleri
sağlar.</p>
<p>Dörtlü Grup / Kuaterniyon (Quaternions)</p>
<p>Bir vektörü, fiziksel objeyi döndürmek için çok faydalı bir diğer
kavram kuaterniyon kavramı. Kuaterniyon matematiği hayali (imaginery,
complex) sayıları baz alan bir cebir sistemidir, William Hamilton
tarafından keşfedilmiştir. Bir kuaterniyon sayı dört reel sayı ve üç
tane hayali sayı içerir,</p>
<p><span class="math display">\[
q = [\begin{array}{cccc} w &amp; x &amp; y &amp; z \end{array}]
\]</span></p>
<p>olarak yazılabilir, ki son üç sayı hayalidir, ya da</p>
<p><span class="math display">\[
q = w + i x + j y + k z
\]</span></p>
<p>Görüldüğü gibi bu cebirin olabilmesi için sadece <span
class="math inline">\(i\)</span> değil, ek olarak <span
class="math inline">\(j,k\)</span> hayali sayıları sisteme ekleniyor, ve
önkabul olarak şu ifade ileri sürülüyor [1, sf. 247],</p>
<p><span class="math display">\[
i^2 = j^2 = k^2 = ijk = -1
\]</span></p>
<p>Üstteki ifadelerden geri kalan eşitlikler türetilebilir [4, sf. 170],
mesela</p>
<p><span class="math display">\[
ijk = -1 = k^2 \Rightarrow ij = k
\]</span></p>
<p>Ayrıca <span class="math inline">\(ij = -ji\)</span>, yani
sırabağımsızlık yoktur.</p>
<p>Tüm önverili ve türetilmiş ifadeleri biraraya koyarsak,</p>
<p><span class="math display">\[
i^2 = j^2 = k^2 = ijk = -1
\]</span></p>
<p><span class="math display">\[
ij = -ji = k
\]</span></p>
<p><span class="math display">\[
jk = -kj = i
\]</span></p>
<p><span class="math display">\[
ki = -ik = j
\]</span></p>
<p>Üsttekilere Hamilton’un kurallları adı veriliyor.</p>
<p>Eşlenik (conjugate) hesabı bir <span class="math inline">\(q\)</span>
için <span class="math inline">\(q^{\ast}\)</span> olarak gösterilir,
hayali olan kısmın negatiflenmesi ile elde edilir, yani</p>
<p><span class="math display">\[
q^{\ast} = [\begin{array}{cccc} w &amp; -x &amp; -y &amp; -z
\end{array}]
\]</span></p>
<p>Tersi (inverse) işlemi ise eşleniğin büyüklüğe bölünmüş halidir,</p>
<p><span class="math display">\[
q^{-1} = \frac{q^{\ast}}{|| q ||}
\]</span></p>
<p>Kuaterniyon çarpımı mesela <span
class="math inline">\(q_1,q_2\)</span> arasında, parantez içi dört
sayının çarpım ve toplamsal açılımı yapılıp üstteki kurallar uygulanarak
elde edilebilir [1, sf. 773],</p>
<p><span class="math display">\[
q_1 = w_1 + x_1 i + y_1 j + z_1 k
\]</span></p>
<p><span class="math display">\[
q_2 = w_2 + x_2 i + y_2 j + z_2 k
\]</span></p>
<p><span class="math display">\[\begin{align*}
q_1 q_2 =
w_1 w_2 + w_1 x_2 i + w_1 y_2 j + w_1 z_2 k + \\
x_1 w_2 i + x_1 x_2 i^2 + x_1 y_2 ij x_1 z_2 ik + \\
y_1 w_2 j + y_1 x_2 ji + y_1 y_2 j^2 + y_1 z_2 jk + \\
z_1 w_2 k + z_1 x_2 ki + z_1 y_2 kj + z_1 z_2 k^2
\end{align*}\]</span></p>
<p><span class="math display">\[\begin{align*}
= w_1 w_2 + w_1 x_2 i + w_1 y_2 j + w_1 z_2 k + \\
x_1 w_2 i + x_1 x_2 (-1) + x_1 y_2 k + x_1 z_2 (-j) + \\
y_1 w_2 j + y_1 x_2 (-k) y_1 y_2 (-1) + y_1 z_2 (i) + \\
z_1 w_2 k + z_1 x_2 j + z_1 y_2 (-i) + z_1 z_2 (-1)
\end{align*}\]</span></p>
<p>Nihai çarpım denklemi</p>
<p><span class="math display">\[\begin{align*}
= w_1 w_2 - x_1 x_2 - y_1 y_2 - z_1 z_2 + \\
(w_1 x_2 + x_1 w_2 + y_1 z_2 - z_1 y_2 + \\
(w_1 y_2 + y_1 w_2 + z_1 x_2 - x_1 z_2) j + \\
(w_1 z_2 + z_1 w_2 + x_1 y_2 - y_1 x_2) k
\end{align*}\]</span></p>
<p>Ve nihayet döndürme işleminin nasıl yapılacağına geliyoruz, <span
class="math inline">\(n\)</span> vektörü etrafında bir <span
class="math inline">\(p\)</span> noktasına <span
class="math inline">\(\theta\)</span> dönüşü yaptırabilmek için bir şu
şekilde bir kuaterniyon yaratıyoruz,</p>
<p><span class="math display">\[
q = [\begin{array}{cccc}
    \cos(\theta/2) &amp;
    \sin(\theta/2) n_x &amp;
    \sin(\theta/2) n_y &amp;
    \sin(\theta/2) n_z \end{array}]
\]</span></p>
<p><span class="math inline">\(p\)</span> noktasını skala değeri 0 olan
bir diğer kuaterniyon olarak yazıyoruz,</p>
<p><span class="math display">\[
p = [\begin{array}{cccc} 0 &amp; p_x &amp; p_y &amp; p_z \end{array}]
\]</span></p>
<p>Ve şu şekilde bir çarpım yapıyoruz,</p>
<p><span class="math display">\[
p&#39; = q p q^{-1}
\]</span></p>
<p>Dikkat, üstteki yöntem üç boyutlu bir gerçek vektörü döndürmek için
bulunmuştur, reel değere 0 verip diğer x,y,z değerlerini vektörün geri
kalan yerlerine yazarak aslında bir numara gerçekleştiriyoruz, ki
kuaterniyon cebiri bu değeri alıp 4 boyutlu uzaya “gömsun” ve onu
kuaterniyon cebirine dahil edebilsin. Dönüş bu uzayda <span
class="math inline">\(q\)</span> çarpımı ile gerçekleşiyor, ve bu hesap
bitince <span class="math inline">\(q^{-1}\)</span> yani <span
class="math inline">\(q\)</span>’nun tersi ile başlangıç uzayına
dönüyoruz.</p>
<p>Üstteki formülün bir vektör dönüşüne eşdeğer olduğunun ispatı bu
yazının altında bulunabilir.</p>
<p>Kod üzerinde görelim [3],</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> q_mult(q1, q2):</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    w1, x1, y1, z1 <span class="op">=</span> q1</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    w2, x2, y2, z2 <span class="op">=</span> q2</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    w <span class="op">=</span> w1 <span class="op">*</span> w2 <span class="op">-</span> x1 <span class="op">*</span> x2 <span class="op">-</span> y1 <span class="op">*</span> y2 <span class="op">-</span> z1 <span class="op">*</span> z2</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> w1 <span class="op">*</span> x2 <span class="op">+</span> x1 <span class="op">*</span> w2 <span class="op">+</span> y1 <span class="op">*</span> z2 <span class="op">-</span> z1 <span class="op">*</span> y2</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> w1 <span class="op">*</span> y2 <span class="op">+</span> y1 <span class="op">*</span> w2 <span class="op">+</span> z1 <span class="op">*</span> x2 <span class="op">-</span> x1 <span class="op">*</span> z2</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> w1 <span class="op">*</span> z2 <span class="op">+</span> z1 <span class="op">*</span> w2 <span class="op">+</span> x1 <span class="op">*</span> y2 <span class="op">-</span> y1 <span class="op">*</span> x2</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> w, x, y, z</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> q_conjugate(q):</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    w, x, y, z <span class="op">=</span> q</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (w, <span class="op">-</span>x, <span class="op">-</span>y, <span class="op">-</span>z)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> normalize(v, tolerance<span class="op">=</span><span class="fl">0.00001</span>):</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    mag2 <span class="op">=</span> <span class="bu">sum</span>(n <span class="op">*</span> n <span class="cf">for</span> n <span class="kw">in</span> v)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">abs</span>(mag2 <span class="op">-</span> <span class="fl">1.0</span>) <span class="op">&gt;</span> tolerance:</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        mag <span class="op">=</span> math.sqrt(mag2)</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> <span class="bu">tuple</span>(n <span class="op">/</span> mag <span class="cf">for</span> n <span class="kw">in</span> v)</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> v</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> axisangle_to_q(v, theta):</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> normalize(v)</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    x, y, z <span class="op">=</span> v</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    theta <span class="op">/=</span> <span class="dv">2</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    w <span class="op">=</span> math.cos(theta)</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> x <span class="op">*</span> math.sin(theta)</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> y <span class="op">*</span> math.sin(theta)</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> z <span class="op">*</span> math.sin(theta)</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> w, x, y, z</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rotate(q1, v1):</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    q2 <span class="op">=</span> (<span class="fl">0.0</span>,) <span class="op">+</span> v1</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    tmp1 <span class="op">=</span> q_mult(q1, q2)</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>    tmp2 <span class="op">=</span> q_conjugate(q1)</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> q_mult(tmp1, tmp2)[<span class="dv">1</span>:]</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>    </span></code></pre></div>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>o1 <span class="op">=</span> (<span class="fl">5.0</span>,<span class="fl">5.0</span>,<span class="fl">5.0</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>v1 <span class="op">=</span> (<span class="fl">3.0</span>,<span class="fl">3.0</span>,<span class="fl">3.0</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>n1 <span class="op">=</span> (<span class="op">-</span><span class="dv">1</span><span class="op">/</span><span class="fl">3.</span>,<span class="dv">2</span><span class="op">/</span><span class="fl">3.</span>,<span class="dv">2</span><span class="op">/</span><span class="fl">3.</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>theta <span class="op">=</span> np.deg2rad(<span class="dv">30</span>)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>r1 <span class="op">=</span> axisangle_to_q(n1, theta)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>v1r <span class="op">=</span> rotate(r1, v1)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, subplot_kw<span class="op">=</span>{<span class="st">&#39;projection&#39;</span>: <span class="st">&#39;3d&#39;</span>})</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>plot3d.plot_vector(ax, o1, v1)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>plot3d.plot_vector(ax, o1, v1r, <span class="st">&#39;cyan&#39;</span>)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>plot3d.plot_vector(ax, o1, <span class="dv">3</span><span class="op">*</span>np.array(n1), <span class="st">&#39;red&#39;</span>)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>plot3d.plot_plane(ax, o1, n1, size<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>ax.view_init(elev<span class="op">=</span><span class="fl">10.</span>, azim<span class="op">=</span><span class="dv">50</span>)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;phy_073_rot_03.jpg&#39;</span>)</span></code></pre></div>
<p><img src="phy_073_rot_03.jpg" /></p>
<p>Farklı bir açıdan daha bakalım, bazen kamera bakış yönüne göre sonuç
tam belli olmayabiliyor. Etrafında dönüş yapılan <span
class="math inline">\(n\)</span> vektörü direk <span
class="math inline">\(y\)</span> eksenine bakıyor olsun, kamerayı o yöne
koyalım ve 90 derece dönüş yapalım,</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>o2 <span class="op">=</span> (<span class="fl">5.0</span>,<span class="fl">5.0</span>,<span class="fl">5.0</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>v2 <span class="op">=</span> (<span class="fl">3.0</span>,<span class="fl">3.0</span>,<span class="fl">3.0</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>n2 <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>theta <span class="op">=</span> np.deg2rad(<span class="dv">90</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>r2 <span class="op">=</span> axisangle_to_q(n2, theta)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>v2r <span class="op">=</span> rotate(r2, v2)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, subplot_kw<span class="op">=</span>{<span class="st">&#39;projection&#39;</span>: <span class="st">&#39;3d&#39;</span>})</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>plot3d.plot_vector(ax, o2, v2)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>plot3d.plot_vector(ax, o2, v2r, <span class="st">&#39;cyan&#39;</span>)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>plot3d.plot_vector(ax, o2, <span class="dv">3</span><span class="op">*</span>np.array(n2), <span class="st">&#39;red&#39;</span>)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>plot3d.plot_plane(ax, o2, n2, size<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>ax.view_init(elev<span class="op">=</span><span class="fl">0.</span>, azim<span class="op">=</span><span class="dv">90</span>)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;phy_073_rot_04.jpg&#39;</span>)</span></code></pre></div>
<p><img src="phy_073_rot_04.jpg" /></p>
<p>Kuaterniyon hesabının rotasyon yaptığının belki de bir diğer ispatı
<span class="math inline">\(q v q^{-1}\)</span> hesabını (2) formundaki
rotasyon matrisı formatında gösterebilmek. (2) matrisindeki her hücreyi
teker teker alıp onu <span
class="math inline">\(n_x,n_y,n_z,\theta\)</span> değişkenlerinden <span
class="math inline">\(w,x,y,z\)</span> kuaterniyon değişkenlerine
tercüme edebilirsek, ve bu matrisin döndürme yaptığını görürsek bir tür
ispat elde etmiş olabiliriz, detaylar için [1,sf. 282].</p>
<p>Farklı Teorik Yaklaşım</p>
<p>Buraya kadar güzel, fakat Hamilton’un sunduğu şekildeki teoride bazı
boşluklar var, mesela <span class="math inline">\(ijk = -1\)</span>
önkabulü biraz zorlanmış gibi geliyor, daha doğrusu rasgele (arbitrary)
seçilmiş gibi. Bir şey denenmiş ve işlediği görülünce kullanılmaya devam
edilmiş. Fakat bir önkabul olsa da bu ifadenin, ve ek hayali sayılar
<span class="math inline">\(j,k\)</span> seçimlerinin daha baz bir
temelden geliyor olmaları iyi olurdu.</p>
<p>[5] bağlantısında bu tür açıklamalar görüyoruz. Bunlardan biri der ki
<span class="math inline">\(i,j,k\)</span> aslında <span
class="math inline">\(\mathbb{R}^4\)</span> uzayında birer
<em>bazdır</em>,</p>
<p><span class="math display">\[
i = \left[\begin{array}{cccc}
0 &amp; 1 &amp; 0 &amp; 0 \\ -1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0
&amp; 0 &amp; 1\\ 0 &amp; 0 &amp; -1 &amp; 0
\end{array}\right], \quad
j = \left[\begin{array}{cccc}
0 &amp; 0 &amp; 0 &amp; -1 \\ 0 &amp; 0 &amp; -1 &amp; 0 \\ 0 &amp; 1
&amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0 &amp; 0
\end{array}\right], \quad
k = \left[\begin{array}{cccc}
0 &amp; 0 &amp; -1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ 1 &amp; 0
&amp; 0 &amp; 0\\ 0 &amp; -1 &amp; 0 &amp; 0
\end{array}\right]
\]</span></p>
<p>Ve Hamilton kuralları bu baz üzerinden hesaplanabilir,</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> np.array([[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>],[<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>]])</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> np.array([[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>],[<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]])</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> np.array([[<span class="dv">0</span>,<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>]])</span></code></pre></div>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>np.dot(i,i)</span></code></pre></div>
<pre><code>Out[1]: 
array([[-1,  0,  0,  0],
       [ 0, -1,  0,  0],
       [ 0,  0, -1,  0],
       [ 0,  0,  0, -1]])</code></pre>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>np.dot(j,j)</span></code></pre></div>
<pre><code>Out[1]: 
array([[-1,  0,  0,  0],
       [ 0, -1,  0,  0],
       [ 0,  0, -1,  0],
       [ 0,  0,  0, -1]])</code></pre>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>np.dot(k,k)</span></code></pre></div>
<pre><code>Out[1]: 
array([[-1,  0,  0,  0],
       [ 0, -1,  0,  0],
       [ 0,  0, -1,  0],
       [ 0,  0,  0, -1]])</code></pre>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>i.dot(j).dot(k)</span></code></pre></div>
<pre><code>Out[1]: 
array([[-1,  0,  0,  0],
       [ 0, -1,  0,  0],
       [ 0,  0, -1,  0],
       [ 0,  0,  0, -1]])</code></pre>
<p>Çarpımlarda elde edilen sonucun eksi birim (identity) matris olduğuna
dikkat, yani <span class="math inline">\(jk = -1\)</span> yerine <span
class="math inline">\(JK = -I\)</span> elde ediyoruz ki <span
class="math inline">\(I\)</span> standart notasyonda birim matristir
(paylaşılan bağlantıda farklı sembol <span
class="math inline">\(U\)</span> kullanılmış çünkü <span
class="math inline">\(I\)</span> matrisi <span
class="math inline">\(i\)</span>’nin bazı olarak kullanılıyor, semboller
karışıklık yaratmasın).</p>
<p>Bu yaklaşım rasgele bir <span class="math inline">\(ijk=-1\)</span>
seçiminden ziyade problemi bir baz seçimi haline dönüştürüyor, ki Lineer
Cebir’de baz seçimi her zaman yapılır, bir transformasyon olduğunda
“yeni baz nedir?’’ diye sorarız, bu daha anlaşılır bir kavramdır.</p>
<p>[1, sf. 264]’te kuaterniyon ve matris cebiri bağlantısı daha ileri
götürülüyor, ve niye <span class="math inline">\(\theta\)</span> yerine
<span class="math inline">\(\theta / 2\)</span> kullanılmış olabileceği
açıklanıyor. Bu açıklamaya göre hiç kuaterniyon cebirine girmeden direk
kuaterniyon sayılarına tekabül eden matrisler ile temel lineer cebir
işlemleri yaparak aynı sonuca erişmek mümkündür.</p>
<p>Paketler</p>
<p>[6] bağlantısında faydalı bazı kodlar var, onu <code>euclid.py</code>
içinde bu dizine kaydettik, kullanım örnekleri,</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> euclid</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>q1 <span class="op">=</span> euclid.Quaternion(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>q1</span></code></pre></div>
<pre><code>Out[1]: Quaternion(real=1.00, imag=&lt;1.00, 1.00, 1.00&gt;)</code></pre>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>q1.conjugated()</span></code></pre></div>
<pre><code>Out[1]: Quaternion(real=1.00, imag=&lt;-1.00, -1.00, -1.00&gt;)</code></pre>
<div class="sourceCode" id="cb18"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>q2 <span class="op">=</span> euclid.Quaternion(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">4</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>q1 <span class="op">*</span> q2</span></code></pre></div>
<pre><code>Out[1]: Quaternion(real=-8.00, imag=&lt;4.00, 4.00, 8.00&gt;)</code></pre>
<p>Kuaterniyon Döndürmesinin Doğruluğunu Göstermek</p>
<p>Bu makalede [7], kuaterniyon döndürmesinin doğru olduğunu gösteren
cebirsel bir ispat sunacağız. İyi bilindiği gibi, bir <span
class="math inline">\(\vec{v}\)</span> vektörünü, <span
class="math inline">\(\vec{u}\)</span> döndürme ekseni etrafında <span
class="math inline">\(\theta\)</span> açısıyla kuaterniyonları
kullanarak döndürebiliriz. Bu, aşağıdaki hesaplama ile yapılır:</p>
<p><span class="math display">\[
\mathbf{q} \vec{v} \mathbf{q}^{-1}.
\]</span></p>
<p>Burada <span class="math inline">\(\mathbf{q}\)</span> bir
kuaterniyondur:</p>
<p><span class="math display">\[
\mathbf{q} = \cos\left(\frac{\theta}{2}\right) +
\vec{u}\sin\left(\frac{\theta}{2}\right)
\qquad (1)
\]</span></p>
<p>Ancak, bu hesaplamanın böyle bir döndürmeyle sonuçlanması hiç de
bariz değildir. Bu makalede, bu hesaplamanın gerçekten de istenen
döndürmeyle sonuçlandığını göstereceğiz. Bu, (1)’in Rodrigues’in
döndürme formülüne [8] eşdeğer olduğunu göstererek yapılacaktır. (1)’in
döndürmesi Rodrigues’in formülü kullanılarak şu şekilde
hesaplanabilir:</p>
<p><span class="math display">\[
\vec{v} \cos(\theta) + (\vec{u} \times \vec{v}) \sin(\theta) +
\vec{u}(\vec{u} \cdot \vec{v})(1 - \cos(\theta))
\qquad (2)
\]</span></p>
<p>Denklem (2)’nin neden istediğimiz döndürmeyle sonuçlandığı çok daha
açıktır. Bu nedenle, (1) ve (2)’nin eşdeğerliğini gösterecek ve böylece
kuaterniyon döndürmesinin beklediğimizi yaptığından emin olacağız.</p>
<p>Kuaterniyon Çarpımı</p>
<p>Bir basamak taşı olarak, iki kuaterniyonun çarpımı için bir formül
gereklidir. İki kuaterniyonun çarpımı şudur:</p>
<p><span class="math display">\[
(a + b \mathbf{i} + c\mathbf{j} + d\mathbf{k})(e + f \mathbf{i} +
g\mathbf{j} +h\mathbf{k}) = \\ (ae + af\mathbf{i} + ag\mathbf{j} +
ah\mathbf{k}) + \\ (be\mathbf{i} +bf \mathbf{i}\mathbf{i} + bg
\mathbf{i}\mathbf{j} + bh \mathbf{i}\mathbf{k} + \\ (ce\mathbf{j} +cf
\mathbf{j}\mathbf{i} + cg \mathbf{j}\mathbf{j} + ch \mathbf{j}\mathbf{k}
+ \\ (de\mathbf{k} +df \mathbf{k}\mathbf{i} + dg \mathbf{k}\mathbf{j} +
dh \mathbf{k}\mathbf{k}
\]</span></p>
<p><span class="math inline">\(\mathbf{i}\mathbf{i},
\mathbf{i}\mathbf{j}, \mathbf{i}\mathbf{k},\dots\)</span> basitleştirmek
mümkündür. Ünlü <span class="math inline">\(\mathbf{i}\mathbf{i} =
\mathbf{j}\mathbf{j} = \mathbf{k}\mathbf{k} =
\mathbf{i}\mathbf{j}\mathbf{k} = -1\)</span> gerçeğini hatırlayın.
Böylece <span class="math inline">\(\mathbf{i}\mathbf{i}\)</span>, <span
class="math inline">\(\mathbf{j}\mathbf{j}\)</span> ve <span
class="math inline">\(\mathbf{k}\mathbf{k}\)</span> için
basitleştirmeler zaten açıktır. Peki ya <span
class="math inline">\(\mathbf{i}\mathbf{j}\)</span>? Elimzide şunlar
var:</p>
<p><span class="math display">\[
\mathbf{i}\mathbf{j}\mathbf{k} = -1 \\
\mathbf{i}\mathbf{j}\mathbf{k}\mathbf{k} = -\mathbf{k} \\
-\mathbf{i}\mathbf{j} = -\mathbf{k} \\ \mathbf{i}\mathbf{j} =
\mathbf{k}.
\]</span></p>
<p>Benzer şekilde,</p>
<p><span class="math display">\[
\mathbf{i}\mathbf{j}\mathbf{k} = -1 \\
\mathbf{i}\mathbf{i}\mathbf{j}\mathbf{k} = -\mathbf{i} \\
\mathbf{j}\mathbf{k} = \mathbf{i}.
\]</span></p>
<p>Yukarıdaki gerçeği kullanarak, şunlar çıkar:</p>
<p><span class="math display">\[
\mathbf{i} = \mathbf{j}\mathbf{k} \\ \mathbf{j}\mathbf{i} =
\mathbf{j}\mathbf{j}\mathbf{k} \\ \mathbf{j}\mathbf{i} = -\mathbf{k}.
\]</span></p>
<p>Özellikle, <span class="math inline">\(\mathbf{i}\mathbf{j} \neq
\mathbf{j}\mathbf{i}\)</span> olduğuna dikkat edin. Kalan üç özdeşliği
kanıtlamak okuyucuya bir alıştırma olarak bırakılmıştır: <span
class="math inline">\(\mathbf{k}\mathbf{j} = -\mathbf{i}\)</span>, <span
class="math inline">\(\mathbf{i}\mathbf{k} = -\mathbf{j}\)</span>, <span
class="math inline">\(\mathbf{k}\mathbf{i} = \mathbf{j}\)</span>.</p>
<p>Bu özdeşliklerle donanımımızda, kuaterniyon çarpımı önemli ölçüde
basitleştirilebilir:</p>
<p><span class="math display">\[
(ae + af\mathbf{i} + ag\mathbf{j} + ah\mathbf{k}) + \\ (be\mathbf{i} +bf
\mathbf{i}\mathbf{i} + bg \mathbf{i}\mathbf{j} + bh \mathbf{i}\mathbf{k}
+ \\ (ce\mathbf{j} +cf \mathbf{j}\mathbf{i} + cg \mathbf{j}\mathbf{j} +
ch \mathbf{j}\mathbf{k} + \\ (de\mathbf{k} +df \mathbf{k}\mathbf{i} + dg
\mathbf{k}\mathbf{j} + dh \mathbf{k}\mathbf{k} = \\ ae - (bf + cg + dh)
+ \\ (be + af + ch - dg)\mathbf{i} + \\ (ce + ag + df - bh)\mathbf{j} +
\\ (de + ah + bg - cf)\mathbf{k}.
\]</span></p>
<p>Bir kuaterniyonu bir skalar ve bir vektörün toplamı olarak düşünmek
faydalıdır. Örneğin, <span class="math inline">\(a + b \mathbf{i} +
c\mathbf{j} + d\mathbf{k}\)</span> kuaterniyonu basitçe <span
class="math inline">\(a\)</span> skalarıdır artı üç boyutlu vektör <span
class="math inline">\(b\mathbf{i} + c\mathbf{j} + d\mathbf{k}\)</span>.
Bu gösterim, <span class="math inline">\(b\)</span>’nin vektörün <span
class="math inline">\(x\)</span>-bileşeni, <span
class="math inline">\(c\)</span>’nin <span
class="math inline">\(y\)</span>-bileşeni vb. olduğu anlamına gelir. Bu
vektörü <span class="math inline">\(\vec{v} = b\mathbf{i} + c\mathbf{j}
+ d\mathbf{k}\)</span> olarak göstereceğiz, böylece <span
class="math inline">\(a + b \mathbf{i} + c\mathbf{j} + d\mathbf{k} = a +
\vec{v}\)</span> yazabiliriz. Benzer şekilde, <span
class="math inline">\(e + f \mathbf{i} + g\mathbf{j} +h\mathbf{k} = e +
\vec{w}\)</span> yazarız. Şimdi şunları gözlemleyin:</p>
<p><span class="math display">\[
ae - (bf + cg + dh) + \\ (be + af + ch - dg)\mathbf{i} + \\ (ce + ag +
df - bh)\mathbf{j} + \\ (de + ah + bg - cf)\mathbf{k} = \\ ae - (bf + cg
+ dh) + \\ \begin{bmatrix} be + af + ch - dg \\ ce + ag + df - bh \\ de
+ ah + bg - cf \end{bmatrix} = \\ ae - (bf + cg + dh) + e\begin{bmatrix}
b \\ c \\ d \end{bmatrix} + a\begin{bmatrix} f \\ g \\ h \end{bmatrix} +
\begin{bmatrix} ch - dg \\ df - bh \\ bg - cf \end{bmatrix} = \\ ae -
\vec{v} \cdot \vec{w} + e\vec{v} + a \vec{w} + \vec{v}\times\vec{w}
\]</span></p>
<p>Böylece, bir kuaterniyon bir skalar ve bir vektörün toplamı olarak
görüldüğünde, zarif bir sonuç ortaya çıkar:</p>
<p><span class="math display">\[
(a + \vec{v})(e + \vec{w}) = (ae - \vec{v} \cdot \vec{w}) + (e\vec{v}
+ a \vec{w} + \vec{v}\times\vec{w})
\qquad (3)
\]</span></p>
<p>Böylece kuaterniyon çarpımının skalar kısmı <span
class="math inline">\((ae - \vec{v} \cdot \vec{w})\)</span>, vektör
kısmı ise <span class="math inline">\((e\vec{v} + a \vec{w} +
\vec{v}\times\vec{w})\)</span>’dir. Beklendiği gibi, iki kuaterniyonun
çarpımı başka bir kuaterniyon verir. Bu formül bir sonraki bölümde yoğun
bir şekilde uygulanacaktır.</p>
<p><strong>Kuaterniyon Döndürmesini Basitleştirmek</strong></p>
<p>Kuaterniyon döndürme formülü ile başlıyoruz:</p>
<p><span class="math display">\[
\mathbf{q} \vec{v} \mathbf{q}^{-1} =
\left(\cos\left(\frac{\theta}{2}\right) +
\vec{u}\sin\left(\frac{\theta}{2}\right)\right) \vec{v}
\left(\cos\left(\frac{\theta}{2}\right) -
\vec{u}\sin\left(\frac{\theta}{2}\right)\right)
\]</span></p>
<p>Denklem (3) çarpımını genişletmek için iki kez kullanılır:</p>
<p><span class="math display">\[
\mathbf{q} \vec{v} \mathbf{q}^{-1} = \\
\left(\cos\left(\frac{\theta}{2}\right) +
\vec{u}\sin\left(\frac{\theta}{2}\right)\right) \vec{v}
\left(\cos\left(\frac{\theta}{2}\right) -
\vec{u}\sin\left(\frac{\theta}{2}\right)\right) = \\
\left(\left(-\sin\left(\frac{\theta}{2}\right){}
\vec{u}\cdot\vec{v}\right) + \cos\left(\frac{\theta}{2}\right){}\vec{v}
+ \sin\left(\frac{\theta}{2}\right){}(\vec{u}\times\vec{v}) \right)
\left(\cos\left(\frac{\theta}{2}\right) -
\vec{u}\sin\left(\frac{\theta}{2}\right)\right) = \\
-\sin\left(\frac{\theta}{2}\right){}\cos\left(\frac{\theta}{2}\right){}
\vec{u}\cdot \vec{v}+ \left(
\cos\left(\frac{\theta}{2}\right){}\vec{v}+
\sin\left(\frac{\theta}{2}\right){}(\vec{u}\times\vec{v})\right) \cdot
\left(\vec{u}\sin\left(\frac{\theta}{2}\right){}\right)+ \\
\left(-\sin\left(\frac{\theta}{2}\right){}\vec{u}\cdot\vec{v}\right)\left(-\vec{u}\sin\left(\frac{\theta}{2}\right){}\right)+
\\
\cos\left(\frac{\theta}{2}\right){}\left(\cos\left(\frac{\theta}{2}\right){}\vec{v}+
\sin\left(\frac{\theta}{2}\right)(\vec{u}\times\vec{v})\right) + \\
\left(\cos\left(\frac{\theta}{2}\right){}\vec{v}+
\sin\left(\frac{\theta}{2}\right){}(\vec{u}\times \vec{v})\right) \times
\left(-\vec{u}
\sin\left(\frac{\theta}{2}\right){}\right)
\]</span></p>
<p>Üçüncü satırdaki formülün sıfıra eşit çıktığına dikkat edin. Bunun
nedeni, nokta çarpımının toplama altında dağılımıdır (<span
class="math inline">\(a \cdot(b +c) = a \cdot b + a \cdot c\)</span>) ve
<span class="math inline">\((\vec{u}\times \vec{v}) \cdot \vec{u}=
0\)</span> olduğu içindir. Bunun nedenini görmek kolaydır: <span
class="math inline">\(\vec{u}\times \vec{v}\)</span> vektörü hem <span
class="math inline">\(\vec{u}\)</span> hem de <span
class="math inline">\(\vec{v}\)</span> ye dik bir vektördür. O zaman
<span class="math inline">\((\vec{u}\times \vec{v}) \cdot
\vec{u}\)</span> basitçe birbirine dik olan iki vektörün nokta
çarpımıdır. Dolayısıyla, bu nokta çarpımı sıfırdır. Geometrik durum
aşağıdaki resimde gösterilmiştir.</p>
<p><img src="crossprod.jpg" /></p>
<p>Böylece basitleştirilmiş ifadeyi elde ederiz:</p>
<p><span class="math display">\[\sin^2\left(\frac{\theta}{2}\right){}
(\vec{u}\cdot \vec{v})\vec{u}+ \\
\cos^2\left(\frac{\theta}{2}\right)\vec{v}+
\sin\left(\frac{\theta}{2}\right)\cos\left(\frac{\theta}{2}\right)(\vec{u}\times\vec{v})
\\
+\sin\left(\frac{\theta}{2}\right){}\cos\left(\frac{\theta}{2}\right){}
(\vec{u}\times \vec{v}) - \sin^2\left(\frac{\theta}{2}\right){}
(\vec{u}\times\vec{v}) \times \vec{u}\]</span></p>
<p>Burada çapraz çarpımın dağılım özelliğini uyguladık: <span
class="math inline">\((\vec{a} + \vec{b})\times\vec{c} =
\vec{a}\times\vec{c} + \vec{b}\times\vec{c}\)</span>. Yarım açı
formülünden <span class="math inline">\(\sin(x) =
2\sin\left(\frac{x}{2}\right)\cos\left(\frac{x}{2}\right)\)</span>, şu
şekilde basitleşir:</p>
<p><span class="math display">\[\sin^2\left(\frac{\theta}{2}\right){}
(\vec{u}\cdot \vec{v})\vec{u}+
\cos^2\left(\frac{\theta}{2}\right)\vec{v}+ \sin(\theta)(\vec{u}\times
\vec{v}) -\sin^2\left(\frac{\theta}{2}\right){} (\vec{u}\times\vec{v})
\times \vec{u}\]</span></p>
<p>Daha sonra vektör üçlü çarpımı (<span
class="math inline">\(\vec{a}\times(\vec{b}\times\vec{c}) =
\vec{b}(\vec{a}\cdot\vec{c}) - \vec{c}(\vec{a}\cdot\vec{b})\)</span>) ve
birkaç yarım açı formülü daha kullanılarak bazı basitleştirmeler
yapılır. Bu burada gösterilmemiştir, ancak okuyucuya küçük bir alıştırma
olarak bırakılmıştır. Basitleştirmeler yapıldıktan sonra geriye kalan
şudur:</p>
<p><span class="math display">\[\vec{v}\cos(\theta) +
(\vec{u}\times\vec{v})\sin(\theta) + (\vec{u}\cdot\vec{v})\vec{u}(1 -
\cos(\theta)).\]</span></p>
<p>Ama bu (2) denklemi değil midir? Ve bununla spat tamamlanmıştır.
Kuaterniyon döndürmesinin Rodrigues’in formülüne eşdeğer olduğu
gösterilmiştir ve bu, kuaterniyon döndürmesinin gerçekten de
beklediğimizi yaptığı anlamına gelir.</p>
<p>Kodlar</p>
<p><a href="euclid.py">euclid.py</a></p>
<p>Kaynaklar</p>
<p>[1] Dunn, <em>3D Math Primer for Graphics and Game
Development</em></p>
<p>[2] Bayramlı, <em>Lineer Cebir - Giriş</em></p>
<p>[3] Stackoverflow, <a
href="https://stackoverflow.com/questions/4870393/rotating-coordinate-system-via-a-quaternion/42180896#42180896">https://stackoverflow.com/questions/4870393/rotating-coordinate-system-via-a-quaternion/42180896#42180896</a></p>
<p>[4] Millington, <em>Game Physics Engine Development</em></p>
<p>[5] Wolfram Mathworld, <a
href="https://mathworld.wolfram.com/Quaternion.html">https://mathworld.wolfram.com/Quaternion.html</a></p>
<p>[6] Ezag, PyEuclid, <a
href="https://github.com/ezag/pyeuclid">https://github.com/ezag/pyeuclid</a></p>
<p>[7] Arneback, <em>Showing the Correctness of Quaternion
Rotation</em>, <a
href="https://erkaman.github.io/posts/quaternion_rotation.html">https://erkaman.github.io/posts/quaternion_rotation.html</a></p>
<p>[8] Bayramli, Fizik - Döndürme (Rotation) - 1</p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
