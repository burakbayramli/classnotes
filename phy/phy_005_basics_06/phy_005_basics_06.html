<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Hareketin Katı-Gövde Denklemleri - 2</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="hareketin-katı-gövde-denklemleri---2">Hareketin Katı-Gövde
Denklemleri - 2</h1>
<p>Daha önce rotasyon matrisi bazlı hareket denklemlerini vermiştik. Bu
yazıda cisim duruşu ve dönüş mekaniğini kuaterniyon kavramı üzerinden
hesaplayacağız, daha önce görülen bazı kavramların da tekrar üzerinden
geçeceğiz.</p>
<p>Lineer Hız, Momentum</p>
<p>Cisim yeri ve hızı şöyle alakalı,</p>
<p><span class="math display">\[
\frac{\mathrm{d} x(t)}{\mathrm{d} t} = v(t)
\]</span></p>
<p>Katı gövdenin momentumu</p>
<p><span class="math display">\[
p(t) = m v(t)
\]</span></p>
<p>Newton’un ikinci kanununa gore,</p>
<p><span class="math display">\[
\frac{\mathrm{d} p(t)}{\mathrm{d} t} = F(t)
\]</span></p>
<p>Yani momentumun zamansal türevi kuvvettir. Hareket hesaplarında <span
class="math inline">\(F\)</span> entegre edilerek <span
class="math inline">\(p\)</span> hesaplanır, <span
class="math inline">\(p\)</span>’yi <span
class="math inline">\(m\)</span> ile bölerek <span
class="math inline">\(v\)</span> elde ederiz, ve onu entegre ederek
cisim yeri <span class="math inline">\(x\)</span> elde edilir [1, sf.
466].</p>
<p>Açısal Momentum</p>
<p>Lineer momentum kavramı anlaşılması kolay, onu bir tür atalet olarak
görüyoruz, hareket eden bir objenin düz bir çizgi üzerindeki hareketini
devam ettirmeye olan meyili. Tabii ki bu meyil, hareketin devamlılığı o
anki hız ve cismin kütlesiyle orantılı, <span
class="math inline">\(mv\)</span> buradan geliyor. Açısal momentum da
benzer bir kavram, tek fark bir eksen etrafında dönmekte olan bir cismin
dönmeye devam etme meyili. O zaman üç boyutta, orijin etrafındaki açısal
momentum <span class="math inline">\(\vec{L}\)</span>, <span
class="math inline">\(m\)</span> kütleli cismin orijine olan uzaklığı
<span class="math inline">\(\vec{r}\)</span> ile <span
class="math inline">\(m\vec{v}\)</span> çapraz çarpımıdır [1, sf.
42].</p>
<p><span class="math display">\[
L = r \times p = r \times mv
\]</span></p>
<p>Aynen kuvvetin momentumun zamansal türevi olması gibi, tork benzer
şekilde açısal momentumun türevidir, bunu görmek için üstteki <span
class="math inline">\(L\)</span>’nin türevini alalım,</p>
<p><span class="math display">\[
\frac{\mathrm{d} L}{\mathrm{d} t} = \frac{\mathrm{d} (r \times
p)}{\mathrm{d} t}
\]</span></p>
<p>Eşitliğin sağındaki türev zincirleme kuralı ile şöyle açılır,</p>
<p><span class="math display">\[
= r \times \frac{\mathrm{d} p}{\mathrm{d} t} + \frac{\mathrm{d}
r}{\mathrm{d} t} \times p
\]</span></p>
<p><span class="math inline">\(\mathrm{d} p / \mathrm{d} t = F\)</span>,
<span class="math inline">\(\mathrm{d} r / \mathrm{d} t = v\)</span>
olduğunu biliyoruz, üstte yerine geçirelim,</p>
<p><span class="math display">\[
= r \times F + v \times p
\]</span></p>
<p>Fakat <span class="math inline">\(v\)</span> ile <span
class="math inline">\(p\)</span> aynı yöne işaret eden vektörler,
onların çapraz çarpımı sıfır, geri kalanlar,</p>
<p><span class="math display">\[
\frac{\mathrm{d} L}{\mathrm{d} t} = r \times F = \tau
\]</span></p>
<p>Bir diğer eşitlik</p>
<p><span class="math display">\[
L(t) = J(t) w(t)
\]</span></p>
<p>Bu formül açısal momentum ile açısal hız <span
class="math inline">\(w\)</span> (diğer kaynaklarda <span
class="math inline">\(\omega\)</span>) ile ilişkilendirir, lineer
momentum’daki kütle yerine burada <span class="math inline">\(J\)</span>
(diğer kaynaklarda <span class="math inline">\(I\)</span> diye geçer)
var, ki <span class="math inline">\(J\)</span> bir atalet tensoru,
objenin şekline, ağırlık dağılımına göre değişir, ve bu değerin kendisi
de obje döndükçe değişime uğrar.</p>
<p>Hesaplarda gereken uygulanan tork <span
class="math inline">\(\tau(t)\)</span>’un sebep olduğu cisim dönüşünü
bulmak, bunun için <span class="math inline">\(\tau\)</span> entegre
edilerek <span class="math inline">\(L\)</span> elde edilir, <span
class="math inline">\(L\)</span> değeri <span
class="math inline">\(J\)</span> ile bölünerek (daha doğrusu <span
class="math inline">\(J\)</span> bir matris olduğu için onun tersi alıp
çarpılarak) <span class="math inline">\(w\)</span> elde edilir.
Kuaterniyon durumunda</p>
<p><span class="math display">\[
\frac{\mathrm{d} q(t)}{\mathrm{d} t} = \frac{1}{2} \omega(t) q(t)
\]</span></p>
<p>entegre edilerek objenin dönüş sonrası yeni işaret ettiği yer bulunur
(burada <span class="math inline">\(\omega\)</span> açısal hızı temsil
eden kuaterniyon). Üstteki denklemi türetmek gerekirse [4, sf. 264]
kaynağına başvurulabilir. Herhangi iki kuaterniyonun bir geçiş
kuaterniyonu ile birbirine bağlanabildiğini biliyoruz. O zaman ufak bir
zaman dilimi <span class="math inline">\(\Delta t\)</span> içinde <span
class="math inline">\(q(t)\)</span> ve <span class="math inline">\(q(t +
\Delta t)\)</span> kuaterniyonlarının nasıl ilişkili olduğuna bakarız,
yani aradığımız bir <span class="math inline">\(\Delta r(t)\)</span>
öyle ki</p>
<p><span class="math display">\[
q(t + \Delta t) = q(t) \Delta r(t)
\]</span></p>
<p>olsun, ve</p>
<p><span class="math display">\[
\Delta r(t) = \cos (\Delta \alpha) + v(t) \sin(\theta \alpha)
\]</span></p>
<p>Üstteki formülü kuaterniyon tanımından [3] biliyoruz, dönüş açısı
<span class="math inline">\(2 \Delta \alpha\)</span>, ve etrafında
dönüşün yapıldığı eksen vektör <span
class="math inline">\(v(t)\)</span>.</p>
<p>Dönüş açısı <span class="math inline">\(\Delta \alpha\)</span> çok
ufak, bu sebeple küçük açı yaklaşıklaması [5] üzerinden <span
class="math inline">\(\cos(\Delta \alpha) \approx 1\)</span>, <span
class="math inline">\(\sin(\Delta \alpha) \approx \Delta
\alpha\)</span>, o zaman</p>
<p><span class="math display">\[
\Delta r(t) = 1 + v(t) (\Delta \alpha)
\]</span></p>
<p>Bu demektir ki</p>
<p><span class="math display">\[
q(t + \Delta t) = q(t) [1 + v(t) (\Delta \alpha)]
\]</span></p>
<p><span class="math display">\[
= q(t)  + q(t) v(t) (\Delta \alpha)
\]</span></p>
<p><span class="math display">\[
\Rightarrow q(t + \Delta t) - q(t) = q(t) v(t) (\Delta \alpha)
\]</span></p>
<p>Şimdi her iki tarafı <span class="math inline">\(\Delta t\)</span>
ile bölüp limit uygularsak,</p>
<p><span class="math display">\[
\frac{\mathrm{d} q}{\mathrm{d} t} = \lim_{\Delta t \to 0} \frac{q(t +
\Delta t) - q(t)}{\Delta t}
\]</span></p>
<p><span class="math display">\[
= \lim_{\Delta t \to 0} \frac{q(t) v(t) (\Delta \alpha)}{\Delta t}
\]</span></p>
<p>Dikkat edersek skalar <span class="math inline">\(\Delta
\alpha\)</span> değişimi <span class="math inline">\(\Delta t\)</span>
ile bölünüyor, bu bize skalar açısal değişim <span
class="math inline">\(\omega(t)\)</span>’yı verir. Bu açısal hızın
vektör <span class="math inline">\(v(t)\)</span> ile çarpılması ise
<span class="math inline">\(v(t)\)</span> etrafındaki skalar açısal
değişim <span class="math inline">\(\vec{\omega}(t)\)</span>’yı verir,
yani</p>
<p><span class="math display">\[
= q(t) v(t) \omega(t) = q(t) \vec{\omega}(t)
\]</span></p>
<p>Son formül dönüş açısı <span class="math inline">\(2 \Delta
\alpha\)</span> içindi, eğer <span class="math inline">\(\Delta
\alpha\)</span> istiyorsak, formülü <span
class="math inline">\(1/2\)</span> ile çarparız. Böylece</p>
<p><span class="math display">\[
\frac{\mathrm{d} q(t)}{\mathrm{d} t} = \frac{1}{2} \vec{\omega}(t) q(t)
\]</span></p>
<p>formülüne erişmiş olduk. <span class="math inline">\(q(t)\)</span>
için gereken entegrasyon üstteki formül üzerinden yapılır.</p>
<p>Not: Hesapsal hataların birikmemesi için <span
class="math inline">\(q(t)\)</span>’yi sürekli normalize etmek iyi bir
fikirdir, bu normalizasyon</p>
<p><span class="math display">\[
q(t) = \frac{\hat{q(t)}}{|\hat{q(t)}|}
\]</span></p>
<p>ile gerçekleştirilebilir [1, sf. 468].</p>
<p>Açısal hız: diyelim <span class="math inline">\(\omega\)</span>
radyan/saniye birimli açısal hız, ve kuaterniyon olarak paylaşılmış.
Eğer bir zaman dilimi <span class="math inline">\(\Delta t\)</span>
içinde <span class="math inline">\(\omega\)</span> sabit ise, bu zaman
sonrası toplam dönüş <span class="math inline">\(q&#39;\)</span> ne
olurdu? Bu durumda formül,</p>
<p><span class="math display">\[
q&#39; = q + \frac{\Delta t}{2} \omega q
\qquad (1)
\]</span></p>
<p>olur, ki <span class="math inline">\(\omega\)</span> yine kuaterniyon
olarak gösterilen açısal hız.</p>
<p>Hepsini bir araya koyarsak entegrasyonun uygulanacağı nihai yapı şu
şekilde gösterilebilir,</p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d} t}
\left[\begin{array}{c}
x \\ q \\ p  \\ L
\end{array}\right] =
\left[\begin{array}{c}
\dot{x} \\ \dot{q} \\ \dot{p}  \\ \dot{L}
\end{array}\right] =
\left[\begin{array}{ccc}
m^{-1} p \\ \omega q / 2 \\ F \\ \tau
\end{array}\right]
\]</span></p>
<p>Başlangıç Kuvvetleri</p>
<p>Şimdi “sıfırıncı anda’’ yani ilk başlangıçta uygulanan kuvvetleri,
lineer, açısal, hesaplamak lazım. Obje üzerinde uygulanan noktaya
bildiğimizi farzedelim, sonu o noktada başlangıcı nesne ağırlık
merkezinde olan bir vektör ile kuvvet vektörü arasında çapraz çarpım
yapıyoruz, bu bize torku veriyor.</p>
<p><img src="phy_005_basics_06_02.jpg" /></p>
<p>Benzer şekilde sonu nesne merkezinde başı o noktada olan bir vektör
daha var, lineer kuvvet bu doğrultuda uygulanacak, o vektör üzerine iki
üstte görülen kırmızı vektörü yansıtıyoruz, bu da lineer kuvvet oluyor.
Bir üstteki resim üzerinde gösterirsek,</p>
<p><img src="phy_005_basics_06_03.jpg" /></p>
<p>Daha önce söylediğimiz gibi her iki kuvvet de ilk anda lineer ve
açısal momentumu ekileyen faktörler, sonraki adımlarda etkileri yok.</p>
<p>Uygulanan kuvveti şöyle seçelim, STL objesi üzerindeki üçgenlerden
birinin köşesini son nokta olarak alalım, uzayda herhangi bir noktası
başlangıç noktası olarak alalım, ve ilk kuvvet bu vektör olsun.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy.linalg <span class="im">as</span> lin</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpl_toolkits <span class="im">import</span> mplot3d</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> stl <span class="im">import</span> mesh</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>mesh1 <span class="op">=</span> mesh.Mesh.from_file(<span class="st">&#39;../../sk/2020/08/shapes/Prism_hexagon.stl&#39;</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_vector1(fig, orig, v, color<span class="op">=</span><span class="st">&#39;blue&#39;</span>):</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>   <span class="co">&#39;&#39;&#39;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">   baslangıcı orig olan v büyüklüğü/yönünde olan vektorü çiz</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">   &#39;&#39;&#39;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>   orig <span class="op">=</span> np.array(orig)<span class="op">;</span> v<span class="op">=</span>np.array(v)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>   ax.quiver(orig[<span class="dv">0</span>], orig[<span class="dv">1</span>], orig[<span class="dv">2</span>], v[<span class="dv">0</span>], v[<span class="dv">1</span>], v[<span class="dv">2</span>],color<span class="op">=</span>color)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_vector2(fig, torig, tend, color<span class="op">=</span><span class="st">&#39;blue&#39;</span>):</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>   <span class="co">&#39;&#39;&#39;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co">   baslangic torig bitis tend olmak uzere bir vektor ciz</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="co">   &#39;&#39;&#39;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>   v <span class="op">=</span> tend <span class="op">-</span> torig</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>   ax.quiver(torig[<span class="dv">0</span>], torig[<span class="dv">1</span>], torig[<span class="dv">2</span>], v[<span class="dv">0</span>], v[<span class="dv">1</span>], v[<span class="dv">2</span>],color<span class="op">=</span>color)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>tidx <span class="op">=</span> <span class="dv">7</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>f0 <span class="op">=</span> np.array([<span class="dv">40</span>,<span class="dv">20</span>,<span class="dv">10</span>])</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>f1 <span class="op">=</span> mesh1.vectors[tidx][<span class="dv">0</span>]</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>cog <span class="op">=</span> mesh1.get_mass_properties()[<span class="dv">1</span>]</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> f1<span class="op">-</span>f0</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> cog<span class="op">-</span>f0</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>flin <span class="op">=</span> (a.dot(b) <span class="op">/</span> (lin.norm(b)<span class="op">**</span><span class="dv">2</span>))<span class="op">*</span>b</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>tau <span class="op">=</span> np.cross(f1<span class="op">-</span>cog,f1<span class="op">-</span>f0)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, subplot_kw<span class="op">=</span>{<span class="st">&#39;projection&#39;</span>: <span class="st">&#39;3d&#39;</span>})</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>obj <span class="op">=</span> mplot3d.art3d.Poly3DCollection(mesh1.vectors)</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>obj.set_edgecolor(<span class="st">&#39;k&#39;</span>)</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>obj.set_alpha(<span class="fl">0.3</span>)</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>ax.add_collection3d(obj)</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>plot_vector2(ax, f0, f1)</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>plot_vector1(ax, cog, tau, color<span class="op">=</span><span class="st">&#39;cyan&#39;</span>)</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>plot_vector1(ax, f0, flin, color<span class="op">=</span><span class="st">&#39;cyan&#39;</span>)</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>ax.plot(cog[<span class="dv">0</span>], cog[<span class="dv">1</span>], cog[<span class="dv">2</span>], <span class="st">&#39;gs&#39;</span>)</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>ax.set_xlim(<span class="dv">30</span>,<span class="dv">70</span>)<span class="op">;</span>ax.set_ylim(<span class="op">-</span><span class="dv">10</span>,<span class="dv">30</span>)<span class="op">;</span> ax.set_zlim(<span class="op">-</span><span class="dv">10</span>,<span class="dv">30</span>)</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="dv">65</span>,<span class="dv">0</span>,<span class="dv">8</span>,<span class="vs">r&#39;$\tau$&#39;</span>,fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="dv">35</span>,<span class="dv">5</span>,<span class="dv">8</span>,<span class="vs">r&#39;$F$&#39;</span>,fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="dv">35</span>,<span class="dv">5</span>,<span class="op">-</span><span class="dv">3</span>,<span class="vs">r&#39;$F_</span><span class="sc">{cog}</span><span class="vs">$&#39;</span>,fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>ax.view_init(elev<span class="op">=</span><span class="dv">20</span>, azim<span class="op">=</span><span class="dv">40</span>)</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;phy_005_basics_06_01.jpg&#39;</span>)</span></code></pre></div>
<p><img src="phy_005_basics_06_01.jpg" /></p>
<p>Kuvvet uygulama yönü ve onun kütle merkezine doğru olan yansıması
gösterildi, ayrıca yerçekim merkezi de bir ufak küp olarak nesne içinde
belirtiliyor. Merkeze olan bileşen kuvveti gösteren vektörün ucu
muhakkak merkeze dokunuyor olmalı, biz burada gösterim amaçlı olarak hem
kuvveti hem de bileşenini aynı başlangıçtan gösterdik. Yansıtma hesabı
için bkz [6]. Tork vektörü de hesaplanıyor, ve COG çıkışlı olarak
gösteriliyor. Objenin dönüşü bu vektör etrafında ve vektörün büyüklüğüne
oranlı hızda olacaktır.</p>
<p>Simulasyon</p>
<p>Alttaki kodlarla bir dış kuvvet uygulanan objenin hareketini
inceleyeceğiz. Obje uzayda hareketsiz duruyor, yerçekim etkisi yok. Önce
ilk uygulanan kuvvet etkisinden bahsedelim. Daha önceki yazıda ilk
uygulanan kuvveti direk hiza çevirmiştik, fakat kavramsal daha mantıklı
olan geçiş kuvvet / tork ve onun ilk lineer ve açısal momentuma olan
etkisidir.</p>
<p>Lineer momentum icin Newton’un ikinci kanunu der ki</p>
<p><span class="math display">\[\frac{dp}{dt} = F\]</span></p>
<p>Lineer momentum değişimi için <span
class="math inline">\(t=0\)</span> anında ve <span
class="math inline">\(t_f - t_i = \Delta t\)</span> süresinde etki eden
<span class="math inline">\(F\)</span> için</p>
<p><span class="math display">\[\int_{p_i}^{p_f} dp = \int_{t_i}^{t_f} F
dt\]</span></p>
<p><span class="math display">\[\Delta p = p_f - p_i = \int_{0}^{\Delta
t} F dt\]</span></p>
<p>Eğer <span class="math inline">\(F\)</span> kuvveti <span
class="math inline">\(\Delta t\)</span> süresince sabit ise,</p>
<p><span class="math display">\[\Delta p = F \Delta t\]</span></p>
<p>Başlangıç açısal momentum benzer şekilde</p>
<p><span class="math display">\[\frac{dL}{dt} = \tau\]</span></p>
<p><span class="math display">\[\int_{L_i}^{L_f} dL = \int_{t_i}^{t_f}
\tau dt\]</span></p>
<p><span class="math display">\[\Delta L = L_f - L_i = \int_{0}^{\Delta
t} \tau dt\]</span></p>
<p><span class="math display">\[\Delta L = \tau \Delta t\]</span></p>
<p><span class="math display">\[\Delta L = (r \times F) \Delta
t\]</span></p>
<p>Yani ilk lineer ve açısal momentumu üstteki <span
class="math inline">\(\Delta p\)</span> ve <span
class="math inline">\(\Delta L\)</span> olarak başlangıçta sıfır olan
<span class="math inline">\(p\)</span> ve <span
class="math inline">\(L\)</span> değerlerine ekleyeceğiz.</p>
<p>İlk değerler hesaplandıktan sonra simülasyonun geri kalanında <span
class="math inline">\(t&gt;0\)</span> için Euler entegrasyonu ile
güncellemeleri yapacak.</p>
<p>Bir püf nokta atalet matrisi tersi <span
class="math inline">\(J^{-1}\)</span> hesabı [1, sf. 467] (bizim daha
önce <span class="math inline">\(I^{-1}\)</span> olarak işlediğimiz
değer). Bunun için</p>
<p><span class="math display">\[
J^{-1} = R J_{cisim}^{-1} R^T
\]</span></p>
<p>kullanabileceğimizi biliyoruz. <span
class="math inline">\(J_{cisim}^{-1}\)</span> değeri objenin
başlangıçtaki atalet matrisi, yani dönüş matrislerini kullanarak atalet
matrisi tersini sürekli güncelleyebiliyoruz. Böylece güncellenen <span
class="math inline">\(J^{-1}\)</span> ile herhangi bir anda açısal hız
<span class="math inline">\(w\)</span>’yi hesaplayabiliyoruz. <span
class="math inline">\(L = J w\)</span> olmasından hareketle,</p>
<p><span class="math display">\[
w = J^{-1} L = J R J_{cisim}^{-1} R^T
\]</span></p>
<p>Tabii hızın kuaterniyon olarak temsil edilmesi lazım, açısal hızı
üstteki <span class="math inline">\(w\)</span> ile hesapladıktan sonra
onu skalar değeri sıfır olan bir kuaterniyon yapıp onu mevcut yönsel
duruş (ki o da kuaterniyon ile temsil ediliyor) ile çarpıyoruz, ve
duruştaki değişimi elde ediyoruz, (1) formülünde gördük.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpl_toolkits <span class="im">import</span> mplot3d</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy.linalg <span class="im">as</span> lin, sys, copy, os</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> stl <span class="im">import</span> mesh</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>sys.path.append(<span class="st">&quot;../phy_073_rot&quot;</span>)<span class="op">;</span> <span class="im">import</span> euclid</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_vector1(fig, orig, v, color<span class="op">=</span><span class="st">&#39;blue&#39;</span>):</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>   orig <span class="op">=</span> np.array(orig)<span class="op">;</span> v<span class="op">=</span>np.array(v)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>   ax.quiver(orig[<span class="dv">0</span>], orig[<span class="dv">1</span>], orig[<span class="dv">2</span>], v[<span class="dv">0</span>], v[<span class="dv">1</span>], v[<span class="dv">2</span>],color<span class="op">=</span>color)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_vector2(fig, torig, tend, color<span class="op">=</span><span class="st">&#39;blue&#39;</span>):</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>   v <span class="op">=</span> tend <span class="op">-</span> torig</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>   ax.quiver(torig[<span class="dv">0</span>], torig[<span class="dv">1</span>], torig[<span class="dv">2</span>], v[<span class="dv">0</span>], v[<span class="dv">1</span>], v[<span class="dv">2</span>],color<span class="op">=</span>color)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>mesh <span class="op">=</span> mesh.Mesh.from_file(<span class="st">&#39;../../sk/2020/08/shapes/Prism_hexagon.stl&#39;</span>)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>cog <span class="op">=</span> mesh.get_mass_properties()[<span class="dv">1</span>]</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>tidx <span class="op">=</span> <span class="dv">7</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="dv">1</span> <span class="co"># kg</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> np.ones(<span class="dv">3</span>) <span class="op">*</span> <span class="dv">0</span> <span class="co"># lineer momentum</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> np.ones(<span class="dv">3</span>) <span class="op">*</span> <span class="dv">0</span> <span class="co"># acisal momentum</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> np.ones(<span class="dv">3</span>) <span class="op">*</span> <span class="dv">0</span> <span class="co"># acisal hiz</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> np.ones(<span class="dv">3</span>) <span class="op">*</span> <span class="dv">0</span> <span class="co"># durus (orientation)</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>f0 <span class="op">=</span> np.array([<span class="dv">40</span>,<span class="dv">20</span>,<span class="dv">10</span>])</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>f1 <span class="op">=</span> mesh.vectors[tidx][<span class="dv">0</span>]</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> f1<span class="op">-</span>f0</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> cog<span class="op">-</span>f0</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>flin <span class="op">=</span> (a.dot(b) <span class="op">/</span> (lin.norm(b)<span class="op">**</span><span class="dv">2</span>))<span class="op">*</span>b</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> cog</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>S1,S2,N <span class="op">=</span> <span class="dv">0</span>,<span class="dv">5</span>,<span class="dv">20</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> (S2<span class="op">-</span>S1) <span class="op">/</span> N</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> euclid.Quaternion(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>)</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>Jbodyinv <span class="op">=</span> lin.inv(mesh.get_mass_properties()[<span class="dv">2</span>])</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>F_ext  <span class="op">=</span> f1<span class="op">-</span>f0</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>tau_ext <span class="op">=</span> np.cross(cog<span class="op">-</span>f1,f1<span class="op">-</span>f0)</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i,t <span class="kw">in</span> <span class="bu">enumerate</span>(np.linspace(S1,S2,N)):</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, subplot_kw<span class="op">=</span>{<span class="st">&#39;projection&#39;</span>: <span class="st">&#39;3d&#39;</span>})</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># x ilk degeri cog, x degistikce cog&#39;den ne kadar uzaklasmissa</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>    <span class="co"># o farki mesh.vectors uzerine eklersek figurde gorulen objeyi</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    <span class="co"># o kadar yerinden oynatabiliriz.    </span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>    R <span class="op">=</span> q.get_rotation_matrix_3x3().to_numpy_array()</span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>    currmesh <span class="op">=</span> copy.deepcopy(mesh)</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>    currmesh.vectors <span class="op">=</span> currmesh.vectors <span class="op">+</span> (x <span class="op">-</span> cog)</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>    currmesh.rotate_using_matrix(R)</span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>    obj <span class="op">=</span> mplot3d.art3d.Poly3DCollection(currmesh.vectors)</span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>    obj.set_edgecolor(<span class="st">&#39;k&#39;</span>)</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>    obj.set_alpha(<span class="fl">0.3</span>)</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>    ax.add_collection3d(obj)</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>    plot_vector2(ax, f0, f1)</span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>    plot_vector1(ax, f0, flin, color<span class="op">=</span><span class="st">&#39;cyan&#39;</span>)</span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>    plot_vector1(ax, cog, tau_ext <span class="op">/</span> <span class="dv">10</span>, color<span class="op">=</span><span class="st">&#39;cyan&#39;</span>)</span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> t<span class="op">==</span><span class="dv">0</span>:</span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>       <span class="co"># baslangicta p sifir, ve ilk F entegre edilerek ilk p</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>       <span class="co"># elde ediliyor. Ayni sekilde L.</span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>       p <span class="op">=</span> F_ext<span class="op">*</span>dt</span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>       L <span class="op">=</span> tau_ext<span class="op">*</span>dt<span class="op">*</span><span class="dv">20</span> <span class="co"># ufak bir &#39;hack&#39; donusun gozukmesi icin</span></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> x <span class="op">+</span> dt<span class="op">*</span>(p <span class="op">/</span> m)</span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>    R <span class="op">=</span> q.get_rotation_matrix_3x3().to_numpy_array()</span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>    Jinv <span class="op">=</span> R.dot(Jbodyinv).dot(R.transpose())</span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>    w <span class="op">=</span> L.dot(Jinv)</span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>    wq <span class="op">=</span> euclid.Quaternion(<span class="dv">0</span>, w[<span class="dv">0</span>], w[<span class="dv">1</span>], w[<span class="dv">2</span>])</span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>    qdiff <span class="op">=</span> (wq <span class="op">*</span> q).scalar_mul(<span class="dv">1</span><span class="op">/</span><span class="dv">2</span>).scalar_mul(dt)</span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>    q <span class="op">=</span> q.add(qdiff).normalize()</span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>    ax.set_xlabel(<span class="st">&#39;x&#39;</span>)<span class="op">;</span>ax.set_ylabel(<span class="st">&#39;y&#39;</span>)<span class="op">;</span>ax.set_zlabel(<span class="st">&#39;z&#39;</span>)</span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>    ax.set_xlim(<span class="dv">30</span>,<span class="dv">70</span>)<span class="op">;</span>ax.set_ylim(<span class="op">-</span><span class="dv">10</span>,<span class="dv">30</span>)<span class="op">;</span> ax.set_zlim(<span class="op">-</span><span class="dv">10</span>,<span class="dv">30</span>)</span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>    ax.view_init(elev<span class="op">=</span><span class="dv">20</span>, azim<span class="op">=</span><span class="dv">50</span>)</span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>    plt.savefig(<span class="st">&#39;img/out-</span><span class="sc">%02d</span><span class="st">.jpg&#39;</span> <span class="op">%</span> i)</span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>    plt.close(fig)</span></code></pre></div>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>os.system(<span class="st">&quot;convert -loop 0 -delay 30 img/*.jpg img/rbmove1.gif&quot;</span>)</span></code></pre></div>
<p>Sonuc animasyon [7]’de bulunabilir.</p>
<p>Kaynaklar</p>
<p>[1] Eberly, <em>Game Physics 2nd Ed</em></p>
<p>[2] Bayramlı, <em>Diferansiyel Denklemler Ders 2</em></p>
<p>[3] Bayramlı, <em>Döndürme (Rotation) - 2</em></p>
<p>[4] Kuipers, <em>Quaternions and Rotation Sequences</em></p>
<p>[5] Bayramlı, <em>Normal Diferansiyel Denklemler,
Trigonometri</em></p>
<p>[6] Bayramlı, <em>Lineer Cebir Ders 15</em></p>
<p>[7] Bayramlı, <a
href="https://www.dropbox.com/scl/fi/7p1j0hsztb2qaq9pnylb1/rbmove1.gif?rlkey=j2g2crndc9sdfwyflrotazdsr&amp;st=0ktgk41h&amp;raw=1">Animasyon
1</a></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
