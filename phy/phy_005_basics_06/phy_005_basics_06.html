<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  
  
  
  
</head>
<body>
<h1 id="hareketin-katı-gövde-denklemleri---2">Hareketin Katı-Gövde Denklemleri - 2</h1>
<p>Daha önce rotasyon matrisi bazlı hareket denklemlerini vermiştik. Bu yazıda cisim duruşu ve dönüş mekaniğini kuaterniyon kavramı üzerinden hesaplayacağız, daha önce görülen bazı kavramların da tekrar üzerinden geçeceğiz.</p>
<p>Lineer Hız, Momentum</p>
<p>Cisim yeri ve hızı şöyle alakalı,</p>
<p><span class="math display">\[
\frac{\mathrm{d} x(t)}{\mathrm{d} t} = v(t)
\]</span></p>
<p>Katı gövdenin momentumu</p>
<p><span class="math display">\[
p(t) = m v(t)
\]</span></p>
<p>Newton'un ikinci kanununa gore,</p>
<p><span class="math display">\[
\frac{\mathrm{d} p(t)}{\mathrm{d} t} = F(t)
\]</span></p>
<p>Yani momentumun zamansal türevi kuvvettir. Hareket hesaplarında <span class="math inline">\(F\)</span> entegre edilerek <span class="math inline">\(p\)</span> hesaplanır, <span class="math inline">\(p\)</span>'yi <span class="math inline">\(m\)</span> ile bölerek <span class="math inline">\(v\)</span> elde ederiz, ve onu entegre ederek cisim yeri <span class="math inline">\(x\)</span> elde edilir [1, sf. 466].</p>
<p>Açısal Momentum</p>
<p>Lineer momentum kavramı anlaşılması kolay, onu bir tür atalet olarak görüyoruz, hareket eden bir objenin düz bir çizgi üzerindeki hareketini devam ettirmeye olan meyili. Tabii ki bu meyil, hareketin devamlılığı o anki hız ve cismin kütlesiyle orantılı, <span class="math inline">\(mv\)</span> buradan geliyor. Açısal momentum da benzer bir kavram, tek fark bir eksen etrafında dönmekte olan bir cismin dönmeye devam etme meyili. O zaman üç boyutta, orijin etrafındaki açısal momentum <span class="math inline">\(\vec{L}\)</span>, <span class="math inline">\(m\)</span> kütleli cismin orijine olan uzaklığı <span class="math inline">\(\vec{r}\)</span> ile <span class="math inline">\(m\vec{v}\)</span> çapraz çarpımıdır [1, sf. 42].</p>
<p><span class="math display">\[
L = r \times p = r \times mv
\]</span></p>
<p>Aynen kuvvetin momentumun zamansal türevi olması gibi, tork benzer şekilde açısal momentumun türevidir, bunu görmek için üstteki <span class="math inline">\(L\)</span>'nin türevini alalım,</p>
<p><span class="math display">\[
\frac{\mathrm{d} L}{\mathrm{d} t} = \frac{\mathrm{d} (r \times p)}{\mathrm{d} t}
\]</span></p>
<p>Eşitliğin sağındaki türev zincirleme kuralı ile şöyle açılır,</p>
<p><span class="math display">\[
= r \times \frac{\mathrm{d} p}{\mathrm{d} t} + \frac{\mathrm{d} r}{\mathrm{d} t} \times p
\]</span></p>
<p><span class="math inline">\(\mathrm{d} p / \mathrm{d} t = F\)</span>, <span class="math inline">\(\mathrm{d} r / \mathrm{d} t = v\)</span> olduğunu biliyoruz, üstte yerine geçirelim,</p>
<p><span class="math display">\[
= r \times F + v \times p
\]</span></p>
<p>Fakat <span class="math inline">\(v\)</span> ile <span class="math inline">\(p\)</span> aynı yöne işaret eden vektörler, onların çapraz çarpımı sıfır, geri kalanlar,</p>
<p><span class="math display">\[
\frac{\mathrm{d} L}{\mathrm{d} t} = r \times F = \tau
\]</span></p>
<p>Bir diğer eşitlik</p>
<p><span class="math display">\[
L(t) = J(t) w(t)
\]</span></p>
<p>Bu formül açısal momentum ile açısal hız <span class="math inline">\(w\)</span> (diğer kaynaklarda <span class="math inline">\(\omega\)</span>) ile ilişkilendirir, lineer momentum'daki kütle yerine burada <span class="math inline">\(J\)</span> (diğer kaynaklarda <span class="math inline">\(I\)</span> diye geçer) var, ki <span class="math inline">\(J\)</span> bir atalet tensoru, objenin şekline, ağırlık dağılımına göre değişir, ve bu değerin kendisi de obje döndükçe değişime uğrar.</p>
<p>Hesaplarda gereken uygulanan tork <span class="math inline">\(\tau(t)\)</span>'un sebep olduğu cisim dönüşünü bulmak, bunun için <span class="math inline">\(\tau\)</span> entegre edilerek <span class="math inline">\(L\)</span> elde edilir, <span class="math inline">\(L\)</span> değeri <span class="math inline">\(J\)</span> ile bölünerek (daha doğrusu <span class="math inline">\(J\)</span> bir matris olduğu için onun tersi alıp çarpılarak) <span class="math inline">\(w\)</span> elde edilir. Kuaterniyon durumunda</p>
<p><span class="math display">\[
\frac{\mathrm{d} q(t)}{\mathrm{d} t} = \frac{1}{2} \omega(t) q(t)
\]</span></p>
<p>entegre edilerek objenin dönüş sonrası yeni işaret ettiği yer bulunur (burada <span class="math inline">\(\omega\)</span> açısal hızı temsil eden kuaterniyon). Üstteki denklemi türetmek gerekirse [4, sf. 264] kaynağına başvurulabilir. Herhangi iki kuaterniyonun bir geçiş kuaterniyonu ile birbirine bağlanabildiğini biliyoruz. O zaman ufak bir zaman dilimi <span class="math inline">\(\Delta t\)</span> içinde <span class="math inline">\(q(t)\)</span> ve <span class="math inline">\(q(t + \Delta t)\)</span> kuaterniyonlarının nasıl ilişkili olduğuna bakarız, yani aradığımız bir <span class="math inline">\(\Delta r(t)\)</span> öyle ki</p>
<p><span class="math display">\[
q(t + \Delta t) = q(t) \Delta r(t)
\]</span></p>
<p>olsun, ve</p>
<p><span class="math display">\[
\Delta r(t) = \cos (\Delta \alpha) + v(t) \sin(\theta \alpha)
\]</span></p>
<p>Üstteki formülü kuaterniyon tanımından [3] biliyoruz, dönüş açısı <span class="math inline">\(2 \Delta \alpha\)</span>, ve etrafında dönüşün yapıldığı eksen vektör <span class="math inline">\(v(t)\)</span>.</p>
<p>Dönüş açısı <span class="math inline">\(\Delta \alpha\)</span> çok ufak, bu sebeple küçük açı yaklaşıklaması [5] üzerinden <span class="math inline">\(\cos(\Delta \alpha) \approx 1\)</span>, <span class="math inline">\(\sin(\Delta \alpha) \approx \Delta \alpha\)</span>, o zaman</p>
<p><span class="math display">\[
\Delta r(t) = 1 + v(t) (\Delta \alpha)
\]</span></p>
<p>Bu demektir ki</p>
<p><span class="math display">\[
q(t + \Delta t) = q(t) [1 + v(t) (\Delta \alpha)]
\]</span></p>
<p><span class="math display">\[
 = q(t)  + q(t) v(t) (\Delta \alpha)
\]</span></p>
<p><span class="math display">\[
\Rightarrow q(t + \Delta t) - q(t) = q(t) v(t) (\Delta \alpha)
\]</span></p>
<p>Şimdi her iki tarafı <span class="math inline">\(\Delta t\)</span> ile bölüp limit uygularsak,</p>
<p><span class="math display">\[
\frac{\mathrm{d} q}{\mathrm{d} t} = \lim_{\Delta t \to 0} \frac{q(t + \Delta t) - q(t)}{\Delta t}
\]</span></p>
<p><span class="math display">\[
= \lim_{\Delta t \to 0} \frac{q(t) v(t) (\Delta \alpha)}{\Delta t}
\]</span></p>
<p>Dikkat edersek skalar <span class="math inline">\(\Delta \alpha\)</span> değişimi <span class="math inline">\(\Delta t\)</span> ile bölünüyor, bu bize skalar açısal değişim <span class="math inline">\(\omega(t)\)</span>'yı verir. Bu açısal hızın vektör <span class="math inline">\(v(t)\)</span> ile çarpılması ise <span class="math inline">\(v(t)\)</span> etrafındaki skalar açısal değişim <span class="math inline">\(\vec{\omega}(t)\)</span>'yı verir, yani</p>
<p><span class="math display">\[
= q(t) v(t) \omega(t) = q(t) \vec{\omega}(t)
\]</span></p>
<p>Son formül dönüş açısı <span class="math inline">\(2 \Delta \alpha\)</span> içindi, eğer <span class="math inline">\(\Delta \alpha\)</span> istiyorsak, formülü <span class="math inline">\(1/2\)</span> ile çarparız. Böylece</p>
<p><span class="math display">\[
\frac{\mathrm{d} q(t)}{\mathrm{d} t} = \frac{1}{2} \vec{\omega}(t) q(t)
\]</span></p>
<p>formülüne erişmiş olduk. <span class="math inline">\(q(t)\)</span> için gereken entegrasyon üstteki formül üzerinden yapılır.</p>
<p>Not: Hesapsal hataların birikmemesi için <span class="math inline">\(q(t)\)</span>'yi sürekli normalize etmek iyi bir fikirdir, bu normalizasyon</p>
<p><span class="math display">\[
q(t) = \frac{\hat{q(t)}}{|\hat{q(t)}|}
\]</span></p>
<p>ile gerçekleştirilebilir [1, sf. 468].</p>
<p>Açısal hız: diyelim <span class="math inline">\(\omega\)</span> radyan/saniye birimli açısal hız, ve kuaterniyon olarak paylaşılmış. Eğer bir zaman dilimi <span class="math inline">\(\Delta t\)</span> içinde <span class="math inline">\(\omega\)</span> sabit ise, bu zaman sonrası toplam dönüş <span class="math inline">\(q&#39;\)</span> ne olurdu? Bu durumda formül,</p>
<p><span class="math display">\[
q&#39; = q + \frac{\Delta t}{2} \omega q
\]</span></p>
<p>olur, ki <span class="math inline">\(\omega\)</span> yine kuaterniyon olarak gösterilen açısal hız.</p>
<p>Hepsini bir araya koyarsak entegrasyonun uygulanacağı nihai yapı şu şekilde gösterilebilir,</p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d} t}
\left[\begin{array}{c}
x \\ q \\ p  \\ L
\end{array}\right] =
\left[\begin{array}{c}
\dot{x} \\ \dot{q} \\ \dot{p}  \\ \dot{L}
\end{array}\right] =
\left[\begin{array}{ccc}
m^{-1} p \\ \omega q / 2 \\ F \\ \tau
\end{array}\right]
\]</span></p>
<p>Başlangıç Kuvvetleri</p>
<p>Şimdi &quot;sıfırıncı anda'' yani ilk başlangıçta uygulanan kuvvetleri, lineer, açısal, hesaplamak lazım. Obje üzerinde uygulanan noktaya bildiğimizi farzedelim, sonu o noktada başlangıcı nesne ağırlık merkezinde olan bir vektör ile kuvvet vektörü arasında çapraz çarpım yapıyoruz, bu bize torku veriyor.</p>
<div class="figure">
<img src="phy_005_basics_06_02.jpg" />

</div>
<p>Benzer şekilde sonu nesne merkezinde başı o noktada olan bir vektör daha var, lineer kuvvet bu doğrultuda uygulanacak, o vektör üzerine iki üstte görülen kırmızı vektörü yansıtıyoruz, bu da lineer kuvvet oluyor. Bir üstteki resim üzerinde gösterirsek,</p>
<div class="figure">
<img src="phy_005_basics_06_03.jpg" />

</div>
<p>Daha önce söylediğimiz gibi her iki kuvvet de ilk anda lineer ve açısal momentumu ekileyen faktörler, sonraki adımlarda etkileri yok.</p>
<p>Başlangıç torku ve kuvvetin nasıl başlangıç hızına çevirilecebileceğini daha önceki derste gördük.</p>
<p>Uygulanan kuvveti şöyle seçelim, STL objesi üzerindeki üçgenlerden birinin köşesini son nokta olarak alalım, uzayda herhangi bir noktası başlangıç noktası olarak alalım, ve ilk kuvvet bu vektör olsun.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy.linalg <span class="im">as</span> lin
<span class="im">from</span> mpl_toolkits <span class="im">import</span> mplot3d
<span class="im">from</span> stl <span class="im">import</span> mesh

mesh1 <span class="op">=</span> mesh.Mesh.from_file(<span class="st">&#39;../../sk/2020/08/shapes/Prism_hexagon.stl&#39;</span>)

<span class="kw">def</span> plot_vector1(fig, orig, v, color<span class="op">=</span><span class="st">&#39;blue&#39;</span>):
   <span class="co">&#39;&#39;&#39;</span>
<span class="co">   baslangıcı orig olan v büyüklüğü/yönünde olan vektorü çiz</span>
<span class="co">   &#39;&#39;&#39;</span>
   ax <span class="op">=</span> fig.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)
   orig <span class="op">=</span> np.array(orig)<span class="op">;</span> v<span class="op">=</span>np.array(v)
   ax.quiver(orig[<span class="dv">0</span>], orig[<span class="dv">1</span>], orig[<span class="dv">2</span>], v[<span class="dv">0</span>], v[<span class="dv">1</span>], v[<span class="dv">2</span>],color<span class="op">=</span>color)
   ax <span class="op">=</span> fig.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)  
   <span class="cf">return</span> fig

<span class="kw">def</span> plot_vector2(fig, torig, tend, color<span class="op">=</span><span class="st">&#39;blue&#39;</span>):
   <span class="co">&#39;&#39;&#39;</span>
<span class="co">   baslangic torig bitis tend olmak uzere bir vektor ciz</span>
<span class="co">   &#39;&#39;&#39;</span>
   ax <span class="op">=</span> fig.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)
   v <span class="op">=</span> tend <span class="op">-</span> torig
   ax.quiver(torig[<span class="dv">0</span>], torig[<span class="dv">1</span>], torig[<span class="dv">2</span>], v[<span class="dv">0</span>], v[<span class="dv">1</span>], v[<span class="dv">2</span>],color<span class="op">=</span>color)
   ax <span class="op">=</span> fig.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)  
   <span class="cf">return</span> fig

tidx <span class="op">=</span> <span class="dv">7</span>
f0 <span class="op">=</span> np.array([<span class="dv">40</span>,<span class="dv">20</span>,<span class="dv">10</span>])
f1 <span class="op">=</span> mesh1.vectors[tidx][<span class="dv">0</span>]
cog <span class="op">=</span> mesh1.get_mass_properties()[<span class="dv">1</span>]

a <span class="op">=</span> f1<span class="op">-</span>f0
b <span class="op">=</span> cog<span class="op">-</span>f0
flin <span class="op">=</span> (a.dot(b) <span class="op">/</span> (lin.norm(b)<span class="op">**</span><span class="dv">2</span>))<span class="op">*</span>b

tau <span class="op">=</span> np.cross(f1<span class="op">-</span>cog,f1<span class="op">-</span>f0)
figure <span class="op">=</span> plt.figure()
ax <span class="op">=</span> mplot3d.Axes3D(figure)
obj <span class="op">=</span> mplot3d.art3d.Poly3DCollection(mesh1.vectors)
obj.set_edgecolor(<span class="st">&#39;k&#39;</span>)
obj.set_alpha(<span class="fl">0.3</span>)
ax.add_collection3d(obj)
plot_vector2(figure, f0, f1)
plot_vector1(figure, cog, tau, color<span class="op">=</span><span class="st">&#39;cyan&#39;</span>)
plot_vector1(figure, f0, flin, color<span class="op">=</span><span class="st">&#39;cyan&#39;</span>)
ax.plot(cog[<span class="dv">0</span>], cog[<span class="dv">1</span>], cog[<span class="dv">2</span>], <span class="st">&#39;gs&#39;</span>)
ax.set_xlim(<span class="dv">30</span>,<span class="dv">70</span>)<span class="op">;</span>ax.set_ylim(<span class="op">-</span><span class="dv">10</span>,<span class="dv">30</span>)<span class="op">;</span> ax.set_zlim(<span class="op">-</span><span class="dv">10</span>,<span class="dv">30</span>)
ax.text(<span class="dv">65</span>,<span class="dv">0</span>,<span class="dv">8</span>,<span class="vs">r&#39;$\tau$&#39;</span>,fontsize<span class="op">=</span><span class="dv">20</span>)
ax.text(<span class="dv">35</span>,<span class="dv">5</span>,<span class="dv">8</span>,<span class="vs">r&#39;$F$&#39;</span>,fontsize<span class="op">=</span><span class="dv">20</span>)
ax.text(<span class="dv">35</span>,<span class="dv">5</span>,<span class="op">-</span><span class="dv">3</span>,<span class="vs">r&#39;$F_</span><span class="sc">{cog}</span><span class="vs">$&#39;</span>,fontsize<span class="op">=</span><span class="dv">20</span>)
ax.view_init(elev<span class="op">=</span><span class="dv">20</span>, azim<span class="op">=</span><span class="dv">40</span>)
plt.savefig(<span class="st">&#39;phy_005_basics_06_01.jpg&#39;</span>)</code></pre></div>
<div class="figure">
<img src="phy_005_basics_06_01.jpg" />

</div>
<p>Kuvvet uygulama yönü ve onun kütle merkezine doğru olan yansıması gösterildi, ayrıca yerçekim merkezi de bir ufak küp olarak nesne içinde belirtiliyor. Merkeze olan bileşen kuvveti gösteren vektörün üçü tabii ki merkeze dokunuyor olmalı, biz burada gösterim amaçlı olarak hem kuvveti hem de bileşenini aynı başlangıçtan gösterdik. Yansıtma hesabı için bkz [6]. Tork vektörü de hesaplanıyor, ve COG çıkışlı olarak gösteriliyor. Objenin dönüşü bu vektör etrafında ve vektörün büyüklüğüne oranlı hızda olacaktır.</p>
<p>[devam edecek]</p>
<p>Kaynaklar</p>
<p>[1] Eberly, <em>Game Physics 2nd Ed</em></p>
<p>[2] Bayramlı, <em>Diferansiyel Denklemler Ders 2</em></p>
<p>[3] Bayramlı, <em>Döndürme (Rotation) - 2</em></p>
<p>[4] Kuipers, <em>Quaternions and Rotation Sequences</em></p>
<p>[5] Bayramlı, <em>Normal Diferansiyel Denklemler, Trigonometri</em></p>
<p>[6] Bayramlı, <em>Lineer Cebir Ders 15</em></p>
</body>
</html>
