<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>

  <title>Temel Fizik 4</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  
  
  
  
</head>
<body>
<h1 id="temel-fizik-4">Temel Fizik 4</h1>
<p>Parçacıklar, Çok Parçacıklı Sistemler, Katı Gövde (Rigid Body)</p>
<p>Kütle Merkezi</p>
<p>Küresel, birörnek parçacıklara uygulanan kuvvetin onların merkezine uygulandığı farzedilebilir, ya da parçacık sanki noktasal bir parçacık imiş gibi işlemler yapılabilir. Fakat bu faraziyeyi nasıl doğrularız? Ayrıca farklı şekillerde, homojen bir maddeden oluşmayan objeleri nasıl idare ederiz?</p>
<p>Burada kütle merkezi (center of mass) kavramı yardımcı olur, mesela <span class="math inline">\(N\)</span> tane <span class="math inline">\(m_i\)</span> kütlesine sahip parçacığın kütle merkezi</p>
<p><span class="math display">\[
r_c =
\sum_{i=1}^{N} \frac{m_i}{m} r_i =
\frac{1}{m} \sum_{i=1}^{N} m_i r_i
\]</span></p>
<p>ile hesaplanabilir. Bu bir nevi bir ağırlıklı ortalama. <span class="math inline">\(O\)</span> bir referans noktasıdır, mesela kordinat orijini, <span class="math inline">\(r_i\)</span> ise <span class="math inline">\(O\)</span>'dan parçacık konumuna işaret eden bir vektör, parçacığın yeri [7, sf. 77].</p>
<div class="figure">
<img src="phy_005_basics_08.png" />

</div>
<p>Dikkat edersek parçacıklar ayrı ayrı duruyor, ama birazdan göreceğiz ki bu parçacıklar tek bir katı gövde objenin içinde olsalar da hesap geçerli oluyor. Hatta gövde katı olmasa bile, mesela titreşen, salınımda olan moleküllere, öğelere sahip objeler bile belli şartlara uyuyorlarsa aynı kurallar ile idare edilebiliyorlar. <span class="math inline">\(F_{ij}\)</span> her <span class="math inline">\(i\)</span> parçacığının <span class="math inline">\(j\)</span> parçacığından hissettiği kuvvet olsun, ve <span class="math inline">\(F_i\)</span> değeri de <span class="math inline">\(i\)</span> parçacığı üzerindeki tüm dış kuvvetlerin toplamı olsun. Newton'un ikinci kuralını her parçacık için yazarsak, <span class="math inline">\(i\)</span>'nin hissettiği tüm kuvvetlerin toplamı solda kütle çarpı ivmeye eşit olacaktır,</p>
<p><span class="math display">\[
m_i \ddot{r}_i = \sum_{j \ne i} F_{ij} + F_i
\]</span></p>
<p>ki <span class="math inline">\(\ddot{r} = \mathrm{d}^2 / \mathrm{d} t^2 r\)</span>, zamana göre ikinci türev anlamında.</p>
<p>Fakat Newton'un etki-tepki üçüncü kuralına göre her parçacık uyguladığı kuvvet kadar ters yönde geri bir kuvvet hisseder, yani <span class="math inline">\(F_{ij} = -F_{ji}\)</span>, olmalı, o zaman her iki tarafta tüm <span class="math inline">\(i\)</span>'ler üzerinden bir toplama yapınca parçacık sistemindeki bu &quot;iç'' kuvvetler birbirini nötralize etmeliler, üstteki formülden geriye kalanlar,</p>
<p><span class="math display">\[
\sum m_i \ddot{r}_i =  \sum F_i
\]</span></p>
<p>olur. <span class="math inline">\(\sum F_i\)</span> değeri sisteme uygulanan tüm dış kuvvetler <span class="math inline">\(F_{ext}\)</span> olarak görülebilir. Sol tarafı <span class="math inline">\(m\)</span> ile hem bölüp, hem çarpalım,</p>
<p><span class="math display">\[
m \frac{\mathrm{d}^2}{\mathrm{d} t^2} \underbrace{\sum \frac{m_i}{m} r_i}_{r_c} =
F_{ext}
\]</span></p>
<p>İşaretli yerde bir <span class="math inline">\(r_c\)</span> elde ettiğimizi görüyoruz, o zaman</p>
<p><span class="math display">\[
m\ddot{r}_c = F_{ext}
\]</span></p>
<p>diyebiliriz, yani tüm sistemin kütle merkezi tek bir parça gibi görülebilir, hesaplarda <span class="math inline">\(m\)</span> ve <span class="math inline">\(F_{ext}\)</span> ile beraber bu şekilde kullanılabilir, ki o merkezin ivmesi <span class="math inline">\(\ddot{r_c}\)</span> olacaktır.</p>
<p>İşin ilginç tarafı bu sistem ayrı ayrı parçalar olsun, ya da aynı katı gövde içindeki &quot;bloklar'' olsun bu hesap yine işliyor olacaktır, çünkü düşünürsek bir katı obje içindeki blokların, parçacıkların da birbiri üzerinde kuvvetleri de birbirini nötralize ederler, hatta katı olmayan ama parçaları titreşen obje için de aynı argüman, ve aynı formül kullanılabilir.</p>
<p>Toplam lineer momentum oldukça basit,</p>
<p><span class="math display">\[
P = \sum_i p_i = \sum_i m_i \dot{r}_i = M \dot{R}
\]</span></p>
<p>Yani kütle merkezi üzerinden tüm kütle için bir momentum kullanılabilir.</p>
<p>Toplam Açısal Momentum</p>
<p>Tek parça için <span class="math inline">\(l = r \times p\)</span> olan momentumların bir parçacık sisteminde hesaplamak istersek daha önce lineer momentumda olduğu gibi toplam alabiliriz,</p>
<p><span class="math display">\[
L = \sum_{i=1}^{N} l_i = \sum_{i=1}^{N} r_i \times p_i
\]</span></p>
<p>Bir katı gövdede hesap aynıdır, ve daha önce gördüğümüz kütle için parçacıkların birbiri üzerine uyguladığı kuvvetlerin iptal olması durumunu, parçacıkların birbirine uyguladığı torkların iptali olarak açısal ortama taşıyabiliyoruz, yani üstteki formül doğru, detaylar için [8, sf. 94].</p>
<p>Kütle merkezinin toplam açısal momentumun hesabında oynadığı rol biraz daha karmaşık ama bir o kadar önemli [8, sf. 368].</p>
<p>Yine bir katı gövde düşünelim, <span class="math inline">\(N\)</span> tane her biri <span class="math inline">\(m_i\)</span> ağırlığında parçacıktan oluşuyor olsun, altta resmedildiği gibi, kütle elipsoid şeklinde.</p>
<div class="figure">
<img src="phy_005_basics_09.png" />

</div>
<p><span class="math inline">\(m_i\)</span>'nin herhangi bir şekilde seçilen referans / orijin noktası <span class="math inline">\(O\)</span>'ya göre olan yeri <span class="math inline">\(r_i\)</span> ile gösteriliyor. Kütle merkezi (center of mass) CM ile, CM'nin <span class="math inline">\(O\)</span>'ya göre yeri <span class="math inline">\(R\)</span>, <span class="math inline">\(m_i\)</span>'nin CM'ye izafi olarak yeri <span class="math inline">\(r_i&#39;\)</span>. Yani</p>
<p><span class="math display">\[
r_i = R + r_i&#39;
\qquad (7)
\]</span></p>
<p>doğru olacak. Şimdi <span class="math inline">\(O\)</span>'ya göre parçacık <span class="math inline">\(i\)</span> için açısal momentum hesaplarsak</p>
<p><span class="math display">\[
l_i = r_i \times p_i = r_i \times m_i \dot{r}_i
\]</span></p>
<p><span class="math inline">\(l,p,r\)</span> vektörsel değerler.</p>
<p>O zaman <span class="math inline">\(O\)</span> referansına izafi olarak toplam momentum</p>
<p><span class="math display">\[
L = \sum_i l_i = \sum_i r_i \times p_i = \sum_i r_i \times m_i \dot{r}_i
\]</span></p>
<p>Eğer (7) denklemini üste sokarsak,</p>
<p><span class="math display">\[
L = \sum_i (\dot{R} + \dot{r}_i&#39;) \times m_i (\dot{R} + \dot{r}_i&#39; )
\]</span></p>
<p>Şu kuralı [8] kullanarak</p>
<p><span class="math display">\[
(A + B) \times (C+D) = (A \times B) + (A \times C) + (B \times C) + (B \times D) 
\]</span></p>
<p>açılımı yapabiliriz,</p>
<p><span class="math display">\[
 = \sum_i (\dot{R} + \dot{r}_i&#39;) \times (m_i \dot{R} + m_i \dot{r}_i&#39; )
\]</span></p>
<p><span class="math display">\[
= \sum_i (R \times m_i \dot{R}) +
  (R \times m_i \dot{r}_i&#39;) +
  (r_i&#39; \times m_i \dot{R}) +
  (r_i\ \times m_i \dot{r}_i&#39;)   
\]</span></p>
<p><span class="math inline">\(M = \sum_i m_i\)</span> diyelim, ki <span class="math inline">\(M\)</span> tüm kütle,</p>
<p><span class="math display">\[
L = R \times M\dot{R} +
R \times \sum m_i \dot{r}_i&#39; +
(\sum r_i&#39; m_i) \times \dot{R} +
\sum r_i&#39; \times m_i \dot{r}_i&#39;
\qquad (8)
\]</span></p>
<p>Bu son denklem üzerinde oldukca fazla basitleştirme mümkün. Mesela üçüncü terimde parantezler içinde olan formül sıfıra eşit, niye? Kütle merkezi formülünü yazarsak,</p>
<p><span class="math display">\[
R = \frac{1}{M} \sum m_i r_i
\]</span></p>
<p><span class="math display">\[
MR = \sum m_i r_i
\]</span></p>
<p>Aynı şekilde izafi açılımı yapalım,</p>
<p><span class="math display">\[
= m_i (R + r_i&#39;) = \sum m_i R + \sum m_i r_i&#39;
\]</span></p>
<p>Yani</p>
<p><span class="math display">\[
MR = MR + \sum m_i r_i&#39;
\]</span></p>
<p>elde ederiz, ve bu formülün doğru olması için <span class="math inline">\(\sum m_i r_i&#39; = 0\)</span> olması gerekir.</p>
<p>Yani (8) denkleminin üçüncü terimi sıfır. O terimin türevini alırsak ikinci terimin elde edileceğini görürüz, o zaman o da sıfır olur. Geriye kalanlar,</p>
<p><span class="math display">\[
L = R \times P + \sum_i r_i&#39; \times m_i \dot{r}_i&#39; 
\]</span></p>
<p>Birinci terim kütle merkezinin <span class="math inline">\(O\)</span>'ya göre açısal momentumu, ikincisi hareketin kütle merkezine göre olan açısal momentumu. Üstteki formül sayesinde bir katı gövdenin açısal momentumunu iki parçaya bölerek düşünmek mümkün oluyor.</p>
<p>CM Torku CM Açısal Momentumu</p>
<p>Şimdi şu soruyu soralım: katı gövdenin açısal momentum değişimi (dönüşsel kuvvet, tork) ona uygulanan, ve yine onun CM'sine göre uygulanmış dış torka eşit midir? Cevap evet olacak ama bu aslında ilk başta çok bariz olmayabiliyor, çünkü CM ivmeleniyor, bu eşitlik o durumda da geçerli olur mu? Fakat CM ivmeleniyor olsa bile cevap değişmiyor.</p>
<p>İspatlamak için CM etrafındaki açısal momentumu formülize edelim [9, sf 37],</p>
<p><span class="math display">\[
L_{CM} = \sum r_i&#39; \times m_i \dot{r}_i&#39; 
\]</span></p>
<p>CM etrafında uygulanan tork, üstteki açısal momentumun zamansal türevidir,</p>
<p><span class="math display">\[
\dot{L}_{CM} = \sum \dot{r}_i \times m_i \dot{r}_i&#39; + \sum r_i&#39; \times m_i\ddot{r}_i&#39;
\]</span></p>
<p>Eşitliğin sağındaki ilk terim sıfır çünkü iki paralel vektörün çapraz çarpımı sıfırdır. Kalanlarla devam edersek, <span class="math inline">\(r_i = r_i&#39; + R\)</span> olduğu için oradan <span class="math inline">\(\ddot{r}_i = \ddot{r}_i&#39; + \ddot{R}\)</span> ve oradan <span class="math inline">\(\ddot{r}_i&#39; = \ddot{r}_i - \ddot{R}\)</span> diyoruz, üstteki ikinci terimde yerine koyunca</p>
<p><span class="math display">\[
= \sum r_i&#39; \times m_i (\ddot{r}_i - \ddot{R})
\]</span></p>
<p><span class="math display">\[
= \sum (r_i&#39; \times m_i \ddot{r}_i) - (r_i&#39; \times m_i \ddot{R})
\]</span></p>
<p><span class="math display">\[
= \sum (r_i&#39; \times m_i \ddot{r}_i) - \sum (r_i&#39; \times m_i \ddot{R})
\]</span></p>
<p>İlk terimde kuvvet tanımı görülüyor,</p>
<p><span class="math display">\[
= \sum (r_i&#39; \times F_i ) - \sum (r_i&#39; \times m_i \ddot{R})
\]</span></p>
<p>İkinci terimde <span class="math inline">\(m_i\)</span> yer değiştirebilir,</p>
<p><span class="math display">\[
= \sum (r_i&#39; \times F_i ) - \sum (m_i r_i&#39; \times \ddot{R})
\]</span></p>
<p><span class="math inline">\(\sum m_i r_i&#39;=0\)</span> olduğunu hatırlarsak ikinci terim kaybolur,</p>
<p><span class="math display">\[
= \sum r_i&#39; \times F_i 
\]</span></p>
<p>Geriye kalan dışarıdan CM etrafında uygulanan tork tanımı değil midir? Evet. O zaman dışarıdan CM etrafında uygulanan tork ile başladığımız ifade <span class="math inline">\(\dot{L}_{CM}\)</span> yani CM etrafındaki momentum değişimi arasındaki eşitliği ispatlamış olduk.</p>
<p>Atalet Matrisi (Inertia Matrix, Tensor)</p>
<p>Bir objenin havaya fırlatıldığını düşünelim, fırlatma sırasında dönüş te var, çetrefil bir hareket sözkonusu yani. Fakat şimdiye kadar gördüğümüz teknikler ile hala bu hareketi analiz edebiliriz, hem lineer momentum, hem de açısal momentum kütle merkezi odaklı olarak analiz edilebiliyor. Herhangi bir katı gövde, cisim şeklini ve hareketi analiz için şimdi bazı genel formülleri ortaya koyalım.</p>
<p>Gövdenin açısal momentumu <span class="math inline">\(L\)</span> için [1, sf. 379],</p>
<p><span class="math display">\[
L = \sum m_i r_i \times v_i
\]</span></p>
<p>ki <span class="math inline">\(L,r,v\)</span> vektör. <span class="math inline">\(v = \omega \times r\)</span> eşitliğini üste sokarsak,</p>
<p><span class="math display">\[
L = \sum m_i r_i \times (\omega \times r_i)
\qquad (1)
\]</span></p>
<p>Şimdi bu son ifadenin her vektörü öğelerini kullanarak açılımını yapalım böylece başka bir forma erişmeyi umuyoruz. <span class="math inline">\(\omega = [\begin{array}{ccc} \omega_x&amp;\omega_y&amp;\omega_z \end{array}]^T\)</span> ve <span class="math inline">\(r = [\begin{array}{ccc} x&amp;y&amp;z \end{array}]^T\)</span> öğelerini kullanacağız, ve üstteki formülün <span class="math inline">\(A \times (B \times C)\)</span> formunda olduğunu farkediyoruz, o zaman genel bir <span class="math inline">\(r \times (\omega \times r)\)</span> üzerinde BAC-CAB açılımı yapmayı deneyebiliriz, bu açılım hatırlarsak,</p>
<p><span class="math display">\[
A \times (B \times C) = B(A \cdot C) - C(A \cdot B)
\]</span></p>
<p>idi. Kendi denklemimiz üzerinde bu açılım</p>
<p><span class="math display">\[
r \times (\omega \times r) = \omega (r \cdot r) - r(r \cdot \omega)
\]</span></p>
<p>şeklinde olacaktır. Açılımı yapınca 3 x 1 boyutunda bir vektör elde ediyoruz onun sadece ilk öğesine, <span class="math inline">\(x\)</span> için olan durumuna bakalım,</p>
<p><span class="math display">\[
r \times (\omega \times r)_x = \omega_x (x^2 + y^2 + z^2) - x(\omega_x x + \omega_y y + \omega_z z)
\]</span></p>
<p><span class="math inline">\(\omega_x x^2\)</span> iki yerden iptal olur, kalanlar,</p>
<p><span class="math display">\[
 = \omega_x ( y^2 + z^2) - \omega_y xy + \omega_z xz
\]</span></p>
<p>Her üç öğe için açılım yapınca,</p>
<p><span class="math display">\[
r \times (\omega \times r) =
\left[\begin{array}{c}
(y^2 + z^2) \omega_x - xy \omega_y - xz \omega_z \\
-yx \omega_x + (z^2 + x^2)\omega_y - yz \omega_z \\    
-zx \omega_x - zy \omega_y + (x^2+y^2)\omega_z
\end{array}\right]
\]</span></p>
<p>Ve ana formülde <span class="math inline">\(m_i\)</span> çarpımı olduğunu unutmayalım,</p>
<p><span class="math display">\[
m r \times (\omega \times r) =
\left[\begin{array}{c}
m (y^2 + z^2) \omega_x - m xy \omega_y - m xz \omega_z \\
-m yx \omega_x + m (z^2 + x^2)\omega_y - m yz \omega_z \\    
-m zx \omega_x - m zy \omega_y + m (x^2+y^2)\omega_z
\end{array}\right]
\]</span></p>
<p>Üstteki sonucu (1)'e sokunca, ve notasyonel olarak bazı rahatlıklar düşünerek, mesela <span class="math inline">\(I_{xx} = \sum_i m_i (y_i^2 + z_i^2)\)</span> gibi, ya da <span class="math inline">\(I_{xy} = - \sum_i m x_i y_i\)</span>. Bunları da yerine koyunca, <span class="math inline">\(L_x,L_y,L_y\)</span> diyelim,</p>
<p><span class="math display">\[
L_x = I_{xx} \omega_x + I_{xy} \omega_y + I_{xz} \omega_z
\]</span></p>
<p><span class="math display">\[
L_y = I_{yx} \omega_x + I_{yy} \omega_y + I_{yz} \omega_z
\]</span></p>
<p><span class="math display">\[
L_z = I_{zx} \omega_x + I_{zy} \omega_y + I_{zz} \omega_z
\]</span></p>
<p>Fakat bu son sonuç hala biraz sadeleştirilebilir. İfadeye bakarsak onu bir matris çarpı bir vektör çarpımı ile temsil edebiliriz gibi geliyor, hakikaten de</p>
<p><span class="math display">\[
I = \left[\begin{array}{ccc}
I_{xx} &amp; I_{xy} &amp; I_{xz} \\
I_{yx} &amp; I_{yy} &amp; I_{yz} \\
I_{zx} &amp; I_{zy} &amp; I_{zz} 
\end{array}\right], \quad
\omega = \left[\begin{array}{c}
\omega_x \\ \omega_y \\ \omega_z
\end{array}\right]
\]</span></p>
<p>üzerinden <span class="math inline">\(I \omega\)</span> çarpımının (2) sonucunu vereceğini görebiliriz. Böylece gayet sade</p>
<p><span class="math display">\[
L = I \omega
\]</span></p>
<p>ifadesine geri gelmiş olduk.</p>
<p><span class="math inline">\(I\)</span>, atalet matrisidir, ve her katı kütle şekline göre farklı olacak bir matristir. O zaman bir objenin açısal momentumunun nasıl olacağını hesaplamak için önce o objenin atalet matrisine hesaplamak gerekir.</p>
<p>Not: Üstte tork diye adlandırılan büyüklük, yani kuvvet çarpı bir merkeze olan uzaklık hesabı, bazı kaynaklarda <em>moment</em> diye geçer, mesela inşaat mühendisliğinde bükülme momenti (bending moment) sözünü görebiliriz. Bu terimi <em>momentum</em> ile karıştırmamak lazım, ki onun da açısal ve lineer çeşitleri var, bu farklı bir kavram.</p>
<p>Ataletin Asal Eksenleri (Principal Axes of Inertia)</p>
<p>Bir konu daha var tabii; dikkat edersek <span class="math inline">\(I\)</span> matrisini çekip çıkardığımız hesap bir <span class="math inline">\(O\)</span> referansını merkez alıyordu. &quot;Genel bir <span class="math inline">\(O\)</span> olsun'' dedik ve oradan türetmeye devam ettik. Fakat bazı referansların, yani dönüşün neyin etrafında olduğunun, her seçime göre farklı <span class="math inline">\(I\)</span>'lara sebebiyet verebileceğini görmek gerekir. Lineer cebirsel olarak <span class="math inline">\(L\)</span> ile <span class="math inline">\(\omega\)</span>'nin aynı yönü göstermesi için <span class="math inline">\(I\)</span>'nin köşegen matris olması gerekir. Fakat elde köşegen matris olmasa da <span class="math inline">\(\omega\)</span>'yi bizim değiştirerek, aynı refarans <span class="math inline">\(O\)</span>'dan geçen ama farklı öyle bir yönü göstermektir ki, bu eksen etrafında bir köşegen <span class="math inline">\(I\)</span> elde edilsin ve hareket simetrik hale gelsin.</p>
<p>Bu hesap için özdeğer, özvektör hesabını yapmak lazım, ya da atalet matrisinin köşegenleştirilmesini [2] (diagonalization) gerçekleştirmek lazım. Eğer <span class="math inline">\(I\)</span> köşegen değil ise, öyle bir <span class="math inline">\(\omega\)</span> bulalım ki <span class="math inline">\(L = I \omega\)</span> hesabındaki <span class="math inline">\(L\)</span>, <span class="math inline">\(I \omega\)</span> ile aynı yönü göstersin, yani</p>
<p><span class="math display">\[
I\omega = \lambda \omega
\]</span></p>
<p>haline gelsin. Bu bir özdeğer problemi değil midir? Evet.</p>
<p>Örnek olarak [1, sf. 382]'deki <span class="math inline">\(O\)</span> etrafında dönen küp orneğini kullanalım,</p>
<div class="figure">
<img src="phy_005_basics_04_01.png" />

</div>
<p>Bu referansa göre atalet matrisi</p>
<p><span class="math display">\[
I = \left[\begin{array}{rrr}
8 &amp; -3 &amp; -3 \\
-3 &amp; 8 &amp; -3 \\
-3 &amp; -3 &amp; 8
\end{array}\right]
\]</span></p>
<p>olarak bulunmuş. Görüldüğü gibi <span class="math inline">\(I\)</span> köşegen değil. Kosegenlestirmek icin,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy.linalg <span class="im">as</span> lin
I <span class="op">=</span> np.array([[<span class="dv">8</span>, <span class="dv">-3</span>, <span class="dv">-3</span>],
              [<span class="op">-</span><span class="dv">3</span>, <span class="dv">8</span>, <span class="dv">-3</span>],
              [<span class="op">-</span><span class="dv">3</span>, <span class="dv">-3</span>, <span class="dv">8</span>]])
e,evec <span class="op">=</span> lin.eig(I)
<span class="bu">print</span> (e)
<span class="bu">print</span> (evec)
<span class="bu">print</span> (evec[:,<span class="dv">0</span>])</code></pre></div>
<pre><code>[11.  2. 11.]
[[ 0.81649658 -0.57735027  0.        ]
 [-0.40824829 -0.57735027 -0.70710678]
 [-0.40824829 -0.57735027  0.70710678]]
[ 0.81649658 -0.40824829 -0.40824829]</code></pre>
<p>Demek ki yeni <span class="math inline">\(I\)</span> matrisi</p>
<p><span class="math display">\[
I = \left[\begin{array}{rrr}
11 &amp; 0 &amp; 0 \\
0 &amp; 2 &amp; 0 \\
0 &amp; 0 &amp; 11 
\end{array}\right]
\]</span></p>
<p>olmalı.</p>
<p>Üç tane <span class="math inline">\(\omega\)</span> vektörü elde edildi, bunlar tabii ki birbirine dik, hepsini grafikleyelim, yeşil çizgiler <span class="math inline">\(x,y,z\)</span> eksenleri olmak üzere,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> mpl_toolkits <span class="im">import</span> mplot3d

<span class="kw">def</span> plot_vector(fig, orig, v, color<span class="op">=</span><span class="st">&#39;blue&#39;</span>):
   ax <span class="op">=</span> fig.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)
   orig <span class="op">=</span> np.array(orig)<span class="op">;</span> v<span class="op">=</span>np.array(v)
   ax.quiver(orig[<span class="dv">0</span>], orig[<span class="dv">1</span>], orig[<span class="dv">2</span>], v[<span class="dv">0</span>], v[<span class="dv">1</span>], v[<span class="dv">2</span>],color<span class="op">=</span>color)
   ax <span class="op">=</span> fig.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)  
   <span class="cf">return</span> fig

fig <span class="op">=</span> plt.figure()
axes <span class="op">=</span> mplot3d.Axes3D(fig)
SCALE <span class="op">=</span> <span class="fl">0.5</span>
plot_vector(fig, [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],evec [:,<span class="dv">0</span>]<span class="op">*</span>SCALE)
plot_vector(fig, [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],evec [:,<span class="dv">1</span>]<span class="op">*</span>SCALE)
plot_vector(fig, [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],evec [:,<span class="dv">2</span>]<span class="op">*</span>SCALE)
axes.view_init(elev<span class="op">=</span><span class="dv">10</span>, azim<span class="op">=</span><span class="dv">200</span>)
axes.set_xlim(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>)
axes.set_ylim(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>)
axes.set_zlim(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>)
axes.plot([<span class="dv">0</span>,<span class="dv">1</span>],[<span class="dv">0</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">0</span>],color <span class="op">=</span> <span class="st">&#39;g&#39;</span>)
axes.plot([<span class="dv">0</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">1</span>],[<span class="dv">0</span>,<span class="dv">0</span>],color <span class="op">=</span> <span class="st">&#39;g&#39;</span>)
axes.plot([<span class="dv">0</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">1</span>],color <span class="op">=</span> <span class="st">&#39;g&#39;</span>)
axes.locator_params(tight<span class="op">=</span><span class="va">True</span>, nbins<span class="op">=</span><span class="dv">4</span>)
plt.savefig(<span class="st">&#39;phy_005_basics_04_02.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="phy_005_basics_04_02.png" />

</div>
<p>Kaynaklar</p>
<p>[1] Taylor, <em>Classical Mechanics</em></p>
<p>[2] Bayramlı, <em>Lineer Cebir, Ders 22</em></p>
<p>[3] Rotenberg, <em>CSE169: Computer Animation, UCSD</em></p>
<p>[4] Bayramlı, <em>Lineer Cebir, Ders 5</em></p>
<p>[5] Witkin, <em>Physically Based Modeling</em></p>
<p>[7] Levi, <em>Classical Mechanics with Calculus of Variations and Optimal Control</em></p>
<p>[8] Bayramlı, <em>Cok Degiskenli Calculus, Ders 3</em></p>
<p>[9] Taylor, <em>Classical Mechanics Problem Solutions</em></p>
</body>
</html>
