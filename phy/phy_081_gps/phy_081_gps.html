<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>GPS, Kullanıcı Yerini Bulmak, GPS Uydularına Olan Açı, Uzaklık</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1
id="gps-kullanıcı-yerini-bulmak-gps-uydularına-olan-açı-uzaklık">GPS,
Kullanıcı Yerini Bulmak, GPS Uydularına Olan Açı, Uzaklık</h1>
<p>Küresel Konumlama Sistemi (Global Positioning System -GPS-) ile
dünyada nerede olduğumuzu kolay bir şekilde bulabiliyoruz. GPS’in
temelinde eldeki bir alıcının dünya etrafında sürekli dönen uydulara
olan mesafesini ölçerek bunlara göre bir konumlama yapması yatıyor.
Eldeki alıcı, ki artık ucuz bir akıllı telefon bile olabiliyor, önce
Almanak denen bir bilgiyi (eğer o anda elde yoksa) uydudan alıyor. Bu
bilgi tüm GPS uydularının kesin yerlerini alıcıya söyler. Ardından uydu
ve alıcı arasında sinyallerin alınıp verilmesindeki zaman farkına
bakılarak olabildiğince detaylı bir mesafe bilgisi alınır. Eğer en az 4
tane uyduya olan mesafe bu şekilde alınabiliyorsa bir üçgenleme
yapılarak alıcının yeryüzündeki yeri saptanabilir. Uydular her biri
yeterince büyük bir bölgeye servis edebilsin diye çok uzaktaki bir
yörüngededirler, dünyaya ortalama mesafeleri 20,000 kilometre (evet,
yirmi bin), kıyasla ISS uzay istasyonu yaklaşık 200 km. mesafede.</p>
<p><img src="sat1.jpg" /></p>
<p>Bu yazıda mesafeleri kullanıp nerede olduğumuz konusuna girmeden eğer
nerede olduğumuz biliniyor olsa uyduya olan yatay açı / azimut (azimuth)
ve yüksekliği (elevation) nasıl buluruz konusunu işleyeceğiz.</p>
<p>Azimut nedir? Yeryüzünde duruyoruz, yüzümüzü kuzeye dönelim, bu
referans duruşu. Eğer mesela azimut 320 derece ise, doğuya doğru o kadar
döneriz (ya da batıya 360-320 kadar dönebiliriz), ve başımızı yukarı
doğru yükseklik açısı kadar kaldırırız, mesela 60 derece yukarı doğru,
ki 90 derece tam dik yukarı bakıyoruz demektir. Aşağı yukarı alttaki
resimdeki gibi bir durum olur,</p>
<p><img src="azelzen.png" /></p>
<p>Üstteki türden bir gösterim kullanıcı merkezlidir. GPS uyduları,
hatta kullanıcının yerini dünyayı merkez alan, daha net şekilde
belirtmek gerekirse dünyanın merkezini merkez alan (orası orijin
sayılıyor, (0,0,0) noktası) sisteminde almak daha kullanışlı oluyor.</p>
<p><img src="eci.jpg" /></p>
<p>Bu sisteme ECI sistemi, ya da ECEF kordinatları deniyor. Tabii mesela
kilometre bağlamında mesela (1,1,1) noktası anlamsız olabilir, dünyanın
“içinde’’, yerkabuğunun altında bir nokta olacaktır, fakat dünya yüzeyi,
ve yüzeyden daha üstteki uydular için anlamlı ve kullanışlı bir sistem.
Daha önemlisi bu sistem Kartezyen geometrisi kullanmamıza izin verecek,
ve daha ileride göreceğimiz gibi uzaklık hesaplarında faydalı olacak.
ECI ve alıcı bazlı kordinat sistemlerini aynı resimde görelim,</p>
<p><img src="ecef_topo.png" /></p>
<p>Hesabın detayları [3]’te bulunabilir. Dünyanın duruşunun hesabı için
yıldız günü (sidereal day) kavramı gerekli. Bilinen gün hesabı güneşin
aynı boylamdan iki geçişi arasındaki zamandır. Öğlen 12’de güneş
yukarıdadır, güneşin tekrar aynı noktada olduğu zaman bir gün geçmiş
demektir. Fakat astronomi hesapları için etrafında döndüğümüz güneş
değil, daha uzaktaki bir noktayı merkez almak gerekebiliyor, bu daha
uzaktaki noktanın aynı boylamın üzerinden iki geçişi arasındaki zaman
bir yıldız günüdür. Normal gün ile yıldız günü arasında 4 dakikalık bir
fark var. Yıldız günü ve ayrıca tek reel sayı bazlı tarih kullanabilmek
için için Jülyen Tarihi kullanılır, bu tarih bir referans başlangıç
anından mevcut ana olan gün sayısıdır. Altta bazı ölçümler aldığımız
zamanı milisaniye olarak kaydettik, onun Jülyen çevrimi alttaki gibi
hesaplanıyor,</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> orbital</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> datetime <span class="im">import</span> datetime</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>millis <span class="op">=</span> <span class="dv">1493036068479</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> datetime.fromtimestamp(millis<span class="op">/</span><span class="fl">1000.0</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>dtj <span class="op">=</span> orbital.jdays(datetime.fromtimestamp(millis<span class="op">/</span><span class="fl">1000.0</span>))</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> dtj</span></code></pre></div>
<pre><code>2457868.09339</code></pre>
<p>Azimut, yükseklik hesapları ölçüm aldığımız an için [1]’den uyduların
nerede olduğunu bir dosyaya kaydettik. GPS uydularının PRN kodları
vardır, örnek seçilen PRN 11,18,16,24,31 uydularının enlem / boylam
pozisyonları altta,</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(<span class="st">&#39;Waas_Sv_Status.txt&#39;</span>,sep<span class="op">=</span><span class="st">&#39;\s*&#39;</span>,index_col<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>sats <span class="op">=</span> [<span class="dv">11</span>,<span class="dv">18</span>,<span class="dv">16</span>,<span class="dv">24</span>,<span class="dv">31</span>]</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.ix[sats]</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> df[[<span class="st">&#39;Lat&#39;</span>,<span class="st">&#39;Long&#39;</span>]]</span></code></pre></div>
<pre><code>           Lat        Long
PRN                       
11   30.518234 -164.259351
18    1.027207  -57.092297
16  -55.533692 -122.123140
24   45.299193   17.625305
31   13.344068 -102.581100</code></pre>
<p>Ölçüm alınan yerin kordinatları altta <code>lat,lon</code> içinde.
Şimdi bu noktadan bakılacak olsa (Berlin’deyiz) uyduların hangi azimut,
yükseklikte olacağının hesabını yapalım,</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>lon <span class="op">=</span> <span class="fl">13.442383333333332</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>lat <span class="op">=</span> <span class="fl">52.483086666666665</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>alt <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>sat_alt <span class="op">=</span> <span class="dv">20</span><span class="op">*</span><span class="dv">1000</span><span class="op">*</span><span class="dv">1000</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> df.<span class="bu">apply</span>(<span class="kw">lambda</span> x: orbital.get_observer_look(x.Long, <span class="op">\</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>               x.Lat, sat_alt, dt, lon, lat, alt),axis<span class="op">=</span><span class="dv">1</span>)</span></code></pre></div>
<pre><code>PRN
11     (358.005492414, -6.99245765159, 20007166.964)
18        (254.95693367, 12.52250143, 20004991.9173)
16    (245.378821316, -64.1703023622, 20012088.4789)
24     (157.451172143, 82.3085240779, 20000057.3405)
31    (298.723320912, -4.42938085218, 20006877.4437)
dtype: object</code></pre>
<p>[2]’den tüm uyduların o anda dünya üzerinde nerede olduğuna
baktık,</p>
<p><img src="waas_sats.png" /></p>
<p>Peki bu hesapları mesela cep telefonunun aldığı azimut, yükseklik ile
karşılaştırsak ne görürüz?</p>
<p><img src="gpstest.png" /></p>
<p>Telefonun raporladığı rakamlar uydu ve alıcı pozisyonuna göre değil,
antene ve sinyale göre hesaplanıyor, GPS kitlemesi yapılmadan da bu
değerleri bir GPS programında [7] görebiliyoruz. 11,31,24 fena durmuyor,
fakat 18 tam ters yönde çıkmış. Telefondaki ölçümlere tam güvenilir
diyemeyiz. Zihin egzersizi: acaba elde yeteri kadar azimut, yükseklik
ölçümü olsa ve uydu pozisyonu ile birleştirince üstteki hesapta geriye
doğru giderek bir alıcı pozisyonu elde edilebilir mi? İstatistiki bir
yaklaşım belki bunu yapabilir. Ödev olsun!</p>
<p>Tüm kodlar</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> datetime <span class="im">import</span> datetime</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np, math</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> <span class="fl">298.257223563</span> <span class="co"># Dunya duzlestirme WGS-84</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>MFACTOR <span class="op">=</span> <span class="fl">7.292115E-5</span> </span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>EPS_COS <span class="op">=</span> <span class="fl">1.5e-12</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> <span class="fl">298.257223563</span>  <span class="co"># Dunya duzlestirme WGS-84</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> <span class="fl">6378.137</span>  <span class="co"># WGS84 ekvotarsal cap</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="fl">6378137.0</span> <span class="co"># tekrar</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co"># yari minor eksen uzunlugu (m)</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> <span class="fl">6356752.3142</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co"># elipsoid duzluk (birimsiz)</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> (a <span class="op">-</span> b) <span class="op">/</span> a</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="co"># eksentriklik (birimsiz)</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>e <span class="op">=</span> np.sqrt(f <span class="op">*</span> (<span class="dv">2</span> <span class="op">-</span> f))</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> jdays2000(utc_time):</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> _days(utc_time <span class="op">-</span> datetime(<span class="dv">2000</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">12</span>, <span class="dv">0</span>))</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> jdays(utc_time):</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> jdays2000(utc_time) <span class="op">+</span> <span class="dv">2451545</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _fdays(dt):</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (dt.days <span class="op">+</span> (dt.seconds <span class="op">+</span> <span class="op">\</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>            dt.microseconds <span class="op">/</span> (<span class="fl">1000000.0</span>)) <span class="op">/</span> (<span class="dv">24</span> <span class="op">*</span> <span class="fl">3600.0</span>))</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>_vdays <span class="op">=</span> np.vectorize(_fdays)</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _days(dt):</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> _fdays(dt)</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gmst(utc_time):</span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>    ut1 <span class="op">=</span> jdays2000(utc_time) <span class="op">/</span> <span class="fl">36525.0</span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>    theta <span class="op">=</span> <span class="fl">67310.54841</span> <span class="op">+</span> ut1 <span class="op">*</span> (<span class="dv">876600</span> <span class="op">*</span> <span class="dv">3600</span> <span class="op">+</span> <span class="fl">8640184.812866</span> <span class="op">+</span> ut1 <span class="op">*</span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>                                 (<span class="fl">0.093104</span> <span class="op">-</span> ut1 <span class="op">*</span> <span class="fl">6.2</span> <span class="op">*</span> <span class="fl">10e-6</span>))</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.deg2rad(theta <span class="op">/</span> <span class="fl">240.0</span>) <span class="op">%</span> (<span class="dv">2</span> <span class="op">*</span> np.pi)    </span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> observer_position(time, lon, lat, alt):</span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>    lon <span class="op">=</span> np.deg2rad(lon)</span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>    lat <span class="op">=</span> np.deg2rad(lat)    </span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>    theta <span class="op">=</span> (gmst(time) <span class="op">+</span> lon) <span class="op">%</span> (<span class="dv">2</span> <span class="op">*</span> np.pi)</span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> np.sqrt(<span class="dv">1</span> <span class="op">+</span> F <span class="op">*</span> (F <span class="op">-</span> <span class="dv">2</span>) <span class="op">*</span> np.sin(lat)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>    sq <span class="op">=</span> c <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> F)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>    achcp <span class="op">=</span> (A <span class="op">*</span> c <span class="op">+</span> alt) <span class="op">*</span> np.cos(lat)</span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> achcp <span class="op">*</span> np.cos(theta)  <span class="co"># kilometers</span></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> achcp <span class="op">*</span> np.sin(theta)</span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> (A <span class="op">*</span> sq <span class="op">+</span> alt) <span class="op">*</span> np.sin(lat)</span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>    vx <span class="op">=</span> <span class="op">-</span>MFACTOR<span class="op">*</span>y  <span class="co"># kilometers/second</span></span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a>    vy <span class="op">=</span> MFACTOR<span class="op">*</span>x</span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>    vz <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (x, y, z), (vx, vy, vz)   </span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_observer_look(sat_lon, sat_lat, sat_alt, utc_time, lon, lat, alt):</span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a>    (pos_x, pos_y, pos_z), (vel_x, vel_y, vel_z) <span class="op">=</span> <span class="op">\</span></span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a>        observer_position(utc_time, sat_lon, sat_lat, sat_alt)</span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a>    (opos_x, opos_y, opos_z), (ovel_x, ovel_y, ovel_z) <span class="op">=</span> <span class="op">\</span></span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a>        observer_position(utc_time, lon, lat, alt)</span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-60"><a href="#cb7-60" aria-hidden="true" tabindex="-1"></a>    lon <span class="op">=</span> np.deg2rad(lon)</span>
<span id="cb7-61"><a href="#cb7-61" aria-hidden="true" tabindex="-1"></a>    lat <span class="op">=</span> np.deg2rad(lat)</span>
<span id="cb7-62"><a href="#cb7-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-63"><a href="#cb7-63" aria-hidden="true" tabindex="-1"></a>    theta <span class="op">=</span> (gmst(utc_time) <span class="op">+</span> lon) <span class="op">%</span> (<span class="dv">2</span> <span class="op">*</span> np.pi)</span>
<span id="cb7-64"><a href="#cb7-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-65"><a href="#cb7-65" aria-hidden="true" tabindex="-1"></a>    rx <span class="op">=</span> pos_x <span class="op">-</span> opos_x</span>
<span id="cb7-66"><a href="#cb7-66" aria-hidden="true" tabindex="-1"></a>    ry <span class="op">=</span> pos_y <span class="op">-</span> opos_y</span>
<span id="cb7-67"><a href="#cb7-67" aria-hidden="true" tabindex="-1"></a>    rz <span class="op">=</span> pos_z <span class="op">-</span> opos_z</span>
<span id="cb7-68"><a href="#cb7-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-69"><a href="#cb7-69" aria-hidden="true" tabindex="-1"></a>    sin_lat <span class="op">=</span> np.sin(lat)</span>
<span id="cb7-70"><a href="#cb7-70" aria-hidden="true" tabindex="-1"></a>    cos_lat <span class="op">=</span> np.cos(lat)</span>
<span id="cb7-71"><a href="#cb7-71" aria-hidden="true" tabindex="-1"></a>    sin_theta <span class="op">=</span> np.sin(theta)</span>
<span id="cb7-72"><a href="#cb7-72" aria-hidden="true" tabindex="-1"></a>    cos_theta <span class="op">=</span> np.cos(theta)</span>
<span id="cb7-73"><a href="#cb7-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-74"><a href="#cb7-74" aria-hidden="true" tabindex="-1"></a>    top_s <span class="op">=</span> sin_lat <span class="op">*</span> cos_theta <span class="op">*</span> rx <span class="op">+</span> <span class="op">\</span></span>
<span id="cb7-75"><a href="#cb7-75" aria-hidden="true" tabindex="-1"></a>        sin_lat <span class="op">*</span> sin_theta <span class="op">*</span> ry <span class="op">-</span> cos_lat <span class="op">*</span> rz</span>
<span id="cb7-76"><a href="#cb7-76" aria-hidden="true" tabindex="-1"></a>    top_e <span class="op">=</span> <span class="op">-</span>sin_theta <span class="op">*</span> rx <span class="op">+</span> cos_theta <span class="op">*</span> ry</span>
<span id="cb7-77"><a href="#cb7-77" aria-hidden="true" tabindex="-1"></a>    top_z <span class="op">=</span> cos_lat <span class="op">*</span> cos_theta <span class="op">*</span> rx <span class="op">+</span> <span class="op">\</span></span>
<span id="cb7-78"><a href="#cb7-78" aria-hidden="true" tabindex="-1"></a>        cos_lat <span class="op">*</span> sin_theta <span class="op">*</span> ry <span class="op">+</span> sin_lat <span class="op">*</span> rz</span>
<span id="cb7-79"><a href="#cb7-79" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> np.sqrt(top_s<span class="op">**</span><span class="dv">2</span><span class="op">+</span>top_e<span class="op">**</span><span class="dv">2</span><span class="op">+</span>top_z<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb7-80"><a href="#cb7-80" aria-hidden="true" tabindex="-1"></a>    az_ <span class="op">=</span> np.arctan(<span class="op">-</span>top_e <span class="op">/</span> top_s)</span>
<span id="cb7-81"><a href="#cb7-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-82"><a href="#cb7-82" aria-hidden="true" tabindex="-1"></a>    az_ <span class="op">=</span> np.where(top_s <span class="op">&gt;</span> <span class="dv">0</span>, az_ <span class="op">+</span> np.pi, az_)</span>
<span id="cb7-83"><a href="#cb7-83" aria-hidden="true" tabindex="-1"></a>    az_ <span class="op">=</span> np.where(az_ <span class="op">&lt;</span> <span class="dv">0</span>, az_ <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> np.pi, az_)</span>
<span id="cb7-84"><a href="#cb7-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-85"><a href="#cb7-85" aria-hidden="true" tabindex="-1"></a>    rg_ <span class="op">=</span> np.sqrt(rx <span class="op">*</span> rx <span class="op">+</span> ry <span class="op">*</span> ry <span class="op">+</span> rz <span class="op">*</span> rz)</span>
<span id="cb7-86"><a href="#cb7-86" aria-hidden="true" tabindex="-1"></a>    el_ <span class="op">=</span> np.arcsin(top_z <span class="op">/</span> rg_)</span>
<span id="cb7-87"><a href="#cb7-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-88"><a href="#cb7-88" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.rad2deg(az_), np.rad2deg(el_), r</span>
<span id="cb7-89"><a href="#cb7-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-90"><a href="#cb7-90" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ecef2lla(ecef, tolerance<span class="op">=</span><span class="fl">1e-9</span>):</span>
<span id="cb7-91"><a href="#cb7-91" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> ecef[<span class="dv">0</span>]</span>
<span id="cb7-92"><a href="#cb7-92" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> ecef[<span class="dv">1</span>]</span>
<span id="cb7-93"><a href="#cb7-93" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> ecef[<span class="dv">2</span>]</span>
<span id="cb7-94"><a href="#cb7-94" aria-hidden="true" tabindex="-1"></a>    lon <span class="op">=</span> math.atan2(y, x)</span>
<span id="cb7-95"><a href="#cb7-95" aria-hidden="true" tabindex="-1"></a>    alt <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-96"><a href="#cb7-96" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> a</span>
<span id="cb7-97"><a href="#cb7-97" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> np.sqrt(x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> y<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb7-98"><a href="#cb7-98" aria-hidden="true" tabindex="-1"></a>    lat <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-99"><a href="#cb7-99" aria-hidden="true" tabindex="-1"></a>    previousLat <span class="op">=</span> <span class="dv">90</span></span>
<span id="cb7-100"><a href="#cb7-100" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">abs</span>(lat <span class="op">-</span> previousLat) <span class="op">&gt;=</span> tolerance:</span>
<span id="cb7-101"><a href="#cb7-101" aria-hidden="true" tabindex="-1"></a>        previousLat <span class="op">=</span> lat</span>
<span id="cb7-102"><a href="#cb7-102" aria-hidden="true" tabindex="-1"></a>        sinLat <span class="op">=</span> z <span class="op">/</span> (N <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> e<span class="op">**</span><span class="dv">2</span>) <span class="op">+</span> alt)</span>
<span id="cb7-103"><a href="#cb7-103" aria-hidden="true" tabindex="-1"></a>        lat <span class="op">=</span> math.atan((z <span class="op">+</span> e<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> N <span class="op">*</span> sinLat) <span class="op">/</span> p)</span>
<span id="cb7-104"><a href="#cb7-104" aria-hidden="true" tabindex="-1"></a>        N <span class="op">=</span> a <span class="op">/</span> np.sqrt(<span class="dv">1</span> <span class="op">-</span> (e <span class="op">*</span> sinLat)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb7-105"><a href="#cb7-105" aria-hidden="true" tabindex="-1"></a>        alt <span class="op">=</span> p <span class="op">/</span> math.cos(lat) <span class="op">-</span> N</span>
<span id="cb7-106"><a href="#cb7-106" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (np.rad2deg(lat), np.rad2deg(lon), alt)</span></code></pre></div>
<p>Uzaklıktan Kullanıcı Pozisyonunu Bulmak</p>
<p>Aynı zamanda bir GPS alıcısı olan akıllı cep telefonları GPS
uydularına olan mesafeyi hesaplayabilir. Bunu uydudan gönderilen
sinyallerin erişim süresini hesaplayarak yaparlar. Uydulardan gelen her
sinyal içinde o sinyalin gönderilme anı vardır, alıcı bu zamana bakar,
ve kendi elindeki saate bakar ve aradaki farkı sinyalin hızı ile
çarparak mesafeyi bulur. Birden fazla yeri bilinen uyduya olan
mesafelerin kesişme noktası alıcının olduğu yerdir.</p>
<p><img src="trilat1.png" /></p>
<p>Yanlız bu hesap yapılırken iki potansiyel problem ortaya çıkar.</p>
<p>Birinci problem alıcıdaki saat yanlılık problemi (clock bias). GPS
sinyali yerine ses dalgası temelli bir örnek üzerinde bu kavramı
anlatalım: Denizcilikte sis sireni (foghorn) denen bir şey var, sisli
durumlarda gemicileri yakında tehlikeli kayalar hakkında uyarmak için
kullanılır. Şimdi diyelim ki sis sirenini yerimizi bulmak için
kullanacağız. Yine basitleştirme amaçlı olarak tek boyutlu bir dünya
düşünelim, bir çizgi üzerindeyiz, bu çizgide ya sola ya da sağa
gidebiliyoruz, sis sireni ise çizginin sıfır noktasında.</p>
<p><img src="foghorn1.png" /></p>
<p>Sis sireninin her gün öğlen 12:00’de çalındığını biliyoruz. Diyelim
ki saat 12:00:10 (yani 10 saniye sonra) sireni duyduk. Üstteki çizgide
neredeyiz? Ses hızı 330 metre / saniye, o zaman 10 saniye sonra 3.3
kilometre uzaktayız.</p>
<p>Fakat bu hesap eğer saatimiz mükemmel bir şekilde siren saati ile
senkronize ise geçerli. Uzaktan bu senkronizasyon var mı yok mu
bilemiyoruz, çünkü sireni duyduğumuzda saate baktık acaba önceden 5
saniye geri miydik de 15 saniye sonra gelen sireni acaba 12:00:10’da
gördük? Ya da senkronizasyon haricinde belki saatimiz daha yavaş, ya da
daha hızlı işliyor, ses havada seyahat ederken bu hızlanma / yavaşlama
ölçüme etki etti?</p>
<p>Bu problemden kurtulmak için elimizdeki saatin yanlılığını
denklemlerde direk kullanarak onu da hesaplamak bir çözüm olabilir.
Yanlılığı modelleyebiliyoruz çünkü sis sirenleri birbirleri ile mükemmel
şekilde senkronize (GPS uyduları için de bu böyle, uydularda birbirleri
ile senkronize atomik saatler var), ve bizim saatimizde yanlılık varsa
bu yanlılık her iki siren için aynı. Yani yanlışlık olması önemli değil,
yanlışlık tutarlı ise ondan kurtulabiliriz!</p>
<p>Yanlılık ikinci bir bilinmeyen tabii, o zaman ikinci bir ölçüm lazım.
Diyelim ki birinci sirenden 990 m. sağda olan ikinci bir sirenden saat
12:00:09’da bir sinyal aldık.</p>
<p><img src="foghorn2.png" /></p>
<p>Şimdi nerede olduğumuzu bulabilir miyiz? Uzaklık, daha doğrusu içinde
yanlılık ta olduğu için, “sözde uzaklık (pseudorange)’’ şöyle
modellenir,</p>
<p><span class="math display">\[ R_1&#39; = v_{ses} (\Delta t_1 + \tau )
= x + v_{ses}\tau = 3300 \]</span></p>
<p><span class="math display">\[ R_2&#39; = v_{ses} (\Delta t_2 + \tau )
= 990 - x + \tau = 2970\]</span></p>
<p>ki <span class="math inline">\(\Delta t_1, \Delta t_2\)</span> geçen
zaman, <span class="math inline">\(\tau\)</span> yanlılık, <span
class="math inline">\(v_{ses}\)</span> ses hızı. Tekrar düzenlersek,</p>
<p><span class="math display">\[ x + v_{ses} \tau = 3300\]</span></p>
<p><span class="math display">\[ x - v_{ses} \tau = -1980  \]</span></p>
<p>Çözersek,</p>
<p><span class="math display">\[ \tau = 8 \textrm{ saniye} \quad x = 660
\textrm{ metre}\]</span></p>
<p>Yanlılık hesabı böyle. Şimdi ikinci probleme gelelim. Bu problem
kesişme hesabı sırasında ortaya çıkıyor. Yanlılık doğru modellense bile
diğer pek çok sebepten dolayı uzaklık hesabında eksikler olabilir. O
zaman mükemmel kesişme yerine alttaki gibi durum ortaya çıkabilir,</p>
<p><img src="trilat2.png" /></p>
<ol type="1">
<li>uydu uzaklığı normalden kısa, 2. ve 3. uzun gelmiş. Acaba bu
uzaklıkların gürültülü bir ortamda olsak bile kesiştiği yeri yaklaşık
bir şekilde bulamaz mıyız? Hatta sistemi öyle kuralım ki ne kadar çok
uydu ölçümü eklersek ölçüm o kadar ilerlesin, yani bir tür istatistiksel
en az kareler (least squares) çözümü arıyoruz.</li>
</ol>
<p>Fakat yine bir problem var, alıcı <span
class="math inline">\(x,y,z\)</span> pozisyonu ve uydu <span
class="math inline">\(i\)</span> arasındaki sözde mesafe, <span
class="math inline">\(P^i\)</span> diyelim, gayrı-lineer bir hesap.</p>
<p><span class="math display">\[
P^i = \sqrt{ \big( (x^i-x)^2 + (y^i-y)^2 + (z^i-z)^2  \big) } + \tau
\]</span></p>
<p>Hesapta kareler, onların toplamı, karekök işlemi var. Üstteki
denklemi, ve bu denklemi kullanacağımız denklem sistemini bir şekilde
lineerleştirmemiz lazım.</p>
<p>Her sözde uzaklık ölçümünü üstteki model artı gürültü olarak
gösterelim,</p>
<p><span class="math display">\[ P_{\textrm{gözlem}} = p_{model} +
\textrm{gürültü} \]</span></p>
<p><span class="math display">\[ = P(x,y,z,\tau) + v \]</span></p>
<p>Şimdi model üzerinde çok boyutlu Taylor açılımı uygulayalım,</p>
<p><span class="math display">\[
P(x,y,z,\tau) = P(x_0,y_0,z_0,\tau_0) +
(x-x_0)\frac{\partial P}{\partial x} +
(y-y_0)\frac{\partial P}{\partial y} +
(z-z_0)\frac{\partial P}{\partial z} +
(\tau-\tau_0)\frac{\partial P}{\partial \tau}  + ...
\]</span></p>
<p>Bu açılımda noktalı yerlerde daha yüksek üstelli terimler var, onları
atalım, geri kalanlar lineer terimler, ve atılan terimler sebebiyle
açılım yaklaşıksal olacak doğal olarak. Taylor açılımını <span
class="math inline">\(x_0,y_0,z_0,\tau_0\)</span> noktası “etrafında’’
yaptık, şimdi <span
class="math inline">\(P(x_0,y_0,z_0,\tau_0)\)</span>’e <span
class="math inline">\(P_{hesap}\)</span> diyelim, bunun sebebini
birazdan göreceğiz, ve tüm denklem şu hale gelir,</p>
<p><span class="math display">\[
= P_{hesap} + \frac{\partial P}{\partial x} \Delta x +
\frac{\partial P}{\partial y} \Delta y +
\frac{\partial P}{\partial z} \Delta z +
\frac{\partial P}{\partial \tau} \Delta \tau
\]</span></p>
<p>Şimdi</p>
<p><span class="math display">\[ \Delta P \equiv P_{\textrm{gözlem}} -
P_{hesap} \]</span></p>
<p>diyelim, ve</p>
<p><span class="math display">\[
= \frac{\partial P}{\partial x} \Delta x +
\frac{\partial P}{\partial y} \Delta y +
\frac{\partial P}{\partial z} \Delta z +
\frac{\partial P}{\partial \tau} \Delta \tau
+ v
\]</span></p>
<p>Matris formunda yazarsak,</p>
<p><span class="math display">\[
\Delta P = \left[\begin{array}{cccc}
\dfrac{\partial P}{\partial x} \Delta x &amp;
\dfrac{\partial P}{\partial y} \Delta y &amp;
\dfrac{\partial P}{\partial z} \Delta z &amp;
\dfrac{\partial P}{\partial \tau} \Delta \tau
\end{array}\right]
\left[\begin{array}{c}
\Delta x \\ \Delta y \\ \Delta z \\ \Delta \tau
\end{array}\right] + v
\]</span></p>
<p>Üstteki tek bir ölçüm için. Her uydudan gelen ölçüm matriste yeni bir
satır oluşturur, <span class="math inline">\(m\)</span> tane ölçüm
için,</p>
<p><span class="math display">\[
\begin{bmatrix}
\Delta P^1 \\[1ex]
\Delta P^2 \\[1ex]
\Delta P^3 \\[1ex]
\vdots \\[1ex]
\Delta P^m
\end{bmatrix}
=
\begin{bmatrix}
\dfrac{\partial P^1}{\partial x} &amp;
\dfrac{\partial P^1}{\partial y} &amp;
\dfrac{\partial P^1}{\partial z} &amp;
\dfrac{\partial P^1}{\partial \tau}
\\[2ex]
\dfrac{\partial P^2}{\partial x} &amp;
\dfrac{\partial P^2}{\partial y} &amp;
\dfrac{\partial P^2}{\partial z} &amp;
\dfrac{\partial P^2}{\partial \tau}
\\[2ex]
\dfrac{\partial P^3}{\partial x} &amp;
\dfrac{\partial P^3}{\partial y} &amp;
\dfrac{\partial P^3}{\partial z} &amp;
\dfrac{\partial P^3}{\partial \tau}
\\[2ex]
\vdots &amp; \vdots &amp; \vdots &amp; \vdots \\[2ex]
\dfrac{\partial P^m}{\partial x} &amp;
\dfrac{\partial P^m}{\partial y} &amp;
\dfrac{\partial P^m}{\partial z} &amp;
\dfrac{\partial P^m}{\partial \tau}
\end{bmatrix}
\begin{bmatrix}
\Delta x \\[1ex]
\Delta y \\[1ex]
\Delta z \\[1ex]
\Delta \tau
\end{bmatrix} +
\begin{bmatrix}
v_1 \\[1ex]
v_2 \\[1ex]
v_2 \\[1ex]
\vdots \\[1ex]
v_m
\end{bmatrix}
\]</span></p>
<p>Bu sistemi bir <span class="math inline">\(b = Ax + v\)</span> lineer
sistemi olarak görebiliriz, ki en az kareler yöntemi sistemi çözer.
<span class="math inline">\(A\)</span> matrisinin içeriği için kısmi
türevlerin alınması lazım, bu türevler, mesela <span
class="math inline">\(P^1\)</span> ve <span
class="math inline">\(x\)</span> için</p>
<p><span class="math display">\[
\frac{\partial P^1}{\partial x} =
\frac{x^1-x}{\sqrt{ \big( (x^1-x)^2 + (y^1-y)^2 + (z^1-z)^2  \big) }} =
\frac{x^1-x}{\rho}
\]</span></p>
<p>Tüm ölçümler ve değişkenler için yapalım,</p>
<p><span class="math display">\[
A = \left[\begin{array}{cccc}
\dfrac{x^1 - x}{\rho} &amp; \dfrac{y^1 - y}{\rho} &amp; \dfrac{z^1 -
z}{\rho} &amp; 1 \\
\dfrac{x^2 - x}{\rho} &amp; \dfrac{y^2 - y}{\rho} &amp; \dfrac{z^2 -
z}{\rho} &amp; 1 \\
\dfrac{x^3 - x}{\rho} &amp; \dfrac{y^3 - y}{\rho} &amp; \dfrac{z^3 -
z}{\rho} &amp; 1 \\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots \\
\dfrac{x^m - x}{\rho} &amp; \dfrac{y^m - y}{\rho} &amp; \dfrac{z^m -
z}{\rho} &amp; 1
\end{array}\right]
\]</span></p>
<p>Böylece bir <span class="math inline">\(b = Ax + v\)</span> sistemi
elde ettik, <span class="math inline">\(\Delta\)</span> değişkenleri
bilinmeyen, <span class="math inline">\(A\)</span>’yı üstte kurduk,
standart en az kareler uygulayınca <span
class="math inline">\(v\)</span>’yi minimize eden bilinmeyenler
bulunacaktır.</p>
<p>Şimdi çözülenin ne olduğuna dikkat, çözümler <span
class="math inline">\(\Delta\)</span> değişkenleri, yani <span
class="math inline">\(x_0,y_0,z_0,\tau_0\)</span> noktası ile olan
<em>fark</em>. Şimdi, bir de Taylor açılımlarının püf noktasını
hatırlayalım, bu açılımlar açılım noktası etrafında, yakınında
geçerlidir. O zaman nihai çözüme bir döngü içinde erişmek gerekecek,
yavaş yavaş, bir önceki çözüme ekleye ekleye. Herhangi bir başlangıç
noktası mesela dünyanın merkezi ve sıfır yanlılık <span
class="math inline">\(x_0,y_0,z_0,\tau_0 = (0,0,0,0)\)</span> ile
başlarız, <span class="math inline">\(\Delta\)</span>’ları hesaplarız,
ve başlangıca ekleriz, bunlar yeni “başlangıç’’ noktası olur, hesabı
tekrarlarız, ve farklar çok ufak oluncaya kadar (çözüme yaklaştık) bunu
tekrar ederiz.</p>
<p>Başlangıç noktasını referans alıp ekleme yaparak hesabın bir ek
faydası var; mesela cep telefonu ile yürüme durumunda bir yeri
hesapladıktan / kitledikten sonra bir sonraki yer hesabı için tekrar
dünya merkezini başlangıç almamıza gerek yok, en son kitlenen yeri
başlangıç kabul ederiz, ve büyük ihtimalle tek bir ek hesap ile yeni
konumu hesaplayabiliriz.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.linalg <span class="im">as</span> lin</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>xtrue <span class="op">=</span> [<span class="fl">3507884.948</span>, <span class="fl">780492.718</span>, <span class="fl">5251780.403</span>, <span class="dv">0</span>]</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>xxyyzz <span class="op">=</span> [[<span class="fl">16577402.072</span>, <span class="fl">5640460.750</span>, <span class="fl">20151933.185</span>],</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>      [<span class="fl">11793840.229</span>, <span class="op">-</span><span class="fl">10611621.371</span>, <span class="fl">21372809.480</span>],</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>      [<span class="fl">20141014.004</span>, <span class="op">-</span><span class="fl">17040472.264</span>, <span class="fl">2512131.115</span>],</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>      [<span class="fl">22622494.101</span>, <span class="op">-</span><span class="fl">4288365.463</span>, <span class="fl">13137555.567</span>],</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>      [<span class="fl">12867750.433</span>, <span class="fl">15820032.908</span>, <span class="fl">16952442.746</span>],</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>      [<span class="op">-</span><span class="fl">3189257.131</span>, <span class="op">-</span><span class="fl">17447568.373</span>, <span class="fl">20051400.790</span>],</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>      [<span class="op">-</span><span class="fl">7437756.358</span>, <span class="fl">13957664.984</span>, <span class="fl">21692377.935</span>]]</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>xxyyzz <span class="op">=</span> np.array(xxyyzz)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>pseudorange <span class="op">=</span> np.array([<span class="fl">20432524.0</span>, <span class="fl">21434024.4</span>, <span class="fl">24556171.0</span>, </span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>                        <span class="fl">21315100.2</span>, <span class="fl">21255217.0</span>, <span class="fl">24441547.2</span>, <span class="fl">23768678.3</span>])</span></code></pre></div>
<p>Üstte örnek ölçümler görüyoruz. [6]’daki araştırmacı Danimarka’da bir
ölçüm merkezinde GPS aletinden 7 tane GPS uydusuna olan sözde uzaklığı
ve bu uyduların o anki yerlerini kaydetmiş, bu kişi acaba nerededir?
Tarif edilen yaklaşım ile hesaplayalım,</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>xx <span class="op">=</span> xxyyzz[:,<span class="dv">0</span>]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>yy <span class="op">=</span> xxyyzz[:,<span class="dv">1</span>]</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>zz <span class="op">=</span> xxyyzz[:,<span class="dv">2</span>]</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.ones((<span class="bu">len</span>(xxyyzz),<span class="dv">4</span>))</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="bu">iter</span> <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">20</span>):</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    rng <span class="op">=</span> np.sqrt((x[<span class="dv">0</span>]<span class="op">-</span>xx)<span class="op">**</span><span class="dv">2</span><span class="op">+</span>(x[<span class="dv">1</span>]<span class="op">-</span>yy)<span class="op">**</span><span class="dv">2</span><span class="op">+</span>(x[<span class="dv">2</span>]<span class="op">-</span>zz)<span class="op">**</span><span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    F <span class="op">=</span> rng <span class="op">+</span> x[<span class="dv">3</span>]</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    irange <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>rng<span class="op">;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    A[:,<span class="dv">0</span>] <span class="op">=</span> irange<span class="op">*</span>(x[<span class="dv">0</span>]<span class="op">-</span>xx)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    A[:,<span class="dv">1</span>] <span class="op">=</span> irange<span class="op">*</span>(x[<span class="dv">1</span>]<span class="op">-</span>yy)<span class="op">;</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    A[:,<span class="dv">2</span>] <span class="op">=</span> irange<span class="op">*</span>(x[<span class="dv">2</span>]<span class="op">-</span>zz)<span class="op">;</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> np.dot(A.T,pseudorange<span class="op">-</span>F)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> np.dot(A.T,A)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    deltahat <span class="op">=</span> lin.solve(N,c)</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> x<span class="op">+</span>deltahat</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> np.<span class="bu">max</span>(np.<span class="bu">abs</span>(deltahat))<span class="op">&lt;</span><span class="fl">0.001</span>: <span class="cf">break</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> <span class="st">&#39;iter&#39;</span>, <span class="bu">iter</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> np.reshape(x, (<span class="dv">4</span>,<span class="dv">1</span>))</span></code></pre></div>
<pre><code>iter 4
[[ 3507889.12958827]
 [  780490.02116445]
 [ 5251783.75537277]
 [   25511.14592576]]</code></pre>
<p>Döngü beş kez tekrarladı ama dünya merkezinden başlamış olmamıza
rağmen sonuca çabukça erişti. ECEF sisteminden enlem / boylam çevirimini
yapalım,</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> orbital</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> orbital.ecef2lla(x)</span></code></pre></div>
<pre><code>(55.796250049381591, 12.543735075055356, 73.165498103015125)</code></pre>
<p>Bu kordinatları bir harita uygulamasından kontrol ettik; yazar
Danimarka’da teknik üniversite yakınlarında imiş. Zaten [6] gerçek
yerini de paylaşmış, üstteki çözüme çok yakın. Sistem işliyor
demektir.</p>
<p><img src="denmark.jpg" /></p>
<p>GPS uydu uzaklıklarını baz alarak konum hesabı niye faydalı? Cep
telefonları zaten enlem / boylam raporlamıyor mu? Bu doğru, fakat farklı
mobil uygulamaları farklı şekilde bu hesabı yapmayı, hızlandırmayı
seçebilirler. Bu ihtiyaçtan dolayı olmalı Android işletim sistemi
tasarlayıcıları 7.0 (Nougat), API 24’ten itibaren ham uzaklık verisini
bir arayüz ile geliştiricilere açmaya karar verdi.</p>
<p>Kaynaklar</p>
<p>[1] Federal Aviation Administration, <em>Uydu Pozisyonları</em>, <a
href="http://www.nstb.tc.faa.gov/incoming/Waas_Sv_Status.txt">http://www.nstb.tc.faa.gov/incoming/Waas_Sv_Status.txt</a></p>
<p>[2] Federal Aviation Administration, <em>WAAS Satellite Status</em>,
<a
href="http://www.nstb.tc.faa.gov/RT_WaasSatelliteStatus.htm">http://www.nstb.tc.faa.gov/RT_WaasSatelliteStatus.htm</a></p>
<p>[3] Kelso, <em>Orbital Coordinate Systems, Part II</em>, <a
href="http://celestrak.com/columns/v02n02/">http://celestrak.com/columns/v02n02/</a></p>
<p>[4] Raspaud, <em>PyOrbital</em>, <a
href="https://github.com/pytroll/pyorbital">https://github.com/pytroll/pyorbital</a></p>
<p>[5] Blewitt, <em>Basics of the GPS Technique: Observation
Equations</em>, <a
href="http://www.nbmg.unr.edu/staff/pdfs/Blewitt%20Basics%20of%20gps.pdf">http://www.nbmg.unr.edu/staff/pdfs/Blewitt%20Basics%20of%20gps.pdf</a></p>
<p>[6] Nielsen, <em>Least Squares Adjustment: Linear and Nonlinear
Weighted Regression Analysis</em>, <a
href="http://www2.imm.dtu.dk/pubdb/views/edoc_download.php/2804/pdf/imm2804.pdf">http://www2.imm.dtu.dk/pubdb/views/edoc_download.php/2804/pdf/imm2804.pdf</a></p>
<p>[7] Chartcross Limited, <em>GPS Test</em>, <a
href="https://play.google.com/store/apps/details?id=com.chartcross.gpstest">https://play.google.com/store/apps/details?id=com.chartcross.gpstest</a></p>
<p>[8] Raquet, <em>Calculation of GPS PNT Solution</em>, <a
href="http://indico.ictp.it/event/a12180/session/21/contribution/12/material/0/0.pdf">http://indico.ictp.it/event/a12180/session/21/contribution/12/material/0/0.pdf</a></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
