<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Hareketin Katı-Gövde Denklemleri - 1</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="hareketin-katı-gövde-denklemleri---1">Hareketin Katı-Gövde
Denklemleri - 1</h1>
<p>Runge-Kutta Hesabı</p>
<p>İleride lazım olacak bir hesapsal yöntemi görelim, katı gövde
cisimlerinin hareketi için diferansiyel denklemleri entegre etmemiz
gerekiyor, bunun için Runge-Kutta yaklaşımını bir örnek üzerine
görebiliriz.</p>
<p>İlk Uygulanan Kuvvet</p>
<p>İki boyutlu ortama ağırlığı <span class="math inline">\(m=1\)</span>
kg olan bir topu 45 derece açıyla sağ yukarı doğru atıyoruz,
uyguladığımız kuvvet 500 Newton. Bu topun gidiş yönü nasıl
hesaplanır?</p>
<p>Önemli bir konu uygulanan kuvveti başlangıçta sisteme nasıl dahil
edeceğimiz. Burada dürtü / vuruş / darbe (impulse) kavramına bakmak
gerekiyor. Kuvvetle hız değişimini ilintilendirmek için Newton’un ikinci
kanunu ile başlayalım,</p>
<p><span class="math display">\[
F = \frac{\mathrm{d} P}{\mathrm{d} t}
\]</span></p>
<p>Uygulanan kuvvet momentum değişimine eşittir, ki <span
class="math inline">\(P = mv\)</span> olmak üzere. Fakat sonsuz küçük
zaman üzerinden iş yapamayız, iki tarafın entegralini alalım,</p>
<p><span class="math display">\[
\int_{t_1}^{t_2} F \mathrm{d} t = \int_{t_1}^{t_2} \mathrm{d} P
\mathrm{d} t
\]</span></p>
<p><span class="math display">\[
J = \int_{t_1}^{t_2} F \mathrm{d} t = P(t_2) - P(t_1)
\]</span></p>
<p>Sonuçtaki <span class="math inline">\(J\)</span> dürtü büyüklüğü,
kuvvetin zaman üzerinden entegrali, yani bir zaman aralığında uygulanan
kuvvetin toplamı. Bu büyüklük momentum üzerinde bir değişime yol açıyor,
<span class="math inline">\(P(t_1)\)</span> momentumundan <span
class="math inline">\(P(t_2)\)</span> değerine geliyoruz.</p>
<p>Üstteki formül şunu söylüyor, momentum değişimi için bir kuvvetin
uygulandığı bir zaman aralığı gerekir. O zaman problem tanımı eksik, 500
Newton’luk kuvvet uyguladık, peki ne kadar süreli? Devam etmeden önce
diyelim ki bir saniye, o zaman dürtü 500 Newton <span
class="math inline">\(\cdot\)</span> saniye (Ns) olur. Dikkat <span
class="math inline">\(m\)</span> değeri değişmediği için tek değişim hız
değişkeninde olacaktır, <span class="math inline">\(J = m(v_2 - v_1) = m
\Delta v\)</span>, yani dürtü sonrası hızda değişim gözleyeceğiz.</p>
<p>Başlangıçta <span class="math inline">\(v_1=0\)</span>, dürtü için
500 N <span class="math inline">\(\cdot\)</span> saniye</p>
<p><span class="math display">\[
J = m v_2 - m v_1 = m v_2 - m(0) \to J = m v_2
\]</span></p>
<p><span class="math display">\[
\to 500 Ns = m v_2
\to 500 \frac{kg \cdot m/s^2}{1 kg } \cdot s = v_2
\to v_2 = 500 m/s
\]</span></p>
<p>diyebiliriz.</p>
<p>Ilk Uygulanan Tork</p>
<p>Gerçi alttaki örnek için lazım değil ama ilk uygulanan kuvvet gibi
ilk uygulanan dürtü (impulse), tork kavramı da simülasyonlarda gerekli.
Bu durumda açısal dürtü belli bir zamanda uygulanan torktur, yani torkun
zaman üzerinden entegralidir denir, ve bu dürtü açısal momentumdaki
değişime eşittir. İlk tanımla başlarsak,</p>
<p><span class="math display">\[
J = \int \tau \mathrm{d} t
\]</span></p>
<p>Eğer zaman aralığı ufak ve tork sabit ise</p>
<p><span class="math display">\[
J = \tau \Delta t
\]</span></p>
<p>Diğer yandan açısal momentum eşitliğini hatırlayalım,</p>
<p><span class="math display">\[
L = I \omega
\]</span></p>
<p>Açısal dürtü açısal momentum değişimine eşit ise</p>
<p><span class="math display">\[
\tau \Delta t = \Delta L = \Delta (I \omega)= I (\omega_2 - \omega_1)
\]</span></p>
<p>ki <span class="math inline">\(\omega_1\)</span> başlangıç açısal
hızı, <span class="math inline">\(\omega_2\)</span> nihai hız. Hız
başlangıçta sıfır olsa, <span class="math inline">\(\omega_1 =
0\)</span>, ve nihai hız ile başlangıçta uygulanan tork arasında
bağlantı kurmak istesek</p>
<p><span class="math display">\[
\tau \Delta t = I \omega_2
\]</span></p>
<p><span class="math display">\[
\to \omega_2 = I^{-1} \tau \Delta t
\]</span></p>
<p>Örnek</p>
<p>Artık sistem denklemini entegre edebiliriz, sistem <span
class="math inline">\(\dot{x} = v_x\)</span>, <span
class="math inline">\(\dot{y} = v_y\)</span> <span
class="math inline">\(\dot{v} = a\)</span>. Sürekli etki eden tek ivme
etkisi yerçekimi <span class="math inline">\(g\)</span>. Sistem bir
vektör üzerinden temsil edilebiliyor,</p>
<p><span class="math display">\[
\left[\begin{array}{c}
\dot{x} \\ \dot{y} \\ \dot{v}
\end{array}\right] = F(\vec{x},t)
\]</span></p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rk4_step(func, dt, t, y):</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    k1 <span class="op">=</span> dt <span class="op">*</span> func(t, y)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    k2 <span class="op">=</span> dt <span class="op">*</span> func(t <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> dt, y <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> k1)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    k3 <span class="op">=</span> dt <span class="op">*</span> func(t <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> dt, y <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> k2)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    k4 <span class="op">=</span> dt <span class="op">*</span> func(t <span class="op">+</span> dt, y <span class="op">+</span> k3)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> y <span class="op">+</span> (k1 <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>k2 <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>k3 <span class="op">+</span> k4) <span class="op">/</span> <span class="dv">6</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> projectile_motion_eom(t, X):</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    x, y_pos, vx, vy <span class="op">=</span> X</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    g <span class="op">=</span> <span class="fl">9.81</span>  <span class="co"># yercekimi</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="dv">1</span>     <span class="co"># topun kutlesi</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    dx_dt <span class="op">=</span> vx</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    dy_dt <span class="op">=</span> vy</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    dvx_dt <span class="op">=</span> <span class="fl">0.0</span> </span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    dvy_dt <span class="op">=</span> <span class="op">-</span>g  </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array([dx_dt, dy_dt, dvx_dt, dvy_dt])</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>initial_force <span class="op">=</span> <span class="fl">500.0</span>  <span class="co"># baslangic kuvveti, Newton </span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>force_direction <span class="op">=</span> np.array([<span class="fl">1.0</span>, <span class="fl">1.0</span>])</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>force_direction <span class="op">=</span> force_direction <span class="op">/</span> np.linalg.norm(force_direction) </span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> <span class="fl">0.01</span>  <span class="co"># zaman dilimi (saniye)</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial position [x0, y0]</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>x0 <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>y0 <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>initial_acceleration <span class="op">=</span> initial_force <span class="op">/</span> m <span class="op">*</span> force_direction</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>initial_velocity_magnitude <span class="op">=</span> initial_force <span class="op">/</span> m </span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>                                                                                                                                             </span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>initial_velocity_vector <span class="op">=</span> initial_velocity_magnitude <span class="op">*</span> force_direction</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>vx0 <span class="op">=</span> initial_velocity_vector[<span class="dv">0</span>]</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>vy0 <span class="op">=</span> initial_velocity_vector[<span class="dv">1</span>]</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Baslangic Hizi: [</span><span class="sc">{</span>vx0<span class="sc">:.2f}</span><span class="ss"> m/s, </span><span class="sc">{</span>vy0<span class="sc">:.2f}</span><span class="ss"> m/s]&quot;</span>)</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>initial_state <span class="op">=</span> np.array([x0, y0, vx0, vy0])</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>time_points <span class="op">=</span> [<span class="fl">0.0</span>]</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>state_history <span class="op">=</span> [initial_state]</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>current_state <span class="op">=</span> initial_state</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>current_time <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> current_state[<span class="dv">1</span>] <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    current_state <span class="op">=</span> rk4_step(projectile_motion_eom, dt, current_time, current_state)</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>    current_time <span class="op">+=</span> dt</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> current_state[<span class="dv">1</span>] <span class="op">&lt;</span> <span class="dv">0</span>: <span class="cf">break</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>    time_points.append(current_time)</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    state_history.append(current_state)</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>state_history <span class="op">=</span> np.array(state_history)</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>x_positions <span class="op">=</span> state_history[:, <span class="dv">0</span>]</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>y_positions <span class="op">=</span> state_history[:, <span class="dv">1</span>]</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>vx_values <span class="op">=</span> state_history[:, <span class="dv">2</span>]</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>vy_values <span class="op">=</span> state_history[:, <span class="dv">3</span>]</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>plt.plot(x_positions, y_positions)</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;(m)&#39;</span>)</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;(m)&#39;</span>)</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>plt.axhline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">&#39;black&#39;</span>, linestyle<span class="op">=</span><span class="st">&#39;--&#39;</span>, linewidth<span class="op">=</span><span class="fl">0.7</span>) <span class="co"># yer</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">&#39;equal&#39;</span>) </span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;phy_005_basics_05_05.jpg&#39;</span>)</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;</span><span class="ch">\n</span><span class="ss">Bitis Zamani: </span><span class="sc">{</span>time_points[<span class="op">-</span><span class="dv">1</span>]<span class="sc">:.2f}</span><span class="ss"> saniye&quot;</span>)</span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Son yer: x = </span><span class="sc">{</span>x_positions[<span class="op">-</span><span class="dv">1</span>]<span class="sc">:.2f}</span><span class="ss"> m, y = </span><span class="sc">{</span>y_positions[<span class="op">-</span><span class="dv">1</span>]<span class="sc">:.2f}</span><span class="ss"> m&quot;</span>)</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Son hız: vx = </span><span class="sc">{</span>vx_values[<span class="op">-</span><span class="dv">1</span>]<span class="sc">:.2f}</span><span class="ss"> m/s, vy = </span><span class="sc">{</span>vy_values[<span class="op">-</span><span class="dv">1</span>]<span class="sc">:.2f}</span><span class="ss"> m/s&quot;</span>)</span></code></pre></div>
<pre><code>Baslangic Hizi: [353.55 m/s, 353.55 m/s]

Bitis Zamani: 72.08 saniye
Son yer: x = 25484.13 m, y = 0.07 m
Son hız: vx = 353.55 m/s, vy = -353.55 m/s</code></pre>
<p><img src="phy_005_basics_05_05.jpg" /></p>
<p>Rotasyon Matrisi ve Türevi</p>
<p>Bir 3 x 3 dönüş matrisi ile herhangi bir vektörü döndürebileceğimizi
biliyoruz. Yersel taşıma daha da basit, 3 boyutlu bir vektör sadece,
mevcut konuma ekleyerek yeni konumu elde ediyoruz.</p>
<p>Bir katı gövdeyi parçacıkları üzerinden alırsak, ve bu gövdenin
açısal dönüşsel olarak hangi yöne baktığını bir dönüş matrisi <span
class="math inline">\(R\)</span> ile temsil edersek, her parçacık
üzerinde bu işlemin uygulandığını düşünebiliriz. Ayrıca konumsal taşınma
ve bakılan yön başlangıçtaki bir “gövde uzayı’’na (body space) göre
yapılabilir, gövdenin kütle merkezini dünya kordinatlarının (0,0,0)
orijin noktasında ve yönü herhangi bir (başta belli) yöne doğru alalım,
hareketler hep bu konuma referansla, onu değiştirecek şekilde
düşünülebilir. Mesela gövde üzerindeki, gövde uzayındaki, herhangi bir
<span class="math inline">\(p_0\)</span> noktasını düşünelim, <span
class="math inline">\(t\)</span> anında bu noktanın dünya uzayındaki
konumu</p>
<p><span class="math display">\[
p(t) = R(t) p_0 + x_{CM}(t)
\]</span></p>
<p>ki <span class="math inline">\(x_{CM}(t)\)</span> bir yersel taşınma,
ve <span class="math inline">\(R(t)\)</span> açısal dönüş. Tabii taşınma
her zaman kütle merkezine uygulandığı için <span
class="math inline">\(x_{CM}\)</span> aynı zamanda kütle merkezinin her
<span class="math inline">\(t\)</span> anında dünya uzayında olduğu yeri
de gösteriyor.</p>
<p><img src="phy_005_basics_04_04.png" /></p>
<p>Türeve gelirsek, bir vektör <span
class="math inline">\(r\)</span>’nin orijin etrafında döndüğünü
düşünelim. Herhangi bir anda bu dönüşün açısal hızı <span
class="math inline">\(\omega\)</span> çapraz çarpımla
hesaplanabilir,</p>
<p><img src="phy_005_basics_04_03.png" /></p>
<p>Hız tabii ki sonsuz küçük zamandaki yer değişimi olduğu için onu</p>
<p><span class="math display">\[
\frac{\mathrm{d} r}{\mathrm{d} t} = \omega \times r
\]</span></p>
<p>olarak ta görebiliriz. Şimdi bir katı gövdeyi düşünelim, onun baktığı
yön (orientation) bir matris <span class="math inline">\(R\)</span>
içinde. Bu matrisin her kolonunda bir eksen var, ilk kolon <span
class="math inline">\(x\)</span>, ikinci <span
class="math inline">\(y\)</span>, vs. Eğer gövdenin baktığı yönü <span
class="math inline">\(R\)</span> ile temsil ediyorsak tüm bu kolonlar
gövde dönerken değişecektir. Eğer dönüş <span
class="math inline">\(\omega\)</span> ise her eksenin açısal hızı <span
class="math inline">\(\omega\)</span> demek, o zaman bu eksenlerin,
<span class="math inline">\(b,c,d\)</span> diyelim, açısal hızı ayrı
ayrı <span class="math inline">\(\omega \times b\)</span>, <span
class="math inline">\(\omega \times c\)</span>, <span
class="math inline">\(\omega \times d\)</span> olarak bulunabilir, ki
bunların her biri aynı zamanda ayrı birer türevdir. Tüm matrisin
türevi</p>
<p><span class="math display">\[
\frac{\mathrm{d} R}{\mathrm{d} t} = \tilde \omega \cdot R
\]</span></p>
<p>ki <span class="math inline">\(\tilde \omega\)</span> ile <span
class="math inline">\(\omega\)</span>’yi eksi bakışımlı [4] bir matris
hale getirdik, böylece çapraz çarpımı noktasal çarpım haline çevirmiş
oluyoruz [5, sf. 9], [3].</p>
<p>Devam edelim, diğer konuları daha önce bir gövdenin her bakımdan
konumunu, statüsünü temsil etmek için gerekli matematiği gördük. Bu
konumu <span class="math inline">\(\overline{X}(t)\)</span> ile
gösterebiliriz,</p>
<p><span class="math display">\[
\overline{X} = \left[\begin{array}{c}
x_{CM}(t) \\ R(t) \\ P(t) \\ L(t)
\end{array}\right]
\]</span></p>
<p>Momentum <span class="math inline">\(P(t) = v(t) M\)</span> olduğu
için <span class="math inline">\(v(t) = \frac{P(t)}{M}\)</span>.</p>
<p><span class="math inline">\(I(t)\)</span>’yi yukarıda gördük, <span
class="math inline">\(I(t) = R(t) I_{body} R(t)^T\)</span>.</p>
<p><span class="math inline">\(L(t) = I(t) \omega(t)\)</span> olduğu
için <span class="math inline">\(\omega(t) = I(t)^{-1} L(t)\)</span></p>
<p>Hepsini biraraya koyunca <span
class="math inline">\(\overline{X}\)</span>’nin türevi</p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d} t} \overline{X}(t) =
\frac{\mathrm{d}}{\mathrm{d} t}
\left[\begin{array}{c}
x_{CM}(t) \\ R(t) \\ P(t) \\ L(t)
\end{array}\right]
=
\left[\begin{array}{c}
v(t) \\ \tilde \omega \cdot R(t) \\ F(t) \\ \tau(t)
\end{array}\right]
\]</span></p>
<p>Katı-Gövde Simülasyonu</p>
<p>Dönüş</p>
<p>Bir örnek gövde üzerinde simülasyon yapmaya uğraşalım. Elimizde bir
simit, ya da geometride torus denen bir şekil var. Bu dosya STL denen
bir format içinde, detaylar için [6]. Kuvvet uygulama sonrası lineer ve
açısal momentum içeren simülasyon için pek çok değişkeni diferansiyel
tanımları üzerinden entegre etmemiz gerekiyor, daha basit bir örnek ile,
özellikle sabit bir açısal hız üzerinden salt döndürme ile başlamak
uygun olabilir. [2]’te tarif edilen döndürme matrisi türevini
hatırlarsak,</p>
<p><span class="math display">\[
\frac{\mathrm{d} R}{\mathrm{d} t} = \tilde \omega \cdot R
\]</span></p>
<p>Döndürmeyi bir <span class="math inline">\(\omega\)</span> etrafında
düşünüyorduk, <span class="math inline">\(\omega\)</span>’nin büyüklüğü
açısal dönme hızına tekabül ediyordu, ve <span
class="math inline">\(\tilde \omega\)</span> eksi-bakışımlı matris
idi.</p>
<p><img src="compscieng_bpp32sim_rigbod_01.png" /></p>
<p>Tüm bunları entegre edici <code>odeint</code> çağrısının kabul
edeceği bir formda nasıl kullanırız? Bu çağrı düzleştirilmiş bir liste
içinde diferansiyel sonuçların, ve ana değişkenlerin olmasını bekliyor.
O zaman <span class="math inline">\(R\)</span>’yi kolon bazlı olmak
üzere düzleştiririz, ve gerektiği o listeden matris formuna geçeriz,
vs.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.integrate <span class="im">import</span> odeint</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> stl <span class="im">import</span> mesh</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> skew(a):</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> np.array([[<span class="dv">0</span>,<span class="op">-</span>a[<span class="dv">2</span>],a[<span class="dv">1</span>]],[a[<span class="dv">2</span>],<span class="dv">0</span>,<span class="op">-</span>a[<span class="dv">0</span>]],[<span class="op">-</span>a[<span class="dv">1</span>],a[<span class="dv">0</span>],<span class="dv">0</span>]])</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>your_mesh <span class="op">=</span> mesh.Mesh.from_file(<span class="st">&#39;torus.stl&#39;</span>)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>prop <span class="op">=</span> your_mesh.get_mass_properties()</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>R0 <span class="op">=</span> np.eye(<span class="dv">3</span>,<span class="dv">3</span>)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>omega <span class="op">=</span> np.array([<span class="fl">1.0</span>,<span class="fl">1.0</span>,<span class="fl">1.0</span>])</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co">#omega = np.array([0.0,1.0,0.0])</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>skew_omega <span class="op">=</span> skew(omega)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dRdt(u,t):   </span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>   R1x,R1y,R1z,R2x,R2y,R2z,R3x,R3y,R3z <span class="op">=</span> u</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>   R <span class="op">=</span> np.array([R1x,R1y,R1z,R2x,R2y,R2z,R3x,R3y,R3z])</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>   R <span class="op">=</span> R.reshape((<span class="dv">3</span>,<span class="dv">3</span>)).T</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>   res <span class="op">=</span> np.dot(skew_omega, R)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> <span class="bu">list</span>(res.T.flatten())</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>LIM <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>STEPS <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>t<span class="op">=</span>np.linspace(<span class="fl">0.0</span>, <span class="fl">3.0</span>, STEPS)</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>R0 <span class="op">=</span> np.eye(<span class="dv">3</span>,<span class="dv">3</span>)</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>u0 <span class="op">=</span> R0.flatten()</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>u1<span class="op">=</span>odeint(dRdt,<span class="bu">list</span>(u0),t)</span></code></pre></div>
<p>Üstte görülen mesela <code>R1x</code> <span
class="math inline">\(R\)</span> matrisinin 1’inci kolonunun <span
class="math inline">\(x\)</span> değişkeni anlamında.</p>
<p>Simülasyonda simit şeklinin baktığı yön <span
class="math inline">\(R\)</span> içinde, ve grafik amaçlı olarak her
seferinde simit şeklini sıfırdan yükleyip son <span
class="math inline">\(R\)</span>’ye ilerletiyoruz, ve her adımda bu
grafiği basıyoruz. Simülasyonu hesapladık, tüm sonuç <code>u1</code>
içinde, görüntüden bazı seçilmiş kareler altta görülebilir,</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpl_toolkits <span class="im">import</span> mplot3d</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_vector(fig, orig, v, color<span class="op">=</span><span class="st">&#39;blue&#39;</span>):</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>   ax <span class="op">=</span> fig.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>   orig <span class="op">=</span> np.array(orig)<span class="op">;</span> v<span class="op">=</span>np.array(v)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>   ax.quiver(orig[<span class="dv">0</span>], orig[<span class="dv">1</span>], orig[<span class="dv">2</span>], v[<span class="dv">0</span>], v[<span class="dv">1</span>], v[<span class="dv">2</span>],color<span class="op">=</span>color)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>   ax <span class="op">=</span> fig.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)  </span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> fig</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(STEPS):</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    fig <span class="op">=</span> plt.figure()</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    axes <span class="op">=</span> mplot3d.Axes3D(fig)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    your_mesh <span class="op">=</span> mesh.Mesh.from_file(<span class="st">&#39;torus.stl&#39;</span>)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    R <span class="op">=</span> u1[i].reshape((<span class="dv">3</span>,<span class="dv">3</span>)).T</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    your_mesh.rotate_using_matrix(R)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    scale <span class="op">=</span> your_mesh.points.flatten()</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    axes.add_collection3d(mplot3d.art3d.Poly3DCollection(your_mesh.vectors,alpha<span class="op">=</span><span class="fl">0.3</span>))</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    plot_vector(fig, [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>], omega, color<span class="op">=</span><span class="st">&#39;red&#39;</span>)</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    axes.auto_scale_xyz(scale, scale, scale)</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    axes.set_xlim(<span class="op">-</span>LIM,LIM)<span class="op">;</span>axes.set_ylim(<span class="op">-</span>LIM,LIM)<span class="op">;</span>axes.set_zlim(<span class="op">-</span>LIM,LIM)</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    axes.view_init(azim<span class="op">=</span><span class="dv">20</span>,elev<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    plt.savefig(<span class="st">&#39;/tmp/rotate_</span><span class="sc">%02d</span><span class="st">.png&#39;</span> <span class="op">%</span> i)  </span></code></pre></div>
<p><img src="sim1/rotate_00.png" /></p>
<p><img src="sim1/rotate_08.png" /></p>
<p><img src="sim1/rotate_14.png" /></p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> convert <span class="op">-</span>delay <span class="dv">20</span> <span class="op">-</span>loop <span class="dv">0</span> <span class="op">/</span>tmp<span class="op">/</span>rotate<span class="op">*</span>.png <span class="op">/</span>tmp<span class="op">/</span>torus_rotate1.gif</span></code></pre></div>
<p>Animasyon sonucu [1]’de.</p>
<p>Torus şekli hakkında bazı istatistikler alttadır.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> stl <span class="im">import</span> mesh</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>your_mesh <span class="op">=</span> mesh.Mesh.from_file(<span class="st">&#39;torus.stl&#39;</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>prop <span class="op">=</span> your_mesh.get_mass_properties()</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;hacim&#39;</span>,np.<span class="bu">round</span>(prop[<span class="dv">0</span>],<span class="dv">3</span>))</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;yercekim merkezi (COG)&#39;</span>,np.<span class="bu">round</span>(prop[<span class="dv">1</span>],<span class="dv">3</span>))</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;COG noktasinda atalet matrisi&#39;</span>)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (np.<span class="bu">round</span>(prop[<span class="dv">2</span>],<span class="dv">3</span>))</span></code></pre></div>
<pre><code>hacim 4.918
yercekim merkezi (COG) [-0.  0. -0.]
COG noktasinda atalet matrisi
[[ 3.223 -0.     0.   ]
 [-0.     3.223  0.   ]
 [ 0.     0.     5.832]]</code></pre>
<p>COG sıfır noktasında olması, ayrıca atalet matrisinin köşegen olması
mantıklı çünkü simit şekli simetrik.</p>
<p>Üstteki simülasyonda kuvvetler, lineer, açısal momentum gibi
kavramlar gösterilmedi, bir sonraki yazıda tüm kavramların olduğu bir
simülasyon olacak, yazıda dönüş matematiği de sayısal açıdan daha sağlam
farklı bir yaklaşım kullanıyor olacak.</p>
<p>Kaynaklar</p>
<p>[1] Bayramlı, <em>Animasyon 1</em>, <a
href="https://www.dropbox.com/scl/fi/l9wjyc2nar8bwucasfqpf/torus_rotate1.gif?rlkey=mhnye63g5auddh7m3e993ic43&amp;st=ttluuezu&amp;raw=1">https://www.dropbox.com/scl/fi/l9wjyc2nar8bwucasfqpf/torus_rotate1.gif?rlkey=mhnye63g5auddh7m3e993ic43&amp;st=ttluuezu&amp;raw=1</a></p>
<p>[2] Bayramlı, <em>Fizik, Temel Fizik 4, Katı Gövde</em></p>
<p>[3] Rotenberg, <em>CSE169: Computer Animation, UCSD</em></p>
<p>[4] Bayramlı, <em>Lineer Cebir, Ders 5</em></p>
<p>[5] Witkin, <em>Physically Based Modeling</em></p>
<p>[6] Bayramlı, <em>3D Baskıya Hazır CAD Tasarımlarına Erişmek,
Numpy-STL</em>, <a
href="https://burakbayramli.github.io/dersblog/sk/2020/08/numpy-stl.html">https://burakbayramli.github.io/dersblog/sk/2020/08/numpy-stl.html</a></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
