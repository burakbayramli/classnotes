<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  
  
  
  
</head>
<body>
<h1 id="materyel-mekaniği---8">Materyel Mekaniği - 8</h1>
<p>Bu derste kirişler ve makaskirişleri üstdüşüm ile birleştirip hem eksenel hem eksene dik kuvvetler ile nasıl hesap yapabileceğimizi göreceğiz. Daha sonra bu yeni parça türü bir şasi içinde biraraya koyulup daha çetrefil yapılar analiz edilecek. Ama önce döndürme kavramını görelim.</p>
<p>Dönüş (Rotation)</p>
<p>Alttaki gibi bir kiriş düşünelim,</p>
<div class="figure">
<img src="phy_020_strs_06_01.jpg" />

</div>
<p>Daha önce bu tür bir kiriş üzerinde eksenel yöndeki kuvvetler ve yer değişimlerinin ilişkisini</p>
<p><span class="math display">\[
\left[\begin{array}{c}
f&#39;_{1x} \\ f&#39;_{2x}
\end{array}\right] =
\frac{AE}{L}
\left[\begin{array}{cc}
1 &amp; -1 \\ -1 &amp; 1
\end{array}\right]
\left[\begin{array}{c}
u&#39;_1 \\ u&#39;_2
\end{array}\right]
\qquad (1)
\]</span></p>
<p>olarak göstermiştik. Üstteki formül kirişin yerel, kendisine has kordinat sistemini baz alıyor. Eğer üstteki değişkenleri global kordinat sistemine eşlemek, yansıtmak istiyorsak o zaman sistemi resimdeki <span class="math inline">\(\theta\)</span> kadar döndürmemiz gerekiyor. Döndürme işlemi genel olarak iki boyuttaki bir <span class="math inline">\([u, v]\)</span> vektörü için [1, sf. 85]</p>
<p><span class="math display">\[
\left[\begin{array}{c}
u&#39; \\ v&#39;
\end{array}\right] =
\left[\begin{array}{cc}
C &amp; S \\ -S &amp; C
\end{array}\right]
\left[\begin{array}{c}
u \\ v
\end{array}\right]
\qquad (2)
\]</span></p>
<p>ile yapılır, ki <span class="math inline">\(C = \cos\theta\)</span>, <span class="math inline">\(S = \sin\theta\)</span>.</p>
<p>Fakat unutmayalım tek eksenlikten çıktığımız zaman kirişin her ucunda iki serbestlik derecesi vardır, her uç <span class="math inline">\(u,v\)</span> yönünde yer değişim yaşayabilir, bunları <span class="math inline">\(u_1,v_1\)</span> ve <span class="math inline">\(u_2,v_2\)</span> diye gösterebiliriz. O zaman dönüş hesabı</p>
<p><span class="math display">\[
\left[\begin{array}{c}
u&#39;_1 \\ v&#39;_1 \\ u&#39;_2 \\ v&#39;_2
\end{array}\right] =
\left[\begin{array}{cccc}
C &amp; S &amp; 0 &amp; 0 \\
-S &amp; C &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; C &amp; S \\
0 &amp; 0 &amp; -S &amp; C 
\end{array}\right]
\left[\begin{array}{c}
u_1 \\ v_1 \\ u_2 \\ v_2
\end{array}\right]
\]</span></p>
<p>İlerlemeden önce iki üstteki dönüş matrisi, <span class="math inline">\(T\)</span> diyelim, hakkında ilginç bir ispatı verelim, ileride lazım olacak. Acaba <span class="math inline">\(T^T = T^{-1}\)</span> ifadesi doğru mudur? Bu aynı zamanda [1] kitabındaki 3.28 probleminin de cevabı. İspat için <span class="math inline">\(T T^T\)</span> çarpımını yapabiliriz, eğer birim (identity) matrisi elde edersek ispat tamam demektir.</p>
<p><span class="math display">\[
T = 
\left[\begin{array}{cccc}
C &amp; S &amp; 0 &amp; 0 \\
-S &amp; C &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; C &amp; S \\
0 &amp; 0 &amp; -S &amp; C 
\end{array}\right], \quad
T^T = 
\left[\begin{array}{cccc}
C &amp; -S &amp; 0 &amp; 0 \\
S &amp; C &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; C &amp; -S \\
0 &amp; 0 &amp; S &amp; C 
\end{array}\right]
\]</span></p>
<p>Çarpımı <code>sympy</code> ile yapalım,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> sympy <span class="im">import</span> symbols, pprint, latex
<span class="im">from</span> sympy.matrices <span class="im">import</span> Matrix
C,S <span class="op">=</span> symbols(<span class="st">&quot;C,S&quot;</span>)
T <span class="op">=</span> Matrix([[C,S,<span class="dv">0</span>,<span class="dv">0</span>],[<span class="op">-</span>S,C,<span class="dv">0</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">0</span>,C,S],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="op">-</span>S,C]])
Tprime <span class="op">=</span> Matrix([[C,<span class="op">-</span>S,<span class="dv">0</span>,<span class="dv">0</span>],[S,C,<span class="dv">0</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">0</span>,C,<span class="op">-</span>S],[<span class="dv">0</span>,<span class="dv">0</span>,S,C]])
<span class="bu">print</span> (latex(T <span class="op">*</span> Tprime)[:<span class="dv">60</span>],<span class="st">&#39;...&#39;</span>)</code></pre></div>
<pre><code>\left[\begin{matrix}C^{2} + S^{2} &amp; 0 &amp; 0 &amp; 0\\0 &amp; C^{2} + S ...</code></pre>
<p>Yani,</p>
<p><span class="math display">\[
\left[\begin{matrix}C^{2} + S^{2} &amp; 0 &amp; 0 &amp; 0\\0 &amp; C^{2} + S^{2} &amp; 0 &amp; 0\\0 &amp; 0 &amp; C^{2} + S^{2} &amp; 0\\0 &amp; 0 &amp; 0 &amp; C^{2} + S^{2}\end{matrix}\right]
\]</span></p>
<p>Hatırlarsak <span class="math inline">\(C = \cos\theta, S = \sin\theta\)</span>, bunları yerine koyunca tüm köşegen boyunca 1 değeri elde edilir, diğer hücrelerde sıfır var, demek ki bir birim matrisi elde ettik. Bu demektir ki <span class="math inline">\(T T^T = I\)</span>, ve bu ifadenin doğru olmasının tek yolu <span class="math inline">\(T^T = T^{-1}\)</span> olmasıdır. İspat tamamlandı.</p>
<p>Bir önemli eşitlik daha, yer değişimlerde olduğu gibi, kuvvetler de döndürme matematiğine tabi olabilirler. Mesela dönüş matrisi <span class="math inline">\(T\)</span> için</p>
<p><span class="math display">\[
d&#39; = T d
\]</span></p>
<p>diyebilirdim, ya da kuvvetler için</p>
<p><span class="math display">\[
f&#39; = T f
\]</span></p>
<p>Bunun bir yan etkisi şudur, yer değişimlerini kuvvetlerle ilintilendiren sistem</p>
<p><span class="math display">\[
f = k d
\]</span></p>
<p>ise,</p>
<p><span class="math display">\[
f&#39; = k&#39; d&#39; 
\]</span></p>
<p>Bu sistem şöyle de gösterilebilir,</p>
<p><span class="math display">\[
f&#39; = k&#39; T d
\]</span></p>
<p>ve</p>
<p><span class="math display">\[
T f = k&#39; T d
\]</span></p>
<p>Eğer üstteki ifadeyi soldan <span class="math inline">\(T^{-1}\)</span> ile çarparsak,</p>
<p><span class="math display">\[
T^{-1} T f = T^{-1} k&#39; T d
\]</span></p>
<p><span class="math inline">\(T^{-1} T = I\)</span> olduğu için yokolur, ayrıca biraz önceki ispattan <span class="math inline">\(T^{-1} = T^T\)</span> olduğunu biliyoruz,</p>
<p><span class="math display">\[
f = T^T k&#39; T d
\]</span></p>
<p>Global direngenlik matrisi <span class="math inline">\(k\)</span> ortadaki <span class="math inline">\(T^T k&#39; T\)</span> büyüklüğüdür.</p>
<p>Devam edelim. Dönüş mekaniğini gördük, şimdi önceki derste işlenen kiriş parçasına hem eksenel dinamiği hem de biraz önce gördüğümüz dönüş mantığını ekleyelim. Altta görülen kiriş parçasının hareketlerini hesaplayabilmek istiyoruz yani,</p>
<div class="figure">
<img src="phy_020_strs_06_02.jpg" />

</div>
<p>Önceki dersten hatırlarsak eksene dik yük alan parçaların mekaniği alttaki formülle gösterilmişti,</p>
<p><span class="math display">\[
\left[\begin{array}{c}
f_{1y} \\ m_1 \\ f_{2y} \\ m_2
\end{array}\right] =
\frac{EI}{L^3}
\left[\begin{array}{cccc}
12 &amp; 6L &amp; -12 &amp; 6L \\
6L &amp; 4L^2 &amp; -6L &amp; 2L^2 \\
-12 &amp; -6L &amp; 12 &amp; -6L \\
6L &amp; 2L^2 &amp; -6L &amp; 4L^2
\end{array}\right]
\left[\begin{array}{ccc}
v_1 \\ \phi_1 \\ v_2 \\ \phi_2
\end{array}\right]
\]</span></p>
<p>Bu formüle (1)'deki eksenel mantığı eklersek, yerel kordinatlarda</p>
<p><span class="math display">\[
\left[\begin{array}{c}
f&#39;_{1x} \\ f&#39;_{1y} \\ m&#39;_1 \\ f&#39;_{2x} \\ f&#39;_{2y} \\ m&#39;_2
\end{array}\right] =
\left[\begin{array}{cccccc}
C_1 &amp; 0 &amp; 0 &amp; -C_1 &amp; 0 &amp; 0 \\
0 &amp; 12C_2 &amp; 6 C_2 L &amp; 0 &amp; -12 C_2 &amp; 6 C_2 L \\
0 &amp; 6C_2 L &amp; 4 C_2 L^2 &amp; 0 &amp; -6 C_2 L &amp; 2 C_2 L^2 \\
-C_1 &amp; 0 &amp; 0 &amp; C_1 &amp; 0 &amp; 0 \\
0 &amp; -12C_2 &amp; -6 C_2 L &amp; 0 &amp; 12 C_2 &amp; -6 C_2 L \\
0 &amp; 6 C_2 L &amp; 2 C_2 L^2 &amp; 0 &amp; -6C_2 L &amp; 4C_2 L^2
\end{array}\right]
\left[\begin{array}{c}
u&#39;_1 \\ v&#39;_1 \\ \phi&#39;_1 \\ u&#39;_2 \\ v&#39;_2 \\ \phi&#39;_2
\end{array}\right]
\qquad (4)
\]</span></p>
<p>elde edilir, ki <span class="math inline">\(C_1 = \dfrac{AE}{L}\)</span> ve <span class="math inline">\(C_2 = \dfrac{EI}{L^3}\)</span> olmak üzere. Üstte ortada duran matris <span class="math inline">\(k&#39;\)</span> matrisidir. İfadenin <code>sympy</code> ile doğrulaması için yazının sonuna gidebiliriz.</p>
<p>Şimdi dönüş mekaniğini ekleyelim.</p>
<p><span class="math display">\[
\left[\begin{array}{ccc}
u&#39;_1 \\ v&#39;_1 \\ \phi&#39;_1 \\ u&#39;_2 \\ v&#39;_2 \\ \phi&#39;_2 
\end{array}\right] =
\left[\begin{array}{cccccc}
C &amp; S &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
-S &amp; C &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; C &amp; S &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; -S &amp; C &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right]
\left[\begin{array}{ccc}
u_1 \\ v_1 \\ \phi_1 \\ u_2 \\ v_2 \\ \phi_2 
\end{array}\right]
\qquad (5)
\]</span></p>
<p>Ortadaki matris yerel öğeler için etkili <span class="math inline">\(T\)</span> matrisi. Dikkat edersek dönüş sağlayan 2 x 2 boyutundaki iki altmatrisler, <span class="math inline">\(T\)</span>'de görülen o iki bölge, daha büyük matriste öyle yerleştirildi ki sadece <span class="math inline">\(u_1,v_1\)</span> ve <span class="math inline">\(u_2,v_2\)</span> değişkenlerini etkiliyor, onlara tekabül eden bölgelerde duruyor.</p>
<p>Böylece <span class="math inline">\(T\)</span> matrisini bulmuş olduk. Şimdi <span class="math inline">\(k\)</span> matrisini hesaplamak için <span class="math inline">\(k = T^T k&#39; T\)</span> işlemini yapabiliriz [1, sf. 243].</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> sympy <span class="im">import</span> symbols, latex, simplify
<span class="im">from</span> sympy.matrices <span class="im">import</span> Matrix
<span class="im">import</span> pickle

C,S,C1,C2,L,A,E,I <span class="op">=</span> symbols(<span class="st">&quot;C,S,C1,C2,L,A,E,I&quot;</span>)
kprime <span class="op">=</span> Matrix([ [C1, <span class="dv">0</span>, <span class="dv">0</span>, <span class="op">-</span>C1, <span class="dv">0</span>, <span class="dv">0</span>],
                  [<span class="dv">0</span>, <span class="dv">12</span><span class="op">*</span>C2, <span class="dv">6</span><span class="op">*</span>C2<span class="op">*</span>L, <span class="dv">0</span>, <span class="dv">-12</span><span class="op">*</span>C2, <span class="dv">6</span><span class="op">*</span>C2<span class="op">*</span>L],
                  [<span class="dv">0</span>, <span class="dv">6</span><span class="op">*</span>C2<span class="op">*</span>L, <span class="dv">4</span><span class="op">*</span>C2<span class="op">*</span>L<span class="op">**</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">-6</span><span class="op">*</span>C2<span class="op">*</span>L, <span class="dv">2</span><span class="op">*</span>C2<span class="op">*</span>L<span class="op">**</span><span class="dv">2</span>],
                  [<span class="op">-</span>C1, <span class="dv">0</span>, <span class="dv">0</span>, C1, <span class="dv">0</span>, <span class="dv">0</span>],
                  [<span class="dv">0</span>, <span class="dv">-12</span><span class="op">*</span>C2, <span class="dv">-6</span><span class="op">*</span>C2<span class="op">*</span>L, <span class="dv">0</span>, <span class="dv">12</span><span class="op">*</span>C2, <span class="dv">-6</span><span class="op">*</span>C2<span class="op">*</span>L],
                  [<span class="dv">0</span>, <span class="dv">6</span><span class="op">*</span>C2<span class="op">*</span>L, <span class="dv">2</span><span class="op">*</span>C2<span class="op">*</span>L<span class="op">**</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">-6</span><span class="op">*</span>C2<span class="op">*</span>L, <span class="dv">4</span><span class="op">*</span>C2<span class="op">*</span>L<span class="op">**</span><span class="dv">2</span>]])

T <span class="op">=</span> Matrix([[C,S,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],[<span class="op">-</span>S,C,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],
            [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,C,S,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="op">-</span>S,C,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]])

res <span class="op">=</span> T.transpose()<span class="op">*</span>kprime<span class="op">*</span>T
res <span class="op">=</span> res.subs(C1,A<span class="op">*</span>E<span class="op">/</span>L) 
res <span class="op">=</span> res.subs(C2,E<span class="op">*</span>I<span class="op">/</span>L<span class="op">**</span><span class="dv">3</span>)
pickle.dump(res,<span class="bu">open</span>(<span class="st">&quot;frame.pkl&quot;</span>,<span class="st">&quot;wb&quot;</span>)) <span class="co"># sonra lazim olacak diske kaydet</span>
pickle.dump(kprime,<span class="bu">open</span>(<span class="st">&quot;kprime.pkl&quot;</span>,<span class="st">&quot;wb&quot;</span>))
pickle.dump(T,<span class="bu">open</span>(<span class="st">&quot;T.pkl&quot;</span>,<span class="st">&quot;wb&quot;</span>))
res <span class="op">=</span> res <span class="op">/</span> (E<span class="op">/</span>L) 
<span class="bu">print</span> (latex(simplify(res))[:<span class="dv">70</span>],<span class="st">&#39;...&#39;</span>)</code></pre></div>
<pre><code>\left[\begin{matrix}A C^{2} + \frac{12 I S^{2}}{L^{2}} &amp; \frac{C S \le ...</code></pre>
<p><span class="math display">\[
k = 
\frac{E}{L} \times 
\left[\begin{matrix}A C^{2} + \frac{12 I S^{2}}{L^{2}} &amp; \frac{C S \left(A L^{2} - 12 I\right)}{L^{2}} &amp; - \frac{6 I S}{L} &amp; - A C^{2} - \frac{12 I S^{2}}{L^{2}} &amp; \frac{C S \left(- A L^{2} + 12 I\right)}{L^{2}} &amp; - \frac{6 I S}{L}\\\frac{C S \left(A L^{2} - 12 I\right)}{L^{2}} &amp; A S^{2} + \frac{12 C^{2} I}{L^{2}} &amp; \frac{6 C I}{L} &amp; \frac{C S \left(- A L^{2} + 12 I\right)}{L^{2}} &amp; - A S^{2} - \frac{12 C^{2} I}{L^{2}} &amp; \frac{6 C I}{L}\\- \frac{6 I S}{L} &amp; \frac{6 C I}{L} &amp; 4 I &amp; \frac{6 I S}{L} &amp; - \frac{6 C I}{L} &amp; 2 I\\- A C^{2} - \frac{12 I S^{2}}{L^{2}} &amp; \frac{C S \left(- A L^{2} + 12 I\right)}{L^{2}} &amp; \frac{6 I S}{L} &amp; A C^{2} + \frac{12 I S^{2}}{L^{2}} &amp; \frac{C S \left(A L^{2} - 12 I\right)}{L^{2}} &amp; \frac{6 I S}{L}\\\frac{C S \left(- A L^{2} + 12 I\right)}{L^{2}} &amp; - A S^{2} - \frac{12 C^{2} I}{L^{2}} &amp; - \frac{6 C I}{L} &amp; \frac{C S \left(A L^{2} - 12 I\right)}{L^{2}} &amp; A S^{2} + \frac{12 C^{2} I}{L^{2}} &amp; - \frac{6 C I}{L}\\- \frac{6 I S}{L} &amp; \frac{6 C I}{L} &amp; 2 I &amp; \frac{6 I S}{L} &amp; - \frac{6 C I}{L} &amp; 4 I\end{matrix}\right]
\qquad (3)
\]</span></p>
<p>Bu sonuç [1]'deki sonuca benziyor, cebirsel olarak eşit.</p>
<p><span class="math inline">\(E/L\)</span> bölümünü <code>sympy</code> basitleştirmesi öncesi sistemde dışarıdan uyguladık çünkü cebirsel düzenlemede sisteme yardım etmek istedik, bu sayede sonuç kitaptaki çıktıya benzemiş oldu. Ayrıca cebirsel işlem sonucunu diske kaydettik (3) çıktısı alttaki problemde lazım olacak.</p>
<p>Birden fazla kiriş formülü de üstdüşüm ile birleştirilerek daha büyük bir yapının formülü haline getirilebilir, alttaki soruda bunun nasıl yapılacağını göreceğiz. Elde edilecek sistem / matris düz katı şasi / düz oynamaz çerçeve (rigid plane frame) formülasyonu için kullanılacak, bu sistem &quot;katı bir şekilde birbirine bağlanmış bir grup kiriş parçalarının toplamı'' olarak ta tarif edilebilir, yani kiriş parçalarının birbirine olan açıları, yük uygulandıktan sonra bağlandıklarında ne ise o halde kalırlar, deformasyon sonrası değişime uğramazlar. Ayrıca bu tür bir sistemde moment bir parçadan diğerine, bağlantı noktaları üzerinden transfer olabilir, yani katı bağlantı noktaları üzerinden bir moment sürekliliği vardır.</p>
<p>Soru</p>
<p>İlk katı düzlem çerçeve analizi olarak alttaki basit sistemi çözün.</p>
<div class="figure">
<img src="phy_020_strs_06_03.jpg" />

</div>
<p>Cevap</p>
<p>Sistem düğüm 1 ve 4 üzerinden sabitlenmiş, düğüm 2 üzerinde ve yatay 40 kN kuvvet uygulanıyor, ayrıca düğüm 3'te pozitif moment 500 N-m var. Üstteki resimde global kordinat sisteminin yeri gösteriliyor [1, sf. 244].</p>
<p>Çözüm için her parçayı kiriş matematiği (3) ile formülize edeceğiz, ve bu parçaları üstdüşüm ile biraraya koyacağız, nihai matrisi çözerek yükleri ve yer değişimleri bulacağız.</p>
<p>Parça 1</p>
<p>Hesap yapabilmek için (3)'teki matrise ihtiyaç var, bu matrisin sembolik halini diskten okuyalım, oraya kaydetmiştik,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> sympy <span class="im">import</span> symbols, latex, simplify
<span class="im">from</span> sympy.matrices <span class="im">import</span> Matrix
<span class="im">import</span> pickle, pandas <span class="im">as</span> pd
pd.set_option(<span class="st">&#39;display.max_columns&#39;</span>, <span class="va">None</span>)
pd.set_option(<span class="st">&quot;display.precision&quot;</span>, <span class="dv">4</span>)
C,S,L,A,E,I <span class="op">=</span> symbols(<span class="st">&quot;C,S,L,A,E,I&quot;</span>)
frame <span class="op">=</span> pickle.load(<span class="bu">open</span>(<span class="st">&#39;frame.pkl&#39;</span>,<span class="st">&#39;rb&#39;</span>))</code></pre></div>
<p>Birinci parçanın duruş açısı 90 derece, o zaman <span class="math inline">\(C = \cos 90 = 0\)</span>, <span class="math inline">\(S = \sin 90 = 1\)</span>. Bu değerleri sembolik matrisi sayısal hale çevirmek için kullanacağız, &quot;yoğun (dense) matris'' elde edeceğiz, <code>subs</code> çağrısı ile,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">d <span class="op">=</span> {L:<span class="fl">3000.0</span>, C:<span class="fl">0.0</span>, S:<span class="fl">1.0</span>, E:<span class="fl">200.0</span><span class="op">*</span><span class="fl">1e3</span>, A:<span class="fl">6500.0</span>, I:<span class="fl">80.0</span><span class="op">*</span><span class="fl">1e6</span>}
res <span class="op">=</span> frame.subs(d) <span class="op">/</span> (<span class="fl">1e3</span><span class="op">*</span>d[E]<span class="op">/</span>d[L])
df1 <span class="op">=</span> pd.DataFrame(np.array(res).astype(np.float64))
df1.columns <span class="op">=</span> [<span class="st">&#39;u1&#39;</span>,<span class="st">&#39;v1&#39;</span>,<span class="st">&#39;phi1&#39;</span>,<span class="st">&#39;u2&#39;</span>,<span class="st">&#39;v2&#39;</span>,<span class="st">&#39;phi2&#39;</span>]
df1 <span class="op">=</span> df1.<span class="bu">round</span>(<span class="dv">2</span>)
<span class="bu">print</span> (<span class="st">&#39;66.67*1000 * </span><span class="ch">\n</span><span class="st">&#39;</span>, df1)</code></pre></div>
<pre><code>66.67*1000 * 
        u1   v1      phi1      u2   v2      phi2
0    0.11  0.0    -160.0   -0.11  0.0    -160.0
1    0.00  6.5       0.0    0.00 -6.5       0.0
2 -160.00  0.0  320000.0  160.00  0.0  160000.0
3   -0.11  0.0     160.0    0.11  0.0     160.0
4    0.00 -6.5       0.0    0.00  6.5       0.0
5 -160.00  0.0  160000.0  160.00  0.0  320000.0</code></pre>
<p>Matrisin birimi N/mm.</p>
<p>Parça 2</p>
<p>Bu parçanın duruşu sebebiyle açı sıfır, yani <span class="math inline">\(C=1,S=0\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">d <span class="op">=</span> {L:<span class="fl">3000.0</span>, C:<span class="fl">1.0</span>, S:<span class="fl">0.0</span>, E:<span class="fl">200.0</span><span class="op">*</span><span class="fl">1e3</span>, A:<span class="fl">6500.0</span>, I:<span class="fl">40.0</span><span class="op">*</span><span class="fl">1e6</span>}
res <span class="op">=</span> frame.subs(d) <span class="op">/</span> (<span class="fl">1e3</span><span class="op">*</span>d[E]<span class="op">/</span>d[L])
df2 <span class="op">=</span> pd.DataFrame(np.array(res).astype(np.float64))
df2.columns <span class="op">=</span> [<span class="st">&#39;u2&#39;</span>,<span class="st">&#39;v2&#39;</span>,<span class="st">&#39;phi2&#39;</span>,<span class="st">&#39;u3&#39;</span>,<span class="st">&#39;v3&#39;</span>,<span class="st">&#39;phi3&#39;</span>]
<span class="bu">print</span> (<span class="st">&#39;66.67*1000 * </span><span class="ch">\n</span><span class="st">&#39;</span>, df2)</code></pre></div>
<pre><code>66.67*1000 * 
     u2       v2      phi2   u3       v3      phi3
0  6.5   0.0000       0.0 -6.5   0.0000       0.0
1  0.0   0.0533      80.0  0.0  -0.0533      80.0
2  0.0  80.0000  160000.0  0.0 -80.0000   80000.0
3 -6.5   0.0000       0.0  6.5   0.0000       0.0
4  0.0  -0.0533     -80.0  0.0   0.0533     -80.0
5  0.0  80.0000   80000.0  0.0 -80.0000  160000.0</code></pre>
<p>Parça 3</p>
<p>Açı 270 derece, demek ki <span class="math inline">\(C=0,S=-1\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">d <span class="op">=</span> {L:<span class="fl">3000.0</span>, C:<span class="fl">0.0</span>, S:<span class="op">-</span><span class="dv">1</span>, E:<span class="fl">200.0</span><span class="op">*</span><span class="fl">1e3</span>, A:<span class="fl">6500.0</span>, I:<span class="fl">80.0</span><span class="op">*</span><span class="fl">1e6</span>}
res <span class="op">=</span> frame.subs(d) <span class="op">/</span> (<span class="fl">1e3</span><span class="op">*</span>d[E]<span class="op">/</span>d[L])
df3 <span class="op">=</span> pd.DataFrame(np.array(res).astype(np.float64))
df3.columns <span class="op">=</span> [<span class="st">&#39;u3&#39;</span>,<span class="st">&#39;v3&#39;</span>,<span class="st">&#39;phi3&#39;</span>,<span class="st">&#39;u4&#39;</span>,<span class="st">&#39;v4&#39;</span>,<span class="st">&#39;phi4&#39;</span>]
<span class="bu">print</span> (<span class="st">&#39;66.67*1000 * </span><span class="ch">\n</span><span class="st">&#39;</span>, df3)</code></pre></div>
<pre><code>66.67*1000 * 
          u3   v3      phi3        u4   v4      phi4
0    0.1067  0.0     160.0   -0.1067  0.0     160.0
1    0.0000  6.5       0.0    0.0000 -6.5       0.0
2  160.0000  0.0  320000.0 -160.0000  0.0  160000.0
3   -0.1067  0.0    -160.0    0.1067  0.0    -160.0
4    0.0000 -6.5       0.0    0.0000  6.5       0.0
5  160.0000  0.0  160000.0 -160.0000  0.0  320000.0</code></pre>
<p>Üstteki üç matris birleştirilip, üstdüşüm üzerinden daha büyük bir matris haline getirilecek. Üstdüşüm yapılabilmesi için her matrisin aynı boyutta, aynı kolonlara sahip olması gerekir. Bir matrisi (ya da Dataframe) alıp yeni değişkenlere &quot;büyüten'' bir kod parçası lazım.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pandas <span class="im">as</span> pd, inspect
pd.set_option(<span class="st">&#39;display.max_columns&#39;</span>, <span class="va">None</span>)

<span class="kw">def</span> expand_dataframe(df, new_cols):

    res <span class="op">=</span> df.copy()
    old_cols <span class="op">=</span> <span class="bu">list</span>(df.columns)
    addn_vars <span class="op">=</span> [x <span class="cf">for</span> x <span class="kw">in</span> new_cols <span class="cf">if</span> x <span class="kw">not</span> <span class="kw">in</span> old_cols]
    res.index <span class="op">=</span> df.columns
    <span class="cf">for</span> x <span class="kw">in</span> addn_vars:
        res[x] <span class="op">=</span> np.nan
        res.loc[x] <span class="op">=</span> pd.Series(res.columns)
    res <span class="op">=</span> res[new_cols]
    res <span class="op">=</span> res.reindex(new_cols).fillna(<span class="dv">0</span>)
    <span class="cf">return</span> res

df <span class="op">=</span> pd.DataFrame([[<span class="st">&#39;a&#39;</span>,<span class="st">&#39;c&#39;</span>],[<span class="st">&#39;b&#39;</span>,<span class="st">&#39;d&#39;</span>]],columns <span class="op">=</span> [<span class="st">&#39;u1&#39;</span>,<span class="st">&#39;u3&#39;</span>])
<span class="bu">print</span> (df)
res <span class="op">=</span> expand_dataframe(df,[<span class="st">&#39;u1&#39;</span>,<span class="st">&#39;u2&#39;</span>,<span class="st">&#39;u3&#39;</span>,<span class="st">&#39;u4&#39;</span>])
<span class="bu">print</span> (res)</code></pre></div>
<pre><code>  u1 u3
0  a  c
1  b  d
   u1   u2 u3   u4
u1  a  0.0  c  0.0
u2  0  0.0  0  0.0
u3  b  0.0  d  0.0
u4  0  0.0  0  0.0</code></pre>
<p>Üstteki kod parçası bunu yapabiliyor, örnek verideki ilk <code>u1</code>, <code>u3</code> kolon listesini <code>u1</code>, <code>u2</code>, <code>u3</code>, <code>u4</code> listesine büyüttük, ve kod gerekli yerlere gerekli sıfır değerlerini yazdı ve eski matrisin değerlerini büyütülmüş yeni matriste uygun yerlere taşıdı.</p>
<p>Nihai matristen değişken çıkartmak ta lazım olabiliyor, sınır şartları bunu gerektiriyor olabilir. mesela <code>u1=0</code> için bu değişkene tekabül eden hem kolon hem satır çıkartılmalı,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">res2 <span class="op">=</span> res.copy()
res2 <span class="op">=</span> res2.drop(<span class="st">&#39;u1&#39;</span>,axis<span class="op">=</span><span class="dv">1</span>)
res2 <span class="op">=</span> res2.drop(<span class="st">&#39;u1&#39;</span>,axis<span class="op">=</span><span class="dv">0</span>)
<span class="bu">print</span> (res2)</code></pre></div>
<pre><code>     u2 u3   u4
u2  0.0  0  0.0
u3  0.0  d  0.0
u4  0.0  0  0.0</code></pre>
<p>Verilen bir kolon ve satırların listesini çıkartmak için de bir fonksiyon yazalım,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> drop_col_row(df, var_list):
    res <span class="op">=</span> df.copy()
    <span class="cf">for</span> x <span class="kw">in</span> var_list:
        res <span class="op">=</span> res.drop(x,axis<span class="op">=</span><span class="dv">1</span>)
        res <span class="op">=</span> res.drop(x,axis<span class="op">=</span><span class="dv">0</span>)
    <span class="cf">return</span> res</code></pre></div>
<p>Son hesap aşamasına geldik. Üstdüşüm yapalım, ve <span class="math inline">\(u_1 = v_1 = \phi_1 = 0\)</span>, <span class="math inline">\(u_4 = v_4 = \phi_4 = 0\)</span> şartlarını uygulayalım,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">all_vars <span class="op">=</span> [<span class="st">&#39;u1&#39;</span>,<span class="st">&#39;v1&#39;</span>,<span class="st">&#39;phi1&#39;</span>,<span class="st">&#39;u2&#39;</span>,<span class="st">&#39;v2&#39;</span>,<span class="st">&#39;phi2&#39;</span>,<span class="st">&#39;u3&#39;</span>,<span class="st">&#39;v3&#39;</span>,<span class="st">&#39;phi3&#39;</span>,<span class="st">&#39;u4&#39;</span>,<span class="st">&#39;v4&#39;</span>,<span class="st">&#39;phi4&#39;</span>]
df1f <span class="op">=</span> expand_dataframe(df1,all_vars)
df2f <span class="op">=</span> expand_dataframe(df2,all_vars)
df3f <span class="op">=</span> expand_dataframe(df3,all_vars)
df_super <span class="op">=</span> df1f <span class="op">+</span> df2f <span class="op">+</span> df3f

df_super <span class="op">=</span> drop_col_row(df_super, [<span class="st">&#39;u1&#39;</span>,<span class="st">&#39;v1&#39;</span>,<span class="st">&#39;phi1&#39;</span>,<span class="st">&#39;u4&#39;</span>,<span class="st">&#39;v4&#39;</span>,<span class="st">&#39;phi4&#39;</span>])
<span class="bu">print</span> (df_super)</code></pre></div>
<pre><code>          u2       v2      phi2        u3       v3      phi3
u2      6.61   0.0000     160.0   -6.5000   0.0000       0.0
v2      0.00   6.5533      80.0    0.0000  -0.0533      80.0
phi2  160.00  80.0000  480000.0    0.0000 -80.0000   80000.0
u3     -6.50   0.0000       0.0    6.6067   0.0000     160.0
v3      0.00  -0.0533     -80.0    0.0000   6.5533     -80.0
phi3    0.00  80.0000   80000.0  160.0000 -80.0000  480000.0</code></pre>
<p>Bu matrisi bir <span class="math inline">\(Ax = b\)</span> lineer sistemini çözmek için kullanacağız. Üstteki matris <span class="math inline">\(A\)</span> olacak, <span class="math inline">\(b\)</span> ise kuvvet ve momentleri taşıyan bir vektör, sınır şartlarının çıkarttığı değerler sonrası kalan değişkenler,</p>
<p><span class="math display">\[
\left[\begin{array}{c}
f_{2x} \\ f_{2y} \\ m_{2} \\ f_{3x} \\ f_{3y} \\ m_{3} 
\end{array}\right] =
\left[\begin{array}{c}
4 \times 10^4 \\ 0 \\ 0 \\ 0 \\ 0 \\ 5 \times 10^5
\end{array}\right]
\]</span></p>
<p>Çözeceğimiz sistem</p>
<p><span class="math display">\[
\left[\begin{array}{c}
4 \times 10^4 \\ 0 \\ 0 \\ 0 \\ 0 \\ 5 \times 10^5
\end{array}\right]
=
66.67 \times 10^3
\left[\begin{array}{cccccc}
  6.61 &amp;  0 &amp;     160 &amp;   -6.5 &amp;   0   &amp;    0 \\
  0    &amp; 6.5533 &amp;  80.0 &amp;    0 &amp;  -0.0533 &amp;   80.0 \\
160 &amp;  80 &amp;  480000 &amp;    0 &amp; -80 &amp;   80000 \\
 -6.50 &amp;   0 &amp;       0 &amp;    6.6067 &amp;   0 &amp;     160.0 \\
  0 &amp;  -0.0533 &amp;     -80.0 &amp;    0 &amp;   6.5533 &amp;     -80.0 \\
  0 &amp;  80 &amp;.   80000 &amp;  160 &amp; -80 &amp;  480000 
\end{array}\right]
\left[\begin{array}{c}
u_2 \\ v_2 \\ \phi_2 \\ u_3 \\ v_3 \\ \phi_3
\end{array}\right]
\]</span></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy.linalg <span class="im">as</span> lin

b <span class="op">=</span> np.array([<span class="dv">4</span><span class="op">*</span><span class="fl">1e4</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">5</span><span class="op">*</span><span class="fl">1e5</span>])

x <span class="op">=</span> lin.solve(<span class="fl">66.67</span><span class="op">*</span><span class="fl">1e3</span><span class="op">*</span>df_super, b)

pd.DataFrame(x,index<span class="op">=</span>df_super.columns)</code></pre></div>
<pre><code>Out[1]: 
           0
u2    4.8197
v2    0.0333
phi2 -0.0014
u3    4.7747
v3   -0.0333
phi3 -0.0014</code></pre>
<p>Birimler yer değişimleri için mm, açılar için radyan. Sonuçlara göre düğüm 2 ve 3 noktalarında şasi bir miktar sağa doğru gidiyor, ve dikey yer değişim ve dönüş yok denecek kadar az.</p>
<p>Her Parçaya Etki Eden Yerel Kuvvetler</p>
<p>Bir kez tüm sistem bazında yer değişimlerini hesapladıktan sonra bunları kullanarak her ögeye etki eden kuvvetleri bulabiliriz, <span class="math inline">\(f&#39; = k&#39; T d\)</span> gerekli. Daha önce (4)'te gösterilen <span class="math inline">\(k&#39;\)</span> ve (5)'te gösterilen <span class="math inline">\(T\)</span> matrislerini sembolik olarak kaydetmiştik, onları geri okuyup birinci öğe için değerleri geçelim [1, sf. 247],</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pickle, pandas <span class="im">as</span> pd
<span class="im">from</span> sympy <span class="im">import</span> symbols
pd.set_option(<span class="st">&quot;display.precision&quot;</span>, <span class="dv">4</span>)
pd.set_option(<span class="st">&#39;display.max_columns&#39;</span>, <span class="va">None</span>)

kprime <span class="op">=</span> pickle.load(<span class="bu">open</span>(<span class="st">&#39;kprime.pkl&#39;</span>,<span class="st">&#39;rb&#39;</span>))
T <span class="op">=</span> pickle.load(<span class="bu">open</span>(<span class="st">&#39;T.pkl&#39;</span>,<span class="st">&#39;rb&#39;</span>))
C,S,C1,C2,L,A,E,I <span class="op">=</span> symbols(<span class="st">&quot;C,S,C1,C2,L,A,E,I&quot;</span>)
d <span class="op">=</span> {L:<span class="fl">3000.0</span>, C:<span class="fl">0.0</span>, S:<span class="fl">1.0</span>, E:<span class="fl">200.0</span><span class="op">*</span><span class="fl">1e3</span>, A:<span class="fl">6500.0</span>, I:<span class="fl">80.0</span><span class="op">*</span><span class="fl">1e6</span>}
kprime <span class="op">=</span> kprime.subs(C1,A<span class="op">*</span>E<span class="op">/</span>L) 
kprime <span class="op">=</span> kprime.subs(C2,E<span class="op">*</span>I<span class="op">/</span>L<span class="op">**</span><span class="dv">3</span>)
kprime <span class="op">=</span> kprime.subs(d) 
kprime <span class="op">=</span> pd.DataFrame(np.array(kprime),dtype<span class="op">=</span>np.float64)  <span class="op">/</span> (<span class="fl">66.67</span><span class="op">*</span><span class="fl">1e3</span>)
<span class="bu">print</span> (kprime)

T <span class="op">=</span> T.subs(C,<span class="dv">0</span>)
T <span class="op">=</span> T.subs(S,<span class="dv">1</span>)
T <span class="op">=</span> pd.DataFrame(np.array(T),dtype<span class="op">=</span>np.float64)
<span class="bu">print</span> (T)</code></pre></div>
<pre><code>      0      1         2     3       4         5
0  6.50   0.00      0.00 -6.50    0.00      0.00
1  0.00   0.11    159.99  0.00   -0.11    159.99
2  0.00 159.99 319984.00  0.00 -159.99 159992.00
3 -6.50   0.00      0.00  6.50    0.00      0.00
4  0.00  -0.11   -159.99  0.00    0.11   -159.99
5  0.00 159.99 159992.00  0.00 -159.99 319984.00
      0    1    2     3    4    5
0  0.00 1.00 0.00  0.00 0.00 0.00
1 -1.00 0.00 0.00  0.00 0.00 0.00
2  0.00 0.00 1.00  0.00 0.00 0.00
3  0.00 0.00 0.00  0.00 1.00 0.00
4  0.00 0.00 0.00 -1.00 0.00 0.00
5  0.00 0.00 0.00  0.00 0.00 1.00</code></pre>
<p>Birinci öğe için geçerli olan yer değişimler</p>
<p><span class="math display">\[
d = \left[\begin{array}{c}
u_1 = 0 \\ v_1 = 0 \\ \phi_1 = 0 \\ u_2 = 5.007 \\ v_2 = 0.0345 \\ \phi_2 = -0.00144
\end{array}\right]
\]</span></p>
<p>Artık <span class="math inline">\(f&#39; = k&#39; T d\)</span> hesaplanabilir,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">d <span class="op">=</span> np.array([[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="fl">5.007</span>,<span class="fl">0.0345</span>,<span class="op">-</span><span class="fl">0.00144</span>]]).T
fprime <span class="op">=</span> <span class="fl">66.67</span><span class="op">*</span><span class="fl">1e3</span> <span class="op">*</span> np.dot(kprime,T).dot(d)
fprime <span class="op">=</span> pd.DataFrame(fprime)
fprime.index <span class="op">=</span> [<span class="st">&#39;fprime1x&#39;</span>,<span class="st">&#39;fprime1y&#39;</span>,<span class="st">&#39;mprime1&#39;</span>,<span class="st">&#39;fprime2x&#39;</span>,<span class="st">&#39;fprime2y&#39;</span>,<span class="st">&#39;mprime2&#39;</span>]
<span class="bu">print</span> (fprime)</code></pre></div>
<pre><code>                   0
fprime1x   -14950.00
fprime1y    20245.33
mprime1  38048000.00
fprime2x    14950.00
fprime2y   -20245.33
mprime2  22688000.00</code></pre>
<p>Birimler kuvvetler için Newton, momentler için Newton-mm.</p>
<p>Diğer ögeler için benzer hesap yapılabilir.</p>
<p>Seyrek Matris Kodlaması</p>
<p>Bir kodlama detayından bahsedelim, gerçek dünya uygulamalarında performans için seyrek matris teknikleri kullanmak daha iyidir, bu yazı demo amaçlı bir yöntem seçti, fakat seyrek seçenek ile mesela matrisler sözlük ile temsil edilebilir, olan değerlerin anahtarı vardır, diğerleri dolaylı olarak yok sayılır. Üstdüşüm yaparken birbirine uyan anahtarların değerleri toplanır, diğerleri yine boş kalır, bu değerler sıfırdır. <span class="math inline">\(Ax=b\)</span> çözerken her satırda mevcut anahtarların değerleri JSON olarak ayrı sözlükler olarak alınabilir ve bu satırlar artımsal (incremental) çözüm yapabilen bir eşlenik gradyan [2,3] koduna satır satır geçilebilir.</p>
<p>Diske Kayıt</p>
<p>Alttakiler biraz önce yazdığımız fonksiyonları diğer kodların kullanabilmesi için onları dinamik olarak hafızadan alıp diske yazıyor.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">fout <span class="op">=</span> <span class="bu">open</span>(<span class="st">&#39;dfutil.py&#39;</span>,<span class="st">&#39;w&#39;</span>)
fout.write(<span class="st">&#39;import pandas as pd, numpy as np</span><span class="ch">\n</span><span class="st">&#39;</span>)
code <span class="op">=</span> inspect.getsourcelines(expand_dataframe)
<span class="cf">for</span> line <span class="kw">in</span> code[<span class="dv">0</span>]: fout.write(line)
code <span class="op">=</span> inspect.getsourcelines(drop_col_row)
<span class="cf">for</span> line <span class="kw">in</span> code[<span class="dv">0</span>]: fout.write(line)
fout.close()</code></pre></div>
<p>Doğrulama</p>
<p>(4)'ün <code>sympy</code> ile doğrulaması</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> sympy <span class="im">import</span> symbols, pprint, latex
<span class="im">from</span> sympy.matrices <span class="im">import</span> Matrix
<span class="im">import</span> pandas <span class="im">as</span> pd
pd.set_option(<span class="st">&#39;display.max_columns&#39;</span>, <span class="va">None</span>)

A,E,L,I,u1,u2,v1,v2,phi1,phi2 <span class="op">=</span> symbols(<span class="st">&quot;A,E,L,I,u1,u2,v1,v2,phi1,phi2&quot;</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">vars1 <span class="op">=</span> [<span class="st">&#39;u1&#39;</span>,<span class="st">&#39;u2&#39;</span>]
M1 <span class="op">=</span> pd.DataFrame([[<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>],[<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>]],index<span class="op">=</span>vars1)
M1 <span class="op">=</span> (A<span class="op">*</span>E<span class="op">/</span>L)<span class="op">*</span>M1
M1.columns <span class="op">=</span> vars1
<span class="bu">print</span> (M1)</code></pre></div>
<pre><code>        u1      u2
u1   A*E/L  -A*E/L
u2  -A*E/L   A*E/L</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">vars2 <span class="op">=</span> [<span class="st">&#39;v1&#39;</span>,<span class="st">&#39;phi1&#39;</span>,<span class="st">&#39;v2&#39;</span>,<span class="st">&#39;phi2&#39;</span>]
M2 <span class="op">=</span> pd.DataFrame([[<span class="dv">12</span>, <span class="dv">6</span><span class="op">*</span>L,<span class="op">-</span><span class="dv">12</span>,<span class="dv">6</span><span class="op">*</span>L],
                  [<span class="dv">6</span><span class="op">*</span>L,<span class="dv">4</span><span class="op">*</span>L<span class="op">**</span><span class="dv">2</span>,<span class="op">-</span><span class="dv">6</span><span class="op">*</span>L,<span class="dv">2</span><span class="op">*</span>L<span class="op">**</span><span class="dv">2</span>],
                  [<span class="op">-</span><span class="dv">12</span>,<span class="op">-</span><span class="dv">6</span><span class="op">*</span>L,<span class="dv">12</span>,<span class="op">-</span><span class="dv">6</span><span class="op">*</span>L],
                  [<span class="dv">6</span><span class="op">*</span>L,<span class="dv">2</span><span class="op">*</span>L<span class="op">**</span><span class="dv">2</span>,<span class="op">-</span><span class="dv">6</span><span class="op">*</span>L,<span class="dv">4</span><span class="op">*</span>L<span class="op">**</span><span class="dv">2</span>]],index<span class="op">=</span>vars2)
M2 <span class="op">=</span> (E<span class="op">*</span>I<span class="op">/</span>L<span class="op">**</span><span class="dv">3</span>)<span class="op">*</span>M2
M2.columns <span class="op">=</span> vars2
<span class="bu">print</span> (M2)</code></pre></div>
<pre><code>                v1         phi1            v2         phi2
v1     12*E*I/L**3   6*E*I/L**2  -12*E*I/L**3   6*E*I/L**2
phi1    6*E*I/L**2      4*E*I/L   -6*E*I/L**2      2*E*I/L
v2    -12*E*I/L**3  -6*E*I/L**2   12*E*I/L**3  -6*E*I/L**2
phi2    6*E*I/L**2      2*E*I/L   -6*E*I/L**2      4*E*I/L</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> dfutil

all_vars <span class="op">=</span> [<span class="st">&#39;u1&#39;</span>,<span class="st">&#39;v1&#39;</span>,<span class="st">&#39;phi1&#39;</span>,<span class="st">&#39;u2&#39;</span>,<span class="st">&#39;v2&#39;</span>,<span class="st">&#39;phi2&#39;</span>]
M1f <span class="op">=</span> dfutil.expand_dataframe(M1,all_vars)
M2f <span class="op">=</span> dfutil.expand_dataframe(M2,all_vars)
Mall <span class="op">=</span> M1f <span class="op">+</span> M2f
<span class="bu">print</span> (Mall)</code></pre></div>
<pre><code>          u1            v1         phi1      u2            v2         phi2
u1     A*E/L             0            0  -A*E/L             0            0
v1         0   12*E*I/L**3   6*E*I/L**2       0  -12*E*I/L**3   6*E*I/L**2
phi1       0    6*E*I/L**2      4*E*I/L       0   -6*E*I/L**2      2*E*I/L
u2    -A*E/L             0            0   A*E/L             0            0
v2         0  -12*E*I/L**3  -6*E*I/L**2       0   12*E*I/L**3  -6*E*I/L**2
phi2       0    6*E*I/L**2      2*E*I/L       0   -6*E*I/L**2      4*E*I/L</code></pre>
<p>Aynı sonuca eriştik.</p>
<p>Kaynaklar</p>
<p>[1] Logan, <em>A First Course in the Finite Element Method, 6th Ed</em></p>
<p>[2] Bayramlı, <em>Hesapsal Bilim, Ders 2-19</em></p>
<p>[3] Bayramlı, <em>Üstdüşümlü Matris Sistemini Çözmek</em> <a href="https://burakbayramli.github.io/dersblog/sk/2024/01/beam_lattice_superposition_cg_sparse.html" class="uri">https://burakbayramli.github.io/dersblog/sk/2024/01/beam_lattice_superposition_cg_sparse.html</a></p>
</body>
</html>
