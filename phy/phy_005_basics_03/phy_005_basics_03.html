<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Temel Fizik 3, Parçacıklar, Çarpışma, Hareket</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="temel-fizik-3-parçacıklar-çarpışma-hareket">Temel Fizik 3, Parçacıklar, Çarpışma, Hareket</h1>
<p>Elastik Çarpışma (Elastic Collision)</p>
<p><span class="math inline">\(m_1,m_2\)</span> kütlesine sahip <span class="math inline">\(v_1,v_2\)</span> hızında iki küre arasında mükemmel bir elastik çarpışma olduğunu düşünelim, yani çarpışma öncesi ve sonrası enerji kaybı yok, bu durumda, sistemin toplam momentumu da önce ve sonra aynı olacaktır,</p>
<p><span class="math display">\[
m_1 \vec{v}_1 + m_2 \vec{v}_2 = m_1 \vec{v}_1&#39; + m_2 \vec{v}_2&#39; 
\]</span></p>
<p>ki <span class="math inline">\(\vec{v}_1,\vec{v}_2,\vec{v}_1&#39;,\vec{v}_2&#39;\)</span> hız vektörleri, <span class="math inline">\(\vec{v}_1&#39;,\vec{v}_2&#39;\)</span> çarpışma sonrası hız vektörleri.</p>
<div class="figure">
<img src="phy_005_basics_06.png" />

</div>
<p>Eğer momentum muhafaza ediliyorsa, birinci topun kaybettiği ya da kazandığı momentum ikinci topa eklenecek ya da ondan çıkartılacaktır.</p>
<p><span class="math display">\[
m_1 \vec{v}_1 = m_1 \vec{v}_1&#39; - \Delta \vec{p}
\]</span></p>
<p><span class="math display">\[
m_2 \vec{v}_2 = m_2 \vec{v}_2&#39; + \Delta \vec{p}
\]</span></p>
<p>Üstteki idealize ortamda momentum transferi sadece çarpışma çizgisi üzerinde olabilir, bu çizgi, ya da vektör yönü eğer iki topun arasında teğet bir düzlem düşünsek ona dik olan bir vektör olacaktır, ona <span class="math inline">\(n\)</span> diyelim. O zaman, ve <span class="math inline">\(p\)</span> vektörünün büyüklüğünü <span class="math inline">\(P\)</span> ile gösterirsek,</p>
<p><span class="math display">\[
\vec{v}_1&#39; = \vec{v}_1 - (P / m_1) \vec{n}
\qquad (1)
\]</span></p>
<p><span class="math display">\[
\vec{v}_2&#39; = \vec{v}_2 + (P / m_2) \vec{n}
\qquad (2)
\]</span></p>
<p>Eğer <span class="math inline">\(P\)</span> skalar büyüklüğünü bulabilirsek, çarpışma sonrası yeni hızı elde edebiliriz.</p>
<p>Üstteki resme bakınca görüyoruz ki <span class="math inline">\(v_1\)</span> ve <span class="math inline">\(v_2\)</span> her biri iki tane ayrı vektörün toplamı olarak temsil edilebilir, bu vektörlerden biri çarpışma, momentum transfer çizgisine dik, diğeri ona paralel. Bu bilgi ile, <span class="math inline">\(v_1,v_1&#39;,v_2,v_2&#39;\)</span> şöyle temsil edilebilir,</p>
<p><span class="math display">\[
\vec{v}_1 = a_1 \vec{n} + b_1 \vec{q}, \qquad \vec{v}_2 = a_2 \vec{n} + b_2 \vec{q}
\qquad (3)
\]</span></p>
<p><span class="math display">\[
\vec{v}_1&#39; = a_1&#39; \vec{n} + b_1&#39; \vec{q}, \qquad v_2&#39; = a_2&#39; \vec{n} + b_2&#39; \vec{q}
\qquad (4)
\]</span></p>
<p><span class="math inline">\(a_1,a_2,b_1,b_2\)</span> tek sayı değerleridir.</p>
<ol style="list-style-type: decimal">
<li>formülüne (3a)'yı sokarsak,</li>
</ol>
<p><span class="math display">\[
v_1&#39; = a_1 \vec{n} + b_1 \vec{q} - (P/m_1) \vec{n}
\]</span></p>
<p><span class="math display">\[
 = (a_1 - p/m_1) \vec{n} + b_1 \vec{q}
\]</span></p>
<p><span class="math display">\[
v_2&#39; = a_2 \vec{n} + b_2 \vec{q} + (P/m_2) \vec{n}
\]</span></p>
<p><span class="math display">\[
= (a_2 + P/m_2) \vec{n} + b_2 \vec{q}
\]</span></p>
<p>Ve tabii ki form olarak <span class="math inline">\(\vec{v}_1&#39; = a_1&#39; \vec{n} + b_1&#39; \vec{q}\)</span>, ve <span class="math inline">\(\vec{v}_2&#39; = a_2&#39; \vec{n} + b_2&#39; \vec{q}\)</span> olduğunu biliyoruz, o zaman birbirine tekabül eden kısımlara bakarak</p>
<p><span class="math display">\[
a_1&#39; = a_1 - (P/m_1), \qquad b_1&#39; = b_1
\qquad (5)
\]</span></p>
<p><span class="math display">\[
a_2&#39; = a_2 + (P/m_2), \qquad b_2&#39; = b_2
\qquad (6)
\]</span></p>
<p>Şimdi <span class="math inline">\(P\)</span> tek sayı değerini bulmak için enerji muhafazası formülünü kullanabiliriz. Tek boyutta <span class="math inline">\(1/2 m v^2\)</span> şeklinde olan formülü <span class="math inline">\(\frac{1}{2} m \cdot \vec{v}\cdot\vec{v}\)</span> olarak değiştirmek lazım. Ya da <span class="math inline">\(\frac{1}{2} m &lt;\vec{v},\vec{v}&gt;\)</span>, ya da <span class="math inline">\(\frac{1}{2} m ||v||^2\)</span>. O zaman</p>
<p><span class="math display">\[
\frac{m_1}{2} ||v_1||^2 + \frac{m_2}{2} ||v_2||^2  =
\frac{m_1}{2} ||v_1&#39;||^2 + \frac{m_2}{2} ||v_2&#39;||^2 
\]</span></p>
<p><span class="math inline">\(||v_1||^2\)</span> ve <span class="math inline">\(||v_1&#39;||^2\)</span>, vs hesabının kolay bir yolu var, eğer üstteki resme bakarsak mesela <span class="math inline">\(||v_1||\)</span> büyüklüğü kenarları <span class="math inline">\(a_1\)</span> ve <span class="math inline">\(b_1\)</span> olan bir üçgenin hipotenüsü olarak görülebilir.</p>
<p><span class="math display">\[
\frac{m_1}{2} (a_1^2+b_1^2) + \frac{m_2}{2} (a_2^2+b_2^2) =
\frac{m_1}{2} (a_1&#39;^2+b_1&#39;^2) + \frac{m_2}{2} (a_2&#39;^2+b_2&#39;^2) 
\]</span></p>
<p>Daha önce bulduğumuz (5),(6) değerlerini üstteki formüle sokunca,</p>
<p><span class="math display">\[
\frac{m_1}{2} (a_1^2+b_1^2) + \frac{m_2}{2} (a_2^2+b_2^2) =
\frac{m_1}{2} \left( \left(a_1-\frac{P}{m_1} \right)^2 + b_1^2 \right)  +
\frac{m_2}{2} \left( \left(a_2-\frac{P}{m_1} \right)^2 + b_2^2 \right) 
\]</span></p>
<p><span class="math inline">\(b_1^2\)</span> ve <span class="math inline">\(b_2^2\)</span> iptal olur. Her şeyi <span class="math inline">\(P\)</span> sol tarafta olacak şekilde tekrar düzenlersek,</p>
<p><span class="math display">\[
P = \frac{2 m_1 m_2 (a_1-a_2)}{m_1+m_2}
\]</span></p>
<p>Bu degeri (1) ve (2)'ye sokarsak,</p>
<p><span class="math display">\[
\vec{v}_1&#39; = \vec{v}_1 - \frac{2 m_2 (a_1-a_2)}{m_1+m_2} \vec{n}
\]</span></p>
<p><span class="math display">\[
\vec{v}_2&#39; = \vec{v}_2 + \frac{2 m_1 (a_1-a_2)}{m_1+m_2} \vec{n}
\]</span></p>
<p>Üstteki formülü değişik kaynaklarda, mesela [3], biraz farklı formda görüyoruz, mesela</p>
<p><span class="math display">\[
\vec{v}_1&#39; =
\vec{v}_1 - \frac{2m_2}{m_1+m_2}
\frac{&lt; \vec{v}_1-\vec{v}_2, \vec{x}_1-\vec{x}_2 &gt;}{||\vec{x}_1-\vec{x}_2||^2}
(\vec{x}_1-\vec{x}_2)
\]</span></p>
<p><span class="math display">\[
\vec{v}_2&#39; =
\vec{v}_2 - \frac{2m_1}{m_1+m_2}
\frac{&lt; \vec{v}_2-\vec{v}_1, \vec{x}_2-\vec{x}_1 &gt;}{||\vec{x}_2-\vec{x}_1||^2}
(\vec{x}_1-\vec{x}_2)
\]</span></p>
<p>Fakat biraz dikkat edilince mesela <span class="math inline">\(a_1-a_2\)</span>'nin <span class="math inline">\(\vec{n}\)</span> yönündeki hız farkı olduğunu görürüz, yani</p>
<p><span class="math display">\[
a_1-a_2=\frac{&lt; \vec{v}_1-\vec{v}_2,\vec{x}_1-\vec{x}_2 &gt;}{||\vec{x}_1-\vec{x}_2||}
\]</span></p>
<p>Geri kalanlardan zaten <span class="math inline">\(\vec{n} = \vec{x}_1-\vec{x}_2/||\vec{x}_1-\vec{x}_2||\)</span> ve <span class="math inline">\(m_1,m_2\)</span> değerleri de aynı şekilde iki tarafta uyar.</p>
<p>İki kütlenin eşit olduğu durumlarda (ki moleküler simülasyonlarda bu çok rahat kabul edilebilir), formül daha da basitleşir [4],</p>
<p><span class="math display">\[
v_1&#39; = v_1 - \left( (v_1-v_2)  \cdot \vec{n} \right) \vec{n}
\]</span></p>
<p><span class="math display">\[
v_2&#39; = v_2 - \left( (v_2-v_1)  \cdot \vec{n} \right) \vec{n}
\]</span></p>
<p>ki <span class="math inline">\(\vec{n} = \frac{x_1-x_2}{|x_1-x_2|}\)</span></p>
<p>Basınç (Pressure) ve Parçacık Çarpışması</p>
<p>Bir sıvı içinde duran bir objeye tek uygulanan etki, stres onu sıkıştıran türden bir etkidir. Diğer bir deyişle bir sıvı içindeki objenin hissettiği kuvvet onun yüzeyine her zaman diktir.</p>
<div class="figure">
<img src="phy_005_basics_07.png" />

</div>
<p>Bir sıvının içindeki objeye uyguladığı basıncı, o objeye uygulanan birim alanda uygulanan kuvvet olarak temsil edilebiliriz, kuvvet <span class="math inline">\(F\)</span> ve alan <span class="math inline">\(A\)</span> ise,</p>
<p><span class="math display">\[
P \equiv \frac{F}{A}
\]</span></p>
<p>Eğer belli bir noktadan bahsetmek istersek, diyelim <span class="math inline">\(dA\)</span> sonsuz ufaklıktaki bir alana uygulanan <span class="math inline">\(dF\)</span> kuvveti,</p>
<p><span class="math display">\[
P = \frac{dF}{dA}
\]</span></p>
<p>O zaman belli bir alandaki basınç için o alan üzerinden entegral almak gerekir.</p>
<p>Basıncın birimi <span class="math inline">\(N / m^2\)</span>, şaşırtıcı olmasa gerek, kuvvet birimi Newton, ve alan birimi <span class="math inline">\(m^2\)</span>.</p>
<p>Simulasyon</p>
<p>Önce basit bir simülasyon kodlayalım. Bazı toplar var, onları başta bir kuvvetle rasgele yönlere iteceğiz ve ne yapacaklarına bakacağız. Fiziksel parametreler şöyle, yerçekimi sabiti <span class="math inline">\(g = 0.8\)</span> (dünyadan daha az), topların birbirine ya da duvara çarpması sonucu hiç enerji kaybı olmuyor.</p>
<p>Bu tür bir sistemin konumu, o anki hali her parçacık için bazı değişkenlerin takip edilmesiyle olacak, bu değişkenler pozisyon, hız, kuvvet. Kütle her parçacık için aynı olacak.</p>
<p>Parçacık hareketi o parçacık üzerinde uygulanan kuvvet ile belirlenir, Newton denklemi <span class="math inline">\(m \bar{a} = \bar{f}\)</span>, ki ivme ve kuvvet çok boyutlu dikkat edelim, o sebeple vektör notasyonu olarak üstte çizgi kullandık. Peki ivmeden, hiza ve yer değişikliğine nasıl gideriz? Newton formülünü bir ODE olarak tekrar düzenlersek onu ileri doğru entegre edebiliriz. Yer <span class="math inline">\(\bar{x}\)</span>, hız <span class="math inline">\(\bar{v}\)</span> olmak üzere [9,10] ve her <span class="math inline">\(i\)</span> parçacığı için,</p>
<p><span class="math display">\[
\dot{\bar{v}}_i = \bar{f}_i / m_i
\]</span></p>
<p><span class="math display">\[
\dot{\bar{x}}_i = \bar{v}_i
\]</span></p>
<p>Bu tür bir sistemi entegre etmek için Euler'in metotu kullanılabilir [5, sf 5], her <span class="math inline">\(n\)</span> anında bir sonraki <span class="math inline">\(n+1\)</span> değeri için</p>
<p><span class="math display">\[
\bar{x}^{n+1} = \bar{x}^n + h \bar{v}^n
\]</span></p>
<p><span class="math display">\[
\bar{v}^{n+1} = \bar{v}^n + h \bar{a}^n
\]</span></p>
<p>ki <span class="math inline">\(h\)</span> ufak zaman aralığı olarak alınır, bir diğer isim <span class="math inline">\(\Delta t\)</span> olabilir, alttaki kodda <code>dt</code> . O zaman her zaman diliminde her parçacığa etki eden kuvvetler toplanır, bir nihai kuvvet vektörü elde edilir. Ardından üstteki formüllerle sistem her parçacık için entegre edilir ve bir sonraki sistem durumu elde edilir.</p>
<p>Bu ilk sistemde bazı basitleştirmeler var; kuvvet uygulanma ve onun hıza dönüşmesine her koşulda bakmıyoruz, duvarlar ve parçacıklar arası etkileri direk hız üzerinde uyguluyoruz. Topların birbirine çarpma sonucu hız vektörlerinin hesabı [8]'te.</p>
<p>Kodlama notu, çarpışma hesabı için her parçacığın diğer parçacığa yakınlık kontrolü pahalı olursa, daha fazla parçacık için mesela, bunun için böleç tekniği kullanılabilir [7].</p>
<p>Genel grafik yöntemi şurada [1] işlendi.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># convert -scale 30% /tmp/sim/*.png /tmp/balls6.gif</span>
<span class="im">from</span> random <span class="im">import</span> random
<span class="im">from</span> collections <span class="im">import</span> defaultdict 
<span class="im">import</span> numpy <span class="im">as</span> np, datetime
<span class="im">import</span> sys, numpy.linalg <span class="im">as</span> lin
<span class="im">from</span> mayavi <span class="im">import</span> mlab

G <span class="op">=</span> np.array([<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">-0.8</span>])

m <span class="op">=</span> <span class="fl">0.1</span>
B <span class="op">=</span> <span class="dv">8</span> <span class="co"># top</span>

EPS <span class="op">=</span> <span class="fl">0.1</span>
BOUND_DAMPING <span class="op">=</span> <span class="fl">-0.6</span>

<span class="kw">class</span> Simulation:
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):
        <span class="va">self</span>.r   <span class="op">=</span> <span class="fl">0.2</span>
        <span class="va">self</span>.rvec   <span class="op">=</span> np.ones(B) <span class="op">*</span> <span class="va">self</span>.r
        <span class="va">self</span>.dt  <span class="op">=</span> <span class="fl">0.1</span>
        <span class="va">self</span>.balls <span class="op">=</span> []
        <span class="va">self</span>.cor <span class="op">=</span> <span class="fl">0.5</span>
        <span class="va">self</span>.mmax <span class="op">=</span>  <span class="fl">2.0</span><span class="op">-</span><span class="va">self</span>.r
        <span class="va">self</span>.mmin <span class="op">=</span> <span class="fl">0.0</span><span class="op">+</span><span class="va">self</span>.r
        
    <span class="kw">def</span> init(<span class="va">self</span>):
        <span class="cf">for</span> b <span class="kw">in</span> <span class="bu">range</span>(B):
            v <span class="op">=</span> np.array([<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>])
            p <span class="op">=</span> np.array([np.random.rand(), np.random.rand(), np.random.rand()])
            f <span class="op">=</span> <span class="dv">5</span><span class="op">*</span>np.array([np.random.rand(), np.random.rand(), np.random.rand()])
            <span class="va">self</span>.balls.append({<span class="st">&#39;x&#39;</span>:p, <span class="st">&#39;f&#39;</span>:f, <span class="st">&#39;v&#39;</span>: v, <span class="st">&#39;i&#39;</span>: b})
                        

    <span class="kw">def</span> computeForces(<span class="va">self</span>, i):
        <span class="cf">if</span> (i<span class="op">==</span><span class="dv">0</span>):
            <span class="cf">for</span> j,b <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="va">self</span>.balls):
                b[<span class="st">&#39;f&#39;</span>] <span class="op">=</span> b[<span class="st">&#39;f&#39;</span>] <span class="op">+</span> (G <span class="op">*</span> m)
        <span class="cf">else</span>: 
            <span class="cf">for</span> b <span class="kw">in</span> <span class="va">self</span>.balls:
                b[<span class="st">&#39;f&#39;</span>] <span class="op">=</span> G <span class="op">*</span> m
                        
    <span class="kw">def</span> integrate(<span class="va">self</span>):
        
        <span class="cf">for</span> j,p <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="va">self</span>.balls):
            p[<span class="st">&#39;v&#39;</span>] <span class="op">+=</span> <span class="va">self</span>.dt<span class="op">*</span>(p[<span class="st">&#39;f&#39;</span>]<span class="op">/</span>m)
            p[<span class="st">&#39;x&#39;</span>] <span class="op">+=</span> <span class="va">self</span>.dt<span class="op">*</span>p[<span class="st">&#39;v&#39;</span>]
            
            <span class="cf">if</span> p[<span class="st">&#39;x&#39;</span>][<span class="dv">0</span>]<span class="op">-</span>EPS <span class="op">&lt;</span> <span class="dv">0</span>:
                p[<span class="st">&#39;v&#39;</span>][<span class="dv">0</span>] <span class="op">*=</span> BOUND_DAMPING
                p[<span class="st">&#39;x&#39;</span>][<span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span>
            <span class="cf">if</span> p[<span class="st">&#39;x&#39;</span>][<span class="dv">0</span>]<span class="op">+</span>EPS <span class="op">&gt;</span> <span class="fl">2.0</span>:
                p[<span class="st">&#39;v&#39;</span>][<span class="dv">0</span>] <span class="op">*=</span> BOUND_DAMPING
                p[<span class="st">&#39;x&#39;</span>][<span class="dv">0</span>] <span class="op">=</span> <span class="fl">2.0</span><span class="op">-</span>EPS

            <span class="cf">if</span> p[<span class="st">&#39;x&#39;</span>][<span class="dv">1</span>]<span class="op">-</span>EPS <span class="op">&lt;</span> <span class="dv">0</span>:
                p[<span class="st">&#39;v&#39;</span>][<span class="dv">1</span>] <span class="op">*=</span> BOUND_DAMPING
                p[<span class="st">&#39;x&#39;</span>][<span class="dv">1</span>] <span class="op">=</span> <span class="dv">0</span>
            <span class="cf">if</span> p[<span class="st">&#39;x&#39;</span>][<span class="dv">1</span>]<span class="op">+</span>EPS <span class="op">&gt;</span> <span class="fl">2.0</span>:
                p[<span class="st">&#39;v&#39;</span>][<span class="dv">1</span>] <span class="op">*=</span> BOUND_DAMPING
                p[<span class="st">&#39;x&#39;</span>][<span class="dv">1</span>] <span class="op">=</span> <span class="fl">2.0</span><span class="op">-</span>EPS

            <span class="cf">if</span> p[<span class="st">&#39;x&#39;</span>][<span class="dv">2</span>]<span class="op">-</span>EPS <span class="op">&lt;</span> <span class="dv">0</span>:
                p[<span class="st">&#39;v&#39;</span>][<span class="dv">2</span>] <span class="op">*=</span> BOUND_DAMPING
                p[<span class="st">&#39;x&#39;</span>][<span class="dv">2</span>] <span class="op">=</span> <span class="dv">0</span>
            <span class="cf">if</span> p[<span class="st">&#39;x&#39;</span>][<span class="dv">2</span>]<span class="op">+</span>EPS <span class="op">&gt;</span> <span class="fl">2.0</span>:
                p[<span class="st">&#39;v&#39;</span>][<span class="dv">2</span>] <span class="op">*=</span> BOUND_DAMPING
                p[<span class="st">&#39;x&#39;</span>][<span class="dv">2</span>] <span class="op">=</span> <span class="fl">2.0</span><span class="op">-</span>EPS


        vDone <span class="op">=</span> {}
        <span class="cf">for</span> j,b <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="va">self</span>.balls):
            <span class="cf">for</span> other <span class="kw">in</span> <span class="va">self</span>.balls:
                <span class="cf">if</span> (other[<span class="st">&#39;i&#39;</span>] <span class="op">!=</span> b[<span class="st">&#39;i&#39;</span>] <span class="kw">and</span> b[<span class="st">&#39;i&#39;</span>] <span class="kw">not</span> <span class="kw">in</span> vDone <span class="kw">and</span> other[<span class="st">&#39;i&#39;</span>] <span class="kw">not</span> <span class="kw">in</span> vDone):
                    dist <span class="op">=</span> lin.norm(other[<span class="st">&#39;x&#39;</span>]<span class="op">-</span>b[<span class="st">&#39;x&#39;</span>])
                    <span class="cf">if</span> (dist <span class="op">&lt;</span> (<span class="dv">2</span><span class="op">*</span><span class="va">self</span>.r)):
                        <span class="co">#print (&#39;collision&#39;)</span>
                        vrel <span class="op">=</span> b[<span class="st">&#39;v&#39;</span>]<span class="op">-</span>other[<span class="st">&#39;v&#39;</span>]
                        n <span class="op">=</span> (other[<span class="st">&#39;x&#39;</span>]<span class="op">-</span>b[<span class="st">&#39;x&#39;</span>]) <span class="op">/</span> dist
                        vnorm <span class="op">=</span> np.dot(vrel,n)<span class="op">*</span>n
                        <span class="co">#print (vnorm)</span>
                        b[<span class="st">&#39;v&#39;</span>] <span class="op">=</span> b[<span class="st">&#39;v&#39;</span>] <span class="op">-</span> vnorm
                        other[<span class="st">&#39;v&#39;</span>] <span class="op">=</span> other[<span class="st">&#39;v&#39;</span>] <span class="op">+</span> vnorm                            
                        vDone[b[<span class="st">&#39;i&#39;</span>]] <span class="op">=</span> <span class="dv">1</span>
                        vDone[other[<span class="st">&#39;i&#39;</span>]] <span class="op">=</span> <span class="dv">1</span>
                            
            
            
    <span class="kw">def</span> update(<span class="va">self</span>,i):
        <span class="va">self</span>.computeForces(i)
        <span class="va">self</span>.integrate()
            
    <span class="kw">def</span> display(<span class="va">self</span>, i):
        mlab.options.offscreen <span class="op">=</span> <span class="va">True</span>
        ball_vect <span class="op">=</span> [[b[<span class="st">&#39;x&#39;</span>][<span class="dv">0</span>],b[<span class="st">&#39;x&#39;</span>][<span class="dv">1</span>],b[<span class="st">&#39;x&#39;</span>][<span class="dv">2</span>]] <span class="cf">for</span> b <span class="kw">in</span> <span class="va">self</span>.balls]
        ball_vect <span class="op">=</span> np.array(ball_vect)

        fig <span class="op">=</span> mlab.figure(figure<span class="op">=</span><span class="va">None</span>, fgcolor<span class="op">=</span>(<span class="fl">0.</span>, <span class="fl">0.</span>, <span class="fl">0.</span>), bgcolor<span class="op">=</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>), engine<span class="op">=</span><span class="va">None</span>)
        color<span class="op">=</span>(<span class="fl">0.2</span>, <span class="fl">0.4</span>, <span class="fl">0.5</span>)
        mlab.points3d(ball_vect[:,<span class="dv">0</span>], ball_vect[:,<span class="dv">1</span>], ball_vect[:,<span class="dv">2</span>], <span class="va">self</span>.rvec, color<span class="op">=</span>color, colormap <span class="op">=</span> <span class="st">&#39;gnuplot&#39;</span>, scale_factor<span class="op">=</span><span class="dv">1</span>, figure<span class="op">=</span>fig)
        mlab.points3d(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="fl">0.1</span>, color<span class="op">=</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>), scale_factor<span class="op">=</span><span class="fl">1.0</span>)
        
        BS <span class="op">=</span> <span class="fl">2.0</span>
        mlab.plot3d([<span class="fl">0.0</span>,<span class="fl">0.0</span>],[<span class="fl">0.0</span>, <span class="fl">0.0</span>],[<span class="fl">0.0</span>, BS], color<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>), tube_radius<span class="op">=</span><span class="va">None</span>, figure<span class="op">=</span>fig)
        mlab.plot3d([<span class="fl">0.0</span>,BS],[<span class="fl">0.0</span>, <span class="fl">0.0</span>],[<span class="fl">0.0</span>, <span class="fl">0.0</span>], color<span class="op">=</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>), tube_radius<span class="op">=</span><span class="va">None</span>, figure<span class="op">=</span>fig)
        mlab.plot3d([<span class="fl">0.0</span>,<span class="fl">0.0</span>],[<span class="fl">0.0</span>, BS],[<span class="fl">0.0</span>, <span class="fl">0.0</span>], color<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>), tube_radius<span class="op">=</span><span class="va">None</span>, figure<span class="op">=</span>fig)
        mlab.plot3d([<span class="fl">0.0</span>,<span class="fl">0.0</span>],[<span class="fl">0.0</span>, BS],[BS, BS], color<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>), tube_radius<span class="op">=</span><span class="va">None</span>, figure<span class="op">=</span>fig)
        mlab.plot3d([<span class="fl">0.0</span>,BS],[<span class="fl">0.0</span>,<span class="fl">0.0</span>],[BS,BS], color<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>), tube_radius<span class="op">=</span><span class="va">None</span>, figure<span class="op">=</span>fig)
        mlab.plot3d([BS,BS],[<span class="fl">0.0</span>,BS],[BS,BS], color<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>), tube_radius<span class="op">=</span><span class="va">None</span>, figure<span class="op">=</span>fig)
        mlab.plot3d([BS,<span class="dv">0</span>],[BS,BS],[BS,BS], color<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>), tube_radius<span class="op">=</span><span class="va">None</span>, figure<span class="op">=</span>fig)
        mlab.plot3d([<span class="dv">0</span>,<span class="dv">0</span>],[BS,BS],[BS,<span class="dv">0</span>], color<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>), tube_radius<span class="op">=</span><span class="va">None</span>, figure<span class="op">=</span>fig)
        mlab.plot3d([BS,BS],[<span class="fl">0.0</span>,<span class="fl">0.0</span>],[<span class="fl">0.0</span>,BS], color<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>), tube_radius<span class="op">=</span><span class="va">None</span>, figure<span class="op">=</span>fig)
        mlab.plot3d([BS,BS],[<span class="fl">0.0</span>,BS],[<span class="fl">0.0</span>,<span class="fl">0.0</span>], color<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>), tube_radius<span class="op">=</span><span class="va">None</span>, figure<span class="op">=</span>fig)
        mlab.plot3d([BS,<span class="fl">0.0</span>],[BS,BS],[<span class="fl">0.0</span>,<span class="fl">0.0</span>], color<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>), tube_radius<span class="op">=</span><span class="va">None</span>, figure<span class="op">=</span>fig)
        mlab.plot3d([BS,BS],[BS,BS],[<span class="fl">0.0</span>,BS], color<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>), tube_radius<span class="op">=</span><span class="va">None</span>, figure<span class="op">=</span>fig)

        mlab.view(azimuth<span class="op">=</span><span class="dv">50</span>, elevation<span class="op">=</span><span class="dv">80</span>, focalpoint<span class="op">=</span>[<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>], distance<span class="op">=</span><span class="fl">8.0</span>, figure<span class="op">=</span>fig)
        
        mlab.savefig(filename<span class="op">=</span><span class="st">&#39;/tmp/sim/out-</span><span class="sc">%02d</span><span class="st">.png&#39;</span> <span class="op">%</span> i)
        <span class="co">#exit()</span>

<span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>:
    s <span class="op">=</span> Simulation()
    s.init()
    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">40</span>):
        s.update(i)
        s.display(i)
        <span class="co">#exit()</span></code></pre></div>
<p><img src="glutout-140.png" /> <img src="glutout-390.png" /></p>
<p>Tüm resimleri birleştirirsek,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">!</span> convert <span class="op">-</span>scale <span class="dv">30</span><span class="op">%</span> <span class="op">/</span>tmp<span class="op">/</span>glutout<span class="op">-*</span>.png <span class="op">/</span>tmp<span class="op">/</span>balls1.gif</code></pre></div>
<p>Sonuç [2]'de görülebilir.</p>
<p>Kaynaklar</p>
<p>[1] Bayramlı, <em>OpenGL, PyOpenGL</em>, <a href="https://burakbayramli.github.io/dersblog/sk/2020/08/pyopengl.html" class="uri">https://burakbayramli.github.io/dersblog/sk/2020/08/pyopengl.html</a></p>
<p>[2] Bayramlı, <em>Simulasyon 1 Animasyon</em>, <a href="https://www.dropbox.com/scl/fi/0hfn6b7wltqfs9hf68uxv/balls1.gif?rlkey=m6atp3r1mx89v10u0adcum4wx&amp;st=e4uvvrv1&amp;raw=1" class="uri">https://www.dropbox.com/scl/fi/0hfn6b7wltqfs9hf68uxv/balls1.gif?rlkey=m6atp3r1mx89v10u0adcum4wx&amp;st=e4uvvrv1&amp;raw=1</a></p>
<p>[3] Wikipedia, <em>Elastic collision</em>, <a href="https://en.wikipedia.org/wiki/Elastic_collision" class="uri">https://en.wikipedia.org/wiki/Elastic_collision</a></p>
<p>[4] Masson, <em>Elastic Collisions in 3D</em>, <a href="https://exploratoria.github.io/exhibits/mechanics/elastic-collisions-in-3d/index.html" class="uri">https://exploratoria.github.io/exhibits/mechanics/elastic-collisions-in-3d/index.html</a></p>
<p>[6] Levi, <em>Classical Mechanics with Calculus of Variations and Optimal Control</em></p>
<p>[7] Bayramlı, <em>Bilgisayar Bilim, Geometrik Anahtarlama (Spatial Hashing) ve Izgara (Grid) ile En Yakın Noktaları Bulmak</em></p>
<p>[8] Bayramlı, Fizik, <em>Temel Fizik 2, Dönüşler, Basınç, Çarpışma</em></p>
<p>[9] Müller, <em>Fluid Simulation SIGGRAPH 2007 Course Notes</em>,</p>
<p>[10] <em>Visual Interactive Simulation (Spring 15)</em>, <a href="https://www8.cs.umu.se/kurser/5DV058/VT15/" class="uri">https://www8.cs.umu.se/kurser/5DV058/VT15/</a></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
