<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>

  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  
  
  
  
</head>
<body>
<h1 id="optimal-yol-hesabı-zermelo">Optimal Yol Hesabı, Zermelo</h1>
<p>Bir geminin çok kuvvetli dalgaların olduğu bir bölgeden geçmesi gerekiyor. Bu dalgaların büyüklüğü ve yönü her nokta için o noktaya etki eden bir vektör olarak gösterilebilir [1, sf. 77]. Bu vektörün iki öğesi,</p>
<p><span class="math display">\[
u = u(x,y), \quad v = v(x,y)
\]</span></p>
<p>Geminin hızı <span class="math inline">\(V\)</span>'nin suya göre sabit olduğunu düşünelim. Bu gemiyi nasıl yönlendirirdik ki <span class="math inline">\(A\)</span> noktasından <span class="math inline">\(B\)</span> noktasına minimal zamanda gidebilelim? Bu probleme literatürde Zermelo'nun problemi ismi verilir.</p>
<p>Problemi çözmek için hareket denklemlerini yazalım,</p>
<p><span class="math display">\[
\dot{x} = V \cos\theta + u(x,y)
\qquad (4)
\]</span></p>
<p><span class="math display">\[
\dot{y} = V \sin\theta + v(x,y)
\qquad (5)
\]</span></p>
<p><span class="math inline">\(\theta\)</span> geminin burnunu hangi yöne doğru tuttuğumuzu kontrol ediyor, yani geminin hızı <span class="math inline">\(V\)</span> o yönde uygulanmış oluyor. <span class="math inline">\(\theta\)</span> sabitlenmiş kordinat eksenlerine göredir, ve <span class="math inline">\(x,y\)</span> bu eksende geminin yönünü gösterir. Dikkat: <span class="math inline">\(u\)</span> çoğunlukla kontrol girdisi olarak gösterilir, burada böyle değil.</p>
<p><span class="math display">\[
\mathcal{H}(x, u, \lambda, t) = \mathcal{L}( x, u, t) + \lambda^T f(x, u, t) 
\]</span></p>
<p>Zaman optimizasyonu icin <span class="math inline">\(\mathcal{L} = 1\)</span>. Niye? Mesela</p>
<p><span class="math display">\[
J = \int_{t_0}^{t_f} \mathcal{L}( x, \dot{x}, u, \lambda, t)
\]</span></p>
<p>performans ölçütünü düşünelim, <span class="math inline">\(\mathcal{L} = 1\)</span> seçmek entegral çözümünden hareketle <span class="math inline">\(J = t_f - t_0\)</span> anlamına gelir, yani geçen zamanın hesabı.</p>
<p>Diğer değişken <span class="math inline">\(\lambda = \left[\begin{array}{cc} \lambda_x &amp; \lambda_y \end{array}\right]^T\)</span> diyelim, sistem denklemi <span class="math inline">\(f\)</span> biraz önce verildi zaten.</p>
<p>Bu sistemin Hamiltonian'ı</p>
<p><span class="math display">\[
\mathcal{H} = 
\lambda_x (V \cos \theta + u ) + 
\lambda_y (V \sin \theta + v ) + 1
\qquad (1)
\]</span></p>
<p>Devam edersek, Euler-Lagrange denklemleri</p>
<p><span class="math display">\[
\dot{\lambda}_x = -\frac{\partial H}{\partial x }  = 
-\lambda_x \frac{\partial u}{\partial x} - 
 \lambda_y \frac{\partial v}{\partial x}
\qquad (2)
\]</span></p>
<p><span class="math display">\[
\dot{\lambda}_y = -\frac{\partial H}{\partial y}  = 
-\lambda_x \frac{\partial y}{\partial y} - 
 \lambda_y \frac{\partial u}{\partial y}
\qquad (3)
\]</span></p>
<p><span class="math display">\[
0 = \frac{\partial H}{\partial \theta}  = 
V (-\lambda_x \sin \theta + \lambda_y \cos \theta ) \to
\tan\theta = \frac{\lambda_y}{\lambda_x}
\]</span></p>
<p>Hamiltonian <span class="math inline">\(\mathcal{H}\)</span> zaman <span class="math inline">\(t\)</span>'ye direk / belirgin şekilde bağlı olmadığı durumlarda <span class="math inline">\(\mathcal{H} = \textrm{sabit}\)</span> sistemin entegrallerinden biridir. İspatlayalım,</p>
<p><span class="math display">\[
\frac{\mathrm{d} \mathcal{H}(x, u, \lambda, t)}{\mathrm{d} t} = 
\cancel{\frac{\partial \mathcal{H}}{\partial t}} + 
\frac{\partial \mathcal{H}}{\partial x}\frac{\partial x}{\partial t} + 
\frac{\partial \mathcal{H}}{\partial u}\frac{\partial u}{\partial t} + 
\frac{\partial \mathcal{H}}{\partial \lambda}\frac{\partial \lambda}{\partial t} 
\]</span></p>
<p>İptalleme mümkün çünkü <span class="math inline">\(\mathcal{H}\)</span> zamandan bağımsız. Devam edelim [1, sf 49],</p>
<p><span class="math display">\[
\dot{H} = \mathcal{H}_x \dot{x} + H_u \dot{u} + \dot{\lambda}^T f
\]</span></p>
<p><span class="math inline">\(f\)</span> nereden geldi, Euler-Lagrange denklemlerini hatırlarsak,</p>
<p><span class="math display">\[
\dot{x} = + \left( \frac{\partial \mathcal{H}}{\partial \lambda} \right)
\quad
\dot{\lambda} = - \left( \frac{\partial \mathcal{H}}{\partial x} \right)
\quad
0 = + \left( \frac{\partial \mathcal{H}}{\partial u} \right)
\]</span></p>
<p>Soldan birinci denklem ile <span class="math inline">\(\dot{x}\)</span> yerine <span class="math inline">\(\frac{\partial \mathcal{H}}{\partial \lambda}\)</span> kullanabiliyoruz, ayrica <span class="math inline">\(\dot{x} = f\)</span> olduğuna göre bu yerine geçirme mümkün oluyor.</p>
<p>Aynı şekilde <span class="math inline">\(\dot{x}\)</span> yerine <span class="math inline">\(f\)</span> ve gruplama sonrası,</p>
<p><span class="math display">\[
\dot{H} = \mathcal{H}_u \dot{u} + (\mathcal{H}_x + \dot{\lambda}^T) f
\]</span></p>
<p>E-L soldan ikinci denklem ile parantez içi sıfır olur, geri kalanlardan, E-L soldan üçüncü denklem ile <span class="math inline">\(\mathcal{H}_u \dot{u}\)</span> sıfır olur, geri kalan,</p>
<p><span class="math display">\[
\dot{H} = 0
\]</span></p>
<p>Eğer üstteki doğruysa o zaman optimal gidiş yolu üzerinde <span class="math inline">\(t\)</span> üzerinden entegral <span class="math inline">\(\mathcal{H}\)</span>'in sabit olması gerekir. Dikkat edersek <span class="math inline">\(\mathcal{H}_u = 0\)</span> sıfır şartı optimal gidiş yolu üzerinde geçerlidir.</p>
<p>Varabileceğimiz bir diğer sonuç <span class="math inline">\(\mathcal{H}\)</span>'nin sabit olmak ötesinde sıfıra eşit olması mecburiyetidir. Bu nereden geliyor? Eğer zaman üzerinden optimize ediyorsak ve <span class="math inline">\(\mathcal{H}\)</span> zamana bağlı değilse ve sabitse, zamanın herhangi bir yerde olabilmesi için sadece sıfır sabiti bu işi yapabilir.</p>
<p>Çözüme gelelim. (1)'den başlayalım,</p>
<p><span class="math display">\[
0 = \lambda_x (V \cos\theta + u) + \lambda_y (W \sin\theta + v) + 1
\]</span></p>
<p><span class="math display">\[
-\frac{1}{\lambda_x} = \cancel{\frac{\lambda_x}{\lambda_x}}
(V  \cos\theta + u) + \frac{\sin\theta}{\cos\theta} (V \sin\theta + v)
\]</span></p>
<p><span class="math display">\[
\frac{-\cos\theta}{\lambda_x} = 
V \cos^2\theta + u\cos\theta + V \sin^2\theta + V \cos\theta
\]</span></p>
<p><span class="math display">\[
= V (\cancelto{1}{\cos^2\theta + \sin^2\theta}) + u + v
\]</span></p>
<p><span class="math display">\[
\lambda_x = \frac{-\cos\theta}{V + u\cos\theta + v\sin\theta} 
\qquad (7)
\]</span></p>
<p>Benzer işlemler sonrası</p>
<p><span class="math display">\[
\lambda_y = \frac{-\sin\theta}{V + u\cos\theta + v\sin\theta}
\]</span></p>
<p>elde edilebilir.</p>
<p>Üstteki iki denklemi (2) ya da (3)'e sokarsak,</p>
<p><span class="math display">\[
\dot{\theta} = \sin^2\theta \frac{\partial v}{\partial x} + 
\sin\theta \cos\theta \left( \frac{\partial u}{\partial x} - \frac{\partial v}{\partial y} \right)-
\cos^2 \theta \frac{\partial u}{\partial y}
\qquad (6)
\]</span></p>
<p>Bu son denklemi bir ODE sisteminin parçası olarak (4) ve (5) ile beraber çözersek, gerekli minimum zaman gidiş yollarını hesaplayacaktır. Verili bir B noktasına A noktasından varmak için doğru <span class="math inline">\(\theta\)</span> seçilecektir, ve optimal yolda böylece gidilecektir.</p>
<p>Örnek</p>
<p>Dalganın <span class="math inline">\(u = -V(y/h), v=0\)</span> şeklinde olduğunu düşünelim, yani bu yatay bir dalga, eksende uzağa gittikçe büyüyor. Başlangıç noktası <span class="math inline">\(x_0 = 3.66, y_0/h = -1.86\)</span> olsun.</p>
<p>Fakat hala işimiz bitmedi, <span class="math inline">\(A\)</span> noktasından başlayıp <span class="math inline">\(B\)</span> noktasına giden yolu, kontrol zincirini hesaplamak için doğru <span class="math inline">\(\theta_A\)</span>'yi seçmemiz gerekiyor, ya da <span class="math inline">\(\theta_0\)</span>'yi. Eğer elimizdekiler <span class="math inline">\(u=u(y)\)</span> ve <span class="math inline">\(v=v(y)\)</span> olsaydı o zaman (2) denklemi şu hale gelirdi,</p>
<p><span class="math display">\[
\dot{\lambda}_x = 0 \to \lambda_x = \textrm{sabit}
\]</span></p>
<p>Ve (7) denklemi şu hale dönüşür,</p>
<p><span class="math display">\[
\frac{\cos\theta}{V + u(y)\cos\theta + v(y)\sin\theta} = \textrm{sabit}
\]</span></p>
<p><span class="math inline">\(u = -V(y/h), v=0\)</span> üzerinden</p>
<p><span class="math display">\[
\frac{\cos\theta}{V - V(y/h)\cos\theta} = \frac{\cos\theta_f}{V} = \textrm{sabit}
\]</span></p>
<p><span class="math display">\[
\cos\theta = \frac{\cos\theta_f}{1 + (y/h)\cos\theta_f} 
\]</span></p>
<p>Bağımsız değişken için <span class="math inline">\(t\)</span> yerine <span class="math inline">\(\theta\)</span> kullanmak daha rahat. Elimizde bir <span class="math inline">\(y(\theta)\)</span> var,</p>
<p><span class="math display">\[
\frac{y}{h} = \sec\theta - \sec\theta_f 
\qquad (8)
\]</span></p>
<ol start="6" style="list-style-type: decimal">
<li>şu hale gelir,</li>
</ol>
<p><span class="math display">\[
\frac{\mathrm{d} t}{\mathrm{d} \theta} = \frac{h}{V} \sec^2\theta \to
\frac{V(t_f-t)}{h} = \tan\theta - \tan\theta_f 
\qquad (9)
\]</span></p>
<p>Bu nasıl oldu? (6)'nin son terimi haricinde tüm diğer terimleri <span class="math inline">\(u = -V(y/h), v=0\)</span> yerine koyunca yokolur, kalanlardan</p>
<p><span class="math display">\[
-\cos^2 \theta \frac{\partial u}{\partial y} = 
\cos^2 \theta \frac{V}{h}=\frac{\mathrm{d} \theta}{\mathrm{d} t}
\]</span></p>
<p>Ve</p>
<p><span class="math display">\[
\frac{1}{\frac{\mathrm{d} \theta}{\mathrm{d} t}} = \frac{\mathrm{d} \theta}{\mathrm{d} t}
\]</span></p>
<p>üzerinden görülen sonuç varılır.</p>
<p>Ve son olarak (4) denklemi, (8) ve (9) ile şu hale gelir,</p>
<p><span class="math display">\[
\frac{\mathrm{d} x}{\mathrm{d} \theta} = 
\frac{V \cos\theta + V (\sec\theta_f - \sec\theta}{-(V/h)\cos^2\theta} =
-h (\sec\theta + \sec\theta_f \sec^2\theta - \sec^3\theta)
\]</span></p>
<p>Bu denklemi entegre edince</p>
<p><span class="math display">\[
\frac{x}{h} = \frac{1}{2} \left[
\sec\theta_f (\tan\theta_f - \tan\theta) - \tan\theta (\sec\theta_f - \sec\theta)
+ \log \frac{\tan\theta_f + \sec\theta_f}{\tan\theta + \sec\theta}
\right] 
\]</span></p>
<p>Şimdi üstteki ve (8) denklemini beraber çözünce <span class="math inline">\(\theta_0,\theta_f\)</span> değerlerini elde edebiliriz, ki bunlar sırasıyla başlangıçtaki <span class="math inline">\(\theta\)</span> değerleridir.</p>
<p>Başlangıç noktaları <span class="math inline">\(x_0/h = 3.66, y_0/h = -1.86\)</span> değerlerini kullanarak</p>
<p><span class="math display">\[
-1.86 = \sec\theta_0 - \sec\theta_f 
\]</span></p>
<p><span class="math display">\[
3.66 = \frac{1}{2} [ \sec\theta_f (\tan\theta_f - \tan\theta_0 ) - 
\tan\theta_0 (\sec\theta_f - \sec\theta_0) + 
\]</span></p>
<p><span class="math display">\[
\sin h^{-1} (\tan\theta_f) - \sin h^{-1} (\tan\theta_0) ]
\]</span></p>
<p>Bu denklemleri çözünce</p>
<p><span class="math display">\[
\theta_0 = 105^0, \quad \theta_f = 240^0
\]</span></p>
<p>elde ediyoruz.</p>
<div class="figure">
<img src="phy_path_01.png" />

</div>
<p>Aslında bu problem bir nevi iki sınır koşullu problemi (two-boint boundary value problem), yani başlangıcı ve bitişi tanımlanarak çözülen bir ODE. Fakat biz şimdi kontrol amaçlı olarak eldeki başlangıç değerleri ile sistemi entegre ederek nereye varıyoruz ona bakalım, bu çözüm diğer yandan bize tüm <span class="math inline">\(x(t),y(t),\theta(t)\)</span> çözümünü de verecek, yani tüm gidiş yolunu. Üstteki resim [1]'den alınmıştır,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> scipy.integrate <span class="im">import</span> odeint

V <span class="op">=</span> <span class="fl">1.0</span>
h <span class="op">=</span> <span class="fl">1.0</span>
<span class="kw">def</span> wave(z, t):
    x,y,theta <span class="op">=</span> z
    tmp1 <span class="op">=</span> V<span class="op">*</span>np.cos(theta) <span class="op">+</span> <span class="op">-</span>V<span class="op">*</span>(y<span class="op">/</span>h)
    tmp2 <span class="op">=</span> V<span class="op">*</span>np.sin(theta) 
    tmp3 <span class="op">=</span> <span class="op">-</span>np.cos(theta)<span class="op">**</span><span class="dv">2</span><span class="op">*</span>(<span class="op">-</span>V<span class="op">/</span>h)
    <span class="cf">return</span> [tmp1, tmp2, tmp3]

t <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">50</span>)

z0 <span class="op">=</span> [<span class="fl">3.66</span>,<span class="op">-</span><span class="fl">1.86</span>,np.deg2rad(<span class="dv">105</span>)]
sol <span class="op">=</span> odeint(wave, z0, t)
idx <span class="op">=</span> <span class="dv">27</span>
thetas <span class="op">=</span> sol[<span class="dv">0</span>:idx,<span class="dv">2</span>]
<span class="bu">print</span> (sol[idx,:])
<span class="bu">print</span> (np.rad2deg(sol[idx,<span class="dv">2</span>]))
<span class="bu">print</span> (t[idx])
<span class="bu">print</span> (np.rad2deg(thetas))</code></pre></div>
<pre><code>[-0.04096147 -0.0363544   4.20008988]
240.64742384230138
5.510204081632653
[105.         105.82533902 106.74404915 107.77235927 108.93033001
 110.24297839 111.74181792 113.46692122 115.46973744 117.81688271
 120.59516753 123.91792862 127.932163   132.82416518 138.81708905
 146.14527764 154.97946458 165.28299453 176.64741416 188.27850714
 199.26873739 208.97172389 217.15287301 223.88529836 229.3803128
 233.87309753 237.57241404]</code></pre>
<p>Görüldüğü gibi <span class="math inline">\(x,y\)</span>'nin sıfıra en yakın olduğu noktada zaman ve bitiş açısına bakıyoruz, üstte bulunan değerle aynı. <span class="math inline">\(\theta\)</span>'ları grafiklersek,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">plt.xlim(<span class="op">-</span><span class="dv">0</span>,<span class="dv">5</span>)
plt.ylim(<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>)
<span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(idx):
    x,y,theta <span class="op">=</span> sol[i]
    plt.quiver(x,y,np.cos(theta),np.sin(theta))
plt.savefig(<span class="st">&#39;phy_path_02.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="phy_path_02.png" />

</div>
<p>Üstte görülen ilk resme oldukca benziyor. Bu <span class="math inline">\(\theta\)</span>'lar her noktada bize geminin burnunu hangi yöne tutmamız gerektiğini gösteriyor öyle ki verili deniz dalgası içinden optimal zamanda istediğimiz sonuç noktasına erisebilelim.</p>
<p>Vektör Formu</p>
<p>Benzer bir problemi vektörel formda çözelim. Bir uçağın rüzgarlı bir bölgede gitmesi gerekiyor. Rüzgarın büyüklüğünü ve yönünü bir vektör alanı olarak temsil edebiliriz, rüzgar pozisyonun bir fonksiyonudur, <span class="math inline">\(w = \vec{w}, r = \vec{r}, u = \vec{u}\)</span> olmak üzere, rüzgar <span class="math inline">\(w = w(r)\)</span>, ki <span class="math inline">\(r = \left[\begin{array}{ccc} r_x, r_y, r_z\end{array}\right]^T\)</span> üç boyutlu pozisyonu temsil ediyor [1, sf. 96]. Uçağın hızı <span class="math inline">\(V\)</span> sabit.</p>
<p>Problem uçağın yönünü her <span class="math inline">\(t\)</span> anında optimal şekilde ayarlayabilmek öyle ki A noktasından B noktasına, verili rüzgar alanı içinden en kısa şekilde gidebilmek.</p>
<p>Yere kıyasla uçağın toplam hızı</p>
<p><span class="math display">\[
\dot{r} = V \hat{u} + w
\qquad (11)
\]</span></p>
<p>ki <span class="math inline">\(\hat{u}\)</span> uçağın yönünü gösteren birim vektör, <span class="math inline">\(\hat{u} \cdot \hat{u} = 1\)</span>.</p>
<div class="figure">
<img src="phy_path_03.png" />

</div>
<p>Üstteki resim toplamsal hızı temsil eden vektörsel toplamı temsili olarak gösteriyor.</p>
<p>Hamiltonian</p>
<p><span class="math display">\[
\mathcal{H} = \lambda \cdot (V \hat{u}  + w) + 
\mu (1 - \hat{u}\cdot\hat{u}) + 1
\]</span></p>
<p>Euler-Lagrange denklemleri</p>
<p><span class="math display">\[
\dot{\lambda} = - \frac{\partial H}{\partial r} = - \nabla (\lambda \cdot w)
\qquad (10)
\]</span></p>
<p><span class="math display">\[
0 = \frac{\partial H}{\partial \hat{u}} = V \lambda - 2\mu\hat{u}
\]</span></p>
<p>Son denkleme bakarak, ve <span class="math inline">\(\hat{u}\)</span>'nun birim vektör olduğunu hatırlayarak, <span class="math inline">\(\hat{u},\lambda\)</span> haricindekileri bir <span class="math inline">\(C\)</span> altında <span class="math inline">\(C =V/2\mu\)</span> gruplayıp, <span class="math inline">\(\hat{u} = C \lambda\)</span> ve, ardından <span class="math inline">\(\hat{u}\)</span> birim vektör olduğu için <span class="math inline">\(C = 1/|\lambda|\)</span> diyebilirdik, fakat bu son ifade yanlış olurdu; ya <span class="math inline">\(V/2\mu\)</span> negatif ise? <span class="math inline">\(C = 1/|\lambda|\)</span> ile <span class="math inline">\(C\)</span>'nin negatif olabilme şansı kalmaz. Şöyle yazmak lazım,</p>
<p><span class="math display">\[
\hat{u} = \pm |C| \lambda = \pm \frac{\lambda}{||\lambda||}
\]</span></p>
<p>Minimum zaman problemi için <span class="math inline">\(H=0\)</span> olmalı. Bu durumda Hamiltonian formülünde ikinci terim sıfır, üçüncü terim pozitif, ve genel resme bakınca <span class="math inline">\(\lambda \cdot (V \hat{u} + w) = \lambda \cdot \dot{r}\)</span> hesabının aşağı yukarı aynı yöne işaret eden vektörler olması sebebiyle pozitif olması gerektiği için, o terimde negatifliği zorlamak için <span class="math inline">\(\hat{\lambda} = -\hat{u}\)</span> seçmemiz gerekir, ki <span class="math inline">\(\hat{\lambda} = \lambda / |\lambda|\)</span>. Yani hız vektörü yer etki vektörü <span class="math inline">\(\lambda\)</span>'nin tam tersi yönünü göstermelidir.</p>
<p>Ana denklemleri ortaya çıkartmak için, şimdi (10) denklemindeki ana ifadeyi açalım,</p>
<p><span class="math display">\[
\nabla (\lambda \cdot w) = 
(\lambda \cdot \nabla) w + (w \cdot \nabla) \lambda + 
\lambda \times (\nabla \times w) + 
w \times (\nabla \times \lambda)
\]</span></p>
<p><span class="math inline">\(\nabla \times \lambda\)</span>'ya bakalım (bu bir curl hesabı),</p>
<p><span class="math display">\[
\nabla \times \lambda = \left[\begin{array}{ccc}
i &amp; j &amp; k \\
\frac{\partial }{\partial x} &amp;
\frac{\partial }{\partial y} &amp;
\frac{\partial }{\partial z} \\
\lambda_1 &amp; \lambda_2 &amp; \lambda_3
\end{array}\right]
\]</span></p>
<p><span class="math display">\[
= \left[\begin{array}{ccc} 
\frac{\partial \lambda_3}{\partial y} - \frac{\partial \lambda_2}{\partial z} &amp; 
\frac{\partial \lambda_1}{\partial z} - \frac{\partial \lambda_3}{\partial x} &amp; 
\frac{\partial \lambda_2}{\partial x} - \frac{\partial \lambda_1}{\partial y} 
\end{array}\right] 
= \left[\begin{array}{ccc} 
0 &amp; 0 &amp; 0
\end{array}\right]
\]</span></p>
<p>Çünkü <span class="math inline">\(\lambda(t)\)</span> sadece <span class="math inline">\(t\)</span>'nin bir fonksiyonu, <span class="math inline">\(x,y,z\)</span> üzerinden alınan tüm türevler sıfır sonucunu veriyor. Ayrıca sıfır vektörle çapraz çarpım sıfır vektördür, o zaman</p>
<p><span class="math display">\[
 = 
(\lambda \cdot \nabla) w + (w \cdot \nabla) \lambda + 
\lambda \times (\nabla \times w) + 
\cancel{w \times (\nabla \times \lambda)}
\]</span></p>
<p>Benzer şekilde <span class="math inline">\((w \cdot \nabla) \lambda\)</span> yine <span class="math inline">\(\lambda\)</span> üzerinde <span class="math inline">\(x,y,z\)</span> kısmi türev demektir, bu ifade de sıfırdır,</p>
<p><span class="math display">\[
= (\lambda \cdot \nabla) w + 
\cancel{(w \cdot \nabla) \lambda} +
\lambda \times (\nabla \times w) 
\]</span></p>
<p><span class="math display">\[
= (\lambda \cdot \nabla) w + \lambda \times (\nabla \times w) 
\qquad (12)
\]</span></p>
<p>Ana denklemleri artık ortaya koyabiliriz. Eğer <span class="math inline">\(\hat{u} = -\hat{\lambda}\)</span> ifadesini (11) içinde kullanırsak, ve (12) sonucunu kullanınca, iki denklem,</p>
<p><span class="math display">\[
\dot{r} = w - V\hat{\lambda}
\]</span></p>
<p><span class="math display">\[
\dot{\lambda} = -(\lambda \cdot \nabla) w - \lambda \times (\nabla \times w) 
\]</span></p>
<p>Kaynaklar</p>
<p>[1] Bryson, Ho, <em>Applied Optimal Control</em></p>
<p>[2] Radhakant Padhi, <em>Optimal Control, Guidence and Estimation</em>, <a href="https://nptel.ac.in/courses/101108057/downloads/Lecture-34.pdf" class="uri">https://nptel.ac.in/courses/101108057/downloads/Lecture-34.pdf</a></p>
</body>
</html>
