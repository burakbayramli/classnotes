\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Geri-Yansýtmayla 3D Iþýn Hesabý (Back-projecting a 3D Ray), ve Düzlem Mesafesi

Üç boyutlu bir noktanýn iki boyuta yansýmasýnda derinlik bilgisinin
kaybolduðunu gördük, birden fazla üç boyutlu nokta ayný piksele tekabül
edebiliyor. Bu durumda sadece piksel kullanarak obje mesafe ölçümünü tek
bir görüntü üzerinden nasýl yapabiliriz? 

Eðer derinlik bilgisini kaybettiysek o zaman resimde bilinen diðer bazý
faktörleri yanyana koyarak bir uzaklýk hesaplayabiliriz belki. Mesela
alttaki resimdeki kýrmýzý piksellerin mesafesini bulmak istiyorum.

\begin{minted}[fontsize=\footnotesize]{python}
from PIL import Image
import util

im = np.array(Image.open('mitte.png'))
plt.xlim(0,320)
plt.ylim(240,0)
plt.imshow(im)
h = np.array(im).shape[0]

np.random.seed(1)
quad = np.array([[140,0],[164,90.],[212,90],[234,0]])
util.plot_quad(quad, h, 'y')
N = 1000 
random_points = np.random.uniform(0, 320, (N, 2)).astype(np.int)
random_points = random_points[random_points[:,1] < 240]
mask = np.array([util.inside_quad(quad, p)[0] for p in random_points])
plt.plot(random_points[mask][:,0], h-random_points[mask][:,1], 'r.')
p1 = np.array([215, 180, 1.])
plt.plot(p1[0], p1[1], 'c.')
plt.savefig('vision_80ray_02.png')
\end{minted}

\includegraphics[width=20em]{vision_80ray_02.png}

Problem öyle ki bu piksellerin yolu temsil eden pikseller olduðunu
biliyorum. Bu bilgiyi nasýl elde ettim? Renksel bazlý, ya da iki boyutta
imajý parçalara bölmeyi çok iyi yapan bir algoritmam var belki, vs. ve bu
sayede o piksellerin caddeye ait oldugunu biliyorum. O zaman, bu bilgi elde
varsa, bu bana bir þey kazandýrdý: üç boyutta bu piksellerin {\em hangi
  düzlemden} geldiðini biliyorum artýk. Bu düzlem $xy$ düzlemidir, orada
$z=0$.

Bir numara daha: bir piksele bakarak onun kesin üç boyutlu yerini
hesaplayamayabilirim. Ama bir piksele tekabül eden, onu oluþturan kamera
merkezinden dünyaya doðru fýrlayan bir ýþýnýn (ray) kesin formülünü
hesaplayabilirim.

\includegraphics[width=20em]{vision_80ray_01.png}

Mesela örnek kýrmýzý piksellerden biri $p_1$ noktasý olabilir, kamera
merkezi $C$'den bir ýþýn fýrlatýyoruz, bu ýþýn $p_1$'i oluþturuyor ve dýþ
dünyadaki bir $X$ noktasýna doðru gidiyor.  Þimdi bu iki fikri biraraya
koyarsak, elde bir düzlem, bir çizgi var; üç boyutlu yer nasýl bulunur?
Ýkisinin kesiþtiði yer ile! Bu nokta yol noktasýnýn üç boyutlu
kordinatýdýr.

Kamera Merkezi

Bu yazýda kamera merkezinin bilindiðini varsaydýk. Ama eðer bilmeseydi, ve
elde sadece $P$ matrisi olsa, kamera merkezini nasýl hesaplarýz onu
görelim. Biraz önceki resmi iþlerken kameranýn yerden 1 metre yükseltilmiþ
olduðunu farzedeceðiz (bunu biliyoruz), fakat bazen bu bilgi verilmemiþ
olabilir. Bu durumda dýþsal matristen baþlayabiliriz.

Dýþsal (exintrinsic) matrisler dýþ dünya kordinatlarýnýn kamera
kordindatlarýna nasýl transform edildiðini tarif ederler. Bunun yerine
kamera duruþunu modelleyip oradan geriye gidersek ayný noktaya gelmiþ
oluruz [1].

$$ 
\left[
\begin{array}{c|c} R & \boldsymbol{t} \\ \hline  \boldsymbol{0} & 1 \\ \end{array}
\right]
 = 
\left[ \begin{array}{c|c} R_c & C \\ \hline \boldsymbol{0} & 1 \\ \end{array}
\right]^{-1} 
$$

$$ 
= \left[ 
\left[ \begin{array}{c|c} I & C \\ 
  \hline \boldsymbol{0} & 1 \\ 
  \end{array}
\right]
\left[ \begin{array}{c|c} R_c & 0 \\ 
  \hline \boldsymbol{0} & 1 \\ 
  \end{array}
\right]
\right]^{-1}
$$

$$ 
= \left[
  \begin{array}{c|c} R_c & 0 \\ 
  \hline \boldsymbol{0} & 1 \\ 
   \end{array} 
  \right]^{-1} 
\left[ \begin{array}{c|c} I & C \\ 
  \hline \boldsymbol{0} & 1 \\ 
   \end{array}
\right]^{-1}
$$

$$ 
= \left[\begin{array}{c|c} R_c^T & 0 \\ 
\hline \boldsymbol{0} & 1 \\ 
\end{array}
\right]
\left[ \begin{array}{c|c} I & -C \\ 
\hline \boldsymbol{0} & 1 \\ 
\end{array}
\right]
$$

$$ 
= \left[\begin{array}{c|c} R_c^T & -R_c^TC \\ 
\hline \boldsymbol{0} & 1 \\ 
\end{array}
\right]
$$

Birbirine tekabül eden hücrelere bakýnca 

$$ t = -R_c^TC$$

O zaman 

$$ C = -R_c^T t$$

Burada $R_c$ $P$ yansýtma matrisinin ilk üç kolonundan oluþan
matristir. Ayrýca kamera merkezinin içsel matris $K$'ye baðlý olmadýðýna
dikkat. 

Sözde Ters ile $X$

Þimdi $X$ bulmak lazým. Bir fikir akla geliyor, $PX = x$ olduðuna göre,
$P$'nin tersini alýp bu tersi soldan iki tarafla çarpsak olmaz mý (solda
$P$ yokolur, $X$ kalýr)? Burada bir problem var, $P$ matrisi $3 \times 4$
matrisi, kare matris olmadýðý için tersi alýnamýyor. Bu hesap için
2. derste iþlenen sözde ters (pseudoinverse) iþlemini
kullanacaðýz. Hatýrlatarsak, $P$'nin sözde tersi $P^{+}$

$$ P^{+} = P^T(PP^T)^{-1}$$

iþlemidir, ki $PP^{+} = I$. Ama $PP^T$ çarpýmý sayýsal iyi sonuçlar
vermeyebilir (çarpýmlar çok büyür), endiþeye gerek yok, sayýsal
kütüphaneler sözde ters iþlemini SVD üzerinden çözüyor (çok hýzlý),
bkz. 2. ders.

O zaman $P^{+}x$ ile bahsettiðimiz ýþýndaki bir noktayý buluruz. Dikkat,
sadece birini buluruz, diðer noktalar da mümkündür. Ama o noktalar bizi
ilgilendirmiyor (þimdilik) elimizde iki nokta olacak, biri kamera merkezi
diðeri bu hesaplanacak olan, bu ikisi yeterli. Ondan önce üstteki hesabýn
gerçekten bir $X$ verip vermediðini kontrol edelim, hesaplanan noktayý
tekrar geri kameraya yansýtýrsak ne olur?

$$ P (P^{+}x) = Ix = x$$

Hesap doðruymuþ demek ki. Iþýn hesabý yapalým. Bir önceki resimde $p_1$'e
benzeyen bir nokta iki üstteki resimde mavi renkli gösterildi. Bu piksele
doðru giden bir çizgi neye benzer?

\begin{minted}[fontsize=\footnotesize]{python}
from mpl_toolkits.mplot3d import Axes3D
import scipy.linalg as lin
import sys; sys.path.append('../vision_02')
import plot3d

K = [[ 282.363047,      0.,          166.21515189],
     [   0.,          280.10715905,  108.05494375],
     [   0.,            0.,            1.        ]]
K = np.array(K)
R = np.eye(3)
t = np.array([[0],[1.],[0]])
P = K.dot(np.hstack((R,t)))
C = np.array([0., 0., 1.])

X = np.dot(lin.pinv(P),p1)
X = X / X[3]
XX  = np.copy(X)
XX[1] = X[2]; XX[2] = X[1]; XX[2] = -XX[2]
w = 10
f = plt.figure()
ax = f.gca(projection='3d')
xvec = C - XX[:3] 
xvec = -xvec
ax.quiver(C[0], C[1], C[2], xvec[0], xvec[1], xvec[2],color='red')
ax.set_xlim(0,10);ax.set_ylim(0,10);ax.set_zlim(0,10)
ax.quiver(0., 0., 1., 0, 5., 0.,color='blue')
plot3d.plot_plane(ax, [0., 0., 1.], [0, 5., 0.], color='y', size=7)
ax.set_xlabel("X")
ax.set_ylabel("Y")
ax.set_zlabel("Z")
ax.set_xlim(-w,w);ax.set_ylim(-w,w);ax.set_zlim(-w,w)
ax.view_init(elev=5, azim=100)
plt.savefig('vision_80ray_04.png')
ax.view_init(elev=5, azim=50)
plt.savefig('vision_80ray_05.png')
\end{minted}

\includegraphics[width=15em]{vision_80ray_04.png}
\includegraphics[width=15em]{vision_80ray_05.png}

Mavi renkli ok kameranýn imaj düzlemine dik (normal) olan vektör. Kýrmýzý
olan ok $p_1$'e iþaret eden üç boyutlu çizgi. 

Þimdi tüm noktalarý yapalým. Altta ilk gösterilen kod iki noktayý baz alan
sonsuza giden çizgi ile bir düzlem (bir nokta, bir normal ile tanýmlý)
arasýnda kesiþmeyi hesaplayan çaðrýdýr, bkz [3]. Üstteki gördüðümüz kýrmýzý renkli pikselleri alýp teker teker onlarýn
ýþýnýný bulacaðýz, sonra bu çizginin $xy$ düzlemi ile kesiþmesini
bulacaðýz. $xy$ düzlemini tanýmlamak için bir nokta, bir de normal vektör
lazým; en basit nokta orijin, yani $(0,0,0)$, normal ise dik yukarý giden
birim vektör $\left[\begin{array}{ccc} 0&0&1 \end{array}\right]^T$.  Kamera
matrisi $K$'yi biliyoruz, çünkü kamerayý biz kalibre ettik, detaylar için
[2].

\begin{minted}[fontsize=\footnotesize]{python}
def intersect(n,V0,P0,P1):
    """
    n: duzleme normal vektor
    V0: duzlemdeki herhangi bir nokta
    P0: P0P1 cizgisinin bir ucu
    P1: P0P1 cizgisinin diger ucu
    """
    w = P0 - V0;
    u = P1-P0;
    N = -np.dot(n,w);
    D = np.dot(n,u)
    sI = N / D
    I = P0+ sI*u
    return I

import scipy.linalg as lin

xx = np.ones((len(random_points[mask]), 3))
xx[:,0] = random_points[mask][:,0]
xx[:,1] = h-random_points[mask][:,1]

xyp = np.array([0,0,0])
xyn = np.array([0,0,1.])

for x in xx:
    X = np.dot(lin.pinv(P),np.array(x))
    X = X / X[3]
    XX  = np.copy(X)
    # Y-Z degistir, Y'nin isaretini degistir
    XX[1] = X[2]; XX[2] = X[1]; XX[2] = -XX[2]
    Xi = intersect(xyn, xyp, XX[:3], C)
    plt.plot(Xi[0], Xi[1],'b.')

plt.xlim(-3,3)
plt.ylim(0,20)
plt.savefig('vision_80ray_03.png')
\end{minted}

\includegraphics[width=20em]{vision_80ray_03.png}

Üstteki görüntü kýrmýzý piksellerin 3 boyutta, caddedeki kuþbakýþý
görüntüsü. Noktalar mantýklý, bir saða kayýþ var, bu doðru çünkü her ne
kadar iki boyutlu görüntüde noktalar yukarý gidiyor gibi dursa da, aslýnda
kesiþme noktasýna giden çizginin saðýna doðru akmýþlar. Bir diðer durum en
altta birkaç metrelik bir kýsmýn boþ olmasý. Bu da mantýklý çünkü kamera
direk altýný göremiyor, en yakýn görebildiði noktalar biraz daha önde
olanlar.

Peki kameranýn duruþunu biliyorum, yere paralel, 1 metre yukarýda, direk
düz ileri bakýyor. Bu bilgiyi kullanarak bir üçgen oluþturup, açýlarla ve
benzeri þekillerle daha basit þekilde mesafeyi hesaplayabilirdim, niye bunu
yapmadým? Özellikle $P$ matrisini kullanmamýzýn sebebi eðer yer
deðiþtirmeyle beraber kamerada dönüþ (rotation) durumu da varsa (bu örnekte
yoktu) bu bilginin de $P$ içinde olacaðýdýr. Bu durumda üstteki sözde ters
ile yine direk bir ýþýný basit bir þekilde elde edebilirdik. Öteki türlü
çetrefil bir sürü ek hesaplara girmek gerekecekti. Yani tarif ettiðimiz
yaklaþýmla her türlü kamera duruþunu idare edebiliriz.

Hesaplarýn metrik olarak bir anlamýnýn olduðuna dikkat. Çünkü yerden 1
metre yüksekte olmayý hesabýn içine direk dahil ettik, bu sebeple mesela
uzaklýk sonuçlarý, 2.5 metre, 5 metre gibi anlamlý çýktý. 

Kaynaklar

[1] Kyle Simek, Dissecting the Camera Matrix, Part 2: The Extrinsic Matrix,
\url{http://ksimek.github.io/2012/08/22/extrinsic/}

[2] Bayramlý, 
    {\em Algýlayýcý Ölçümleri, Video, Android}, 
     \url{https://burakbayramli.github.io/dersblog/sk/2017/02/algilayici-olcumleri-video-android.html}

[3] Bayramlý, {\em Çok Boyutlu Calculus, Ders 5}

\end{document}
