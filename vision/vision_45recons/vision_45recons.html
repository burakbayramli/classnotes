<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>İki İmaj Kullanarak 3 Boyutta Tekrar Oluşturmak (3D Reconstruction from Two Images)</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1
id="iki-imaj-kullanarak-3-boyutta-tekrar-oluşturmak-3d-reconstruction-from-two-images">İki
İmaj Kullanarak 3 Boyutta Tekrar Oluşturmak (3D Reconstruction from Two
Images)</h1>
<p>Temel Matris (Fundamental Matrix)</p>
<p>8’inci derste vazgeçilmez matris (essential matrix) konusunu
görmüştük. Şimdi bu bölümdeki eşkutupsal kısıtlamanın (epipolar
contraint) bir daha üzerinden geçelim, ama bu sefer temel matrisi merkez
alalım. Aslında vazgeçilmez ve temel matrisler birbirine çok yakınlar,
temel matris vazgeçilmezin içinden kalibre edilme faraziyesinin
çıkartılmış hali. [1, sf. 257] diyor ki vazgeçilmez matriste her şey
vazgeçilmez değilmiş demek ki (!).</p>
<p>Kalibrasyon, yani <span class="math inline">\(K\)</span> nasıl
çıkartılır? Diyelim ki bir kamera matrisi <span class="math inline">\(P
= K[R | t]\)</span> olarak tanımlı ve <span class="math inline">\(x =
PX\)</span> görüntüdeki bir piksel noktası. Bilinen bir <span
class="math inline">\(K\)</span> varsa onun tersini <span
class="math inline">\(x\)</span>’e uygulayarak <span
class="math inline">\(\hat{x} = K ^{-1}x\)</span> noktasını elde
edebiliriz, o zaman <span class="math inline">\(\hat{x} = [R |
t]X\)</span> olur. Burada <span class="math inline">\(\hat{x}\)</span>’i
bir tür “normalize edilmiş’’ kordinat sistemindeki bir görüntü pikseli
olarak düşünebiliriz, bu sistem sanki kalibrasyonu birim matris, yani
<span class="math inline">\(I\)</span> olan bir kamera sistemidir. Aynı
şekilde <span class="math inline">\(K ^{-1} P = [R|t]\)</span> normalize
kamera matrisi olarak adlandırılır.</p>
<p>Şimdi eşkutupsal kısıtlamaya tekrar bakalım. Altta soldaki resimde üç
boyutlu gerçek dünyada bir <span class="math inline">\(X\)</span>
noktası var, bu noktadan merkezi <span
class="math inline">\(C_1\)</span>’de olan kameraya bir çizgi çekiyoruz.
Bu çizgi üzerindeki her nokta aslında aynı piksel noktasına tekabül
ediyor. Değil mi? Bu aslında bir bilgi kaybıdır, o çizgi üzerindeki tüm
noktalar aynı piksele yansırsa bir şeyler kaybediliyor. Bu kaybedilen
derinlik bilgisi. Neyse, şimdi bu çizgi üzerindeki tüm o noktaların
ikinci bir kameradaki yansımalarını düşünelim. Bu tüm değişik yansımalar
ikinci kameranın görüntüsünde bir çizgi oluştururlar (aynı piksel değil
bu sefer, çünkü başka bir kameradayız), bu çizgiye eşkutupsal çizgi
diyoruz (alt sağda).</p>
<p><img src="vision_20recons_04.png" /> <img
src="vision_20recons_05.png" /></p>
<p>Aynı duruma tek bir <span class="math inline">\(X\)</span> için
bakalım,</p>
<p><img src="vision_20recons_06.png" /></p>
<p>Demek ki ilk kameradaki iki boyutlu bir <span
class="math inline">\(x\)</span>’i alıp ikinci kameradaki <span
class="math inline">\(x&#39;\)</span> noktasına transfer eden bir
fonksiyon var, buna <span class="math inline">\(H_{\pi}\)</span>
diyelim. Tranfer 2D-2D, yani iki boyuttan iki boyuta bir geçiş, bir
homografi, ve <span class="math inline">\(\pi\)</span> düzlemi üzerinde
bu geçiş oluyor. İkinci kameradaki eşkutupsal çizgi <span
class="math inline">\(l&#39; = [e&#39;]_x x&#39;\)</span> ile elde
edilir, çünkü hatırlarsak iki noktadan çizgi elde etmek için çapraz
çarpım lazım, ya da vektörlerden birinin eksi bakışımlı hali ile normal
çarpım (altsimge <span class="math inline">\(_x\)</span> eksi
bakışımlılık dönüşümünü temsil ediyor). O zaman, ve <span
class="math inline">\(x&#39; = H_\pi x\)</span> olduğu için,</p>
<p><span class="math display">\[ l&#39; = [e&#39;]_x x&#39; = l&#39; =
[e&#39;]_x H x = F x \]</span></p>
<p>de denebilir. İşte bu denklemin <span
class="math inline">\([e&#39;]_xH\)</span> kısmına temel matris <span
class="math inline">\(F\)</span> denir.</p>
<p>Eşkutupsal kısıtlama nedir? Bu kısıtlama</p>
<p><span class="math display">\[ x&#39;^T F x = 0\]</span></p>
<p>ifadesidir. Bu ifade doğru çünkü eğer <span
class="math inline">\(x\)</span> ve <span
class="math inline">\(x&#39;\)</span> birbirlerine karşılık noktalar
iseler, o zaman <span class="math inline">\(x&#39;\)</span> eşkutupsal
çizgi <span class="math inline">\(l&#39; = Fx\)</span> üzerinde olmalı,
yani <span class="math inline">\(0 = x&#39;^T l&#39; = x&#39;^T F
x\)</span>.</p>
<p>Nokta Karşılıkları ve 8-Nokta Algoritması</p>
<p>İki resimden üç boyutta tekrar oluşturma için önce <span
class="math inline">\(F\)</span> matrisini hesaplamak gerekiyor. Oradan
vazgeçilmez matris <span class="math inline">\(E\)</span>’ye geçeceğiz,
sonra <span class="math inline">\(E\)</span> içinden <span
class="math inline">\(R,T\)</span> matrislerini çıkartabiliriz.</p>
<p><span class="math inline">\(F\)</span>’den <span
class="math inline">\(E\)</span>’ye geçiş basit, <span
class="math inline">\(E = K^TFK\)</span>. İspat: Eğer eşkutupsal
kısıtlama türetiminde normalize edilmiş noktaları kullansaydık <span
class="math inline">\(\hat{x}&#39;E \hat{x} = 0\)</span> elde ederdik,
ve <span class="math inline">\(\hat{x}\)</span> ve <span
class="math inline">\(\hat{x}&#39;\)</span> yerine <span
class="math inline">\(x\)</span> ve <span
class="math inline">\(x&#39;\)</span> kullanırsak, <span
class="math inline">\(\hat{x} = K ^{-1}x, \hat{x&#39;} = K
^{-1}x&#39;\)</span>, o zaman <span
class="math inline">\(x&#39;^TK^{-T}E K ^{-1}x = 0\)</span> elde ederiz,
bu demektir ki <span class="math inline">\(E = K ^T F K\)</span>.</p>
<p><span class="math inline">\(F\)</span> hesabına dönelim. Elimizde iki
imaj var, Alkatraz adasının iki değişik yerden fotoğrafı [2,3]. Bu iki
imaj üzerinde önce birbirine tekabül eden noktaları bulacağız. Bu iş
için OpenCV’nin ORB adı verilen nokta özelliği (feature) çıkartan
işlevini kullanabiliriz, onun yerine SIFT, SURF te olabilirdi.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpl_toolkits.mplot3d <span class="im">import</span> axes3d</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.linalg <span class="im">as</span> lin</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cv2</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="bu">dir</span> <span class="op">=</span> <span class="st">&quot;/opt/Downloads&quot;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>img1 <span class="op">=</span> cv2.imread(<span class="bu">dir</span> <span class="op">+</span> <span class="st">&quot;/alcatraz1.jpg&quot;</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>img2 <span class="op">=</span> cv2.imread(<span class="bu">dir</span> <span class="op">+</span> <span class="st">&quot;/alcatraz2.jpg&quot;</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>detector <span class="op">=</span> cv2.ORB_create( nfeatures <span class="op">=</span> <span class="dv">10000</span> )</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> detect_features(frame):</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    keypoints, descrs <span class="op">=</span> detector.detectAndCompute(frame, <span class="va">None</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> descrs <span class="kw">is</span> <span class="va">None</span>: descrs <span class="op">=</span> []</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> keypoints, descrs</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>FLANN_INDEX_LSH    <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>flann_params<span class="op">=</span> <span class="bu">dict</span>(algorithm <span class="op">=</span> FLANN_INDEX_LSH,</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>                   table_number <span class="op">=</span> <span class="dv">6</span>, <span class="co"># 12</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>                   key_size <span class="op">=</span> <span class="dv">12</span>,     <span class="co"># 20</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>                   multi_probe_level <span class="op">=</span> <span class="dv">1</span>) <span class="co">#2</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>kp1, des1 <span class="op">=</span> detect_features(img1)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>kp2, des2 <span class="op">=</span> detect_features(img2)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>matcher <span class="op">=</span> cv2.FlannBasedMatcher(flann_params, {})</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>matches <span class="op">=</span> matcher.knnMatch(des1, des2, k <span class="op">=</span> <span class="dv">2</span>)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>matches <span class="op">=</span> [m[<span class="dv">0</span>] <span class="cf">for</span> m <span class="kw">in</span> matches <span class="op">\</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>           <span class="cf">if</span> <span class="bu">len</span>(m) <span class="op">==</span> <span class="dv">2</span> <span class="kw">and</span> m[<span class="dv">0</span>].distance <span class="op">&lt;</span> m[<span class="dv">1</span>].distance <span class="op">*</span> <span class="fl">0.75</span>]</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;uyan noktalar&#39;</span>, <span class="bu">len</span>(matches))</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>pts1 <span class="op">=</span> []<span class="op">;</span> pts2 <span class="op">=</span> []</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(matches)):</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    pt_a <span class="op">=</span> kp1[matches[i].queryIdx].pt</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    pt_b <span class="op">=</span> kp2[matches[i].trainIdx].pt</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    pt_a <span class="op">=</span> np.array(pt_a).astype(<span class="bu">int</span>)</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>    pt_b <span class="op">=</span> np.array(pt_b).astype(<span class="bu">int</span>)</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> np.sqrt(np.dot(pt_b<span class="op">-</span>pt_a,pt_b<span class="op">-</span>pt_a)) <span class="op">&lt;</span> <span class="dv">200</span>:</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>        pts1.append(pt_a)</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>        pts2.append(pt_b)</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>        cv2.line(img1, <span class="bu">tuple</span>(pt_a), <span class="bu">tuple</span>(pt_b), (<span class="dv">255</span>, <span class="dv">0</span>, <span class="dv">0</span>), <span class="dv">5</span>)</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>        cv2.circle(img1,<span class="bu">tuple</span>(pt_b), <span class="dv">5</span>, (<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">255</span>), <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>h,w,d <span class="op">=</span> img1.shape</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>tmp <span class="op">=</span> cv2.resize(img1, (<span class="bu">int</span>(w<span class="op">/</span><span class="dv">4</span>),<span class="bu">int</span>(h<span class="op">/</span><span class="dv">4</span>)))</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>cv2.imwrite(<span class="st">&#39;vision_20recons_01.jpg&#39;</span>,tmp)</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> pt <span class="kw">in</span> pts2: cv2.circle(img2,<span class="bu">tuple</span>(pt),<span class="dv">5</span>,(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">255</span>),<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>tmp <span class="op">=</span> cv2.resize(img2, (<span class="bu">int</span>(w<span class="op">/</span><span class="dv">4</span>),<span class="bu">int</span>(h<span class="op">/</span><span class="dv">4</span>)))</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>cv2.imwrite(<span class="st">&#39;vision_20recons_02.jpg&#39;</span>,tmp)</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>pts1 <span class="op">=</span> np.array(pts1)</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>pts2 <span class="op">=</span> np.array(pts2)</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>h,w,dum <span class="op">=</span> img1.shape</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>pts1[:,<span class="dv">1</span>] <span class="op">=</span> h<span class="op">-</span>pts1[:,<span class="dv">1</span>]</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>pts2[:,<span class="dv">1</span>] <span class="op">=</span> h<span class="op">-</span>pts2[:,<span class="dv">1</span>]</span></code></pre></div>
<pre class="text"><code>uyan noktalar 1289</code></pre>
<p><img src="vision_20recons_01.jpg" /></p>
<p><img src="vision_20recons_02.jpg" /></p>
<p>Birinci resimde saptanan ORB noktalarının ikinci resimdeki noktalara
nasıl nasıl eşleştiğini (yine birinci resimde) gösterdik, ikinci resimde
o resimdeki eşleşme noktaları görülüyor. Noktalardaki kayma kameranının
hareketi hakkında bir ipucu veriyor bize, hareketi çıplak gözle bile
görebiliyoruz. Temel matrisi hesaplayınca daha net bir sonuç alacağız
tabii.</p>
<p>8-Nokta Algoritması</p>
<p>Daha önce <span class="math inline">\(E\)</span> için 8-nokta
algoritmasını gördük, benzer bir hesap <span
class="math inline">\(F\)</span> için de var. Bu arada 8 nokta dedik
daha fazlasına da izin veren bir çözüm yöntemi SVD ile mümkün. Çözülecek
sistem eşkutupsal kısıtlamadan başlar, <span
class="math inline">\(i=1,2,..\)</span> olacak şekilde her <span
class="math inline">\(x_1^i,x_2^i\)</span> eşleşmelerini bir <span
class="math inline">\(x_1^i F x_2^i = 0\)</span> hesabını içinde
barındıran bir <span class="math inline">\(Af = 0\)</span> sistemi
yaratabiliriz, <span class="math inline">\(x_1^i =
(x_1^i,y_1^i,w_1^i)\)</span> ve <span
class="math inline">\(x_2^i=(x_2^i,y_2^i,w_2^i)\)</span> olacak
şekilde,</p>
<p><span class="math display">\[
\left[\begin{array}{ccccc}
x_2^1x_1^1 &amp; x_2^1y_1^1 &amp; x_2^1w_1^1 &amp; \dots &amp;
w_2^1w_1^1 \\
x_2^2x_1^2 &amp; x_2^2y_1^2 &amp; x_2^2w_1^2 &amp; \dots &amp;
w_2^2w_1^2 \\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots  \\
x_2^nx_1^n &amp; x_2^ny_1^n &amp; x_2^nw_1^n &amp; \dots &amp;
w_2^nw_1^n
\end{array}\right]
\left[\begin{array}{c}
F_{11} \\ F_{12} \\ F_{13} \\ \vdots \\ F_{33}
\end{array}\right] = 0
\]</span></p>
<p>ki <span class="math inline">\(f\)</span> içinde <span
class="math inline">\(F\)</span>’nin öğeleri var. Üstteki çarpım
yapılınca teker teker her satırda eşkutupsal kısıtlamayı elde
edebileceğimizi görebiliriz. <span class="math inline">\(Af = 0\)</span>
sistemi yaklaşık olarak SVD ile çözülebilir.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_fundamental(x1, x2):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  n <span class="op">=</span> x1.shape[<span class="dv">1</span>]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  A <span class="op">=</span> np.zeros((n, <span class="dv">9</span>))</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    A[i] <span class="op">=</span> [x1[<span class="dv">0</span>, i] <span class="op">*</span> x2[<span class="dv">0</span>, i],  x1[<span class="dv">0</span>, i] <span class="op">*</span> x2[<span class="dv">1</span>, i],  x1[<span class="dv">0</span>, i] <span class="op">*</span> x2[<span class="dv">2</span>, i],</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>            x1[<span class="dv">1</span>, i] <span class="op">*</span> x2[<span class="dv">0</span>, i],  x1[<span class="dv">1</span>, i] <span class="op">*</span> x2[<span class="dv">1</span>, i],  x1[<span class="dv">1</span>, i] <span class="op">*</span> x2[<span class="dv">2</span>, i],</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>            x1[<span class="dv">2</span>, i] <span class="op">*</span> x2[<span class="dv">0</span>, i],  x1[<span class="dv">2</span>, i] <span class="op">*</span> x2[<span class="dv">1</span>, i],  x1[<span class="dv">2</span>, i] <span class="op">*</span> x2[<span class="dv">2</span>, i],</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>           ]</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  U, S, V <span class="op">=</span> np.linalg.svd(A)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  F <span class="op">=</span> V[<span class="op">-</span><span class="dv">1</span>].reshape(<span class="dv">3</span>, <span class="dv">3</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>  U, S, V <span class="op">=</span> np.linalg.svd(F)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>  S[<span class="dv">2</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>  F <span class="op">=</span> np.dot(U, np.dot(np.diag(S), V))</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> F <span class="op">/</span> F[<span class="dv">2</span>, <span class="dv">2</span>]</span></code></pre></div>
<p>Eğer biraz önce bulunan noktalar üzerinde uygularsak,</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> make_homog(points):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> np.vstack((points, np.ones((<span class="dv">1</span>, points.shape[<span class="dv">1</span>]))))</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (compute_fundamental(make_homog(pts1.T),make_homog(pts2.T)))</span></code></pre></div>
<pre class="text"><code>[[ 9.72179429e-08  1.72737429e-06 -1.74727581e-03]
 [-8.39498472e-07  9.04878124e-07 -2.19855069e-03]
 [ 8.74608699e-04  2.38371775e-04  1.00000000e+00]]</code></pre>
<p>Dahası da var. Bu hesap fena değildir, fakat <span
class="math inline">\(F\)</span> gibi kritik bir hesap için daha sağlam
bir yaklaşım tercih ediliyor. RANSAC adı verilen metotla verilen tüm
eşleşme noktalarından ufak örneklemler toplanır, her örneklem üzerinde
üstteki hesap uygulanır, ve elde edilen sonuçlara bakılarak gerçek <span
class="math inline">\(F\)</span>’e yaklaşıp yaklaşılmadığı
kararlarlaştırılmaya çalışılır, en iyi, stabil olan nihai sonuç elde
tutulur. Detaylar için [1, sf. 291]. OpenCV
<code>cv2.findFundamentalMat</code> çağrısı <span
class="math inline">\(F\)</span>’yi RANSAC ile hesaplayabilir. Sonra
<span class="math inline">\(E\)</span>, onu <span
class="math inline">\(R,t\)</span> parçalarına ayırırız, vs., böyle
devam ederiz.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># kamera matrisi biliniyor</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> np.array([[<span class="dv">2394</span>,<span class="dv">0</span>,<span class="dv">932</span>],[<span class="dv">0</span>,<span class="dv">2398</span>,<span class="dv">628</span>],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]])</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>F, mask <span class="op">=</span> cv2.findFundamentalMat(pts1, pts2, cv2.FM_RANSAC, <span class="fl">3.0</span>, <span class="fl">0.99</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;F&#39;</span>, F)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>E <span class="op">=</span> K.T.dot(F).dot(K)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;E&#39;</span>, E)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>R1,R2,t <span class="op">=</span> cv2.decomposeEssentialMat(E)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;R1&#39;</span>,R1)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;R2&#39;</span>,R2)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;t&#39;</span>,t)</span></code></pre></div>
<pre class="text"><code>F [[ 3.23525233e-08  4.38638128e-06 -1.14468511e-03]
 [-4.85059031e-06  2.48532709e-07  1.50124300e-02]
 [ 9.19665040e-04 -1.62050730e-02  1.00000000e+00]]
E [[  0.18541995  25.1813903    3.92643503]
 [-27.84632704   1.42916348  25.53332459]
 [ -5.01866937 -28.68220729  -0.1042787 ]]
R1 [[ 0.00756453 -0.15206339  0.9883418 ]
 [-0.17952009 -0.9725189  -0.14825492]
 [ 0.98372522 -0.17630573 -0.03465508]]
R2 [[ 0.99321306 -0.02705221  0.11311937]
 [ 0.02918137  0.99942599 -0.01720867]
 [-0.11258891  0.02039286  0.99343237]]
t [[ 0.74947563]
 [-0.11258766]
 [ 0.65238815]]</code></pre>
<p>Üçgenleme (Triangulation)</p>
<p>Yer değiştirme, rotasyon matrislerini biliyoruz, oradan her kamera
için yansıtma matrisleri <span
class="math inline">\(P,P&#39;\)</span>’yi oluşturabiliriz. Peki bu
matrisleri kullanarak üç boyutta gerçek nokta <span
class="math inline">\(X\)</span>’leri nasıl hesaplarız? Halen elimizde
sadece iki boyutlu imaj noktaları var, 3D dünya noktaları yok. <span
class="math inline">\(X\)</span>’leri hesaplamak için daha önce
gördüğümüz direk lineer transform metotunun benzerini uygularız. Bu
gerekli çünkü her iki kameradaki yansımadan oluşan hatalar, vs. sonucu
mesela iki kameradan direk çizgi çekerek kesiştikleri yeri bulmaya
çalışsak, alttaki durum ortaya çıkar,</p>
<p><img src="vision_20recons_07.png" /></p>
<p>O zaman yaklaşıksal bir çözüm gerekli, üstteki hata ortaya çıksa da,
bu hatayı olabildiğince minimize etmeye uğraşmalıyız.</p>
<p>Birbirinin eşi olan iki piksel noktası için elimizde <span
class="math inline">\(x = PX, x&#39; = P&#39;X\)</span> denklemleri var,
bu denklemde <span class="math inline">\(X\)</span> aynı dikkat edersek,
çünkü aynı 3D noktasının iki kameradaki değişik yansımaları var. Bu
denklemleri birleştirerek bir <span class="math inline">\(AX=0\)</span>
sistemi ortaya çıkartabiliriz [1, sf. 312], ve bu sistem minimize
edilebilir. Çapraz çarpım ile homojen ölçek faktörünü çıkartırsak,
mesela ilk imaj için</p>
<p><span class="math display">\[ x \times (PX) = 0\]</span></p>
<p>Bu bize üç denklem verir,</p>
<p><span class="math display">\[ x(p^{3T}X) - (p^{1T}X) = 0
\]</span></p>
<p><span class="math display">\[ y(p^{3T}X) - (p^{2T}X) = 0
\]</span></p>
<p><span class="math display">\[ x(p^{2T}X) - (p^{1T}X) = 0
\]</span></p>
<p>ki <span class="math inline">\(p^{iT}\)</span> <span
class="math inline">\(P\)</span> matrisinin satırlarıdır. Bu denklemler
<span class="math inline">\(X\)</span>’in öğelerine göre lineerdir. Bu
sistemden hareketle <span class="math inline">\(AX=0\)</span>’daki <span
class="math inline">\(A\)</span> şöyle,</p>
<p><span class="math display">\[ A = \left[\begin{array}{c}
xp^{3T} - p^{1T} \\
yp^{3T} - p^{2T} \\
x&#39;p&#39;^{3T} - p&#39;^{1T} \\
y&#39;p&#39;^{3T} - p&#39;^{2T}
\end{array}\right]\]</span></p>
<p>Her iki imajdan iki denklem alındı, toplam 4 denklem oldu. Bu denklem
SVD ile, ya da <span class="math inline">\(AX=b\)</span> şeklinde tekrar
düzenlenip 2. derste gördüğümüz sözde ters (pseudoinverse) ile
çözülebilir. Altta bu yöntem takip edildi,</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.linalg <span class="im">as</span> lin</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> triangulate_point(u1, u2, P1, P2):</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  A <span class="op">=</span> [[u1[<span class="dv">0</span>]<span class="op">*</span>P1[<span class="dv">2</span>,<span class="dv">0</span>]<span class="op">-</span>P1[<span class="dv">0</span>,<span class="dv">0</span>],u1[<span class="dv">0</span>]<span class="op">*</span>P1[<span class="dv">2</span>,<span class="dv">1</span>]<span class="op">-</span>P1[<span class="dv">0</span>,<span class="dv">1</span>],u1[<span class="dv">0</span>]<span class="op">*</span>P1[<span class="dv">2</span>,<span class="dv">2</span>]<span class="op">-</span>P1[<span class="dv">0</span>,<span class="dv">2</span>]],</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>       [u1[<span class="dv">1</span>]<span class="op">*</span>P1[<span class="dv">2</span>,<span class="dv">0</span>]<span class="op">-</span>P1[<span class="dv">1</span>,<span class="dv">0</span>],u1[<span class="dv">1</span>]<span class="op">*</span>P1[<span class="dv">2</span>,<span class="dv">1</span>]<span class="op">-</span>P1[<span class="dv">1</span>,<span class="dv">1</span>],u1[<span class="dv">1</span>]<span class="op">*</span>P1[<span class="dv">2</span>,<span class="dv">2</span>]<span class="op">-</span>P1[<span class="dv">1</span>,<span class="dv">2</span>]],</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>       [u2[<span class="dv">0</span>]<span class="op">*</span>P2[<span class="dv">2</span>,<span class="dv">0</span>]<span class="op">-</span>P2[<span class="dv">0</span>,<span class="dv">0</span>],u2[<span class="dv">0</span>]<span class="op">*</span>P2[<span class="dv">2</span>,<span class="dv">1</span>]<span class="op">-</span>P2[<span class="dv">0</span>,<span class="dv">1</span>],u2[<span class="dv">0</span>]<span class="op">*</span>P2[<span class="dv">2</span>,<span class="dv">2</span>]<span class="op">-</span>P2[<span class="dv">0</span>,<span class="dv">2</span>]],</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>       [u2[<span class="dv">1</span>]<span class="op">*</span>P2[<span class="dv">2</span>,<span class="dv">0</span>]<span class="op">-</span>P2[<span class="dv">1</span>,<span class="dv">0</span>],u2[<span class="dv">1</span>]<span class="op">*</span>P2[<span class="dv">2</span>,<span class="dv">1</span>]<span class="op">-</span>P2[<span class="dv">1</span>,<span class="dv">1</span>],u2[<span class="dv">1</span>]<span class="op">*</span>P2[<span class="dv">2</span>,<span class="dv">2</span>]<span class="op">-</span>P2[<span class="dv">1</span>,<span class="dv">2</span>]]]</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  B <span class="op">=</span> [[<span class="op">-</span>(u1[<span class="dv">0</span>]<span class="op">*</span>P1[<span class="dv">2</span>,<span class="dv">3</span>]<span class="op">-</span>P1[<span class="dv">0</span>,<span class="dv">3</span>])],</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>       [<span class="op">-</span>(u1[<span class="dv">1</span>]<span class="op">*</span>P1[<span class="dv">2</span>,<span class="dv">3</span>]<span class="op">-</span>P1[<span class="dv">1</span>,<span class="dv">3</span>])],</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>       [<span class="op">-</span>(u2[<span class="dv">0</span>]<span class="op">*</span>P2[<span class="dv">2</span>,<span class="dv">3</span>]<span class="op">-</span>P2[<span class="dv">0</span>,<span class="dv">3</span>])],</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>       [<span class="op">-</span>(u2[<span class="dv">1</span>]<span class="op">*</span>P2[<span class="dv">2</span>,<span class="dv">3</span>]<span class="op">-</span>P2[<span class="dv">1</span>,<span class="dv">3</span>])]]</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>  A <span class="op">=</span> np.array(A)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>  B <span class="op">=</span> np.array(B)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>  X <span class="op">=</span> lin.lstsq(A,B)[<span class="dv">0</span>].T[<span class="dv">0</span>]</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>  res <span class="op">=</span> np.array([X[<span class="dv">0</span>],X[<span class="dv">1</span>],X[<span class="dv">2</span>],<span class="dv">1</span>])</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> res</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> triangulate(x1, x2, P1, P2):</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>  X <span class="op">=</span> [triangulate_point(x1[i, :], x2[i, :], P1, P2) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(x1))]</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> np.array(X).T</span></code></pre></div>
<p>Test amaçlı olarak bilinen <code>P1,P2</code> ve yine iki boyutta
eşliği bilinen noktalarla üçgenleme yapalım, sonra elde edilen üç
boyutlu noktaları kameralara yansıtalım ve başladığımız imaj noktalarına
uyuyor mu kontrol edelim.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>P1 <span class="op">=</span> np.eye(<span class="dv">4</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>P2 <span class="op">=</span> np.array([[ <span class="fl">0.878</span>, <span class="op">-</span><span class="fl">0.01</span> ,  <span class="fl">0.479</span>, <span class="op">-</span><span class="fl">1.995</span>],</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>              [ <span class="fl">0.01</span> ,  <span class="fl">1.</span>   ,  <span class="fl">0.002</span>, <span class="op">-</span><span class="fl">0.226</span>],</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>              [<span class="op">-</span><span class="fl">0.479</span>,  <span class="fl">0.002</span>,  <span class="fl">0.878</span>,  <span class="fl">0.615</span>],</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>              [ <span class="fl">0.</span>   ,  <span class="fl">0.</span>   ,  <span class="fl">0.</span>   ,  <span class="fl">1.</span>   ]])</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Homogeneous arrays</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>x1real <span class="op">=</span> np.array([[ <span class="fl">0.091</span>,  <span class="fl">0.167</span>,  <span class="fl">0.231</span>,  <span class="fl">0.083</span>,  <span class="fl">0.154</span>],</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>                   [ <span class="fl">0.364</span>,  <span class="fl">0.333</span>,  <span class="fl">0.308</span>,  <span class="fl">0.333</span>,  <span class="fl">0.308</span>],</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>                   [ <span class="fl">1.</span>   ,  <span class="fl">1.</span>   ,  <span class="fl">1.</span>   ,  <span class="fl">1.</span>   ,  <span class="fl">1.</span>   ]])</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>x2real <span class="op">=</span> np.array([[ <span class="fl">0.42</span> ,  <span class="fl">0.537</span>,  <span class="fl">0.645</span>,  <span class="fl">0.431</span>,  <span class="fl">0.538</span>],</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>                   [ <span class="fl">0.389</span>,  <span class="fl">0.375</span>,  <span class="fl">0.362</span>,  <span class="fl">0.357</span>,  <span class="fl">0.345</span>],</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>                   [ <span class="fl">1.</span>   ,  <span class="fl">1.</span>   ,  <span class="fl">1.</span>   ,  <span class="fl">1.</span>   ,  <span class="fl">1.</span>   ]])</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> triangulate( x1real.T, x2real.T, P1, P2 )</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>X <span class="op">/=</span> X[<span class="dv">3</span>]</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>x1 <span class="op">=</span> np.dot(P1[:<span class="dv">3</span>],X)</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>x2 <span class="op">=</span> np.dot(P2[:<span class="dv">3</span>],X)</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>x1 <span class="op">/=</span> x1[<span class="dv">2</span>]</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>x2 <span class="op">/=</span> x2[<span class="dv">2</span>]</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;X&#39;</span>, X)</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;x&#39;</span>, x1)</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;x2&#39;</span>, x2)</span></code></pre></div>
<pre class="text"><code>X [[ 1.00277411  2.00859585  3.01259205  1.00350223  2.01053989]
 [ 4.01217675  4.01023497  4.01743619  4.02955748  4.01893278]
 [11.01977032 12.02833872 13.04162674 12.0914948  13.05493008]
 [ 1.          1.          1.          1.          1.        ]]
x [[0.09099773 0.16698863 0.23099818 0.0829924  0.15400618]
 [0.36408896 0.33339891 0.30804717 0.33325553 0.3078479 ]
 [1.         1.         1.         1.         1.        ]]
x2 [[0.4200205  0.53709008 0.64501081 0.43105574 0.5379661 ]
 [0.38890029 0.37453124 0.36194221 0.35671322 0.34517828]
 [1.         1.         1.         1.         1.        ]]</code></pre>
<p>Ana problemimize dönelim; şimdi ikinci kamera için ayrıştırmadan elde
edilen <span class="math inline">\(R,t\)</span> sonuçlarını kamera
matrisi <span class="math inline">\(K\)</span> ile çarparak <span
class="math inline">\(P_2\)</span> oluşturulmak lazım (<span
class="math inline">\(P_1\)</span> birim matrisi, o biliniyor), ve
böylece her imaj nokta eşleri için üçgenleme yapacağız. Fakat 8. derste
bahsedildiği gibi <span class="math inline">\(E\)</span>’nin
ayrıştırmasından dört türlü farklı <span
class="math inline">\(R,t\)</span> olasılığı ortaya çıkıyor, bu
sonuçların her biri denenmeli. Altta bunu yapıyoruz, yani her seçenek
için bir üç boyutta tekrar oluşturma yapacağız, ve sonuçları farklı
grafiklerde göstereceğiz.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i,P <span class="kw">in</span> <span class="bu">enumerate</span>(((R1,t),(R1,<span class="op">-</span>t),(R2,t),(R2,<span class="op">-</span>t))):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    P1 <span class="op">=</span> K.dot(np.hstack(P))</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    P00 <span class="op">=</span> np.float64([ [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>                       [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>],</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>                       [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>]])</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    P0 <span class="op">=</span> K.dot(P00) </span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> triangulate(pts1, pts2, P0, P1)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, subplot_kw<span class="op">=</span>{<span class="st">&#39;projection&#39;</span>: <span class="st">&#39;3d&#39;</span>})</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    ax.plot(X[<span class="dv">0</span>], X[<span class="dv">2</span>], X[<span class="dv">1</span>], <span class="st">&#39;r.&#39;</span>)</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    ax.view_init(elev<span class="op">=</span><span class="fl">23.</span>, azim<span class="op">=-</span><span class="dv">67</span>)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    plt.savefig(<span class="st">&#39;vision_20recons_03_</span><span class="sc">%d</span><span class="st">.png&#39;</span> <span class="op">%</span> i)</span></code></pre></div>
<p><img src="vision_20recons_03_0.png" /></p>
<p><img src="vision_20recons_03_1.png" /></p>
<p><img src="vision_20recons_03_2.png" /></p>
<p><img src="vision_20recons_03_3.png" /></p>
<p>Galiba alt sağdaki resim Alkatraz’a daha çok benziyor. Gerçek dünya
uygulamalarında “kamera önüne düşen en çok nokta hangisinde’’ gibi ek
kodlar geliştirip gerçek 3D sonucu bu şekilde elenebiliyor.</p>
<p>Kaynaklar</p>
<p>[1] Zisserman, <em>Multiple View Geometry in Computer Vision 2nd
Edition</em></p>
<p>[2] Bayramlı, <em>Resim 1</em>,
[https://www.dropbox.com/scl/fi/fy280cfv76a0wqhm08zf6/alcatraz1.jpg?rlkey=837qf9yvut7v0ha25q5qfm6gb&amp;st=th3vk7f5&amp;raw=1)</p>
<p>[3] Bayramlı, <em>Resim 2</em>,
[https://www.dropbox.com/scl/fi/mtqme2tbkfogoryxhjeg5/alcatraz2.jpg?rlkey=wn153s6fjoppjizw2619p1wt6&amp;st=c0s25ki8&amp;raw=1)</p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
