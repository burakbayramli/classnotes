<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  
  
  
  
</head>
<body>
<h1 id="ders-1">Ders 1</h1>
<p>Ders kitabımız Ma, Soatto, Kosecka, ve Sastry'nin {} kitabıdır. Videolar [1] adresinde. Dersin ana odağı kameradan gelen iki boyuttaki görüntüleri birleştirerek o görüntülerin geldiği dünyanın 3 boyutlu modelini oluşturmak.</p>
<p>Bilgisayar kontrollü arabalar bugünlerde çok konuşuluyor, bu arabalar etrafını nasıl algılıyor acaba? İnsan gibi mi davranıyorlar? Bu soruya kısa cevap hayır. [2015 itibariyle] bu arabalar aslında Lidar adı verilen lazer bazlı uzaklık ölçüm algılayıcıları kullanıyorlar (bu kelime ışık -light- ile radar kelimelerinin birleşimi), etraflarına lazer ışığı yollayıp yansımayı alıyorlar, ve bunu çok yüksek çözünürlük ile yapıyorlar, sonuç olarak dış dünya hakkında çok detaylı bilgileri var. Fakat biz insan olarak biliyoruz ki sadece görüntü ile araba kullanmak mümkün, çünkü insanlar Lidar'a sahip değil. Bunu nasıl yapıyoruz?</p>
<p>Bazıları stereo görüş (stereo vision) ile bunu yapabildiğimizi söylüyor fakat bir gözümüzü kapatsak tek gözümüz ile bile araba kullanabiliriz. İnsanlar aslında şunu beceriyor; hareket ederken farklı açılardan gördüğümüz objelerin 3 boyutlu yerini hesaplayabilmek. Bu işi iyi yapıyoruz, hatta bilim adamlarına göre zihinsel işlem gücümüzün neredeyse yarısı görüntü işlemekle haşır neşir! Peki bu hesap nasıl yapılıyor?</p>
<p>Bir binaya bakalım, şimdi birkaç adım atarak tekrar bakalım, bina iki boyutlu görüntümüz içinde, yani gözümüzde, farklı bir yere gelmiş olacak. Bu fark, attığımız adım, o binanın büyüklüğü, ve yeri ile orantılı bir fark. Solumuzda ve çok ileride olan bir obje ona yaklaştıktan sonra gözümüzde çok az sola kayma oluşturabilir, sağımızda çok yakınımızda olan bir obje ona doğru ilerlerken ve yanından geçerken çok hızlı bir şekilde gözümüzdeki resimde sağa doğru kayar. Eğer yeterince adım atıp o binanın, objenin yeterince değişik görüntüsünü alırsak, ve kuvvetli algoritmalar kullanarak bina hakkında üç boyutlu bir şekil oluşturmuş oluruz. Hareketten Yapı Oluşturmak (Structure from Motion -SfM-) bilim dalının yapmaya uğraştığı işte budur, SfM bu derslerin ana amacı olacaktır.</p>
<p>Altta örnek olarak Alkatraz adasının iki değişik açıdan çekilmiş resmini görüyoruz.</p>
<p><img src="alcatraz1.png" /> <img src="alcatraz2.png" /></p>
<p>Biri daha uzaktan, biri daha yakından, büyük bir ihtimalle adaya yaklaşmakta olan bir tekne üzerinden aynı kişi tarafından çekilmiş. SfM için önce her iki resim üzerinde o resimlerin özelliklerini (features) çıkartan bir algoritma kullanırız (alttaki örnekte SURF kullandık, bir diğer alternatif SIFT). Daha sonra bu özelliklerin her iki resim arasında eşleştirilmesini sağlayan bir diğer algoritma kullanırız, böylece onların hangi yöne kaymış olduklarını anlayabiliriz. SURF hakkında daha fazla detay bu yazının altında. Eşleştirmeleri 1. resim üzerinde görsel olarak gösterirsek (kırmızı nokta ilk resimden, yeşil nokta ikinci resimden),</p>
<div class="figure">
<img src="alcatraz3.png" />

</div>
<p>Yani kamera hareketini, ve hareketin resim üzerinde nasıl bir değişim yarattığının bulabiliyoruz. Muhakkak 1. resimdeki tüm özellik noktalarının 2. resimde nerede olduğu mükemmel bir şekilde bulunamamış olabilir, ama bu &quot;gürültü'' içerisinden bir model çıkartmak SfM'in bir parçası olacaktır.</p>
<p>İlk önce Lineer Cebir'den bazı kavramları hatırlayalım.</p>
<p>Uzaylar</p>
<p>Her tür kavram için akılda tek bir örnek tutmak iyi oluyor; Vektör uzayı için mesela <span class="math inline">\(\mathbb{R}^3\)</span>, altuzay (subspace) için ise bu uzay içindeki bir düzlem (plane) olabilir. Bu düzlemin orijinden (0,0,0) noktasından geçmesi gerekir.</p>
<p>Bazlar</p>
<p>Sonsuz tane baz olabilir, mesela <span class="math inline">\(\mathbb{R}^3\)</span> için. Örnek, kordinat eksenleri bir bazdır, onları, birbirine dikgen olma şartıyla, pek çok değişik şekilde seçebilirim.</p>
<p>Bir bazı oluşturan vektörlerin lineer kombinasyonunu alarak bir başka baz oluşturabilirim. Buna baz transformasyonu deniyor. Baz <span class="math inline">\(B = \{ b_1,..,b_n\}\)</span> olsun, yeni bir baz <span class="math inline">\(b_j&#39; \in B&#39;\)</span>,</p>
<p><span class="math display">\[ b_j&#39; = \sum_{j=1}^{n} \alpha_{ji}b_j \]</span></p>
<p>ki <span class="math inline">\(\alpha_{ji}\)</span> özgün bir transformasyonu temsil eden transformasyon katsayıları olacaktır.</p>
<p>Katsayıları bir matris <span class="math inline">\(A\)</span> içine koyarsak bu matrisi bir transformasyon matrisi olarak kullanabiliriz,</p>
<p><span class="math display">\[ B&#39; = BA \iff B = B&#39;A^{-1} \]</span></p>
<p>Baz transformasyonu çok faydalı çünkü 3 boyutlu dünyayı oluştururken onu hangi şekilde oluşturacağız? Artık biliyoruz ki hiçbir model, temsiliyet özgün değil. Mesela kameranın ardı ardına aldığı resimleri birleştiriyoruz, fakat baz aldığımız kameranın yeri sürekli değişiyor, bu sırada bazı değiştirmemiz gerekebiliyor. Ya da, yeri değişmeyen tek bir &quot;referans temsiliyet'' baz alarak ona dönük transformasyon yapmak gerekebiliyor.</p>
<p>İçsel / Noktasal Çarpım (Inner / Dot Product)</p>
<p>İki vektörün noktasal çarpımı <span class="math inline">\(\langle u,v \rangle\)</span>. Norm, yani <span class="math inline">\(v\)</span> vektörünün uzunluğu ile noktasal çarpım arasında bir ilişki var, <span class="math inline">\(|v| = \sqrt{\langle v,v \rangle}\)</span>.</p>
<p>Tabii ki <span class="math inline">\(\langle v,v \rangle \ge 0\)</span> yani pozitif kesin.</p>
<p>İki vektör arasındaki mesafeyi bir tür norm hesabı ile yapabilirim,</p>
<p><span class="math display">\[ d(v,w) = |v - w| = \sqrt {\langle v-w, v-w \rangle }  \]</span></p>
<p>Yani iki vektörün farkının normu bu iki vektör arasındaki mesafeyi verir.</p>
<p>Üstteki mümkün ölçevlerden (metric) sadece biri, farklı ölçevler olabilir, mesela 2D iki nokta arasında Manhattan mesafesi kullanılabilir,</p>
<div class="figure">
<img src="manhattan.png" />

</div>
<p>Bu mesafeye Manhattan deniyor çünkü Manhattan bilindiği gibi New York'un üzerinde pek çok gökdeleni olan bir adası, ve bir noktadan diğerine gitmek için binaların etrafından dolaşarak gitmemiz gerekiyor, direk pat diye dümdüz istediğimiz noktaya gidemiyoruz. Düz mesafe Öklitsel (Euclidian) olurdu.</p>
<p>Üstte noktasal çarpım üzerinden bir eşleme (<span class="math inline">\(V\)</span> diyelim) yaratmış olduk aslında, bu durumda <span class="math inline">\(V\)</span> bir ölçev uzayı haline geldi. Bu uzay noktasal çarpımla yaratıldığı için bu sebeple ona bir Hilbert Uzayı deniyor (detaylar için [2] notları). Her ölçek uzayı noktasal çarpım üzerinden yaratılmayabilir, mesela bir ezber tablo üzerinde bile bir mesafe eşlemesi yaratırdım, bu bir tür ölçev olurdu, ama bu ölçev noktasal çarpım olmadığı için ortaya bir Hilbert Uzayı çıkmazdı.</p>
<p>Doğal Baz</p>
<p><span class="math inline">\(I_n\)</span> ile <span class="math inline">\(n \times n\)</span> boyutunda birim matrise doğal baz (canonical basis) ismi veriliyor. Diyelim bu bazdan diğer bir baz <span class="math inline">\(B&#39;\)</span>'ye <span class="math inline">\(A\)</span> ile geçiş yapabiliyoruz, ve <span class="math inline">\(\langle x,y \rangle\)</span>'nin bu bazda nasıl gözükeceğini merak ediyoruz,</p>
<p><span class="math display">\[ \langle x&#39;,y&#39; \rangle = x&#39;^Ty&#39; = 
(Ax)^T (Ay) = x^TA^TAy = {\langle x&#39;,y&#39; \rangle}_{A^T A}
 \]</span></p>
<p>Eşitliğin en sağ tarafı notasyonel bir ek. Bu çarpıma doğuşturucu (induced) içsel çarpım ismi veriliyor, doğuşturucu kelimesi kullanılmış çünkü yeni bazın &quot;etkisi'' ile ortaya çıkan, &quot;doğan'' bir içsel çarpım bu.</p>
<p>Dikgenlik</p>
<p>Eğer <span class="math inline">\(\langle x,y \rangle = 0\)</span> ise <span class="math inline">\(x,y\)</span> birbirine dikgen demektir.</p>
<p>Bir bazın, yani o bazı temsil eden vektörlerin birbirine dikgen olması gerekmez. Ama bu durum var ise, faydalıdır.</p>
<p>Kronecker Çarpımı</p>
<p><span class="math inline">\(A\)</span> herhangi bir matris olabilir, illa karesel olması gerekmez, <span class="math inline">\(A \in \mathbb{R}^{m \times n }\)</span> ve <span class="math inline">\(B \in \mathbb{R}^{k \times l }\)</span>. Çarpım şöyle,</p>
<p><span class="math display">\[ A \otimes B =  
\left[\begin{array}{ccc} 
a_{11}B &amp; \dots &amp; a_{1n}B \\ 
\vdots &amp; \ddots &amp; \vdots \\
a_{m1}B &amp; \dots &amp; a_{mn}B
\end{array}\right]
\]</span></p>
<p>Yani <span class="math inline">\(A\)</span>'nin her öğesi <span class="math inline">\(B\)</span>'nin <em>tamamı</em> ile çarpılıyor ve bu sonuçlar yanyana, üst üste diziliyor. Bu tabii ki devasa yeni bir matris ortaya çıkartır, sonuç <span class="math inline">\(A \otimes B \in \mathbb{R}^{mk \times nl}\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">A <span class="op">=</span> np.array([[<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>],[<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">5</span>]])
B <span class="op">=</span> np.array([[<span class="dv">3</span>,<span class="dv">4</span>],[<span class="dv">4</span>,<span class="dv">5</span>]])
<span class="bu">print</span> np.kron(A,B)</code></pre></div>
<pre><code>[[ 9 12 12 16 15 20]
 [12 15 16 20 20 25]
 [12 16  9 12 15 20]
 [16 20 12 15 20 25]]</code></pre>
<p>Yığma (Stacking)</p>
<p>Yine çok basit bir operasyon, <span class="math inline">\(A^S\)</span>, bir matrisin kolonlarını alıyoruz, ve her kolonu diğerinin altına gelecek şekilde koyuyoruz, ve dikey olarak çok büyük bir vektör ortaya çıkartıyor. Numpy ile,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> A
<span class="bu">print</span> A.flatten(order<span class="op">=</span><span class="st">&#39;F&#39;</span>)</code></pre></div>
<pre><code>[[3 4 5]
 [4 3 5]]
[3 4 4 3 5 5]</code></pre>
<p>Bu iki operasyondan ilginc bir yetenek elde ettik,</p>
<p><span class="math display">\[ u^T A v = ( v \otimes  u)^T A^S \]</span></p>
<p>Yani eşitliğin sol tarafı <span class="math inline">\(A\)</span>'nin öğeleri üzerinden bir lineer kombinasyon.</p>
<p>[Gruplar, Halkalar konuları atlandı]</p>
<p>Grupları matris olarak temsil etmek mümkündür, bu fikir biraz garip gelebilir, çünkü grup oldukça soyut bir kavram, ama matrisler gayet somut, sayısal kavramlar. Bunun nasıl olduğuna gelelim; çoklu bakış açıdan 3D tekrar oluşturma (reconstruction) halinde hareket halindeki bir kameranın bir eksen etrafında tüm mümkün dönüşleri bir grup oluştururlar. Nasıl? Mesela kamera 30 derece dönmüş (rotate) olsun, sonra bir 30 derece daha dönmüş olsun. Toplam 60 derece dönüşün kendisi, ayrı ayrı 30 dereceler gibi, bir dönüş sayılır. Yani dönüşler, toplam operasyonu için kapalıdır. Ayrıca her dönüşün bir tersi vardır.</p>
<p><span class="math inline">\(\mathbb{R}^2\)</span>'daki bir <span class="math inline">\(\theta\)</span> dönüşü tipik olarak</p>
<p><span class="math display">\[ A_\theta = \left[\begin{array}{rr}
\cos \theta &amp; -\sin \theta \\
\sin \theta &amp; \cos \theta
\end{array}\right] \]</span></p>
<p>şeklinde gösterilir, ki <span class="math inline">\(0 \le \theta \le 2\pi\)</span>. Üstteki matris soyut bir grubun somut olarak belirtilmiş hali, 2 boyuttaki tüm dönüşler. Yani bir grubun her üyesi somut bir matris ile ifade edilebiliyor.</p>
<p>Dönüş dışında ve yine kamera bağlamında diğer transformasyonlar vardır; mesela kameranın yerini değiştirebilirim (translation). Dönüş ile beraber bu hareket te bir grup oluşturur, çünkü üç eksende ileri geri hareket, üç eksende dönüş, toplam 6 boyutlu bir grup ortaya çıkar, ya da &quot;serbestlik derecemiz 6'' diyebiliriz, ki bu grubun da bir matris temsili olacaktır.</p>
<p>Yani matris üzerinden grupları incelemiş olurum. Matrisler somuttur, onları hesapsal rutinlerde de kullanabilirim.</p>
<p>İlgin Transformasyon (Affine Transformation)</p>
<p>Hareket ettirmek bir vektör toplamıdır, döndürmek / rotasyon matris çarpımıdır (eğer matris döndürme için tasarlammışsa), bir araya koyarsak,</p>
<p><span class="math inline">\(L: \mathbb{R}^n \to \mathbb{R}^n\)</span>, <span class="math inline">\(A \in GL(n)\)</span> ve <span class="math inline">\(b \in \mathbb{R}^n\)</span> olmak uzere</p>
<p><span class="math display">\[ L(x) = Ax + b \]</span></p>
<p>işlemini tanımlayabiliriz, bu bir ilgin transformasyondur. Verilen bir <span class="math inline">\(x\)</span> vektörünün yerini değiştirir ve döndürür. Tabii <span class="math inline">\(A\)</span> tersi alınabilir (invertible) bir matris olmalıdır çünkü bu işlemin tersini de alabilmek isterim, <span class="math inline">\(A\)</span> tersi alınabilir olmasaydı tüm transformasyon tersi alınabilir olmazdı.</p>
<p>Dikkat: eğer <span class="math inline">\(b=0\)</span> değilse, <span class="math inline">\(L\)</span> bir lineer transformasyon olamaz (bu cebirsel olarak kontrol edilebilir, mesela <span class="math inline">\(x+y\)</span> vektörünün ilgin transformasyonu, sonuç içinde <span class="math inline">\(2b\)</span> olur tek <span class="math inline">\(b\)</span> değil), fakat bu işlemi boyut büyüterek bir lineer transformasyon haline getirebiliriz. Bu arada, bu boyut büyütme işlemini bu derste çok kullanacağız. Bu işlem şöyle; bir <span class="math inline">\(x\)</span> vektörünü alıyoruz, altına '1' ekliyoruz. Bu işleme &quot;homojen kordinata çevirmek'' ismi veriliyor. Bu işlem ardından <span class="math inline">\(L(x)\)</span>'i</p>
<p><span class="math display">\[ \left[\begin{array}{rr}
A &amp; b \\ 0 &amp; 1
\end{array}\right]
\left[\begin{array}{r}
x \\ 1
\end{array}\right]
\]</span></p>
<p>olarak temsil edebiliriz, yani tek bir matris çarpımıyla. Üstteki işlem sonucunun <span class="math inline">\(Ax+b\)</span> ile aynı olduğu kontrol edilebilir.</p>
<p>Homojen kordinata çevirerek ilgin transformasyonu bir lineer transformasyon haline getirmiş olduk. Bu numara işimize yarayacak, dersin ilerisinde göreceğiz, pek çok kez kamera açısı, yer değişimini hesaplamak gerekecek, ve bunun için lineer cebir kullanmak istiyoruz [lineer cebirin çarpım işlemini yani] ve bu numarayla bu kullanım mümkün oluyor.</p>
<p>Üstteki matrislerden solda olanı ilgin matris; bu matris ayrıca tersi alınabilir bir matris, eğer <span class="math inline">\(A\)</span> da böyle ise.</p>
<p>Ilgin matrisler grubu lineer <span class="math inline">\(GL(n+1)\)</span>'in bir alt grubunu oluşturur. Alt grup olduklarını ispatlamak için grubun çarpım operasyonu için kapalı olduğunu, ve tersi alınabilir olduğunu ispatlamak gerekir.</p>
<p>Dikgen Grup (Orthogonal Group)</p>
<p>Bu grubu tanıştırmanın pek çok yolu var, bizim seçeceğimiz yol, eğer <span class="math inline">\(A \in M(n)\)</span> üzerinden transformasyon noktasal çarpımı muhafaza ediyorsa, yani değiştirmiyorsa, yani</p>
<p><span class="math display">\[ \langle Ax, Ay \rangle = \langle x,y \rangle,  
\qquad \forall x,y \in \mathbb{R}^n
\]</span></p>
<p>Noktasal çarpım hesabının hatırlayacağımız üzere iki vektör arasındaki açıyı hesaplamak ile yakından bir bağlantısı var. Yani iki vektörü <span class="math inline">\(A\)</span> ile çarpmak o vektörler arasındaki açıyı değiştirmiyor. İspat için</p>
<p><span class="math display">\[ \langle Ax, Ay \rangle = x^T A^TA y = x^Ty \]</span></p>
<p>çünkü <span class="math inline">\(A^TA = AA^T = I\)</span>. Lineer Cebir kaynaklarında dikgenlik tanımı için çoğunlukla bu devriği ile çarpımın birim matrise eşit olması kavramının kullanıldığını görürsünüz; bana göre bu tanım akılda canlandırmak için yeterli değil, üstte gördüğümüz &quot;<span class="math inline">\(A\)</span> ile çarpımın iki vektörün arasındaki açıyı değiştirmiyor olduğu'' tanımı başlangıç noktası olarak akılda canladırmakta daha faydalı. Dikgen grup (<span class="math inline">\(A\)</span> yerine <span class="math inline">\(R\)</span> kullanalım artık)</p>
<p><span class="math display">\[ O(n) = \{ R \in GL(n) \mid R^TR = I \} \]</span></p>
<p><span class="math inline">\(GL\)</span> bir genel lineer grup notasyonu. Devam edelim, bir dikgen matris <span class="math inline">\(R\)</span> için</p>
<p><span class="math display">\[ \det(R^TR) = (\det(R))^2 = \det(I) = 1 \]</span></p>
<p>ki o zaman <span class="math inline">\(\det(R) \in \{\pm 1\}\)</span>.</p>
<p><span class="math inline">\(O(n)\)</span>'in bir alt grubu <span class="math inline">\(\det(R) = +1\)</span> şartını getirince tanımlanabilir, bu gruba özel dikgen grup ismi veriliyor, <span class="math inline">\(SO(n)\)</span>. Bu grup aslında tüm rotasyon matrislerini tanımlıyor; sezgisel olarak bunu görebiliriz, eğer iki vektörü dikgen matrisle transform edersem aradaki açı değişmez, ama başka bir lineer transformasyon uygularsam açının değişmeyeceği garanti değil.</p>
<p>Soru</p>
<p>Eğer <span class="math inline">\(\det(R) = -1\)</span> şartını kullansaydım başka bir alt grup elde edebilir miydim?</p>
<p>Cevap</p>
<p>Hayır, çünkü mesela</p>
<p><span class="math display">\[ 
\left[\begin{array}{rrr}
1 &amp; 0 \\ 0 &amp; -1
\end{array}\right]
 \]</span></p>
<p>matrisini düşünelim, bu matrisin determinantı -1. Ama bu matrisin devriğini kendisi ile çarparsam sonucun determinantı -1 değil.</p>
<p>Gerçek dünyada üstteki gibi bir matrisle transformasyon ne anlama gelir acaba? Bir tür aynadaki yansımayı almak.. mesela <span class="math inline">\(x\)</span> ekseninde eksi bölgedeyken artı bölgeye geçmek, bir tür &quot;çevirmek (flip)''.</p>
<p>Öklitsel Grup (Euclidian Group)</p>
<p><span class="math inline">\(R \in O(n)\)</span> ve <span class="math inline">\(T \in \mathbb{R}^n\)</span> olmak üzere (<span class="math inline">\(T\)</span> bir vektör)</p>
<p><span class="math display">\[ L: \mathbb{R}^n \to \mathbb{R}^n; x \to Rx + T \]</span></p>
<p>Üstteki tanıma uyan tüm transformasyonlar Öklitsel Grubu oluşturur. Bu grup doğal olarak ilgin grubun bir alt grubudur. Homojenleştirmek mümkündür,</p>
<p><span class="math display">\[ E(n) = 
\bigg\{
\left[\begin{array}{rrr}
R &amp; T \\ 0 &amp; 1
\end{array}\right]
\bigg |
R \in O(n), T \in \mathbb{R}^n
\bigg\}
 \]</span></p>
<p>Öklitsel Grup içinde, eğer <span class="math inline">\(R \in SO(n)\)</span> olan alt grubu alırsam (yani <span class="math inline">\(\det R = 1\)</span>), o zaman özel Öklitsel Grup <span class="math inline">\(SE(n)\)</span>'i elde ederim. Bu grup önemli bir grup, çünkü bu grubun <span class="math inline">\(SE(3)\)</span> formu, fizikte katı gövde hareketi (rigid-body motion) diye bilinen hareketi modellememize izin veriyor, ki kameramızın hareketini bu grupla modelleyeceğiz; katı gövde normal bildiğimiz cisimler (hareket ederken kütlesi şekil değiştirmeyen).</p>
<p>Özet olarak</p>
<p><span class="math display">\[ SO(n) \subset O(n) 
\subset GL(n)
\subset SE(n) 
\subset E(n)
\subset A(n) 
\subset GL(n+1)
\]</span></p>
<p>ki <span class="math inline">\(\subset\)</span> altküme sembolüdür.</p>
<p><span class="math inline">\(GL(n)\)</span>, genel lineer grup, tüm tersi alınabilir matrisler. <span class="math inline">\(O(n)\)</span> dikgen matrisler, ayna imajı, dönüşümler için. <span class="math inline">\(SO(n)\)</span> özel dikgen grup ki dikgen matrisin determinantının +1 olduğu durum. <span class="math inline">\(GL(n+1)\)</span> genel lineer grubun homojenleştirilmiş hali. Onun alt kümesi <span class="math inline">\(A(n)\)</span> ki bu kümede <span class="math inline">\(R,T\)</span> gelişigüzel matrisler. <span class="math inline">\(A(n)\)</span>'in altkümesi <span class="math inline">\(E(n)\)</span>, bu durumda <span class="math inline">\(R\)</span> dikgen olmalı. Onun altkümesi için özel Öklitsel grup, ki katı gövde transformasyonu burada.</p>
<p>Çekirdek (Kernel), Menzil (Range)</p>
<p>Aslında çekirdek sıfır uzayı (nullspace), menzil ise kapsam (span) aynı şey. Daha fazla detay için [3] notları.</p>
<p>Menzil ve sıfır uzayı kavramları bir lineer denklem sistemini çözerken faydalı. Hatırlayacağımız üzere <span class="math inline">\(Ax = b\)</span> denklem sisteminin çözüm bağlamında 3 seçeneği vardır; ya hiç çözüm yoktur, ya tek çözüm vardır, ya da sonsuz tane çözüm vardır. Bunlardan hangisinin olacağı menzil ve sıfır uzayına bağlıdır.</p>
<p><span class="math inline">\(Ax=b\)</span>'nin, ki <span class="math inline">\(x \in \mathbb{R}^n\)</span> olacak şekilde, sadece ve sadece <span class="math inline">\(b \in range(A)\)</span> ise çözümü vardır. Bu çözüm özgündür eğer <span class="math inline">\(kernel(A) =\{0\}\)</span> ise, yani sıfır uzayı boş ise (sıfır haricinde boş tabii). Ayrıca eğer <span class="math inline">\(x_s\)</span> bir çözüm ise ve <span class="math inline">\(x_o \in kernel(A)\)</span> olacak şekilde ise, o zaman <span class="math inline">\(x_s + x_0\)</span> da bir çözümdür. yani <span class="math inline">\(A(x_s+x_0) = Ax_s + Ax_o = b\)</span>.</p>
<p>Algoritma şöyle; elimdeki vektör <span class="math inline">\(A\)</span>'nin menzilinde mi? Evet ise o zaman elimde bir çözüm var (hatta bu çıkarım neredeyse kendi etrafında dönmeye benziyor, menzil tanım itibariyle zaten <span class="math inline">\(A\)</span>'nin tüm lineer kombinasyonlarıdır), bundan sonra sıfır uzayına bakarız, boş mu? Öyleyse elimizdeki çözüm özgündür. Eğer sıfır uzayı boş değilse, bu uzaydaki her öğe <span class="math inline">\(x_0\)</span> üzerinden <span class="math inline">\(x_s+x_0\)</span> da bir çözümdür. Niye? Çünkü <span class="math inline">\(x_0\)</span> sıfır uzayında olduğu için <span class="math inline">\(Ax_0 = 0\)</span>, o zaman <span class="math inline">\(Ax_s + \cancel{Ax_0} = b\)</span>, ve bu durumda sonsuz tane çözüm olacaktır, çünkü <span class="math inline">\(x_0\)</span>'i istediğim sabitle çarpıp büyütebilirim, o hala sıfır uzayında olur.</p>
<p>Kerte (Rank)</p>
<p>Bir matrisin kertesi o matrisin menzilinin boyutudur.</p>
<p>Sylvester'in eşitsizliği</p>
<p><span class="math inline">\(A \in \mathbb{R}^{m \times n}, B \in \mathbb{R}^{n \times k}\)</span> olsun. O zaman</p>
<p><span class="math display">\[ rank(A) + rank(B) - n \le rank(AB) \le \min(rank(A),rank(B)) \]</span></p>
<p>Yani <span class="math inline">\(A,B\)</span>'nin kertesi üzerinden bu iki matrisin çarpımının kertesi hakkında bir fikir edinebiliyorum.</p>
<p>Eğer elimde iki eşsiz olmayan (nonsingular), yani tersi alınabilir matris var ise, diyelim <span class="math inline">\(C \in \mathbb{R}^{m \times m}, D \in \mathbb{R}^{n \times n}\)</span>, o zaman <span class="math inline">\(rank(A) = rank(CAD)\)</span>, yani eşsiz olmayan matrisler ile çarpım kerteyi değiştirmiyor.</p>
<p>SURF</p>
<p>İmajlardan özellik çıkartıp bunları eşleştireceğiz demiştik; SURF algoritması özellik bulabilen yaklaşımlardan biri. SURF resimde köşe olarak betimlenebilecek, ya da diğer ilginç yerlere odaklanıyor, bu bölgelerin yeri, genel rengi, resmin bütününe göre açısı, vs. hesaplanıyor. İmajda bu tür yerler keşfedilince, SURF onları 64 öğesi olan bir vektör olarak temsil eder, ve bu vektöre &quot;tarif edici (descriptor)'' adı verilir. Bu vektördeki değerler o özelliği özgün olarak temsil ederler.</p>
<p>SURF ve SİFT yaklaşımları genel kategori olarak görüntü işleme (image processing) alanına girerler, bu alandaki diğer yaklaşımlar mesela kenar keşfi (edge detection), köşe (corner) keşfi -Harris algoritması burada ünlü-, imajdan bulanıklık giderme gibi işlemlerdir.</p>
<p>Altta 1. Alkatraz resmindeki SURF noktalarını görebiliriz.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> mahotas.features <span class="im">import</span> surf
<span class="im">import</span> pandas <span class="im">as</span> pd
<span class="im">from</span> PIL <span class="im">import</span> Image

im<span class="op">=</span>Image.<span class="bu">open</span>(<span class="st">&quot;alcatraz1.pgm&quot;</span>)
descriptors <span class="op">=</span> pd.DataFrame(surf.surf(np.array(im)))
<span class="bu">print</span> descriptors.shape</code></pre></div>
<pre><code>(461, 70)</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">descriptors.plot(kind<span class="op">=</span><span class="st">&#39;scatter&#39;</span>,x<span class="op">=</span><span class="dv">1</span>,y<span class="op">=</span><span class="dv">0</span>)
plt.hold(<span class="va">True</span>)
plt.imshow(im,cmap <span class="op">=</span> plt.get_cmap(<span class="st">&#39;gray&#39;</span>))
plt.savefig(<span class="st">&#39;vision_02_01.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="vision_01_01.png" />

</div>
<p>Üstteki imajın mesela ilk SURF vektörünün içeriğine bakarsak (sadece ilk 10 öğesi)</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> descriptors.ix[<span class="dv">0</span>][:<span class="dv">10</span>]</code></pre></div>
<pre><code>0     226.943034
1     339.099974
2       2.125709
3    1477.629660
4      -1.000000
5      -0.029199
6       0.003429
7       0.000933
8       0.003470
9       0.001833
Name: 0, dtype: float64</code></pre>
<p>İlk iki hücre özelliğin yeridir (x,y kordinatı olarak), tarif edici bölge ise 6. hücreden başlar, ve 64 tane vardır.</p>
<p>Peki eşleştirmenin başarılı olması ne kadar garantidir? Cevap için yazının başındaki örneğe dönelim tekrar, mesela bir binaya bakıyorum, SURF işletiyorum, sonra adım atıp aynı binaya tekrar bakıyorum (daha doğrusu bakar halde adım atıyorum). Büyük bir ihtimalle bina iki adım arasında mor rengine dönüşmedi. Hala beyaz renkte, hala kapısı, penceresi aynı şekilde, aynı yerlerde duruyor. O zaman ikinci imaj üzerinde bir daha SURF işletirsem, benzer özelliklerin çıkartılıyor olmasını beklerim, yani tarif edici bölgeleri birbirine çok benzeyen özellik vektörleri elde etmem lazım. Kullanılan ana numara da bu zaten; birinci imajın özelliklerinin tarif edici bölgeleri (vektörlerini) ikinciye eşleştiriyorum, ki bu eşleştirme basit vektör uzaklığı üzerinden olabilir; 1. resimdeki vektörlerin her biri için 2. resimden gelen vektörlerin en yakınını bulurum, ve bir eşleşme elde ederim. Bu eşleşmeleri bulduktan sonra imajdaki piksellerin hangi yöne hareket ettiği hakkında bir fikir edinmiş oluyorum, çünkü mesela, belli bir tarif bloğuna sahip bir bölge (10,10) kordinatından (12,12) kordinatına gitmiş olsun - bu önemli bir bilgi. Bu bilgiyi kendi hareketim, kamera açısı, ve diğer imajlar ile birleştirince ve SfM algoritmaları uygulayarak baktığım objelerin üç boyutlu uzaydaki yerlerini hesaplayabilirim.</p>
<p>Kaynaklar</p>
<p>[1] Cremers, <em>Multiple View Geometry</em>, <a href="https://www.youtube.com/watch?v=RDkwklFGMfo&amp;list=PLTBdjV_4f-EJn6udZ34tht9EVIW7lbeo4" class="uri">https://www.youtube.com/watch?v=RDkwklFGMfo&amp;list=PLTBdjV_4f-EJn6udZ34tht9EVIW7lbeo4</a></p>
<p>[2] Bayramlı, Fonksiyonel Analiz</p>
<p>[3] Bayramlı, Lineer Cebir</p>
</body>
</html>
