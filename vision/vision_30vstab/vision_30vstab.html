<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>İki Boyut Nokta Eşleşmesi, Homografi, Video Stabilizasyonu</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="iki-boyut-nokta-eşleşmesi-homografi-video-stabilizasyonu">İki
Boyut Nokta Eşleşmesi, Homografi, Video Stabilizasyonu</h1>
<p>Oldukça çok ortaya çıkan bir imaj işleme problemi şudur: elimizde iki
nokta grubu var, bu noktaların arasındaki eşleşmeyi biliyoruz. Öyle bir
<span class="math inline">\(H\)</span> ilişkisi bulmak istiyoruz ki
verili <span class="math inline">\(x\)</span> noktasınının (homojen)
kordinatını <span class="math inline">\(x&#39;\)</span> noktasına
taşısın, yani eldeki her veri noktasının ima ettiği eşleşmeyi
bulsun.</p>
<p>Örnek</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>x1 <span class="op">=</span> [[<span class="fl">25.8064516129</span>,<span class="fl">25.0</span>],[<span class="fl">23.87096</span>,<span class="fl">45.625</span>],</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>      [<span class="fl">20.0</span>,<span class="fl">69.375</span>],[<span class="fl">28.387</span>,<span class="fl">92.5</span>],</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      [<span class="fl">38.709</span>,<span class="fl">116.875</span>],[<span class="fl">64.5161290323</span>,<span class="fl">115.0</span>],</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      [<span class="fl">64.516</span>,<span class="fl">89.375</span>],[<span class="fl">65.16</span>,<span class="fl">66.875</span>],</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      [<span class="fl">57.4193</span>,<span class="fl">45.0</span>],[<span class="fl">45.80645</span>,<span class="fl">23.75</span>]]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>x2 <span class="op">=</span> [[<span class="fl">93.548</span>,<span class="fl">66.25</span>],[<span class="fl">114.838</span>,<span class="fl">110.0</span>],</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>      [<span class="fl">138.709</span>,<span class="fl">153.125</span>],[<span class="fl">182.580</span>,<span class="fl">179.375</span>],</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>      [<span class="fl">241.935</span>,<span class="fl">204.375</span>],[<span class="fl">276.77</span>,<span class="fl">163.75</span>],</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>      [<span class="fl">254.193</span>,<span class="fl">123.125</span>],[<span class="fl">212.903</span>,<span class="fl">73.125</span>],</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>      [<span class="fl">158.064</span>,<span class="fl">54.375</span>],[<span class="fl">120.6451</span>,<span class="fl">40.625</span>]]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>x1 <span class="op">=</span> np.array(x1)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>x2 <span class="op">=</span> np.array(x2)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>plt.plot(x1[:,<span class="dv">0</span>], x1[:,<span class="dv">1</span>], <span class="st">&#39;rd&#39;</span>)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>plt.plot(x2[:,<span class="dv">0</span>], x2[:,<span class="dv">1</span>], <span class="st">&#39;bd&#39;</span>)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">0</span>,<span class="dv">320</span>)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="dv">0</span>,<span class="dv">240</span>)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;vision_30vstab_02.png&#39;</span>)</span></code></pre></div>
<p><img src="vision_30vstab_02.png" /></p>
<p>Yani kırmızı noktaları mavi noktalara çeviren ilişkiyi arıyoruz. Bu
transformasyonda ne var? Sağa doğru bir yer değiştirme (translation),
ölçekleme (scaling), ve saat yönüne doğru bir döndürme (rotation). Bu
tür 2D-2D ilişkilerine homografi adı veriliyor. Aradığımız alttaki
türden bir formül [3],</p>
<p><span class="math display">\[ x&#39; = H x\]</span></p>
<p>yani her <span class="math inline">\(x\)</span> noktası <span
class="math inline">\(H\)</span> üzerinden <span
class="math inline">\(x&#39;\)</span> haline gelecek. <span
class="math inline">\(H\)</span> matrisi homojen kordinatları baz
alır,</p>
<p><span class="math display">\[
\left[\begin{array}{r} x&#39; \\ y&#39; \\ w&#39; \end{array}\right]
\left[\begin{array}{rrr}
h_1 &amp; h_2 &amp; h_3 \\ h_3 &amp; h_4 &amp; h_5 \\ h_6 &amp; h_7
&amp; h_8
\end{array}\right]
\left[\begin{array}{r} x \\ y \\ w \end{array}\right]
\]</span></p>
<p><span class="math inline">\(H\)</span> matrisinin bazı şekilleri
vardır, mesela</p>
<p><span class="math display">\[
\left[\begin{array}{r} x&#39; \\ y&#39; \\ 1 \end{array}\right]
\left[\begin{array}{rrr}
a_1 &amp; a_2 &amp; t_x \\ a_3 &amp; a_4 &amp; t_y \\ 0 &amp; 0 &amp; 1
\end{array}\right]
\left[\begin{array}{r} x \\ y \\ 1 \end{array}\right]
\]</span></p>
<p>Ya da matris içindeki bölgeleri vektör / matrisler ile
özetlersek,</p>
<p><span class="math display">\[
x&#39; = \left[\begin{array}{rr} A &amp; t \\ 0 &amp; 1
\end{array}\right] x
\]</span></p>
<p>Üstteki transformasyona ilgin transformasyonu (affine transformation)
deniyor, yamultma (warping) denen işlem budur. Bu transformasyon <span
class="math inline">\(w=1\)</span> şartını korur.</p>
<p>Eğer <span class="math inline">\(H\)</span> şu türden olursa,</p>
<p><span class="math display">\[
\left[\begin{array}{r} x&#39; \\ y&#39; \\ 1 \end{array}\right]
\left[\begin{array}{rrr}
s\cos(\theta) &amp; -s\sin(\theta) &amp; t_x \\
s\sin(\theta) &amp; s\cos(\theta) &amp; t_y \\
0 &amp; 0 &amp; 1
\end{array}\right]
\left[\begin{array}{r} x \\ y \\ 1 \end{array}\right]
\]</span></p>
<p>Ya da</p>
<p><span class="math display">\[
x&#39; = \left[\begin{array}{rr}
sR &amp; t \\ 0 &amp; 1
\end{array}\right] x
\]</span></p>
<p>Dönüş <span class="math inline">\(R\)</span>, taşınma <span
class="math inline">\(t\)</span>, dönme <span
class="math inline">\(\theta\)</span>, ölçekleme <span
class="math inline">\(s\)</span>. Bu transformasyona ölçeklemeye
(scaling) izin veren bir katı (rigid) transformasyon deniyor. “Katı’’
demek <span class="math inline">\(s=1\)</span>, yani noktalar arası
mesafeler değişmeyecek demek, daha büyük <span
class="math inline">\(s\)</span> ile tabii ölçekleme olabilir, mesafeler
artabilir, ama mesafe oranları yine aynı kalır, ayrıca döndürme de
-rotation- yapılabilir. Bu transformasyona yansıtsal (projective) ismi
de verilir. Yansıtsal transformasyonun ilgin transformasyondan daha
esnek / kuvvetli olduğu bilinir.</p>
<p>Not: ilgin transformasyon ve onu kestirme hesabı bazen literatürde
iki boyutlu kordinat sisteminde ve <span class="math inline">\(x&#39; =
R x + t\)</span>, yani rotasyon artı yer değişimi gibi bir formda da
görülebilir, biz homojen sisteme geçerek her ikisini aynı matris <span
class="math inline">\(H\)</span> içinde ve tek çarpım operasyonu ile
gösterebilmiş oluyoruz. Homojen, tek matrisli formda hesap yapmak daha
kolay.</p>
<p>Homografi hesabının kullanım alanları geniş; mesela elde olan iki
imaj arasında birbirine uyan noktaları biliyorsak, <span
class="math inline">\(H\)</span>’yi hesaplayarak tüm imaj üzerinde bir
değişim matrisi hesaplamış oluruz.</p>
<p>Yansıtsal <span class="math inline">\(H\)</span> hesabı için direk
lineer transform (direct linear transform -DLT-) tekniği var. Eldeki tüm
eşleşmeler için alttaki sistemi yaratırız,</p>
<p><span class="math display">\[
\left[\begin{array}{rrrrrrrrr}
-x_1 &amp; -y_1 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; x_1x_1&#39; &amp;
y_1x_1&#39; &amp; x_1&#39; \\
0 &amp; 0 &amp; 0 &amp; -x_1 &amp; -y_1 &amp; -1 &amp; x_1y_1&#39; &amp;
y_1y_1&#39; &amp; y_1&#39; \\
-x_2 &amp; -y_2 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; x_2x_2&#39; &amp;
y_2x_2&#39; &amp; x_2&#39; \\
0 &amp; 0 &amp; 0 &amp; -x_2 &amp; -y_2 &amp; -1 &amp; x_2y_2&#39; &amp;
y_2y_2&#39; &amp; y_2&#39; \\
&amp;  \vdots &amp;  &amp;  \vdots &amp;  &amp; \vdots
&amp;  &amp;  \vdots &amp;
\end{array}\right]
\left[\begin{array}{r}
h_1 \\ h_2 \\ h_3 \\ h_4 \\ h_5 \\ h_6 \\ h_7 \\ h_8 \\ h_9
\end{array}\right] = 0
\]</span></p>
<p>Bu sistem <span class="math inline">\(x&#39; - Hx = 0\)</span>
sistemini temsil etmiş oluyor, ne kadar fazla nokta olursa üstteki
matris o kadar aşağı doğru genişleyecektir (öğe ayarlaması öne göre
yapılacak tabii). Mükemmel <span class="math inline">\(H\)</span>
bulunamayabilir, ama sıfıra olabildiğince yaklaşmak için üstteki
problemi bir minimizasyon problemi olarak görürüz, SVD bu çözümü bize
sağlar.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy.linalg <span class="im">as</span> lin</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> H_from_points(fp,tp):</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> fp.shape <span class="op">!=</span> tp.shape:</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">RuntimeError</span>(<span class="st">&#39;number of points do not match&#39;</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> np.mean(fp[:<span class="dv">2</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    maxstd <span class="op">=</span> np.<span class="bu">max</span>(np.std(fp[:<span class="dv">2</span>], axis<span class="op">=</span><span class="dv">1</span>)) <span class="op">+</span> <span class="fl">1e-9</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    C1 <span class="op">=</span> np.diag([<span class="dv">1</span><span class="op">/</span>maxstd, <span class="dv">1</span><span class="op">/</span>maxstd, <span class="dv">1</span>]) </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    C1[<span class="dv">0</span>][<span class="dv">2</span>] <span class="op">=</span> <span class="op">-</span>m[<span class="dv">0</span>]<span class="op">/</span>maxstd</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    C1[<span class="dv">1</span>][<span class="dv">2</span>] <span class="op">=</span> <span class="op">-</span>m[<span class="dv">1</span>]<span class="op">/</span>maxstd</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    fp <span class="op">=</span> np.dot(C1,fp)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> np.mean(tp[:<span class="dv">2</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    maxstd <span class="op">=</span> np.<span class="bu">max</span>(np.std(tp[:<span class="dv">2</span>], axis<span class="op">=</span><span class="dv">1</span>)) <span class="op">+</span> <span class="fl">1e-9</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    C2 <span class="op">=</span> np.diag([<span class="dv">1</span><span class="op">/</span>maxstd, <span class="dv">1</span><span class="op">/</span>maxstd, <span class="dv">1</span>])</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    C2[<span class="dv">0</span>][<span class="dv">2</span>] <span class="op">=</span> <span class="op">-</span>m[<span class="dv">0</span>]<span class="op">/</span>maxstd</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    C2[<span class="dv">1</span>][<span class="dv">2</span>] <span class="op">=</span> <span class="op">-</span>m[<span class="dv">1</span>]<span class="op">/</span>maxstd</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    tp <span class="op">=</span> np.dot(C2,tp)</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    nbr_correspondences <span class="op">=</span> fp.shape[<span class="dv">1</span>]</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> np.zeros((<span class="dv">2</span><span class="op">*</span>nbr_correspondences,<span class="dv">9</span>))</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nbr_correspondences):        </span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        A[<span class="dv">2</span><span class="op">*</span>i] <span class="op">=</span> [<span class="op">-</span>fp[<span class="dv">0</span>][i],<span class="op">-</span>fp[<span class="dv">1</span>][i],<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>                    tp[<span class="dv">0</span>][i]<span class="op">*</span>fp[<span class="dv">0</span>][i],tp[<span class="dv">0</span>][i]<span class="op">*</span>fp[<span class="dv">1</span>][i],tp[<span class="dv">0</span>][i]]</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        A[<span class="dv">2</span><span class="op">*</span>i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="op">-</span>fp[<span class="dv">0</span>][i],<span class="op">-</span>fp[<span class="dv">1</span>][i],<span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>                    tp[<span class="dv">1</span>][i]<span class="op">*</span>fp[<span class="dv">0</span>][i],tp[<span class="dv">1</span>][i]<span class="op">*</span>fp[<span class="dv">1</span>][i],tp[<span class="dv">1</span>][i]]</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    U,S,V <span class="op">=</span> lin.svd(A)</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    H <span class="op">=</span> V[<span class="dv">8</span>].reshape((<span class="dv">3</span>,<span class="dv">3</span>))    </span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    H <span class="op">=</span> np.dot(lin.inv(C2),np.dot(H,C1))</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># normalize and return</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> H <span class="op">/</span> H[<span class="dv">2</span>,<span class="dv">2</span>]</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>x1h <span class="op">=</span> np.ones((<span class="bu">len</span>(x1),<span class="dv">3</span>))</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>x1h[:,:<span class="dv">2</span>] <span class="op">=</span> x1</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>x2h <span class="op">=</span> np.ones((<span class="bu">len</span>(x1),<span class="dv">3</span>))</span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>x2h[:,:<span class="dv">2</span>] <span class="op">=</span> x2</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> H_from_points(x1h.T,x2h.T)</span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> np.dot(A, x1h.T).T</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> res.T <span class="op">/</span> res[:,<span class="dv">2</span>]</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>plt.plot(x1[:,<span class="dv">0</span>], x1[:,<span class="dv">1</span>], <span class="st">&#39;rd&#39;</span>)</span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>plt.plot(x2[:,<span class="dv">0</span>], x2[:,<span class="dv">1</span>], <span class="st">&#39;bd&#39;</span>)</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>plt.plot(res.T[:,<span class="dv">0</span>], res.T[:,<span class="dv">1</span>], <span class="st">&#39;bx&#39;</span>)</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">0</span>,<span class="dv">320</span>)</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="dv">0</span>,<span class="dv">240</span>)</span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;vision_30vstab_03.png&#39;</span>)</span></code></pre></div>
<p><img src="vision_30vstab_03.png" /></p>
<p>Çarpı ile işaretli noktalar kestirme hesabı yapılan <span
class="math inline">\(H\)</span> ile kırmızı noktaların transform
edilmesiyle elde edildi. Gerçek noktalara oldukca yakın!</p>
<p>İlgin transformasyon matrisinin hesabı için üstteki metotta <span
class="math inline">\(h_7=0,h_8=0\)</span> kullanmak yeterli. Alternatif
bir yöntem de var, daha fazla detay için [3, sf. 76].</p>
<p>İmaj Bölgesi Çekip Çıkarmak</p>
<p>Üstteki tekniğin ilginç uygulamalarından biri; diyelim ki bir imajın
belli bir bölgesindeki görüntüyü eşit kenarlı olacak şekilde çekip
çıkarmak istiyorum, mesela alttaki Sudoku oyun karesini,</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> ndimage</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>im <span class="op">=</span> np.array(Image.<span class="bu">open</span>(<span class="st">&#39;sudoku81.JPG&#39;</span>).convert(<span class="st">&#39;L&#39;</span>))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>corners <span class="op">=</span> [[<span class="fl">257.4166</span>, <span class="fl">14.9375</span>], </span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>           [<span class="fl">510.8489</span>, <span class="fl">197.6145</span>], </span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>           [<span class="fl">59.30208</span>, <span class="fl">269.65625</span>], </span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>           [<span class="fl">325.598958</span>, <span class="fl">469.05729</span>]]</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>corners <span class="op">=</span> np.array(corners)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>plt.plot(corners[:,<span class="dv">0</span>], corners[:,<span class="dv">1</span>], <span class="st">&#39;rd&#39;</span>)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>plt.imshow(im, cmap<span class="op">=</span>plt.cm.Greys_r)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;vision_30vstab_04.png&#39;</span>)</span></code></pre></div>
<p><img src="vision_30vstab_04.png" /></p>
<p>Kenarları kırmızı noktalarla ben seçtim, şimdi o bölgenin alınıp eşit
kenarlı halde gösterilmesini istiyorum. Bu ne demektir? Bu seçilen her
köşe noktasının eşit kenarlı bir karenin köşelerine transform edilmesi
demektir, mesela bu köşeler <span
class="math inline">\((1,300),(300,300),..\)</span> gibi olabilir
(imajın en uç noktaları). Sonra daha önce yaptığım gibi <span
class="math inline">\(H\)</span> hesaplarım, ve o bölgedeki tüm
pikselleri alıp hesapladığım transformasyonu onlara uygularım,
<code>scipy.ndimage.geometric_transform</code> bu işi yapar.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> ndimage</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>fp <span class="op">=</span> [ [p[<span class="dv">1</span>],p[<span class="dv">0</span>],<span class="dv">1</span>] <span class="cf">for</span> p <span class="kw">in</span> corners]</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>fp <span class="op">=</span> np.array(fp).T</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>tp <span class="op">=</span> np.array([[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>],[<span class="dv">0</span>,<span class="dv">300</span>,<span class="dv">1</span>],[<span class="dv">300</span>,<span class="dv">0</span>,<span class="dv">1</span>],[<span class="dv">300</span>,<span class="dv">300</span>,<span class="dv">1</span>]]).T</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>H <span class="op">=</span> H_from_points(tp,fp)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> warpfcn(x):</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.array([x[<span class="dv">0</span>],x[<span class="dv">1</span>],<span class="dv">1</span>])</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    xt <span class="op">=</span> np.dot(H,x)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    xt <span class="op">=</span> xt<span class="op">/</span>xt[<span class="dv">2</span>]</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> xt[<span class="dv">0</span>],xt[<span class="dv">1</span>]</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>im_g <span class="op">=</span> ndimage.geometric_transform(im,warpfcn,(<span class="dv">300</span>,<span class="dv">300</span>))</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>scipy.misc.imsave(<span class="st">&#39;vision_30vstab_05.png&#39;</span>, im_g)</span></code></pre></div>
<p><img src="vision_30vstab_05.png" /></p>
<p>Video Stabilizasyonu</p>
<p>Elde tutulan kamera ile kaydedilen görüntülerde titreme çok olabilir.
Mesela şurada [1] bizim cep telefonu ile kaydettiğimiz bir örnek var. Bu
görüntüyü yazılım ile stabilize etmek mümkün mü? Cevap evet - ve çözüm
şaşırtıcı derecede basit. [4]’ün tekniği şöyle özetlenebilir: bir
video’yu baştan itibaren kare kare işlerken, her karede ilginç köşe
noktaları (Harris tekniği ile) buluruz, ve bu noktaların bir sonraki
resimdeki eşlerini elde ederiz, bu artık görüntü işlemede demirbaş
haline gelmiş bir işlem. Sonra tüm eşlemeleri kullanarak her video
karesi için bir homografi / transformasyon hesaplarız, bu transformasyon
matrisi içinde <span class="math inline">\(x,y\)</span> değişimi, yani
taşınma, ve <span class="math inline">\(a\)</span> açısı ki döndürme
bilgisi vardır. Bu bilgileri <span
class="math inline">\(dx,dy,da\)</span> olarak biriktiririz.</p>
<p>Tüm kareler işlenince başa dönüp tüm bu değişimlerin kümülatif
toplamını alarak <span class="math inline">\(x,y,a\)</span> zaman
serilerini oluştururuz. Bu zaman serileri üzerinde bir yürüyen ortalama
(moving average) hesabı yaparız, bu bize pürüzüşleştirilmiş zaman
serileri verir. Şimdi kümülatif serinin pürüzsüz seriden olan farklarını
buluruz, ve her kare için bu farkı alıp, onunla bir <span
class="math inline">\(H\)</span> oluştururuz ve bu <span
class="math inline">\(H\)</span> ile bir önceki kare üzerinde yamultma
yaparak onu “düzeltiriz’’. Bu kadar.</p>
<p>Bu teknik niye işliyor? İşliyor çünkü üstte gösterdiğimiz türde
video’larda “beklenen” bir “akış’’, bir nokta eşleşmesi var. Düz
yürüyoruz, kamera ileri dönük, ortadaki pikseller dışa doğru eşleşmeli,
sağdakiler daha sağa doğru, vs. Bu beklentiyi hareketli ortalama ile
hesaplamak mümkün, ve ondan olan sapmaları kameranın istenmeyen
titremesi olarak algılıyoruz, ve düzeltiyoruz.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/usr/bin/env python</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cv2, sys</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">len</span>(sys.argv) <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span> <span class="st">&quot;Usage: vs.py [input file]&quot;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    exit()</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>fin <span class="op">=</span> sys.argv[<span class="dv">1</span>]</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>cap <span class="op">=</span> cv2.VideoCapture(fin)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="bu">int</span>(cap.get(cv2.CAP_PROP_FRAME_COUNT))</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>fps <span class="op">=</span> <span class="bu">int</span>(cap.get(cv2.CAP_PROP_FPS))</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>status, prev <span class="op">=</span> cap.read()</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>prev_gray <span class="op">=</span> cv2.cvtColor(prev, cv2.COLOR_BGR2GRAY)</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>(h,w) <span class="op">=</span> prev.shape[:<span class="dv">2</span>]</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>last_T <span class="op">=</span> <span class="va">None</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>prev_to_cur_transform <span class="op">=</span> []</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(N<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    status, cur <span class="op">=</span> cap.read()</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    cur_gray <span class="op">=</span> cv2.cvtColor(cur, cv2.COLOR_BGR2GRAY)</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    prev_corner <span class="op">=</span> cv2.goodFeaturesToTrack(prev_gray,</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>                                          maxCorners <span class="op">=</span> <span class="dv">200</span>,</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>                                          qualityLevel <span class="op">=</span> <span class="fl">0.01</span>,</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>                                          minDistance <span class="op">=</span> <span class="fl">30.0</span>,</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>                                          blockSize <span class="op">=</span> <span class="dv">3</span>)</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>    cur_corner, status, err <span class="op">=</span> cv2.calcOpticalFlowPyrLK(prev_gray,</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>                                                       cur_gray,</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>                                                       prev_corner,</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>                                                       <span class="va">None</span>)</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>    prev_corner2 <span class="op">=</span> []</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>    cur_corner2 <span class="op">=</span> []</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i,st <span class="kw">in</span> <span class="bu">enumerate</span>(status):</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> st<span class="op">==</span><span class="dv">1</span>:</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>            prev_corner2.append(prev_corner[i])</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>            cur_corner2.append(cur_corner[i])</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>    prev_corner2 <span class="op">=</span> np.array(prev_corner2)</span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>    cur_corner2 <span class="op">=</span> np.array(cur_corner2)</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> cv2.estimateRigidTransform(prev_corner2, cur_corner2, <span class="va">False</span>)<span class="op">;</span></span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>    last_T <span class="op">=</span> T[:]</span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>    dx <span class="op">=</span> T[<span class="dv">0</span>,<span class="dv">2</span>]<span class="op">;</span></span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>    dy <span class="op">=</span> T[<span class="dv">1</span>,<span class="dv">2</span>]<span class="op">;</span></span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>    da <span class="op">=</span> np.arctan2(T[<span class="dv">1</span>,<span class="dv">0</span>], T[<span class="dv">0</span>,<span class="dv">0</span>])</span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>    prev_to_cur_transform.append([dx, dy, da])</span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>    prev <span class="op">=</span> cur[:]</span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>    prev_gray <span class="op">=</span> cur_gray[:]</span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>prev_to_cur_transform <span class="op">=</span> np.array(prev_to_cur_transform)</span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a>trajectory <span class="op">=</span> np.cumsum(prev_to_cur_transform, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a>trajectory <span class="op">=</span> pd.DataFrame(trajectory)</span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a>smoothed_trajectory <span class="op">=</span> pd.rolling_mean(trajectory,window<span class="op">=</span><span class="dv">30</span>)</span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a>smoothed_trajectory <span class="op">=</span> smoothed_trajectory.fillna(method<span class="op">=</span><span class="st">&#39;bfill&#39;</span>)</span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a>new_prev_to_cur_transform <span class="op">=</span> prev_to_cur_transform <span class="op">+</span> <span class="op">\</span></span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a>                            (smoothed_trajectory <span class="op">-</span> trajectory)</span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a>new_prev_to_cur_transform <span class="op">=</span> np.array(new_prev_to_cur_transform)</span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> np.zeros((<span class="dv">2</span>,<span class="dv">3</span>))</span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a>cap <span class="op">=</span> cv2.VideoCapture(fin)</span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a>out <span class="op">=</span> cv2.VideoWriter(<span class="st">&#39;out.avi&#39;</span>, cv2.VideoWriter_fourcc(<span class="st">&#39;P&#39;</span>,<span class="st">&#39;I&#39;</span>,<span class="st">&#39;M&#39;</span>,<span class="st">&#39;1&#39;</span>),</span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a>                      fps, (w, h), <span class="va">True</span>)</span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(N<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true" tabindex="-1"></a>    status, cur <span class="op">=</span> cap.read()</span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true" tabindex="-1"></a>    T[<span class="dv">0</span>,<span class="dv">0</span>] <span class="op">=</span> np.cos(new_prev_to_cur_transform[k][<span class="dv">2</span>])<span class="op">;</span></span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true" tabindex="-1"></a>    T[<span class="dv">0</span>,<span class="dv">1</span>] <span class="op">=</span> <span class="op">-</span>np.sin(new_prev_to_cur_transform[k][<span class="dv">2</span>])<span class="op">;</span></span>
<span id="cb5-69"><a href="#cb5-69" aria-hidden="true" tabindex="-1"></a>    T[<span class="dv">1</span>,<span class="dv">0</span>] <span class="op">=</span> np.sin(new_prev_to_cur_transform[k][<span class="dv">2</span>])<span class="op">;</span></span>
<span id="cb5-70"><a href="#cb5-70" aria-hidden="true" tabindex="-1"></a>    T[<span class="dv">1</span>,<span class="dv">1</span>] <span class="op">=</span> np.cos(new_prev_to_cur_transform[k][<span class="dv">2</span>])<span class="op">;</span></span>
<span id="cb5-71"><a href="#cb5-71" aria-hidden="true" tabindex="-1"></a>    T[<span class="dv">0</span>,<span class="dv">2</span>] <span class="op">=</span> new_prev_to_cur_transform[k][<span class="dv">0</span>]<span class="op">;</span></span>
<span id="cb5-72"><a href="#cb5-72" aria-hidden="true" tabindex="-1"></a>    T[<span class="dv">1</span>,<span class="dv">2</span>] <span class="op">=</span> new_prev_to_cur_transform[k][<span class="dv">1</span>]<span class="op">;</span></span>
<span id="cb5-73"><a href="#cb5-73" aria-hidden="true" tabindex="-1"></a>    cur2 <span class="op">=</span> cv2.warpAffine(cur, T, (w,h))<span class="op">;</span></span>
<span id="cb5-74"><a href="#cb5-74" aria-hidden="true" tabindex="-1"></a>    out.write(cur2)<span class="op">;</span></span>
<span id="cb5-75"><a href="#cb5-75" aria-hidden="true" tabindex="-1"></a>    cv2.waitKey(<span class="dv">20</span>)<span class="op">;</span></span></code></pre></div>
<p><code>cv2.estimateRigidTransform</code> çağrısı katı transformasyonu
hesaplayan bir çağrıdır, aynen <code>H_from_points</code> gibi.</p>
<p>Üstteki kodu [1] üzerinde uygularsak stabilizasyon yapıldığını
göreceğiz. Sonuç [2]’de. C++ kodu <code>vidstab.cpp</code>’de
bulunabilir.</p>
<p>Canlı Zamanda (Real-Time) Stabilizasyon</p>
<p>[4]’ün tekniği toptan (batch) işleyen bir teknik, ortalama alınması,
düzeltme yapılması için video’nun baştan sona işlenmesi, ve geriye
dönülmesi gerekiyor. Düzeltme işlemini canlı olarak yapamaz mıyız?</p>
<p>Bu mümkün olmalı; yürüyen ortalama için [6] yazısına bakabiliriz;
orada işlenen üstel ağırlıklı hareketli ortalama kullanılabilir. Bu
ortalamanın özyineli (recursive) formu da vardır,</p>
<p><span class="math display">\[ z_t = \alpha g_t + (1-\alpha)
z_{t-1}\]</span></p>
<p>ki <span class="math inline">\(\alpha\)</span> kullanıcı tarafından
seçilen parametredir, en son verilere ne kadar ağırlık verileceğini
tanımlar. Algoritma şöyle olabilir: Stabilizasyon için her video karesi
işlenirken <span class="math inline">\(dx,dy,da\)</span> farklarını
hesaplarız, bunların kümülatif toplamını da anlık hesaplarız (kolay). Bu
kümülatif <span class="math inline">\(x,y,a\)</span>’yı üstteki tanımda
<span class="math inline">\(g_t\)</span> olarak formüle veririz, en son
ortalama her zaman <span class="math inline">\(z_t\)</span> içinde
olacaktır. Bu ortalamanın kumulatif olandan farkı, “sapması’’ her kare
üzerinde düzeltme amacı ile kullanılabilir. Bu kod
<code>vsonline.py</code> içinde bulunabilir.</p>
<p>Kaynaklar</p>
<p>[1] Bayramlı, Veri 1 (Video), <a
href="https://drive.google.com/uc?export=view&amp;id=1nR4E7SYLfKhm8nO0BEfFcw0pwWmMNm19">https://drive.google.com/uc?export=view&amp;id=1nR4E7SYLfKhm8nO0BEfFcw0pwWmMNm19</a></p>
<p>[2] Bayramlı, Veri 2 (Video), <a
href="https://drive.google.com/uc?export=view&amp;id=11fPP7bxL32AhTNUFPVRqeG-PIxTQ1lqB">https://drive.google.com/uc?export=view&amp;id=11fPP7bxL32AhTNUFPVRqeG-PIxTQ1lqB</a></p>
<p>[3] Solem, <em>Computer Vision with Python</em></p>
<p>[4] Nghia Ho, <em>Simple Video Stabilization using OpenCV</em>, <a
href="http://nghiaho.com/?p=2093">http://nghiaho.com/?p=2093</a></p>
<p>[5] Bayramlı, <em>OpenCV 3.0</em>, <a
href="https://burakbayramli.github.io/dersblog/sk/2017/03/opencv-30.html">https://burakbayramli.github.io/dersblog/sk/2017/03/opencv-30.html</a></p>
<p>[6] Bayramlı, Zaman Serileri ve Finans, <em>ARIMA, ARCH, GARCH,
Periyotlar, Yürüyen Ortalama</em></p>
<p>[7] Bayramlı, <em>Kalman Filters and Homography: Utilizing the Matrix
A</em> <a
href="https://arxiv.org/abs/1006.4910">https://arxiv.org/abs/1006.4910</a></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
