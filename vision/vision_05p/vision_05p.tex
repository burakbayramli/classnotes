\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Yansýtma Matrisini Bilinen 3D-2D Eþlemelerinden Hesaplamak

Çoðu kaynakta ve bu ders anlatýmlarýnda kameraya yansýtýlan görüntü, dünya
kordinatlarý kavramlarý birbirine karýþýk þekilde gösterildi.

\includegraphics[width=25em]{vision_055_02.png}

Fakat dünya kordinat sistemi, kamera merkezi gibi kavramlarý birbirinden
ayýrmamýz gerekiyor. Çünkü uygulamalarda kamera z kordinatý üzerinde
durmuyor ve kamera merkezi ile dünya merkezi birbirinden farklý, ayrýca
çoðunlukla ne $P$'nin ne de onu oluþturan içsel parametre matrisi
(intrinsic parameter matrix) $K$ biliniyor.

Önce kameranýn nerede olduðuna bakalým. Kamera çoðunlukla dünya merkezinden
deðiþik bir yerdedir, mesela elle tutulan bir cep telefonu durumunda boy
yüksekliðinde ve $z$ kordinatýna yönünde (ama üzerinde olmayabilir) doðru
tutulmaktadýr. Önündeki objelerin yerleri dünya (world) kordinatlarýna
göredir, ayrýca kameranýn kendisi dünya merkezinden o noktaya bir
döndürülme ve taþýnma (rotation and translation) sonucu gelmiþtir.

\includegraphics[width=25em]{vision_055_01.png}

Bu döndürülme ve taþýnma matrislerini $R,T$ olarak tanýmlarsak,

$$ P = K \left[\begin{array}{c|c} R & t \end{array}\right]$$

olduðunu görmüþtük, ve bu matris 3 x 4 boyutundadýr, ki $K$ içsel parametre
matrisi idi. Ayrýca biliyoruz ki $P$'yi baz alarak bir $X_i$ üç boyutlu
noktasýnýn iki boyutlu noktaya yansýmasý

$$ \lambda_i x_i = PX_i$$

olarak hesaplanýyor. Kordinatlar homojen kordinatlar, yani (vektörleri bir
kerelik net olmasý için koyu renkle gösterirsek)
$\mathbf{x}_i = \left[\begin{array}{ccc}x_i&y_i&1\end{array}\right]^T$,
ayný þekilde
$\mathbf{X}_i=\left[\begin{array}{cccc}X_i&Y_i&Z_i&1\end{array}\right]^T$.

$P$'yi nasýl hesaplarýz? Bu hesap için elimizde belli sayýda dýþ dünyada üç
boyutlu ve onun iki boyutlu yansýmalarýný içeren, birbiri ile eþlenmiþ bir
veri seti olduðunu varsayacaðýz. Bu veriyi elde etmek zor deðil,
profosyonel ölçümler için kamera önüne belli uzaklýkta, gerçek boyutlarý
kesin bilinen bir obje konur, ve kamera görüntüsünde bu cismin bilinen
noktalarýnýn nereye tekabül ettiðine bakýlýr, vs. Ya da kabaca yeri bilinen
objelerin piksel yerleri kaydedilir. Dýþ dünyada þöyle bir resim olduðunu
düþünelim,

\includegraphics[width=25em]{out-cam.png}

Bu resimde ölçümleri bir dünya merkezine göre almak lazým. Resimde kamerayý
ben tutuyorum, ve þimdi ölçümler için merkezin 20 metre arkamda ve 20 metre
solumda olduðunu farzediyorum ve kameranýn yerden yüksekliðini 2 metre
kabul ediyorum. Þimdi bu merkeze göre resimde görülen bazý noktalarý elle
kendim seçerim, ve kabaca onlarýn uzaklýklarýný biliyordum, ona göre üç
boyutlu uzaklýk atayýp, ayrýca bu noktalarýn hangi piksel kordinatýnda
olduðunu bir imaj programý üzerinden yine kendim bulup bu eþlemeyi bir yere
kaydederim. Görsel olarak irdeleme kolay olsun diye bunlarý ayný resim
üzerinde ekrana basarsak,

\begin{minted}[fontsize=\footnotesize]{python}
w = 620; h = 465
from PIL import Image
im = Image.open('out-cam.png')
plt.imshow(im)
x = [[228, 398],\
     [249, 338],\
     [123, 245],\
     [121, 186],\
     [278, 248],\
     [488,205],\
     [291,194],\
     [432,167],\
     [73,288],\
     [477,404],\
     [123,130]]
X = [[20,0,21],\
     [20,0,22],\
     [18,0,30],\
     [18,1,30],\
     [20,0,30],\
     [22,2,21],\
     [20,1,30],\
     [22,2,22],\
     [18,0,25],\
     [22,0,21],\
     [18,2,30]]
for i in range(len(x)): 
    plt.plot(x[i][0],x[i][1],'r+')
    plt.text(x[i][0]+2,x[i][1]+2,str(X[i]),color='cyan')
plt.savefig('out-cam2.png')
\end{minted}


\includegraphics[width=35em]{out-cam2.png}

Bunlar çok mantýksýz üç boyutlu deðerler deðiller herhalde. 

$P$'nin hesabýna gelelim. Her veri noktasý $i$ için elimizde bir
$\lambda_i x_i = PX_i$ denklemi olduðuna göre, önce her bu tür denklemi
$PX_i-\lambda_ix_i=0$ olarak düzenlersek ve bu denklemleri üst üste gelecek
þekilde koyarsak,

$$ 
\left[\begin{array}{ccccccc}
X_1^T & 0 & 0 & -x_1 & 0 & 0 & \dots \\
0 & X_1^T & 0 & -y_1 & 0 & 0 & \dots \\
0 & 0 & X_1^T & -1 & 0 & 0 & \dots \\
X_2^T & 0 & 0 & 0 & -x_2 & 0 & \dots \\
0 & X_2^T & 0 & 0 & -y_2 & 0 & \dots \\
0 & 0 & X_2^T & 0 & -1 & 0 & \dots \\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots &  
\end{array}\right]
\left[\begin{array}{c}
p_1^T \\ p_2^T \\ p_3^T \\ \lambda_1 \\ \lambda_2 \\ \vdots
\end{array}\right] = 0
$$

sistemini elde ederiz. $p_1,p_2,p_3$ degiskenleri $P$ matrisinin
satýrlarýdýr. Üstteki matris daha fazla veri noktasý için saða ve aþaðý
doðru uzayacaktýr tabii.

Üstteki matrisi, $M$ diyelim, görüldüðü gibi hazýrladýktan sonra, ve
çarpýlan kolon vektörüne $v$ dersek artýk,

$$ Mv = 0$$ 

denklemini çözebiliriz. Bu denklemi yaklaþýksal olarak çözmek için problemi
bir $||v||=1$ þartýna baðlý olmak üzere $||Mv||$ minimizasyon problemi
olarak görebiliriz, yani ``sýfýra olabildiðince yaklaþma problemi'' olarak,
ki bu problem çözümü için SVD kullanýlabilir, daha fazla detaylar [3]
yazýsýnda. Peki $||v||=1$ þartýný nasýl getirebiliyoruz? Bunun sebebi
homojen kordinat sisteminin getirdiði bir avantajla alakalý; homojen
kordinat sistemindeki noktalar ``belli bir ölçek (up to scale)'' içinde
tanýmlýdýr, ve mesela 2 boyutlu bir nokta ve herhangi bir sabit $\alpha$
için
$\mathbf{x} = \left[\begin{array}{ccc}x&y&w\end{array}\right] =
\left[\begin{array}{ccc}\alpha x& \alpha y& \alpha w\end{array}\right] =
\left[\begin{array}{ccc}x/w&y/w&1\end{array}\right]$
noktalarýnýn hepsi aslýnda ayný 2 boyutlu noktadýr. Bunun sonucu olarak $M$
de belli bir ölçek içinde tanýmlý olacaktýr, ve o zaman $||v|| = 1$ farz
edebiliriz. Bu tabii ki hesabýmýz için faydalý oldu yoksa SVD bazlý
minimizasyon kullanamazdýk.

\begin{minted}[fontsize=\footnotesize]{python}
from scipy import linalg

def compute_P(x,X):
    n = x.shape[1]
    if X.shape[1] != n:
        raise ValueError("Number of points don't match.")
        
    M = np.zeros((3*n,12+n))
    for i in range(n):
        M[3*i,0:4] = X[:,i]
        M[3*i+1,4:8] = X[:,i]
        M[3*i+2,8:12] = X[:,i]
        M[3*i:3*i+3,i+12] = -x[:,i]
    print M.shape
    U,S,V = linalg.svd(M)
    
    return V[-1,:12].reshape((3,4))

xx = np.array(x)
# h'den cikar cunku imaj programlari sol ustu (0,0) olarak kabul 
# ediyor, bizim hesap icin sol at (0,0) olmali
xx[:,1] = h-xx[:,1] 
xx = np.hstack((xx,np.ones((len(x),1))))
XX = np.array(X)
XX = np.hstack((XX,np.ones((len(X),1))))

P = compute_P(xx.T,XX.T)
print P
\end{minted}

\begin{verbatim}
(33, 23)
[[ -4.01225744e-02   5.31972373e-03  -1.06308256e-02   9.71131258e-01]
 [ -9.79700368e-04  -2.64464969e-02  -1.09893337e-02   2.33086445e-01]
 [ -1.80165364e-05   5.44992018e-06  -3.40782252e-05   8.40827305e-04]]
\end{verbatim}

$P$'yi hesapladýk. Bu $P$'yi þimdi resme bir üç boyutlu þekil yansýtmak
için kullanalým. Mesela iki metre solumdan bir metre saðýmdan çýkan yerden
uzaða doðru yol üzerinde giten iki tane çizgiyi iki boyuta yansýtalým.

\begin{minted}[fontsize=\footnotesize]{python}
res1 = np.array([[18, 0, 20+i, 1.] for i in np.linspace(0,30,100)])
res2 = np.array([[21, 0, 20+i, 1.] for i in np.linspace(0,30,100)])

X3 = np.dot(P, res1.T)
X3 = X3 / X3[2]
im = Image.open('out-cam.png')
plt.imshow(im)

for xx in X3.T: 
    plt.hold(True)
    if xx[0] > w or xx[0] < 0: continue
    if xx[1] > h or xx[1] < 0: continue
    plt.plot(xx[0],h-xx[1],'r.')

plt.hold(True)

X3 = np.dot(P, res2.T)
X3 = X3 / X3[2]
for xx in X3.T: 
    plt.hold(True)
    if xx[0] > w or xx[0] < 0: continue
    if xx[1] > h or xx[1] < 0: continue
    plt.plot(xx[0],h-xx[1],'r.')

plt.savefig('out-cam4.png')
\end{minted}

\includegraphics[width=20em]{out-cam4.png}

$R,T$ Hesabý

Bilinen $P$ ve $R,T$ üzerinden $K$'yi hesaplamak için
$\left[\begin{array}{c|c}R&t\end{array}\right]$'nin cebirsel olarak neyi
ifade ettigini hatýrlayalým,

$$ 
\left[\begin{array}{c|c}
R & t
\end{array}\right] = 
\left[\begin{array}{ccc|c}
r_{1,1} & r_{1,2} & r_{1,3} & t_1 \\
r_{2,1} & r_{2,2} & r_{2,3} & t_2 \\
r_{3,1} & r_{3,2} & r_{3,3} & t_3 
\end{array}\right]
$$

Çoðunlukla üstteki matrise bir ekstra
$\left[\begin{array}{cccc}0&0&0&1\end{array}\right]$ satýrý eklenir, 
böylece matris kare haline gelir, ve böylece dönüþ ve taþýnmanýn basit
çarpým olarak ayrýþtýrýlabilmesi saðlanýr. 

$$ 
\left[\begin{array}{c|c} 
R & t \\  \hline 0 & 1
\end{array}\right] =
\left[\begin{array}{c|c} 
I & t \\  \hline 0 & 1
\end{array}\right]
\left[\begin{array}{c|c} 
R & 0 \\  \hline 0 & 1
\end{array}\right]
$$

$$ 
= \left[\begin{array}{ccc|c}
1 & 0 & 0 & t_1 \\
0 & 1 & 0 & t_1 \\
0 & 0 & 1 & t_1  \\
\hline
0 & 0 & 1 & 1
\end{array}\right]
\left[\begin{array}{ccc|c}
r_{1,1} & r_{1,2} & r_{1,3} & 0 \\
r_{2,1} & r_{2,2} & r_{2,3} & 0 \\
r_{3,1} & r_{3,2} & r_{3,3} & 0 \\
\hline
0 & 0 & 1 & 1
\end{array}\right]
$$

$P$ Üzerinden $K,R,T$

$K$'yi hesabý için þunu hatýrlarýz: Her matrisin bir QR ayrýþtýrmasýnýn
olduðunu biliyoruz. O zaman eldeki $P$'yi ayrýþtýrarak $R,t$'yi bilmeden
direk $K,R,t$ hesaplarýný yapabiliriz.

\begin{minted}[fontsize=\footnotesize]{python}
K,R = linalg.rq(P[:,:3])
T = np.diag(np.sign(np.diag(K)))
if linalg.det(T) < 0: T[1,1] *= -1
K = np.dot(K,T)
R = np.dot(T,R) 
t = np.dot(linalg.inv(K),P[:,3])
print K
print R
print t
\end{minted}

\begin{verbatim}
[[  2.99407581e-02   5.97285792e-03   2.86183659e-02]
 [  0.00000000e+00  -2.79384510e-02   6.37066885e-03]
 [  0.00000000e+00   0.00000000e+00   3.89309986e-05]]
[[-0.88366792 -0.15133543  0.44297698]
 [-0.07045937  0.9785196   0.19373918]
 [-0.46278126  0.13998922 -0.87534937]]
[ 12.47297147  -3.41799407  21.59788692]
\end{verbatim}

Gerçi ayrýþtýrma özgün (unique) deðil, bir iþaret belirsizliði olabiliyor,
ama bunun çaresi var, detaylar için [1, sf. 108]. Bu hesabýn bize ne
verdiðini tekrar vurgulamak lazým - sadece $P$'ye bakarak hem $K$'yi hem de
kameranýn ne kadar hareket ettiðini bulmuþ olduk. Bu kuvvetli bir özellik.

Bu þekilde bulunan $R,t$ belki ölçümlerin kalite kontrolu için
kullanýlabilir. Mesela $R,t$'nin ne olduðunu kesin biliyorduk, ama $P$
ayrýþtýrmasý bize beklediðimizden farklý bir $R,t$ verdi. O zaman belki
2D-3D eþleþtirmesi daha iyi olabilirdi.


Kaynaklar

[1] Solem, {\em Computer Vision with Python}

[2] {\em Dissecting the Camera Matrix, Part 2: The Extrinsic Matrix}, \url{http://ksimek.github.io/2012/08/22/extrinsic/}

[3] Bayramli, Lineer Cebir, {\em Lineer Cebir ile Minimizasyon}

\end{document}
