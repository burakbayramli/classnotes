<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  
  
  
  
</head>
<body>
<h1 id="fx-u">F(X) = U</h1>
<p>Başlıktaki matematiğin alt dallarından Simulasyon'un en temel formüllerinden biri. Basitliği derin bir sonucu gizliyor aslında; ve simulasyon dahil olmak üzere en az iki istatistiksel yöntemi mümkün kılıyor. Formülü ve mümkün kıldığı iki yöntemi bu yazıda göreceğiz.</p>
<p>Başlıkta söylemi tam notasyonla vermek gerekirse;</p>
<p><span class="math display">\[ F_X(X) \sim U(0,1) \]</span></p>
<p>Yani, dağılımı her ne olursa olsun, bu dağılımdan gelen bir rasgele değişkenin değerlerini o dağılımın kümülatif dağılım fonksiyonuna (cdf) geçersek, elde edilen değerler yeni bir rasgele değişken <span class="math inline">\(U(0,1)\)</span> olarak, yani birörnek (uniform) olarak dağılacaktır! Müthiş bir sonuç. Bu metot simülasyonda Ters Transform Metotu (Inverse Transform Method) olarak geçiyor.</p>
<p>Teori</p>
<p>Diyelim ki <span class="math inline">\(X\)</span> cdf <span class="math inline">\(F_X\)</span>'e sahip surekli rasgele degisken. O zaman <span class="math inline">\(F_X(X) \sim U(0,1)\)</span>.</p>
<p>İspat</p>
<p><span class="math inline">\(Y = F_X(X)\)</span> olsun, ve <span class="math inline">\(Y\)</span>'nin cdf'i <span class="math inline">\(G(y)\)</span>. O zaman</p>
<p><span class="math display">\[ G(y) = P(Y \le y) = P(F_X(X) \le y) \]</span></p>
<p>Olasılık operatörü içinde iki tarafa <span class="math inline">\(F_X\)</span>'in tersini uygulayalım, sol tarafta tersi ile kendisi sonucu fonksiyon kaybolur, geri kalanlar,</p>
<p><span class="math display">\[ = P(X \le F_X^{-1}(y) ) \]</span></p>
<p>Üstteki ifadeye geldik. Bu ifade de aslında bir cdf hesabı değil midir? Evet. <span class="math inline">\(X\)</span>'in cdf hesabıdır,</p>
<p><span class="math display">\[ = F_X(F_X^{-1}(y)) = y \]</span></p>
<p><span class="math display">\[ G(y) = y \]</span></p>
<p>Yani <span class="math inline">\(y\)</span>'nin cdf değeri <span class="math inline">\(y\)</span>'nin kendisidir, bu da sadece <span class="math inline">\(Y\)</span> birörnek olarak dağılmışsa mümkündür [1].</p>
<p>Herhangi Bir Dağılım İçin Rasgele Sayı Üretmek</p>
<p>Bu teorinin rasgele sayı üretmek için nasıl kullanıldığını görmek zor değil. Çünkü eğer</p>
<p><span class="math display">\[ F_X(X) = U \]</span></p>
<p>ise</p>
<p><span class="math display">\[ X = F_X^{-1}(U) \]</span></p>
<p>de doğrudur; O zaman birörnek dağılımdan örneklem alırız, bu örneklem içindeki sayıları teker teker üretmek istediğimiz dağılımın cdf'inin {} geçeriz, ve elimizdeki sonuçlar otomatik olarak hedeflediğimiz dağılımdan gelen sayılar olur!</p>
<p>Not: Tabii <span class="math inline">\(F^{-1}\)</span> hesabının yapılabilmesi için bu fonksiyonun bir analitik formu olması gerekir; bazı durumlarda bu mümkün olmayabilir. Mesela normal (gaussian) dağılımın cdf'inin tersinin analitik formu mevcut değildir. Ya da çok daha çetrefil, çok boyutlu dağılımlar durumunda da bu mümkün olmayabilir. Bu tür durumlar için başka yöntemler var, Markov Zinciri Monte Carlo (MCMC) yöntemleri mesela, ya da daha basit Kabul-Reddet (Accept-Rejection) yöntemi... Dağılımları simüle etme konusunun arkasında derin bir literatür var [2].</p>
<p>Peki <span class="math inline">\(U\)</span> Nereden Geliyor?</p>
<p>Diyelim ki elimizde tersi alınabilir bir cdf var, ve artık bu dağılımdan sayı üretmek istiyoruz. Peki cdf tersine verilecek birörnek sayılar nereden gelecek?</p>
<p>Bu durumda sözde rasgele (pseudorandom) sayı üretimi konusuna girebiliriz. Favori hesap kütüphanemizden birörnek sayılar üretebiliriz, fakat bu kütüphanelerin ne yaptığını bilmek iyi olur. Kendimiz rasgele sayı üretmek istiyorsak, bunun en kolay, etkili yolu lineer eşleşikşel üretici (linear congruential generator) kullanmak.</p>
<p><span class="math display">\[ Z_i = (a Z_{i-1} + c) \bmod m \]</span></p>
<p><span class="math inline">\(a\)</span> çarpan, <span class="math inline">\(m\)</span> ise genlik (modülüs). <span class="math inline">\(\bmod\)</span> bildiğimiz gibi modülo matematiğinden geliyor, <span class="math inline">\(4 \bmod 2 = 0\)</span>, <span class="math inline">\(5 \bmod 3 = 2\)</span>, vs., bölümden arta kalanların matematiği yani. Modülo operatörü sayesinde <span class="math inline">\(Z_i\)</span> sonuçları 1 ile <span class="math inline">\(m-1\)</span> arasında olacaktır. Çoğunlukla <span class="math inline">\(m\)</span> büyük ve asal bir sayı olarak seçilir. <span class="math inline">\(R_i = Z_i / m\)</span> ve <span class="math inline">\(R_i \in (0,1)\)</span>. Amaç bir dizi <span class="math inline">\(R_i\)</span>'in <span class="math inline">\(U(0,1)\)</span>'den geliyormuş gibi gözükmesini sağlamak. Bu seri tabii ki bir süre sonra kendini tekrar edecektir, ama bunun olması için uzun zaman geçiyorsa bu bizim için iyi bir sonuçtur.</p>
<p><span class="math inline">\(a,c,m\)</span>'in dikkatli seçilmesi gerekir, ki tekrarsız periyot uzun ve üretilen sayıların istatistiki kalitesi iyi olsun. Eğer <span class="math inline">\(c=0\)</span> ise üstte gösterilene çarpımsal üreteç ismi veriliyor. Neyse, örnek olarak</p>
<p><span class="math display">\[ Z_i = (5 Z_{i-1} + 3) \bmod 8 \]</span></p>
<p>kullanalım. Eğer <span class="math inline">\(Z_0 = 0\)</span> ise (ki bu başlangıç noktasına tohum -seed- ismi de verilir) bir sonraki sayı <span class="math inline">\(Z_1 = (5 Z_0 + 3) \bmod 8 = 3\)</span> olur, ve böyle devam edersek,</p>
<div class="figure">
<img src="stat_fxu_01.png" />

</div>
<p>Görüldüğü gibi 8. adımda başa dönmüş olduk, çünkü <span class="math inline">\(Z_8 = 0\)</span>. Bu üreteç tam-periyot üretecidir, yani <span class="math inline">\(\bmod \ 8\)</span> dedik ve tekrar edene kadar 8 tane sayı ürettik. Genel olarak tam periyot iyi bir şeydir. Eğer</p>
<p><span class="math display">\[ Z_i = (5 Z_{i-1} + 1) \bmod 7\]</span></p>
<p>seçseydik, <span class="math inline">\(Z_0=1\)</span> ile <span class="math inline">\(1,6,3,2,4,6\)</span> yani küt diye 6'ya döndük. Bu olmadı, tam periyot değil. Eğer <span class="math inline">\(Z_0=5\)</span> seçseydik sonuç daha da kötü olurdu, bir sonraki sayı başlangıcın kendisi, yani 5! Bu durumda tek bir tane bile sözde rasgele sayı bile üretememiş olurduk.</p>
<p>Çok iyi üreteçlerden biri</p>
<p><span class="math display">\[ Z_i = 16807 Z_{i-1} \bmod (2^{31}-1)\]</span></p>
<p>Bu çok hızlı işleyen, tekrar edene kadar 2 milyar (dikkat: <em>milyar</em>) sayıdan daha fazla sayı üretebilen bir üreteçtir. Kodu altta bulunabilir, <span class="math inline">\(2^{31}-1=2147483647\)</span> olduğunu biliyoruz,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> do_unif(ix): 
    u <span class="op">=</span> (<span class="dv">16807</span><span class="op">*</span>ix) <span class="op">%</span> <span class="dv">2147483647</span>
    <span class="cf">return</span> u

u <span class="op">=</span> do_unif(<span class="fl">1e7</span>)
<span class="bu">print</span> u
u <span class="op">=</span> do_unif(u)
<span class="bu">print</span> u
u <span class="op">=</span> do_unif(u)
<span class="bu">print</span> u</code></pre></div>
<pre><code>566275534.0
1892860081.0
476634709.0</code></pre>
<p>Biraz daha farklı bir yaklaşım [1], [5, sf. 215],</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> do_unif(ix): 
    k1 <span class="op">=</span> <span class="bu">int</span>(ix<span class="op">/</span><span class="dv">127773</span>)
    ix <span class="op">=</span> <span class="dv">16807</span><span class="op">*</span>(ix <span class="op">-</span> k1<span class="op">*</span><span class="dv">127773</span>) <span class="op">-</span> k1<span class="op">*</span><span class="dv">2836</span>
    <span class="cf">if</span> ix <span class="op">&lt;</span> <span class="dv">0</span>: ix <span class="op">=</span> ix <span class="op">+</span> <span class="dv">2147483647</span>
    u <span class="op">=</span> ix<span class="op">*</span><span class="fl">4.656612875e-10</span> <span class="co"># 1&#39;den kucuk olmasi icin</span>
    <span class="cf">return</span> ix, u

ix, u <span class="op">=</span> do_unif(<span class="fl">1e7</span>)
<span class="bu">print</span> u
ix, u <span class="op">=</span> do_unif(ix)
<span class="bu">print</span> u
ix, u <span class="op">=</span> do_unif(ix)
<span class="bu">print</span> u</code></pre></div>
<pre><code>0.263692594242
0.881431662376
0.22195033226</code></pre>
<p>Eğer tek bir çağrı ile istediğimiz kadar birörnek sayı üretmek istiyorsak,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> unif(size,seed<span class="op">=</span><span class="fl">1e7</span>):
    tmp <span class="op">=</span> seed<span class="op">;</span> res <span class="op">=</span> []
    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(size):
       tmp,u<span class="op">=</span>do_unif(tmp)
       res.append(u)
    <span class="cf">return</span> np.array(res)
<span class="bu">print</span> unif(size<span class="op">=</span><span class="dv">10</span>)</code></pre></div>
<pre><code>[ 0.26369259  0.88143166  0.22195033  0.31923449  0.37412169  0.8632809
  0.16214486  0.16868319  0.05836612  0.95940828]</code></pre>
<p>Örnek: Üstel Rasgele Değişken Üretmek</p>
<p><span class="math inline">\(X = F^{-1}(U)\)</span> prensibini kullanarak üstel (exponential) dağılımdan gelen rasgele sayılar üretelim. Birörnek üreticimiz var, üstel dağılım için cdf'in tersini biliyoruz, ki bu <span class="math inline">\(F^{-1}(p;\lambda) = -\ln(1-p) / \lambda\)</span>. Tüm bunları biraraya koyarsak,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">x <span class="op">=</span> unif(size<span class="op">=</span><span class="dv">1000</span>)
lam <span class="op">=</span> <span class="fl">4.</span>
y <span class="op">=</span> <span class="op">-</span>np.log(<span class="dv">1</span><span class="op">-</span>x) <span class="op">/</span> lam <span class="co"># cdf tersi</span>
f<span class="op">=</span>plt.figure()<span class="op">;</span>
plt.hist(y)
plt.savefig(<span class="st">&#39;stat_fxu_02.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="stat_fxu_02.png" />

</div>
<p>Üstel dağılıma benziyor! İşin iyi tarafı bu üretimi yapmak için tüm öğeleri evde kendimiz pişirdik. Birörnek rasgele sayıları bile kendimiz üretiyoruz.</p>
<p>Uyum Derecesi ve Düzgünlük Testi (Goodness-of-Fit, Smooth Test)</p>
<p><span class="math inline">\(F_X(X) = U\)</span> başka bir açıdan bir &quot;numara'' olarak ta kullanılabilir, çünkü teoriye göre sadece ve sadece <span class="math inline">\(F_X\)</span> fonksiyonu hakikaten <span class="math inline">\(X\)</span>'in cdf'i ise ispat geçerli. Bu gerçeği bir istatistiki test için başlangıç noktası olarak kullanabiliriz; Diyelim ki elimizde bir <span class="math inline">\(X\)</span> var ve dağılımının ne olduğunu bilmiyoruz. Ama eğer doğru dağılımı seçmişsek, mesela <span class="math inline">\(F_0\)</span>, <span class="math inline">\(F_0(X)\)</span> bize birörnek sonuç verir, değilse vermez. O zaman bir tahmini cdf'i birörneklik testiyle birleştirirsek, verinin / rasgele değişkenin dağılımın ne olduğunu test eden bir istatistiki test bulmuş oluruz [3, sf. 325].</p>
<p>Birörneklik testi dedik, bunun için zaten bilinen chi kare, K-S uyum derece testi gibi testleri mi kullansak acaba? Neyman adlı istatistikçi mevcut olanları kullanmak yerine özellikle birörnek dağılımına odaklı bir test yaratmaya karar verdi. Neyman'ın düzgünlük testi (Neyman's smooth test) birkaç baz fonksiyonunun toplamından oluşan bir alternatifi (0,1) aralığına gömüyor (embed), ki sıfır hipotezinde bu gömülü fonksiyon bize birörnek sonuçla aynı sonucu verir, ama birörneklikten sapma varsa, baz fonksiyonları öyle oluşturulmuştur ki bu sapmanın etkisi düzgün, sürekli bir şekilde birörneklikten ayrılır (ki testin ismi buradan geliyor). Ayrıca baz fonksiyonları öyle seçilmiştir ki sıfır hipotezi altında test için bir chi kare dağılımı elde ederiz, birörnek olmama durumunu bu chi kare dağılımda aykırı bölgeye düşmek olarak irdeleyebiliriz, ve testimiz bunun üzerinden hesaplanır.</p>
<p>Bu özel fonksiyonlar nelerdir? Onları <span class="math inline">\(h_j(y)\)</span> olarak gösterelim, ki <span class="math inline">\(j=1,..,d\)</span> olsun, yani <span class="math inline">\(d\)</span> tane baz fonksiyonu var. Neyman'a göre <span class="math inline">\(d=4\)</span> yeterlidir (baz fonksiyonuna göre değişir tabii, biz alttaki örnekte 5 kullandık). Bu fonksiyonlara bazı şartlar getiriliyor, öncelikle <span class="math inline">\(h_j\)</span>'ler sabit fonksiyona (yani 1'e) ve birbirlerine dikgen (orthogonal) olmalılar. Yani</p>
<p><span class="math display">\[ \int_{0}^{1} h_j(y) \mathrm{d} y = 0 \]</span></p>
<p><span class="math display">\[ \int_{0}^{1} h_k(y)h_j(y) \mathrm{d} y = 0 \]</span></p>
<p>Ayrıca büyüklüğü (yani karesi) normalize edilmiş olmalı</p>
<p><span class="math display">\[ 
\int_{0}^{1} h_j(y)^2 \mathrm{d} y = 1 
\qquad (1)
\]</span></p>
<p>Bu şartları tatmin eden hangi fonksiyonlar vardır? Aklımıza gelen her fonksiyon tipi üstteki şartlara uymayabilir. Neyman Legendre polinomları denen polinomları kullandı, fakat aslında üstteki şartları yerine getiren</p>
<p><span class="math display">\[ h_j(y) = c_j \cos (2\pi j y) \]</span></p>
<p>ki <span class="math inline">\(c_j\)</span> normalizasyon sabiti, gayet rahat kullanılabilir. Dikkat, üstteki sabit <span class="math inline">\(h_j\)</span>'yi bir dağılım haline getirmez, &quot;büyüklük hesabı için'' onu normalize eder. Sebebini birazdan göreceğiz.</p>
<p>Not: Üstteki fonksiyon eğer Fourier serilerini hatırlattıysa bu doğru bir gözlemdir, böyle bir bağlantı var.. Birbirine dikgen fonksiyonlar özel fonksiyonlar tabii, Fourier serilerinde bu sebeple kullanılıyorlar, ve dikgenlik lineer cebirde de çok ortaya çıkar. Kontrol edilmek istenirse <span class="math inline">\(1, \cos (2\pi y), \cos (4\pi y), \cos (6 \pi y), ..\)</span> fonksiyonlarının birbirine dikgen olduğu entegral hesabını yapılarak görülebilir.</p>
<p>Devam edelim, (1)'i tatmin etmek için gereken <span class="math inline">\(c_j\)</span>'i hesaplayalım,</p>
<p><span class="math display">\[ 
\int_{0}^{1} c_j^2 \cos(2 \pi y)^2 \mathrm{d} y = 1
\]</span></p>
<p><span class="math display">\[ 
\int_{0}^{1}\cos(2 \pi y)^2 \mathrm{d} y = 1/c_j^2 
\]</span></p>
<p>Trigonometrik eşitlik [4, sf 435]</p>
<p><span class="math display">\[ \cos(\theta)^2 = \frac{1 + \cos 2 \theta }{2}\]</span></p>
<p>O zaman,</p>
<p><span class="math display">\[ 
 \cos(2 \pi y)^2 = \frac{1}{2} + \frac{1}{2}\cos(4 \pi y)
 \]</span></p>
<p>Entegrale geri koyalım,</p>
<p><span class="math display">\[ 
\int_{0}^{1} \frac{1}{2} + \frac{1}{2}\cos(4 \pi y) \mathrm{d} y
\]</span></p>
<p><span class="math display">\[ 
= \frac{y}{2} + \frac{1}{8\pi}\sin(4 \pi y)  \bigg|_{0}^{1} 
\Rightarrow \frac{1}{2} = 1/c_j^2
\]</span></p>
<p><span class="math display">\[ c_j = \sqrt{2} \]</span></p>
<p>Bulunan <span class="math inline">\(c_j\)</span> her <span class="math inline">\(j\)</span> için geçerli olacaktır.</p>
<p>Düzgünlük testi için önce <span class="math inline">\(x_i\)</span> veri noktaları o verinin geldiğini düşündüğümüz cdf'e geçilir, yani <span class="math inline">\(y_i = F(x_i)\)</span> hesaplanır. Ardından,</p>
<p><span class="math display">\[ \overline{h_j} = \frac{1}{n} \sum_{i=1}^{n} h_j(y_i) \]</span></p>
<p>Sıfır hipotezi altında ve Büyük Sayılar Kanununa göre <span class="math inline">\(\overline{h_j} \to0\)</span>.<br />
<span class="math inline">\(\sqrt{n} \cdot \overline{h_j}\)</span> ise Merkezi Limit Teorisi'ne göre Gaussian'dır, ve bu Gaussian'ın varyansı 1 olacaktır. Demek ki</p>
<p><span class="math display">\[ 
\Psi^2 = n \sum_{j=1}^{d} \overline{h_j}^2
\]</span></p>
<p>hesabı sıfır hipotezi altında <span class="math inline">\(\chi^2_d\)</span> dağılımına sahiptir. <span class="math inline">\(h_j\)</span>'lerin birbirine dikgen seçilmesinin sebebi şimdi biraz daha açıklık kazanıyor herhalde, dikgen fonksiyonlar ile arasında hiç korelasyon olmayan standart normaller üretiyoruz, ve bu normallerin toplamının bize chi kare vermesini bekliyoruz (chi kare için korelasyonsuz standard normallerin toplamı gerekir).</p>
<p><span class="math inline">\(\overline{h_j} \to 0\)</span> ispatı için sıfır hipotezinde <span class="math inline">\(y_i\)</span>'lerin, ya da <span class="math inline">\(u_i\)</span> diyelim, birörnek dağılım <span class="math inline">\(U(0,1)\)</span>'dan geldiğini hatırlayalım, yani o zaman <span class="math inline">\(h_j(U)\)</span> bir rasgele değişkendir, ve</p>
<p><span class="math display">\[ h_j(u_1) + h_j(u_2) + .. + h_j(u_n) / n \]</span></p>
<p><span class="math inline">\(h_j\)</span>'nin nüfus beklentisine yaklaşır. Peki <span class="math inline">\(h_j\)</span>'in nüfus beklentisi nedir? Bunun için</p>
<p><span class="math display">\[ E(h_j) = \int_{-\infty}^{\infty} f_U(u)h_j(u) \mathrm{d} u \]</span></p>
<p><span class="math inline">\(f_U(u) = 1\)</span>, ayrıca (0,1) arasına odaklı olduğumuz için,</p>
<p><span class="math display">\[
= \int_{0}^{1} h_j(u) \mathrm{d} u = \int_{0}^{1} \cos 2\pi j u \mathrm{d} u
= \frac{\sin 2j\pi u }{2j\pi u} \bigg|_{0}^{1} = 0
\]</span></p>
<p><span class="math inline">\(j\)</span> ne olursa olsun beklenti sıfır demektir bu. Peki varyans?</p>
<p><span class="math display">\[
Var(h_j) = E(h_j^2)-E(h_j)^2 = \int_{-\infty}^{\infty} f_U(u)h_j^2(u) \mathrm{d} u
\]</span></p>
<p>üstte <span class="math inline">\(E(h_j)=0\)</span> olduğunu bulduk, bu terim üstteki formülde iptal oldu. Ve (1)'ın de yardımıyla,</p>
<p><span class="math display">\[  = \int_{0}^{1}  h_j^2(u) \mathrm{d} u = 1\]</span></p>
<p>Prosedür böylece tamamlandı.</p>
<ol style="list-style-type: decimal">
<li><p>cdf ile veriden <span class="math inline">\(y=F(x)\)</span> hesapla</p></li>
<li><p><span class="math inline">\(h_j\)</span> hesapla, ki bizim seçtiğimiz baz için <span class="math inline">\(c_j = \sqrt{2}\)</span>, ardından <span class="math inline">\(\overline{h_j}\)</span></p></li>
<li><p>En son <span class="math inline">\(\Psi^2\)</span>, sonucu <span class="math inline">\(\chi^2_d\)</span> üzerinde kontrol et.</p></li>
</ol>
<p>Örnek</p>
<p>Bir standart normal, bir 4 derece serbestliğe sahip bir Öğrenci t dağılımı, bir de üstel (exponential) dağılımdan üretilmiş veriyi standart normal olup olmadığına bakmak için test ettik.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> scipy.stats <span class="im">import</span> norm
<span class="im">from</span> scipy.stats <span class="im">import</span> t
<span class="im">from</span> scipy.stats <span class="im">import</span> expon
s <span class="op">=</span> <span class="dv">200000</span>
np.random.seed(<span class="dv">0</span>)
xnorm <span class="op">=</span> norm.rvs(size<span class="op">=</span>s)
xstudent <span class="op">=</span> t.rvs(df<span class="op">=</span><span class="dv">4</span>, size<span class="op">=</span>s)
xexp <span class="op">=</span> expon.rvs(scale<span class="op">=</span><span class="dv">1</span>,size<span class="op">=</span>s)

<span class="im">from</span> scipy.stats <span class="im">import</span> norm
<span class="kw">def</span> test(x,d<span class="op">=</span><span class="dv">5</span>,cdf<span class="op">=</span>norm.cdf):
    y <span class="op">=</span> cdf(x)
    c <span class="op">=</span> np.sqrt(<span class="dv">2</span>)
    <span class="co"># baz fonksiyonlar</span>
    hs <span class="op">=</span> [c<span class="op">*</span>np.cos(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>i<span class="op">*</span>x) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,d<span class="op">+</span><span class="dv">1</span>)]
    res <span class="op">=</span> [xx.mean() <span class="cf">for</span> xx <span class="kw">in</span> hs]
    res <span class="op">=</span> [xx<span class="op">**</span><span class="dv">2</span> <span class="cf">for</span> xx <span class="kw">in</span> res]
    <span class="bu">print</span> <span class="bu">len</span>(x)<span class="op">*</span>np.<span class="bu">sum</span>(res)

test(xstudent)
test(xnorm)
test(xexp)

<span class="im">from</span> scipy.stats <span class="im">import</span> chi2
dof <span class="op">=</span> <span class="dv">5</span>
<span class="bu">print</span> <span class="st">&#39;chi kare&#39;</span>, chi2.ppf(<span class="fl">0.95</span>,dof)</code></pre></div>
<pre><code>12.1463285033
2.20265705473
259.103849686
chi kare 11.0704976935</code></pre>
<p>Görüldüğü gibi Öğrenci t reddedildi, normal kabul edildi, üstel çok ciddi şekilde reddedildi. Öğrenci t dağılımı normal dağılıma çok benzer bu arada, buna rağmen arada büyük fark dikkate değer.</p>
<p>Kaynaklar</p>
<p>[1] Goldsman, D., <em>ISyE 6644 - Simulation Lecture</em>, <a href="http://www2.isye.gatech.edu/~sman/courses/6644/" class="uri">http://www2.isye.gatech.edu/~sman/courses/6644/</a></p>
<p>[2] Ross, <em>Introduction to Probability Models, 10th Edition</em></p>
<p>[3] Shalizi, <em>Advanced Data Analysis from an Elementary Point of View</em></p>
<p>[4] Thomas, <em>Thomas' Calculus, 11th Ed</em></p>
<p>[5] Schrage, <em>A Guide to Simulation</em></p>
</body>
</html>
