<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>F(X) = U</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="fx-u">F(X) = U</h1>
<p>Başlıktaki matematiğin alt dallarından Simulasyon’un en temel
formüllerinden biri. Basitliği derin bir sonucu gizliyor aslında; ve
simulasyon dahil olmak üzere en az iki istatistiksel yöntemi mümkün
kılıyor. Formülü ve mümkün kıldığı iki yöntemi bu yazıda göreceğiz.</p>
<p>Başlıkta söylemi tam notasyonla vermek gerekirse;</p>
<p><span class="math display">\[ F_X(X) \sim U(0,1) \]</span></p>
<p>Yani, dağılımı her ne olursa olsun, bu dağılımdan gelen bir rasgele
değişkenin değerlerini o dağılımın kümülatif dağılım fonksiyonuna (cdf)
geçersek, elde edilen değerler yeni bir rasgele değişken <span
class="math inline">\(U(0,1)\)</span> olarak, yani birörnek (uniform)
olarak dağılacaktır! Müthiş bir sonuç. Bu metot simülasyonda Ters
Transform Metotu (Inverse Transform Method) olarak geçiyor.</p>
<p>Teori</p>
<p>Diyelim ki <span class="math inline">\(X\)</span> cdf <span
class="math inline">\(F_X\)</span>’e sahip surekli rasgele degisken. O
zaman <span class="math inline">\(F_X(X) \sim U(0,1)\)</span>.</p>
<p>İspat</p>
<p><span class="math inline">\(Y = F_X(X)\)</span> olsun, ve <span
class="math inline">\(Y\)</span>’nin cdf’i <span
class="math inline">\(G(y)\)</span>. O zaman</p>
<p><span class="math display">\[ G(y) = P(Y \le y) = P(F_X(X) \le y)
\]</span></p>
<p>Olasılık operatörü içinde iki tarafa <span
class="math inline">\(F_X\)</span>’in tersini uygulayalım, sol tarafta
tersi ile kendisi sonucu fonksiyon kaybolur, geri kalanlar,</p>
<p><span class="math display">\[ = P(X \le F_X^{-1}(y) ) \]</span></p>
<p>Üstteki ifadeye geldik. Bu ifade de aslında bir cdf hesabı değil
midir? Evet. <span class="math inline">\(X\)</span>’in cdf
hesabıdır,</p>
<p><span class="math display">\[ = F_X(F_X^{-1}(y)) = y \]</span></p>
<p><span class="math display">\[ G(y) = y \]</span></p>
<p>Yani <span class="math inline">\(y\)</span>’nin cdf değeri <span
class="math inline">\(y\)</span>’nin kendisidir, bu da sadece <span
class="math inline">\(Y\)</span> birörnek olarak dağılmışsa mümkündür
[1].</p>
<p>Herhangi Bir Dağılım İçin Rasgele Sayı Üretmek</p>
<p>Bu teorinin rasgele sayı üretmek için nasıl kullanıldığını görmek zor
değil. Çünkü eğer</p>
<p><span class="math display">\[ F_X(X) = U \]</span></p>
<p>ise</p>
<p><span class="math display">\[ X = F_X^{-1}(U) \]</span></p>
<p>de doğrudur; O zaman birörnek dağılımdan örneklem alırız, bu örneklem
içindeki sayıları teker teker üretmek istediğimiz dağılımın cdf’inin {}
geçeriz, ve elimizdeki sonuçlar otomatik olarak hedeflediğimiz
dağılımdan gelen sayılar olur!</p>
<p>Not: Tabii <span class="math inline">\(F^{-1}\)</span> hesabının
yapılabilmesi için bu fonksiyonun bir analitik formu olması gerekir;
bazı durumlarda bu mümkün olmayabilir. Mesela normal (gaussian)
dağılımın cdf’inin tersinin analitik formu mevcut değildir. Ya da çok
daha çetrefil, çok boyutlu dağılımlar durumunda da bu mümkün
olmayabilir. Bu tür durumlar için başka yöntemler var, Markov Zinciri
Monte Carlo (MCMC) yöntemleri mesela, ya da daha basit Kabul-Reddet
(Accept-Rejection) yöntemi… Dağılımları simüle etme konusunun arkasında
derin bir literatür var [2].</p>
<p>Peki <span class="math inline">\(U\)</span> Nereden Geliyor?</p>
<p>Diyelim ki elimizde tersi alınabilir bir cdf var, ve artık bu
dağılımdan sayı üretmek istiyoruz. Peki cdf tersine verilecek birörnek
sayılar nereden gelecek?</p>
<p>Bu durumda sözde rasgele (pseudorandom) sayı üretimi konusuna
girebiliriz. Favori hesap kütüphanemizden birörnek sayılar üretebiliriz,
fakat bu kütüphanelerin ne yaptığını bilmek iyi olur. Kendimiz rasgele
sayı üretmek istiyorsak, bunun en kolay, etkili yolu lineer eşleşikşel
üretici (linear congruential generator) kullanmak.</p>
<p><span class="math display">\[ Z_i = (a Z_{i-1} + c) \bmod m
\]</span></p>
<p><span class="math inline">\(a\)</span> çarpan, <span
class="math inline">\(m\)</span> ise genlik (modülüs). <span
class="math inline">\(\bmod\)</span> bildiğimiz gibi modülo
matematiğinden geliyor, <span class="math inline">\(4 \bmod 2 =
0\)</span>, <span class="math inline">\(5 \bmod 3 = 2\)</span>, vs.,
bölümden arta kalanların matematiği yani. Modülo operatörü sayesinde
<span class="math inline">\(Z_i\)</span> sonuçları 1 ile <span
class="math inline">\(m-1\)</span> arasında olacaktır. Çoğunlukla <span
class="math inline">\(m\)</span> büyük ve asal bir sayı olarak seçilir.
<span class="math inline">\(R_i = Z_i / m\)</span> ve <span
class="math inline">\(R_i \in (0,1)\)</span>. Amaç bir dizi <span
class="math inline">\(R_i\)</span>’in <span
class="math inline">\(U(0,1)\)</span>’den geliyormuş gibi gözükmesini
sağlamak. Bu seri tabii ki bir süre sonra kendini tekrar edecektir, ama
bunun olması için uzun zaman geçiyorsa bu bizim için iyi bir
sonuçtur.</p>
<p><span class="math inline">\(a,c,m\)</span>’in dikkatli seçilmesi
gerekir, ki tekrarsız periyot uzun ve üretilen sayıların istatistiki
kalitesi iyi olsun. Eğer <span class="math inline">\(c=0\)</span> ise
üstte gösterilene çarpımsal üreteç ismi veriliyor. Neyse, örnek
olarak</p>
<p><span class="math display">\[ Z_i = (5 Z_{i-1} + 3) \bmod 8
\]</span></p>
<p>kullanalım. Eğer <span class="math inline">\(Z_0 = 0\)</span> ise (ki
bu başlangıç noktasına tohum -seed- ismi de verilir) bir sonraki sayı
<span class="math inline">\(Z_1 = (5 Z_0 + 3) \bmod 8 = 3\)</span> olur,
ve böyle devam edersek,</p>
<p><img src="stat_fxu_01.png" /></p>
<p>Görüldüğü gibi 8. adımda başa dönmüş olduk, çünkü <span
class="math inline">\(Z_8 = 0\)</span>. Bu üreteç tam-periyot
üretecidir, yani <span class="math inline">\(\bmod \ 8\)</span> dedik ve
tekrar edene kadar 8 tane sayı ürettik. Genel olarak tam periyot iyi bir
şeydir. Eğer</p>
<p><span class="math display">\[ Z_i = (5 Z_{i-1} + 1) \bmod
7\]</span></p>
<p>seçseydik, <span class="math inline">\(Z_0=1\)</span> ile <span
class="math inline">\(1,6,3,2,4,6\)</span> yani küt diye 6’ya döndük. Bu
olmadı, tam periyot değil. Eğer <span
class="math inline">\(Z_0=5\)</span> seçseydik sonuç daha da kötü
olurdu, bir sonraki sayı başlangıcın kendisi, yani 5! Bu durumda tek bir
tane bile sözde rasgele sayı bile üretememiş olurduk.</p>
<p>Çok iyi üreteçlerden biri</p>
<p><span class="math display">\[ Z_i = 16807 Z_{i-1} \bmod
(2^{31}-1)\]</span></p>
<p>Bu çok hızlı işleyen, tekrar edene kadar 2 milyar (dikkat:
<em>milyar</em>) sayıdan daha fazla sayı üretebilen bir üreteçtir. Kodu
altta bulunabilir, <span
class="math inline">\(2^{31}-1=2147483647\)</span> olduğunu
biliyoruz,</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> do_unif(ix): </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> (<span class="dv">16807</span><span class="op">*</span>ix) <span class="op">%</span> <span class="dv">2147483647</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> u</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> do_unif(<span class="fl">1e7</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> u</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> do_unif(u)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> u</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> do_unif(u)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> u</span></code></pre></div>
<pre><code>566275534.0
1892860081.0
476634709.0</code></pre>
<p>Biraz daha farklı bir yaklaşım [1], [5, sf. 215],</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> do_unif(ix): </span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    k1 <span class="op">=</span> <span class="bu">int</span>(ix<span class="op">/</span><span class="dv">127773</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    ix <span class="op">=</span> <span class="dv">16807</span><span class="op">*</span>(ix <span class="op">-</span> k1<span class="op">*</span><span class="dv">127773</span>) <span class="op">-</span> k1<span class="op">*</span><span class="dv">2836</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ix <span class="op">&lt;</span> <span class="dv">0</span>: ix <span class="op">=</span> ix <span class="op">+</span> <span class="dv">2147483647</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> ix<span class="op">*</span><span class="fl">4.656612875e-10</span> <span class="co"># 1&#39;den kucuk olmasi icin</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ix, u</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>ix, u <span class="op">=</span> do_unif(<span class="fl">1e7</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> u</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>ix, u <span class="op">=</span> do_unif(ix)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> u</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>ix, u <span class="op">=</span> do_unif(ix)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> u</span></code></pre></div>
<pre><code>0.263692594242
0.881431662376
0.22195033226</code></pre>
<p>Eğer tek bir çağrı ile istediğimiz kadar birörnek sayı üretmek
istiyorsak,</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> unif(size,seed<span class="op">=</span><span class="fl">1e7</span>):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    tmp <span class="op">=</span> seed<span class="op">;</span> res <span class="op">=</span> []</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(size):</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>       tmp,u<span class="op">=</span>do_unif(tmp)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>       res.append(u)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(res)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> unif(size<span class="op">=</span><span class="dv">10</span>)</span></code></pre></div>
<pre><code>[ 0.26369259  0.88143166  0.22195033  0.31923449  0.37412169  0.8632809
  0.16214486  0.16868319  0.05836612  0.95940828]</code></pre>
<p>Örnek: Üstel Rasgele Değişken Üretmek</p>
<p><span class="math inline">\(X = F^{-1}(U)\)</span> prensibini
kullanarak üstel (exponential) dağılımdan gelen rasgele sayılar
üretelim. Birörnek üreticimiz var, üstel dağılım için cdf’in tersini
biliyoruz, ki bu <span class="math inline">\(F^{-1}(p;\lambda) =
-\ln(1-p) / \lambda\)</span>. Tüm bunları biraraya koyarsak,</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> unif(size<span class="op">=</span><span class="dv">1000</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>lam <span class="op">=</span> <span class="fl">4.</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="op">-</span>np.log(<span class="dv">1</span><span class="op">-</span>x) <span class="op">/</span> lam <span class="co"># cdf tersi</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>f<span class="op">=</span>plt.figure()<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>plt.hist(y)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;stat_fxu_02.png&#39;</span>)</span></code></pre></div>
<p><img src="stat_fxu_02.png" /></p>
<p>Üstel dağılıma benziyor! İşin iyi tarafı bu üretimi yapmak için tüm
öğeleri evde kendimiz pişirdik. Birörnek rasgele sayıları bile kendimiz
üretiyoruz.</p>
<p>Uyum Derecesi ve Düzgünlük Testi (Goodness-of-Fit, Smooth Test)</p>
<p><span class="math inline">\(F_X(X) = U\)</span> başka bir açıdan bir
“numara’’ olarak ta kullanılabilir, çünkü teoriye göre sadece ve sadece
<span class="math inline">\(F_X\)</span> fonksiyonu hakikaten <span
class="math inline">\(X\)</span>’in cdf’i ise ispat geçerli. Bu gerçeği
bir istatistiki test için başlangıç noktası olarak kullanabiliriz;
Diyelim ki elimizde bir <span class="math inline">\(X\)</span> var ve
dağılımının ne olduğunu bilmiyoruz. Ama eğer doğru dağılımı seçmişsek,
mesela <span class="math inline">\(F_0\)</span>, <span
class="math inline">\(F_0(X)\)</span> bize birörnek sonuç verir, değilse
vermez. O zaman bir tahmini cdf’i birörneklik testiyle birleştirirsek,
verinin / rasgele değişkenin dağılımın ne olduğunu test eden bir
istatistiki test bulmuş oluruz [3, sf. 325].</p>
<p>Birörneklik testi dedik, bunun için zaten bilinen chi kare, K-S uyum
derece testi gibi testleri mi kullansak acaba? Neyman adlı istatistikçi
mevcut olanları kullanmak yerine özellikle birörnek dağılımına odaklı
bir test yaratmaya karar verdi. Neyman’ın düzgünlük testi (Neyman’s
smooth test) birkaç baz fonksiyonunun toplamından oluşan bir alternatifi
(0,1) aralığına gömüyor (embed), ki sıfır hipotezinde bu gömülü
fonksiyon bize birörnek sonuçla aynı sonucu verir, ama birörneklikten
sapma varsa, baz fonksiyonları öyle oluşturulmuştur ki bu sapmanın
etkisi düzgün, sürekli bir şekilde birörneklikten ayrılır (ki testin
ismi buradan geliyor). Ayrıca baz fonksiyonları öyle seçilmiştir ki
sıfır hipotezi altında test için bir chi kare dağılımı elde ederiz,
birörnek olmama durumunu bu chi kare dağılımda aykırı bölgeye düşmek
olarak irdeleyebiliriz, ve testimiz bunun üzerinden hesaplanır.</p>
<p>Bu özel fonksiyonlar nelerdir? Onları <span
class="math inline">\(h_j(y)\)</span> olarak gösterelim, ki <span
class="math inline">\(j=1,..,d\)</span> olsun, yani <span
class="math inline">\(d\)</span> tane baz fonksiyonu var. Neyman’a göre
<span class="math inline">\(d=4\)</span> yeterlidir (baz fonksiyonuna
göre değişir tabii, biz alttaki örnekte 5 kullandık). Bu fonksiyonlara
bazı şartlar getiriliyor, öncelikle <span
class="math inline">\(h_j\)</span>’ler sabit fonksiyona (yani 1’e) ve
birbirlerine dikgen (orthogonal) olmalılar. Yani</p>
<p><span class="math display">\[ \int_{0}^{1} h_j(y) \mathrm{d} y = 0
\]</span></p>
<p><span class="math display">\[ \int_{0}^{1} h_k(y)h_j(y) \mathrm{d} y
= 0 \]</span></p>
<p>Ayrıca büyüklüğü (yani karesi) normalize edilmiş olmalı</p>
<p><span class="math display">\[
\int_{0}^{1} h_j(y)^2 \mathrm{d} y = 1
\qquad (1)
\]</span></p>
<p>Bu şartları tatmin eden hangi fonksiyonlar vardır? Aklımıza gelen her
fonksiyon tipi üstteki şartlara uymayabilir. Neyman Legendre polinomları
denen polinomları kullandı, fakat aslında üstteki şartları yerine
getiren</p>
<p><span class="math display">\[ h_j(y) = c_j \cos (2\pi j y)
\]</span></p>
<p>ki <span class="math inline">\(c_j\)</span> normalizasyon sabiti,
gayet rahat kullanılabilir. Dikkat, üstteki sabit <span
class="math inline">\(h_j\)</span>’yi bir dağılım haline getirmez,
“büyüklük hesabı için’’ onu normalize eder. Sebebini birazdan
göreceğiz.</p>
<p>Not: Üstteki fonksiyon eğer Fourier serilerini hatırlattıysa bu doğru
bir gözlemdir, böyle bir bağlantı var.. Birbirine dikgen fonksiyonlar
özel fonksiyonlar tabii, Fourier serilerinde bu sebeple kullanılıyorlar,
ve dikgenlik lineer cebirde de çok ortaya çıkar. Kontrol edilmek
istenirse <span class="math inline">\(1, \cos (2\pi y), \cos (4\pi y),
\cos (6 \pi y), ..\)</span> fonksiyonlarının birbirine dikgen olduğu
entegral hesabını yapılarak görülebilir.</p>
<p>Devam edelim, (1)’i tatmin etmek için gereken <span
class="math inline">\(c_j\)</span>’i hesaplayalım,</p>
<p><span class="math display">\[
\int_{0}^{1} c_j^2 \cos(2 \pi y)^2 \mathrm{d} y = 1
\]</span></p>
<p><span class="math display">\[
\int_{0}^{1}\cos(2 \pi y)^2 \mathrm{d} y = 1/c_j^2
\]</span></p>
<p>Trigonometrik eşitlik [4, sf 435]</p>
<p><span class="math display">\[ \cos(\theta)^2 = \frac{1 + \cos 2
\theta }{2}\]</span></p>
<p>O zaman,</p>
<p><span class="math display">\[
\cos(2 \pi y)^2 = \frac{1}{2} + \frac{1}{2}\cos(4 \pi y)
\]</span></p>
<p>Entegrale geri koyalım,</p>
<p><span class="math display">\[
\int_{0}^{1} \frac{1}{2} + \frac{1}{2}\cos(4 \pi y) \mathrm{d} y
\]</span></p>
<p><span class="math display">\[
= \frac{y}{2} + \frac{1}{8\pi}\sin(4 \pi y)  \bigg|_{0}^{1}
\Rightarrow \frac{1}{2} = 1/c_j^2
\]</span></p>
<p><span class="math display">\[ c_j = \sqrt{2} \]</span></p>
<p>Bulunan <span class="math inline">\(c_j\)</span> her <span
class="math inline">\(j\)</span> için geçerli olacaktır.</p>
<p>Düzgünlük testi için önce <span class="math inline">\(x_i\)</span>
veri noktaları o verinin geldiğini düşündüğümüz cdf’e geçilir, yani
<span class="math inline">\(y_i = F(x_i)\)</span> hesaplanır.
Ardından,</p>
<p><span class="math display">\[ \overline{h_j} = \frac{1}{n}
\sum_{i=1}^{n} h_j(y_i) \]</span></p>
<p>Sıfır hipotezi altında ve Büyük Sayılar Kanununa göre <span
class="math inline">\(\overline{h_j} \to0\)</span>.<br />
<span class="math inline">\(\sqrt{n} \cdot \overline{h_j}\)</span> ise
Merkezi Limit Teorisi’ne göre Gaussian’dır, ve bu Gaussian’ın varyansı 1
olacaktır. Demek ki</p>
<p><span class="math display">\[
\Psi^2 = n \sum_{j=1}^{d} \overline{h_j}^2
\]</span></p>
<p>hesabı sıfır hipotezi altında <span
class="math inline">\(\chi^2_d\)</span> dağılımına sahiptir. <span
class="math inline">\(h_j\)</span>’lerin birbirine dikgen seçilmesinin
sebebi şimdi biraz daha açıklık kazanıyor herhalde, dikgen fonksiyonlar
ile arasında hiç korelasyon olmayan standart normaller üretiyoruz, ve bu
normallerin toplamının bize chi kare vermesini bekliyoruz (chi kare için
korelasyonsuz standard normallerin toplamı gerekir).</p>
<p><span class="math inline">\(\overline{h_j} \to 0\)</span> ispatı için
sıfır hipotezinde <span class="math inline">\(y_i\)</span>’lerin, ya da
<span class="math inline">\(u_i\)</span> diyelim, birörnek dağılım <span
class="math inline">\(U(0,1)\)</span>’dan geldiğini hatırlayalım, yani o
zaman <span class="math inline">\(h_j(U)\)</span> bir rasgele
değişkendir, ve</p>
<p><span class="math display">\[ h_j(u_1) + h_j(u_2) + .. + h_j(u_n) / n
\]</span></p>
<p><span class="math inline">\(h_j\)</span>’nin nüfus beklentisine
yaklaşır. Peki <span class="math inline">\(h_j\)</span>’in nüfus
beklentisi nedir? Bunun için</p>
<p><span class="math display">\[ E(h_j) = \int_{-\infty}^{\infty}
f_U(u)h_j(u) \mathrm{d} u \]</span></p>
<p><span class="math inline">\(f_U(u) = 1\)</span>, ayrıca (0,1) arasına
odaklı olduğumuz için,</p>
<p><span class="math display">\[
= \int_{0}^{1} h_j(u) \mathrm{d} u = \int_{0}^{1} \cos 2\pi j u
\mathrm{d} u
= \frac{\sin 2j\pi u }{2j\pi u} \bigg|_{0}^{1} = 0
\]</span></p>
<p><span class="math inline">\(j\)</span> ne olursa olsun beklenti sıfır
demektir bu. Peki varyans?</p>
<p><span class="math display">\[
Var(h_j) = E(h_j^2)-E(h_j)^2 = \int_{-\infty}^{\infty} f_U(u)h_j^2(u)
\mathrm{d} u
\]</span></p>
<p>üstte <span class="math inline">\(E(h_j)=0\)</span> olduğunu bulduk,
bu terim üstteki formülde iptal oldu. Ve (1)’ın de yardımıyla,</p>
<p><span class="math display">\[  = \int_{0}^{1}  h_j^2(u) \mathrm{d} u
= 1\]</span></p>
<p>Prosedür böylece tamamlandı.</p>
<ol type="1">
<li><p>cdf ile veriden <span class="math inline">\(y=F(x)\)</span>
hesapla</p></li>
<li><p><span class="math inline">\(h_j\)</span> hesapla, ki bizim
seçtiğimiz baz için <span class="math inline">\(c_j = \sqrt{2}\)</span>,
ardından <span class="math inline">\(\overline{h_j}\)</span></p></li>
<li><p>En son <span class="math inline">\(\Psi^2\)</span>, sonucu <span
class="math inline">\(\chi^2_d\)</span> üzerinde kontrol et.</p></li>
</ol>
<p>Örnek</p>
<p>Bir standart normal, bir 4 derece serbestliğe sahip bir Öğrenci t
dağılımı, bir de üstel (exponential) dağılımdan üretilmiş veriyi
standart normal olup olmadığına bakmak için test ettik.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> norm</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> t</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> expon</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="dv">200000</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">0</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>xnorm <span class="op">=</span> norm.rvs(size<span class="op">=</span>s)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>xstudent <span class="op">=</span> t.rvs(df<span class="op">=</span><span class="dv">4</span>, size<span class="op">=</span>s)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>xexp <span class="op">=</span> expon.rvs(scale<span class="op">=</span><span class="dv">1</span>,size<span class="op">=</span>s)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> norm</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test(x,d<span class="op">=</span><span class="dv">5</span>,cdf<span class="op">=</span>norm.cdf):</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> cdf(x)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> np.sqrt(<span class="dv">2</span>)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># baz fonksiyonlar</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    hs <span class="op">=</span> [c<span class="op">*</span>np.cos(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>i<span class="op">*</span>x) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,d<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> [xx.mean() <span class="cf">for</span> xx <span class="kw">in</span> hs]</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> [xx<span class="op">**</span><span class="dv">2</span> <span class="cf">for</span> xx <span class="kw">in</span> res]</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span> <span class="bu">len</span>(x)<span class="op">*</span>np.<span class="bu">sum</span>(res)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>test(xstudent)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>test(xnorm)</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>test(xexp)</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> chi2</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>dof <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> <span class="st">&#39;chi kare&#39;</span>, chi2.ppf(<span class="fl">0.95</span>,dof)</span></code></pre></div>
<pre><code>12.1463285033
2.20265705473
259.103849686
chi kare 11.0704976935</code></pre>
<p>Görüldüğü gibi Öğrenci t reddedildi, normal kabul edildi, üstel çok
ciddi şekilde reddedildi. Öğrenci t dağılımı normal dağılıma çok benzer
bu arada, buna rağmen arada büyük fark dikkate değer.</p>
<p>Kaynaklar</p>
<p>[1] Goldsman, D., <em>ISyE 6644 - Simulation Lecture</em>, <a
href="http://www2.isye.gatech.edu/~sman/courses/6644/">http://www2.isye.gatech.edu/~sman/courses/6644/</a></p>
<p>[2] Ross, <em>Introduction to Probability Models, 10th
Edition</em></p>
<p>[3] Shalizi, <em>Advanced Data Analysis from an Elementary Point of
View</em></p>
<p>[4] Thomas, <em>Thomas’ Calculus, 11th Ed</em></p>
<p>[5] Schrage, <em>A Guide to Simulation</em></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
