<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  
  
  
  
</head>
<body>
<h1 id="binom-için-normal-yaklaşıksallığı">Binom İçin Normal Yaklaşıksallığı</h1>
<p>Merkezi Limit Teorisinden <span class="math inline">\(\bar{X}\)</span>'nin her <span class="math inline">\(X_i\)</span> için aynı olan nüfus beklentisi ve sapmasını içeren <span class="math inline">\(N(\mu,\sigma)\)</span> olarak dağılacağını biliyoruz. Ve bu durum, nüfus <em>hangi dağılıma sahip olursa olsun</em> geçerlidir. <span class="math inline">\(X_1,..,X_n\)</span> birbirinden bağımsız ve aynı Bernoulli olarak dağılmış, ve onların toplamını temsil eden binom dağılımı <span class="math inline">\(X\)</span> olarak tanımlayalım, o zaman</p>
<p><span class="math display">\[ X = X_1 + X_2 + .. +  X_n \]</span></p>
<p>Daha önceden biliyoruz ki <span class="math inline">\(E(X_i) = p, Var(X_i) = p(1-p)\)</span>, standart sapma varyansın karekökü. O zaman Merkezi Limit Teorisine göre,</p>
<p><span class="math display">\[ 
Z = 
\frac{X/n - p}{\sqrt{p(1-p)/n}} =
\frac{X - np}{\sqrt{np(1-p)}}
\]</span></p>
<p>Soru</p>
<p>Amerikalıların yüzde 12'sinin zenci olduğunu biliyoruz. Eğer 1500 kişiyi içeren bir örneklem alsaydık, bu örneklemde 170'den daha az zenci olmasının olasılığı nedir?</p>
<p>Cevap</p>
<p>%12 nüfus parametresidir, yani <span class="math inline">\(p=0.12\)</span>. Örneklem <span class="math inline">\(n=1500\)</span>. Normal yaklaşıksallaması ile</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> scipy.stats <span class="im">import</span> norm
n <span class="op">=</span> <span class="dv">1500</span>
p <span class="op">=</span> <span class="fl">0.12</span>
mu <span class="op">=</span> n<span class="op">*</span>p
std <span class="op">=</span> np.sqrt(n<span class="op">*</span>p<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>p))
<span class="bu">print</span> mu,std
<span class="bu">print</span> <span class="st">&#39;olasilik&#39;</span>,norm.cdf(<span class="dv">170</span>,loc<span class="op">=</span>mu,scale<span class="op">=</span>std)</code></pre></div>
<pre><code>180.0 12.585706178
olasilik 0.213437028747</code></pre>
<p>Yani <span class="math inline">\(N(180,12.58)\)</span> dağılımını elde ettik ve hesapları onun üzerinden yaptık. Sonuç diyor ki verilen örneklem ve nüfus <span class="math inline">\(p\)</span> değeri ile 170 altında zenci sayısı elde etmek oldukça düşük bir ihtimalde.</p>
<p>Örnek</p>
<p>Diyelim ki elimizde bir Web sitesinin günlük ziyaret, tıklama sayılarını gösteren bir veri seti var, CVR ziyaretçilerin sitedeki tıklayan müşteriye dönüşmesi oranı (conversion).</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pandas <span class="im">as</span> pd
<span class="im">from</span> scipy <span class="im">import</span> stats
a <span class="op">=</span> pd.DataFrame({<span class="st">&#39;tiklama&#39;</span>: [<span class="fl">20.</span>,<span class="fl">2.</span>,<span class="fl">40.</span>,<span class="fl">5.</span>,<span class="fl">10.</span>,<span class="fl">100.</span>],
                  <span class="st">&#39;ziyaret&#39;</span>: [<span class="fl">100.</span>,<span class="fl">10.</span>,<span class="fl">300.</span>,<span class="fl">400.</span>,<span class="fl">30.</span>,<span class="fl">800.</span>]})
a[<span class="st">&#39;cvr&#39;</span>] <span class="op">=</span> a[<span class="st">&#39;tiklama&#39;</span>] <span class="op">/</span> a[<span class="st">&#39;ziyaret&#39;</span>] 
<span class="bu">print</span> a</code></pre></div>
<pre><code>   tiklama  ziyaret       cvr
0       20      100  0.200000
1        2       10  0.200000
2       40      300  0.133333
3        5      400  0.012500
4       10       30  0.333333
5      100      800  0.125000</code></pre>
<p>Bu veri seti için cvr'in 0.16, yani yüzde 16 olduğunu önceden biliyoruz. Üstteki başarı oranı binom dağılı ile modellenebilir, ziyaretler &quot;deneylerdir&quot;, yani örneklem büyüklüğünü gösterirler. Tıklama ise başarıdır, önceki binom örneğindeki aynı formülü kullanırsak, normal yaklaşıksallığı üzerinden bir z-skoru hesaplayabiliriz,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">p <span class="op">=</span> <span class="fl">0.16</span>
btest <span class="op">=</span> <span class="kw">lambda</span> x: (x[<span class="st">&#39;cvr&#39;</span>]<span class="op">-</span>p) <span class="op">/</span> np.sqrt( p<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>p)<span class="op">/</span>x[<span class="st">&#39;ziyaret&#39;</span>])
a[<span class="st">&#39;guven&#39;</span>] <span class="op">=</span> a.<span class="bu">apply</span>(btest, axis<span class="op">=</span><span class="dv">1</span>)
a[<span class="st">&#39;guven&#39;</span>] <span class="op">=</span> np.<span class="bu">round</span>(stats.zprob(a[<span class="st">&#39;guven&#39;</span>])<span class="op">*</span><span class="dv">100</span>,<span class="dv">2</span>)
<span class="bu">print</span> a</code></pre></div>
<pre><code>   tiklama  ziyaret       cvr  guven
0       20      100  0.200000  86.24
1        2       10  0.200000  63.50
2       40      300  0.133333  10.39
3        5      400  0.012500   0.00
4       10       30  0.333333  99.52
5      100      800  0.125000   0.35</code></pre>
<p>Soru</p>
<p>Amerika'da 2009 yılında halkın ne kadarının arabalarında yakıt tasarrufunu desteklediği merak konusuydu. Bir Gallup telefon anketinde bu soru 1012 yetişkine (18 ve üstü yaşta) soruldu. Cevap 810 kişinin tasarrufu desteklediği yönündeydi. Yani <span class="math inline">\(n=1012,k=810\)</span>. O zaman <span class="math inline">\(p\)</span> için %95 güven aralığını bulun.</p>
<p>Cevap</p>
<p><span class="math display">\[ \bigg(
\frac{810}{1012}
-1.96 \sqrt{ \frac{(810/1012)(1-810/1012)}{1012} } ,
1.96  \sqrt{ \frac{(810/1012)(1-810/1012)}{1012} }
\bigg)
\]</span></p>
<p><span class="math display">\[ = (0.776,0825) \]</span></p>
<p>Python ile</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">m <span class="op">=</span> <span class="dv">810</span><span class="op">/</span><span class="fl">1012.</span>
low <span class="op">=</span> m <span class="op">-</span> <span class="fl">1.96</span><span class="op">*</span>np.sqrt(m<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>m)<span class="op">/</span><span class="fl">1012.</span>)
high <span class="op">=</span> m <span class="op">+</span> <span class="fl">1.96</span><span class="op">*</span>np.sqrt(m<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>m)<span class="op">/</span><span class="fl">1012.</span>)
<span class="bu">print</span> low, high</code></pre></div>
<pre><code>0.775768711331 0.825021802503</code></pre>
<p>Soru</p>
<p>Borsa konusunda okuyuculara tiyo veren bir gazete, bir şirket hissesinin belli bir olay ardından çoğunlukla yükseldiğini söylüyor. Yazara göre hisse 9 olay içinden 6'sında bu çıkmış. Buradan hareketle yazar hissenin tekrar çıkma şansının 6/9=%66.7 olduğunu iddia ediyor. Okuyucu bunu ciddiye alsın mı?</p>
<p>Cevap</p>
<p>Ufak örneklemler için Agresti ve Coull yöntemini kullanmak iyi olur, bu yönteme göre başarılı olay sayısına iki, tüm olay sayısına 4 ekleriz (yani 2 başarısızlık eklemiş oluruz) ve <span class="math inline">\(\hat{p} = (x+2)(n+4)\)</span> elde edilir. Bu ekler hem genel teorik olarak bir değişim yaratmaz, hem de örneklem sayısını arttırarak Normal yaklaşıksallığını kullanabilmemizi sağlar. Güven aralığı,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">x<span class="op">=</span><span class="fl">6.</span><span class="op">;</span>n<span class="op">=</span><span class="fl">9.</span><span class="op">;</span>p<span class="op">=</span>(x<span class="op">+</span><span class="dv">2</span>)<span class="op">/</span>(n<span class="op">+</span><span class="dv">4</span>)<span class="op">;</span> z <span class="op">=</span> <span class="fl">1.96</span>
<span class="bu">print</span> p <span class="op">+</span> np.array([<span class="op">-</span><span class="dv">1</span>,<span class="op">+</span><span class="dv">1</span>])<span class="op">*</span>z<span class="op">*</span>np.sqrt(p<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>p)<span class="op">/</span>n)</code></pre></div>
<pre><code>[ 0.29753517  0.93323406]</code></pre>
<p>Demek ki yazar okuyucularına kötü bir tavsiye vermiş, güven aralığının alt kısmı %30 olduğuna göre hissenin yükselmesi garanti değildir, garanti için güven aralığının iki ucu da %50 üzerinde olmalıydı. Noktasal tahmin bağlamında %66.7 rakamı da yanıltıcıdir. Bu yazar okuyucularının para kaybetmesine sebep olabilir.</p>
<p>Örneklem Büyüklüğü</p>
<p>Bir araştırmacı <span class="math inline">\(n\)</span> bağımsız deney baz alınarak elde edilen binom parametresi <span class="math inline">\(p\)</span>'yi tahmin etmek istiyor, fakat kaç tane <span class="math inline">\(n\)</span> kullanması gerektiğini bilmiyor. Tabii ki daha büyük <span class="math inline">\(n\)</span> değerleri daha iyi sonuçlar verecektir, ama her deneyin bir masrafı vardır. Bu iki gereklilik nasıl birbiri ile uzlaştırılır?</p>
<p>Yeterli olacak en az kesinliği, duyarlılığı (precision) bulmak için Z transformasyonu kullanılabilir belki. Diyelim ki <span class="math inline">\(p\)</span> için maksimum olurluk tahmini olan <span class="math inline">\(X/n\)</span>'in en azından <span class="math inline">\(100(1-\alpha)\%\)</span> olasılıkta <span class="math inline">\(p\)</span>'nin <span class="math inline">\(d\)</span> kadar yakınında olmasını istiyoruz. O zaman alttaki denklemi tatmin eden en ufak <span class="math inline">\(n\)</span>'i bulduğumuz anda problemimizi çözdük demektir,</p>
<p><span class="math display">\[ P\bigg( -d \le \frac{X}{n} - p \le d \bigg)  = 1-\alpha
\qquad (1)
\]</span></p>
<p>Tahmin edici <span class="math inline">\(X/n\)</span>'nin kendisi de bir rasgele değişkendir. Bu değişken normal olarak dağılmıştır, çünkü <span class="math inline">\(X\)</span> Binom olarak dağılmış ise, bu dağılım ayrı Bernoulli dağılımlarının toplamına eşittir. Fakat başka bir irdeleme bizi daha basitçe sonuca götürür, binom dağılımı bir toplamdır, bu toplamı, yani <span class="math inline">\(X\)</span>'i <span class="math inline">\(n\)</span> ile bölüyorsak, otomatik olarak bir aritmetik averaj işlemi yapmış oluyoruz. Bağımsız özdeşçe dağılmış (ıid) rasgele değişkenlerin aritmetik ortalaması Merkezi Limit Kanunu'na göre normal'e yaklaştığına göre o zaman, elimizde bir normal dağılım var demektir.</p>
<p>Standardize etmek için <span class="math inline">\(X/n\)</span>'den beklentiyi çıkartıp standart sapmaya bölebiliriz. Beklenti zaten çıkartılmış durumda (şansa bak!), beklentinin ne olduğunu kontrol edelim tabii, ezbere yapmayalım bu işi, eğer her Bernoulli'yi <span class="math inline">\(X_i\)</span> olarak temsil edersek,</p>
<p><span class="math display">\[ X = X_1 + .. + X_n \]</span></p>
<p><span class="math display">\[ X/n = 1/n(X_1 + .. + X_n )\]</span></p>
<p><span class="math display">\[ E[X/n] = E[1/n(X_1 + .. + X_n )]\]</span></p>
<p><span class="math display">\[  = 1/nE[(X_1 + .. + X_n )]\]</span></p>
<p><span class="math display">\[  = (1/n)np = p\]</span></p>
<p>Varyans için</p>
<p><span class="math display">\[
Var(X/n) = \frac{1}{n^2}Var(X) = \frac{1}{n^2}np(1-p)=
\frac{1}{n}p(1-p) 
\]</span></p>
<p>Binom dağılımlar için <span class="math inline">\(Var(X) = np(1-p)\)</span> olduğunu biliyoruz. Standart sapma üstteki ifadenin karekökü, yani</p>
<p><span class="math display">\[ Std(X/n) = \sqrt{p(1-p)/n}
\]</span></p>
<p>Simdi standardize edelim,</p>
<p><span class="math display">\[ P\bigg( 
\frac{-d}{\sqrt{p(1-p)/n}} \le 
\frac{\frac{X}{n} - p }{\sqrt{p(1-p)/n}}\le 
\frac{d}{\sqrt{p(1-p)/n}} 
\bigg)  = 
1-\alpha\]</span></p>
<p><span class="math display">\[ P\bigg( 
\frac{-d}{\sqrt{p(1-p)/n}} \le 
Z
\frac{d}{\sqrt{p(1-p)/n}} 
\bigg)  = 
1-\alpha\]</span></p>
<p>Daha önceki z-skoru içeren eşitsizlikleri hatırlarsak, üstteki ifade</p>
<p><span class="math display">\[ \frac{d}{\sqrt{p(1-p)/n}} = z_{\alpha/2} 
\]</span></p>
<p>O zaman</p>
<p><span class="math display">\[ \frac{z_{\alpha/2}^2p(1-p)}{d^2} = n \]</span></p>
<p>Fakat bu bir nihai sonuç olamaz, çünkü <span class="math inline">\(n\)</span>, <span class="math inline">\(p\)</span>'nin bir fonksiyonun haline geldi ve <span class="math inline">\(p\)</span> bilinmeyen bir değer. Fakat biliyoruz ki <span class="math inline">\(0 \le p \le 1\)</span>, ve <span class="math inline">\(p(1-p) \le \frac{1}{4}\)</span>. Yani bir üst sınır (upper bound) elde ettik.</p>
<p>Bunu kontrol edelim, <span class="math inline">\(p(1-p)\)</span> hangi <span class="math inline">\(p\)</span>'de maksimize olur? <span class="math inline">\(p\)</span>'ye göre türev alırız, sıfıra eşitleriz, <span class="math inline">\((p-p^2)&#39; = 1 - 2p = 0, p=1/2\)</span>. Ve hesabı yaparsak, <span class="math inline">\(1/2(1-1/2)=1/4\)</span>. Demek ki <span class="math inline">\(p(1-p)\)</span> değeri <span class="math inline">\(1/4\)</span>'ten daha büyük olamaz. Buna göre, üstteki formüle <span class="math inline">\(p(1-p)\)</span> yerine onun olabileceği en büyük değeri koyarsak,</p>
<p><span class="math display">\[ \frac{z_{\alpha/2}^21/4}{d^2} = n \]</span></p>
<p><span class="math display">\[ n = \frac{z_{\alpha/2}^2}{4d^2} \]</span></p>
<p>Not: <span class="math inline">\(p(1-p)\)</span>, 1/4 değerinden daha küçük olabilir mi? Olabilir. Bu durumda <span class="math inline">\(n\)</span> üstteki formülden elde edebileceğimiz değerden daha küçük te çıkabilecektir. Fakat <span class="math inline">\(p(1-p)\)</span>'in olabileceği en büyük değer 1/4'u kullanarak &quot;<span class="math inline">\(n\)</span>'in bundan daha büyük olmasına gerek yok'' diyebilen bir formüle erişmiş olduk, yani, aslında <span class="math inline">\(n\)</span> için bir üst sınır elde ettik.</p>
<p>Örnek</p>
<p>Büyük bir şehirde çocukların kaçta kaçının aşısını almış olup olmadığını anlamak için bir anket gerçekleştirilecek. Anketi düzenleyenler örneklem oranı olan <span class="math inline">\(X/n\)</span>'in en az 98% oranda gerçek oran <span class="math inline">\(p\)</span>'nin 0.05 yakınında olmasını istiyorlar. Örneklem ne kadar büyük olmalıdır?</p>
<p>Burada <span class="math inline">\(100(1-\alpha) = 98\)</span>, o zaman <span class="math inline">\(\alpha = 0.02\)</span>, demek ki <span class="math inline">\(z_{\alpha/2} = z_{0.02/2} = z_{0.01}\)</span> değerine ihtiyacımız var. Python ile</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> scipy.stats.distributions <span class="im">import</span> norm
<span class="bu">print</span> norm.ppf(<span class="fl">0.99</span>)</code></pre></div>
<pre><code>2.32634787404</code></pre>
<p>Tüm hesap için</p>
<p><span class="math display">\[ n = \frac{(2.33)^2}{4(0.05)^2} = 543\]</span></p>
<p>Demek ki kabul edilebilir en ufak değer 543.</p>
<p>Hata Payı (Margin of Error)</p>
<p>Basında oranları rapor ederken onunla beraber telafuz edilen bir kavram hata payıdır. Aslında bu binom dağılımlarda güven aralığı ile çok yakından alakalıdır; hata payı %95 güven aralığının en maksimum genişliğinin yarısı olarak bilinir. Yani %95 aralığının bir ucunu diğer ucundan çıkartırsak ve ikiye bölersek, istenen sonuca erişiriz. Formülsel olarak genişlik <span class="math inline">\(w\)</span>,</p>
<p><span class="math display">\[ w = \frac{k}{n} + 
1.96 \sqrt{\frac{(k/n)(1-k/n)}{n}} - 
- \bigg[ 
\frac{k}{n} -
1.96 \sqrt{\frac{(k/n)(1-k/n)}{n}}
\bigg]
 \]</span></p>
<p><span class="math display">\[ = 3.92 \sqrt{\frac{(k/n)(1-k/n)}{n}} \]</span></p>
<p>Şimdi <span class="math inline">\((k/n)(1-k/n)\)</span> çarpımını düşünelim. [8] bölümünde gördük, <span class="math inline">\(n\)</span> her zaman <span class="math inline">\(k\)</span>'den büyük olduğuna göre <span class="math inline">\(k/n\)</span> her zaman 0 ve 1 arasındadır, o zaman <span class="math inline">\((k/n)(1-k/n) \le 1/4\)</span> olmalıdır, yani gösterilen çarpım 1/4'ten büyük olamaz. Bunu alıp üstteki formül içine koyarsak,</p>
<p><span class="math display">\[ \max w = 3.92 \sqrt{\frac{1}{4n}} \]</span></p>
<p>elde ederiz. Bunun yarısı hata payıdır <span class="math inline">\(d\)</span> olur, yani</p>
<p><span class="math display">\[ d = \frac{0.98}{\sqrt{n}} \]</span></p>
<p>Örnek</p>
<p>Bir seçim kampanyası sırasında A ve B adayları arasında hangisinin daha önce olduğunu bulmak için bir anket yapılır. Telefonda 597 kişiye sorulduğunda A adayının 299 kişinin oyunu alacağı saptanmıştır. Basın durumu &quot;A adayının avantajı hata payı %4 içinde olduğu için o önde kabul edilebilir'' diye rapor etmiştir. A oylarının hata payı hakikaten %4'müdür?</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">n <span class="op">=</span> <span class="fl">597.</span>
k <span class="op">=</span> <span class="dv">299</span>
<span class="bu">print</span> n<span class="op">/</span><span class="dv">2</span>
<span class="bu">print</span> k<span class="op">/</span>n
d <span class="op">=</span> <span class="fl">0.98</span><span class="op">/</span>np.sqrt(n) 
<span class="bu">print</span> d<span class="op">*</span><span class="dv">100</span></code></pre></div>
<pre><code>298.5
0.500837520938
4.01087299444</code></pre>
<p>Evet hata payı %4 çıktı.</p>
<p>Dikkat edilirse hata payının anketten gelen sonuçlarla hiçbir alakası yok, A için tercih %25, %75 olabilirdi ama üstteki hata payı hesabı yine aynı kalırdı. Bunun sebebi formülün <span class="math inline">\(n\)</span>'ye bağlı olması.</p>
<p>Daha önemli soru hata payı basının üstteki ifadesinin gerçekten seçim sonucu ile alakalı olup olmadığı!</p>
<p>Hipotez Testleri (Hypothesis Testing)</p>
<p>İstatistik tek ya da aralıklar olarak sayısal tahminler üretmenin ötesinde, &quot;iki şey arasında birisini seçmek'' türünde bir karar bağlamında da kullanılabilir. Bir psikolog bir davaya uzman görüş vermek için çağrılmıştır ve sanık hakkında 'aklı olarak dengesiz ya da dengeli' arasında bir seçim yapacaktır. İlaç regülasyonu ile uğraşan kurum yeni bir ilaç hakkında 'etkili' ya da 'etkisiz' şeklinde bir karara ulaşacaktır.</p>
<p>Bir deneyin mümkün sonuçlarını belli seçeneklere yönlendirip olasılık teorisini kullanarak bunlardan birisini seçmeye İstatistik biliminde Hipotez Test Etmek adı verilir.</p>
<p>Birbiriyle yarış halinde olan iki hipotez vardır, bunlar sıfır hipotezi (<span class="math inline">\(H_0\)</span> olarak yazılıyor) ve alternatif hipotezdir (<span class="math inline">\(H_1\)</span> olarak yazılıyor). <span class="math inline">\(H_o\)</span> ve <span class="math inline">\(H_1\)</span> arasında nasıl seçim yapacağımız kavramsal olarak bir davada jürinin yaptığı seçime benzer: aynen sanığın, tersi ispatlanana kadar, masum kabul edilmesi gibi eğer veri tersi sonuca varmaya yetmezse <span class="math inline">\(H_0\)</span> da &quot;kabul edilir'', yani suçsuzluğun devam etmesi gibi <span class="math inline">\(H_0\)</span> görüşü terkedilmemiş olur. Statüko devam eder. Bu kararı verirken mahkemenin kanıtları incelemesi, hipotez testinde rasgele değişkenlerle verinin üzerinden hesaplar yapmaya benzer.</p>
<p>Bunu bir örnek üzerinden daha iyi anlayabiliriz. Diyelim ki araba üreten bir şirket yakıt performansını (gas mileage) arttırmaya uğraşıyor. Benzine katılan yeni bir madde üzerinde deneyler yapıyorlar, deney için Boston / Los Angeles arasında 30 tane araba sefer yapıyor. Yeni katkı maddesi olmadığı durumda (statüko) yakıt performansının ortalama 25.0 mil/galon ve standart sapmanın 2.4 mil/galon olduğu biliniyor. Diyelim ki deney sonrasında arabalar ortalama olarak <span class="math inline">\(\bar{y}\)</span>=26.3 mil/galon performansı göstermişler. Katkı maddesi etkili mi, etkili değil mi?</p>
<p>Araştırmacılar 25.0'dan 26.3'e olan değişikliği daha önce bahsettiğimiz mahkeme örneğindeki gibi bir çerçevede incelerler. Tipik olarak sıfır hipotezi statükoyu temsil eder, yani değişmesi için &quot;ezici şekilde aksi yönde veri olması gereken şey'' budur. Öyle değil mi? Eğer etkisiz bir katkı maddesine evet dersek, ve ileride öyle olmadığı belli olursa bunun şirket için çok negatif etkileri olacaktır, aynen masum bir kişiyi yanlışlıkla hapse atmış olmak gibi. O yüzden kalmak istediğimiz güvenli konum <span class="math inline">\(H_0\)</span>'i temsil etmelidir.</p>
<p>Bu noktada problemi rasgele değişkenlerin terminolojisi üzerinden tekrar tanımlamak faydalı olur. Diyelim ki test sırasında 30 tane aldığımız ölçüm <span class="math inline">\(y_1,..,y_n\)</span>, her <span class="math inline">\(y_i\)</span> normal olarak dağılmış ve bu dağılımların <span class="math inline">\(\mu\)</span>'şu aynı, ve <span class="math inline">\(\mu\)</span>'u birazdan &quot;eski'' ölçümlerin ortalaması olarak alacağız, çünkü çürütmek istediğimiz hipotez bu. Ayrıca daha önceki tecrübelerimiz gösteriyor ki <span class="math inline">\(\sigma = 2.4\)</span>. Yani,</p>
<p><span class="math display">\[ 
f_Y(y;\mu) = \frac{1}{\sqrt{2\pi}(2.4)} 
e^{-\frac{1}{2}(\frac{y-\mu}{2.4})^2},
-\infty &lt; y &lt; \infty
\]</span></p>
<p>Hipotezleri şöyle tanımlayalım,</p>
<p><span class="math inline">\(H_0\)</span>: <span class="math inline">\(\mu = 25.0\)</span> (Katkı maddesi etkili <em>değildir</em>)</p>
<p><span class="math inline">\(H_0\)</span>: <span class="math inline">\(\mu &gt; 25.0\)</span> (Katkı maddesi etkilidir)</p>
<p>Şimdi yeni dağılımı standardize edip, bir hayali ortalama eşik değeri üzerinden bir sonuç çıkartalım, standardize etmek için kullandığımız <span class="math inline">\(\mu = 25.0\)</span> çünkü eski ortalama bu. Şimdi diyelim ki test ettiğimiz eşik değer 25.25 (esas amaç 26.3 ama oraya geleceğiz), aradığımız olasılık,</p>
<p><span class="math display">\[ P(\bar{Y}  \ge 25.25) \]</span></p>
<p>Üstteki ifade &quot;eğer örneklem eski dağılımdan geliyor olsaydı, 25.25 eşik değerini geçmesi ne kadar mümkün olabilirdi'' diye bir soru soruyor. <span class="math inline">\(\bar{Y}\)</span>'yi standardize edelim, o sırada eşitsizliğin sağ tarafı da değişir,</p>
<p><span class="math display">\[ P(\frac{\bar{Y} - 25.0}{2.4 / \sqrt{30}} \ge 
\frac{25.25 - 25.0}{2.4 / \sqrt{30}}) 
\]</span></p>
<p><span class="math display">\[ P(Z \ge 0.57)\]</span></p>
<p>z-Skoru tablosunu kullanakarak bu hesabı yapmak için</p>
<p><span class="math display">\[ 1 - P(Z &lt; 0.57)\]</span></p>
<p>0.57'nin z-skoru (satır 0.5 kolon .07) 0.7157 olarak gösterilmiş, o zaman 1-0.7157 = 0.2843. Kod ile</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> <span class="dv">1</span><span class="op">-</span>norm.cdf(<span class="fl">0.57</span>)</code></pre></div>
<pre><code>0.284338849046</code></pre>
<p>Demek ki</p>
<p><span class="math display">\[ P(Z \ge 0.57) = 0.2843\]</span></p>
<p>Demek ki yeni deney sonuçlarının, eski dağılıma göre, eşik değerinden fazla gelmesi hala az da muhtemel, demek ki eski hipotezi tam çürütemedik. Seçtiğimiz eşik değeri bize kesin bir sonuç sağlamadı, sezgisel olarak bu olasılığın büyük olduğunu görüyoruz. Mahkeme durumunda suçsuz olması çok muhtemeldir diyemiyoruz. Ya da araba örneğinde (ve pozitif bağlamda) yeni yakıt kesinlikle farklıdır / fazladır diyemiyoruz. Bize daha kesin noktalar lazım, aklımızda bize &quot;acaba?'' dedittirecek eşik değerler istemiyoruz.</p>
<div class="figure">
<img src="carhyp1.png" />

</div>
<p>Hayali eşik noktası <span class="math inline">\(\bar{y}^\ast\)</span>'nin daha büyük yapsak (ki o zaman ona bağlı olan sağdaki olasılık küçülecek). Bu olur mu? Eğer <span class="math inline">\(\bar{y}^\ast = 26.50\)</span> olsaydı?</p>
<p><span class="math display">\[ P(\frac{\bar{Y} - 25.0}{2.4 / \sqrt{30}} \ge 
\frac{26.50 - 25.0}{2.4 / \sqrt{30}}) 
\]</span></p>
<p><span class="math display">\[ P(Z \ge 3.42) \]</span></p>
<p><span class="math display">\[ = 0.0003 \]</span></p>
<p>Bu olasılık ise çok küçük, yani eşik değeri çok büyük! Çıtayı çok fazla kaldırdık, mahkeme durumunda sanki diyoruz ki suçun 1000 tane tanığı lazım, sanık suçunu itiraf etmiş olmalı, herşey apaçık olmalı, bir de herşeyi bizzat ben görmüş olmalıyım, yoksa kabul etmem. Araba örneğinde katkı maddesi arabaya Formula-1 yarısı kazandırmazsa biz bu yakıtı daha iyi olarak kabul etmeyiz diyoruz.</p>
<div class="figure">
<img src="carhyp2.png" />

</div>
<p>Peki eğer 0.28 çok fazla, 0.0003 çok küçük ise hangi olasılık en iyi eşik değerini verir? Bu soruya kesin olarak ve matematiksel bir cevap vermek mümkün değil, fakat hipotez test etme tekniğini kullanan araştırmacıların ulaştığı konsensüs 0.05 olasılık seviyesinin en iyi sonuçlar verdiğidir. Bu durumda sıfır hipotezinin çok kolayca kenara atılmaması, ya da ona gereğinden fazla bağlı kalınmaması mümkün oluyor.</p>
<p>O zaman 0.05 olasılığını verdirtecek eşik değeri hesaplayalım,</p>
<p><span class="math display">\[ P(\frac{\bar{Y} - 25.0}{2.4 / \sqrt{30}} \ge 
\frac{\bar{y}^\ast - 25.0}{2.4 / \sqrt{30}}) = 0.05
\]</span></p>
<p><span class="math display">\[ P(Z \ge  \frac{\bar{y}^\ast - 25.0}{2.4 / \sqrt{30}}) = 0.05
\]</span> ya da</p>
<p><span class="math display">\[ P(Z \le  \frac{\bar{y}^\ast - 25.0}{2.4 / \sqrt{30}}) = 0.95 \]</span></p>
<p>z-Skor tablosuna bakıyoruz, &quot;hangi z değeri 0.95 değeri sonucunu verir'', kordinatlardan 1.64 z-skorunu buluyoruz. Ya da</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> norm.ppf(<span class="fl">0.95</span>)</code></pre></div>
<pre><code>1.64485362695</code></pre>
<p><span class="math display">\[ P(Z \le 1.64)  = 0.95 \]</span> O zaman</p>
<p><span class="math display">\[ \frac{\bar{y}^\ast - 25.0}{2.4 / \sqrt{30}} = 1.64 \]</span></p>
<p>ve buradan <span class="math inline">\(\bar{y}^\ast = 25.178\)</span> sonucu çıkıyor. 26.3 değeri bu değerden yüksektir demek ki sıfır hipotezi çürütülmüştür. Yeni yakıt katkısının performansı arttırıyor olması büyük bir olasılıktır.</p>
<p>Not: Bu testi aslında daha basit şekilde <span class="math inline">\(\bar{y}^\ast = 26.3\)</span> değerini vererek elde edilen değeri 0.05'ten küçük olup olmadığına bakarak ta yapabilirdik. Fakat metotu inşa ediyorduk o sebeple daha fazla örnekli anlatmak gerekti.</p>
<p>Örnek</p>
<p>SAT-I testinde ülke averajına oldukça yakın sonuçlar alan bir lisede yeni bir müfredat denenmesine karar veriliyor. Deneme için 86 öğrenci rasgele şekilde seçiliyor ve yeni bir tür cebir ve geometri dersine sokuluyor. Sonraki SAT-1 testinde sonuçlarına göre bu çocuklar ortalama 502 sonuç almışlar, ülke çapındaki ortalama 494, standart sapma 124. <span class="math inline">\(\alpha=0.05\)</span> önemliliği (significance) seviyesinde yeni müfredatın başarılı olduğu iddia edilebilir mi?</p>
<p>İlk önce <span class="math inline">\(\mu\)</span> parametresinin yeni müfredatın gerçek ortalaması olduğunu farzediyoruz. O zaman statüko nedir? Bu ortalamanın ülke ortalaması seviyesinde kalmasıdır, yani <span class="math inline">\(\mu_0 = 494\)</span> olmasıdır. Fakat bu sefer alternatif hipotez iki yönlü (two-sided) olmalı çünkü yeni müfredat, hiç istenmese de, test sonuçlarında negatif sonuca da yol açabilir! O zaman <span class="math inline">\(H_0\)</span>'i reddetmeliyiz eğer z istatistiği <span class="math inline">\(\le -z_{0.025}\)</span> ise (yani -1.96'dan küçük ise), ya da <span class="math inline">\(\ge z_{0.025}\)</span> (yani 1.96'dan büyük ise).</p>
<p><span class="math display">\[ z = \frac{502-494}{124\sqrt{86}} = 0.60\]</span></p>
<p>Sonuç 1.96'dan büyük değil. O zaman <span class="math inline">\(H_0\)</span>'i, yani statükoyu değiştiremedik. Elde edilen sonuçlar bir ilerlemedir fakat bu ilerlemenin şans eseri olması da muhtemel.</p>
<div class="figure">
<img src="sat1.png" />

</div>
<p>Binom Hipotez Testleri</p>
<p>Örnek</p>
<p>Erteleme Teorisi: Yaygın bir inanışa göre insanlar ölüm tarihlerini onlar için önemli bir gün sonrasına erteleyebiliyorlar, mesela kendi doğum günleri, aile toplantıları, bir akrabanın dönüşünü beklemek, vs. gibi Hatta ülke çapında seçimlerin bile ölüm günlerini etkilediği görülmüştür, başkanlık seçimleri olan Eylül ve Ekim ayları sırasında ölüm oranlarının düştüğü saptanmıştır. Bu teoriye göre pek çok yaşlı insan kimin kazandığını görmek için &quot;biraz daha dayanıyor''.</p>
<p>Bir araştırma bu teorinin doğru olup olmadığını kontrol etti. Bu bağlamda Salt Lake City şehrindeki bir gazetenin ölüm ilanı kısmına bakıldı ve 747 kişi içinden sadece 60 kişinin, daha doğrusu %8'inin kendi doğumgünlerinin 3 ay öncesi içinde olduğunu saptadı. Eğer insanların ölümü rasgele olsaydı yaklaşık olarak %25'inin bu periyod içinde ölmesini beklerdiniz. O zaman bu %25'den %8'e düşüşü nasıl açıklamalıyız? Araştırma teoriyi destekleyecek rakamları veriyor mu?</p>
<p>Diyelim ki 747 ölüm iki kategori üzerinden temsil edilsin, doğumgünü öncesindeki 3 ay içinde ölenler ve ölmeyenler. <span class="math inline">\(k_i=1\)</span> ile <span class="math inline">\(i\)</span>'inci kişinin 1. kategoriye, <span class="math inline">\(k_i=0\)</span> ise 2. kategoriye ait olmasını temsil ediyoruz. O zaman <span class="math inline">\(k = k_1 + k_2 + .. + k_{747}\)</span> birinci kategorideki toplam ölümü temsil ediyor. Üstteki her <span class="math inline">\(k\)</span> doğal olarak Binom dağılımı, ve <span class="math inline">\(p\)</span> parametresini kullanıyor ki</p>
<p><span class="math display">\[ p = P(\textrm{sahıs doğumgünü öncesindeki 3 ay içinde ölüyor}) \]</span></p>
<p>Eğer insanlar ölümlerini ertelemeseydi <span class="math inline">\(p = 3/12 = 0.25\)</span> olurdu. Eğer erteliyorlar ise <span class="math inline">\(p\)</span> 0.25'den daha küçük olmalı. Bu azalmanın ne kadar önemli (significant) olduğunu irdelemek için tek taraflı bir Binom Testi uygulamak lazım.</p>
<p><span class="math inline">\(H_0\)</span>: <span class="math inline">\(p = 0.25\)</span></p>
<p><span class="math inline">\(H_1\)</span>: <span class="math inline">\(p &lt; 0.25\)</span></p>
<p>Test için <span class="math inline">\(p_0\)</span> olduğunu farzettiğimiz &quot;gerçek'' dağılımı (ki statükoyu onun üzerinden temsil edeceğiz) kullanacağız.</p>
<p><span class="math display">\[ z = \frac{k-np_0}{\sqrt{np_0(1-p_0)}} \le -z_{0.05} = -1.64 \]</span></p>
<p><span class="math display">\[ = \frac{60-747(0.25)}{747(0.25)(0.75)} = -10.7 \le -1.64  \]</span></p>
<p>Test istatistiği kritik değerin aşırı derecede sol tarafına düştü. Demek ki ezici miktarda kanıt, veri, sonuç elde ettik, %25'ten %8'e düşüşün pür şans dışında başka bir sebebi var. Tabii bu sebep Erteleme Teorisi haricinde bir şey de olabilir, fakat yine de ortaya çıkan kalıp bize ölüm vaktimizin kontrolümüzde olduğunu destekleyen yönde bir sonuç veriyor.</p>
<p>Not: Üstteki test &quot;büyük örneklem'' olduğu durumlarda geçerlidir. Küçük örneklem durumunda Binom dağılımının kendisi test için kullanılabilir.</p>
<p>Tek Örneklem t Testi (The One-Sample t test)</p>
<p>Bu test verinin bir <span class="math inline">\(N(\mu,\sigma)\)</span> Normal dağılımından geldiğini farzeder, test etmek istediğimiz hipotez / karşılaştırma <span class="math inline">\(\mu = \mu_0\)</span>. Ayrıca <span class="math inline">\(\sigma\)</span> bilinmiyor, ki Öğrenci t dağılımından bahsetmemizin ana sebebi buydu zaten, o zaman hipotez testine Tek Örneklem t Testi adı verilir.</p>
<p>Örnek</p>
<p>Alttaki veride bir grup hanımın ne kadar kalori tükettiği kayıtlanmış. Acaba bu hanımların aldığı enerji tavsiye edilen 7725'ten ne kadar sapmıştır?</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">daily_intake <span class="op">=</span> np.array([<span class="fl">5260.</span>,<span class="fl">5470.</span>,<span class="fl">5640.</span>,<span class="fl">6180.</span>,<span class="fl">6390.</span>,<span class="fl">6515.</span>,<span class="fl">6805.</span>,<span class="op">\</span>
<span class="fl">7515.</span>,<span class="fl">7515.</span>,<span class="fl">8230.</span>,<span class="fl">8770.</span>])</code></pre></div>
<p>Örneklem küçük. O sebeple t dağılımı kullanmak mantıklı. t değerini <span class="math inline">\(\frac{\bar{y}-\mu_o}{s/\sqrt{n}}\)</span> olarak hesaplayacağız, ki <span class="math inline">\(\mu_0=7725\)</span> olacak.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> scipy.stats.distributions <span class="im">import</span> t
<span class="im">import</span> pandas <span class="im">as</span> pd, math
data <span class="op">=</span> pd.DataFrame(daily_intake)
n <span class="op">=</span> <span class="bu">len</span>(data)
df <span class="op">=</span> n<span class="dv">-1</span> <span class="co"># serbestlik derecesi</span>
mu0 <span class="op">=</span> <span class="fl">7725.</span>
ybar <span class="op">=</span> <span class="bu">float</span>(data.mean())
s <span class="op">=</span> <span class="bu">float</span>(data.std())
<span class="bu">print</span> <span class="st">&#39;ortalama&#39;</span>,ybar,<span class="st">&#39;std&#39;</span>,s
tval <span class="op">=</span> (ybar<span class="op">-</span>mu0)<span class="op">/</span>(s<span class="op">/</span>np.sqrt(n))
<span class="bu">print</span> <span class="st">&#39;df&#39;</span>,df,<span class="st">&#39;tval&#39;</span>,tval
<span class="bu">print</span> <span class="st">&#39;sol&#39;</span>,t.ppf(<span class="fl">0.025</span>,df)
<span class="bu">print</span> <span class="st">&#39;sag&#39;</span>,t.ppf(<span class="fl">0.975</span>,df)</code></pre></div>
<pre><code>ortalama 6753.63636364 std 1142.12322214
df 10 tval -2.82075406083
sol -2.22813885196
sag 2.22813885196</code></pre>
<p>Sol ve sağ eşik değerlerini hesapladık ve t değeri bu aralığın içine düşmüyor. Yani hipotezi reddediyoruz. Bazıları bu problemde p değeri görmek isteyebilir,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> <span class="st">&#39;t degeri&#39;</span>, tval
<span class="bu">print</span> <span class="st">&#39;iki tarafli p degeri&#39;</span>, <span class="dv">2</span><span class="op">*</span>t.cdf(tval,df)</code></pre></div>
<pre><code>t degeri -2.82075406083
iki tarafli p degeri 0.0181372351761</code></pre>
<p>p değeri hesapladık 0.05'ten küçük çıktı. İkiyle çarpmamızın sebebi iki-taraflı p-testi yapmış olmamız, yani kabul edilebilir bölgenin hem solundan hem de sağından ne kadar dışına düşüyorsak, bu iki taraftaki p değerini birbirine toplamalıyız. Tabii t dağılımı simetrik olduğu için her iki taraftan da aynı şekilde dışarıda kalıyoruz. Bazı kaynaklar iki taraflı p testinin <span class="math inline">\(|t| &lt; -t_{esik,derece}\)</span> karşılaştırmasını yaptığını söyler.</p>
<p>Benzer bir hesabı kütüphane çağrısı ile yaparsak,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> scipy.stats <span class="im">import</span> ttest_1samp
t_statistic, p_value <span class="op">=</span> ttest_1samp(daily_intake, mu0)
<span class="bu">print</span> <span class="st">&#39;t&#39;</span>, t_statistic, <span class="st">&#39;one-sample t-test&#39;</span>, p_value</code></pre></div>
<pre><code>t -2.82075406083 one-sample t-test 0.0181372351761</code></pre>
<p>Sonuç p değeri 0.05'ten küçük çıktı yani yüzde 5 önemliliğini (significance) baz aldık bu durumda veri hipotezden önemli derecede (significantly) uzakta. Demek ki ortalamanın 7725 olduğu hipotezini reddetmemiz gerekiyor.</p>
<p>İki Örneklemli Test</p>
<p>Gruplar 0/1 değerleri ile işaretlendi, ve test etmek istediğimiz iki grubun ortalamasının (mean) aynı olduğu hipotezini test etmek. t-test bu arada varyansın aynı olduğunu farzeder.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">energ <span class="op">=</span> np.array([
[<span class="fl">9.21</span>, <span class="dv">0</span>],[<span class="fl">7.53</span>, <span class="dv">1</span>],
[<span class="fl">7.48</span>, <span class="dv">1</span>],[<span class="fl">8.08</span>, <span class="dv">1</span>],
[<span class="fl">8.09</span>, <span class="dv">1</span>],[<span class="fl">10.15</span>, <span class="dv">1</span>],
[<span class="fl">8.40</span>, <span class="dv">1</span>],[<span class="fl">10.88</span>, <span class="dv">1</span>],
[<span class="fl">6.13</span>, <span class="dv">1</span>],[<span class="fl">7.90</span>, <span class="dv">1</span>],
[<span class="fl">11.51</span>, <span class="dv">0</span>],[<span class="fl">12.79</span>, <span class="dv">0</span>],
[<span class="fl">7.05</span>, <span class="dv">1</span>],[<span class="fl">11.85</span>, <span class="dv">0</span>],
[<span class="fl">9.97</span>, <span class="dv">0</span>],[<span class="fl">7.48</span>, <span class="dv">1</span>],
[<span class="fl">8.79</span>, <span class="dv">0</span>],[<span class="fl">9.69</span>, <span class="dv">0</span>],
[<span class="fl">9.68</span>, <span class="dv">0</span>],[<span class="fl">7.58</span>, <span class="dv">1</span>],
[<span class="fl">9.19</span>, <span class="dv">0</span>],[<span class="fl">8.11</span>, <span class="dv">1</span>]])
group1 <span class="op">=</span> energ[energ[:, <span class="dv">1</span>] <span class="op">==</span> <span class="dv">0</span>][:, <span class="dv">0</span>]
group2 <span class="op">=</span> energ[energ[:, <span class="dv">1</span>] <span class="op">==</span> <span class="dv">1</span>][:, <span class="dv">0</span>]
t_statistic, p_value <span class="op">=</span> ttest_ind(group1, group2)
<span class="bu">print</span> <span class="st">&quot;two-sample t-test&quot;</span>, p_value</code></pre></div>
<pre><code>two-sample t-test 0.00079899821117</code></pre>
<p><span class="math inline">\(p\)</span> değeri <span class="math inline">\(&lt; 0.05\)</span> yani iki grubun ortalaması aynı değildir. Aynı olduğu hipotezi reddedildi.</p>
<p>Eşlemeli t-Test (Paired t-test)</p>
<p>Eşlemeli testler aynı deneysel birimin ölçümü alındığı zaman kullanılabilir, yani ölçüm alınan aynı grupta, deney sonrası deneyin etki edip etmediği test edilebilir. Bunun için aynı ölçüm deney sonrası bir daha alınır ve &quot;farkların ortalamasının sıfır olduğu&quot; hipotezi test edilebilir. Altta bir grup hastanın deney öncesi ve sonrası ne kadar yiyecek tükettiği listelenmiş.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">intake <span class="op">=</span> np.array([
[<span class="dv">5260</span>, <span class="dv">3910</span>],[<span class="dv">5470</span>, <span class="dv">4220</span>],
[<span class="dv">5640</span>, <span class="dv">3885</span>],[<span class="dv">6180</span>, <span class="dv">5160</span>],
[<span class="dv">6390</span>, <span class="dv">5645</span>],[<span class="dv">6515</span>, <span class="dv">4680</span>],
[<span class="dv">6805</span>, <span class="dv">5265</span>],[<span class="dv">7515</span>, <span class="dv">5975</span>],
[<span class="dv">7515</span>, <span class="dv">6790</span>],[<span class="dv">8230</span>, <span class="dv">6900</span>],
[<span class="dv">8770</span>, <span class="dv">7335</span>],
])
pre <span class="op">=</span> intake[:, <span class="dv">0</span>]
post <span class="op">=</span> intake[:, <span class="dv">1</span>]
t_statistic, p_value <span class="op">=</span> ttest_1samp(post <span class="op">-</span> pre, <span class="dv">0</span>)
<span class="bu">print</span> <span class="st">&quot;paired t-test&quot;</span>, p_value</code></pre></div>
<pre><code>paired t-test 3.05902094293e-07</code></pre>
<p>Wilcoxon işaretli-sıralı testi (Wilcoxon signed-rank test)</p>
<p>t Testleri Normal dağılıma göre sapmaları yakalamak açısından, özellikle büyük örneklemler var ise, oldukça sağlamdır. Fakat bazen verinin Normal dağılımdan geldiği faraziyesini yapmak istemeyebiliriz. Bu durumda <em>dağılımdan bağımsız metotlar</em> daha uygundur, bu tür metotlar için verinin yerine çoğunlukla onun sıra istatistiklerini (order statistics) kullanır.</p>
<p>Tek örneklemli Wilcoxon testi için prosedür <span class="math inline">\(\mu_0\)</span>'i tüm veriden çıkartmak ve geri kalan (farkları) işaretine bakmadan sayısal (numeric) değerine göre sıralamak, ve bu sıra değerini bir kenara yazmak. Daha sonra geri dönüp bu sefer çıkartma işlemi sonucunun işaretine bakmak, ve eksi işareti taşıyan sıra değerlerini toplamak, aynı işlemi artı işareti için yapmak, ve eksi toplamı artı toplamından çıkartmak. Sonuçta elimize bir istatistik <span class="math inline">\(W\)</span> gelecek. Bu test istatistiği aslında <span class="math inline">\(1..n\)</span> tane sayı içinden herhangi birini <span class="math inline">\(1/2\)</span> olasılığıyla seçmek, ve sonuçları toplamaya tekabül etmektedir. Ve bu sonuç yine <code>0.05</code> ile karşılaştırılır.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> scipy.stats <span class="im">import</span> wilcoxon, ttest_ind
daily_intake <span class="op">=</span> np.array([<span class="dv">5260</span>,<span class="dv">5470</span>,<span class="dv">5640</span>,<span class="dv">6180</span>,<span class="dv">6390</span>,<span class="dv">6515</span>,<span class="dv">6805</span>,<span class="dv">7515</span>,<span class="dv">7515</span>,<span class="dv">8230</span>,<span class="dv">8770</span>])
z_statistic, p_value <span class="op">=</span> wilcoxon(daily_intake <span class="op">-</span> <span class="dv">7725</span>)
<span class="bu">print</span> <span class="st">&quot;one-sample wilcoxon-test&quot;</span>, p_value</code></pre></div>
<pre><code>one-sample wilcoxon-test 0.0279991628713</code></pre>
<p>Hipotezi reddettik.</p>
<p>Eşlemeli t-testi şimdi Wilcoxon testi ile yapalım,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">z_statistic, p_value <span class="op">=</span> wilcoxon(post <span class="op">-</span> pre)
<span class="bu">print</span> <span class="st">&quot;paired wilcoxon-test&quot;</span>, p_value</code></pre></div>
<pre><code>paired wilcoxon-test 0.00463608893545</code></pre>
<p>Normallik Testi</p>
<p>Paket <code>scipy.stats</code> altında normallik testleri için bazı çağrılar var, bu tekniklerden ikisini altta gösteriyoruz,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> scipy.stats <span class="im">as</span> st
arr <span class="op">=</span> np.array([<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">10</span>,<span class="dv">10</span>,<span class="dv">444</span>,<span class="dv">444</span>,<span class="dv">3</span>,<span class="dv">98</span>])
arr2 <span class="op">=</span> np.array([np.random.normal() <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">100</span>)])

<span class="bu">print</span> <span class="st">&#39;D-Agostino and Pearsons&#39;</span>
<span class="bu">print</span> st.normaltest(arr)
<span class="bu">print</span> st.normaltest(arr2)
<span class="bu">print</span>
<span class="bu">print</span> <span class="st">&#39;Shapiro-Wilk&#39;</span>
<span class="bu">print</span> st.shapiro(arr)
<span class="bu">print</span> st.shapiro(arr2)</code></pre></div>
<pre><code>D-Agostino and Pearsons
(4.6919700569024814, 0.095752836393526289)
(1.4265636263795889, 0.49003335773235424)

Shapiro-Wilk
(0.6167718172073364, 0.00015052134403958917)
(0.9891485571861267, 0.5962899923324585)</code></pre>
<p>Sonuçlara göre Shapiro-Wilk yaklaşımı daha güvenilir gözüküyor, zaten [6, sf 53]'e göre örneklem sayısı <span class="math inline">\(\le 50\)</span> olduğu durumlarda bu test tercih edilmelidir.</p>
<p>Biraz Matematik</p>
<p>Diyelim ki Gaussian dağılımına sahip olduğunu düşündüğümüz <span class="math inline">\(\{ x_i\}\)</span> verilerimiz var. Bu verilerin Gaussian dağılımına uyup uymadığını nasıl kontrol edeceğiz? Normal bir dağılımı her veri noktası için şöyle temsil edebiliriz,</p>
<p><span class="math display">\[ y_i = \Phi\bigg(\frac{ x_i - \mu}{\sigma}\bigg) \]</span></p>
<p>Burada <span class="math inline">\(\Phi\)</span> standart Gaussian'ı temsil ediyor (detaylar için [7] ve CDF fonksiyonuna tekabül ediyor. CDF fonksiyonunun aynı zamanda yüzdelik dilimi (quantile) hesapladığı söylenir, aslında CDF son derece detaylı bir olasılık değeri verir fakat evet, dolaylı yoldan noktanın hangi çeyrek içine düştüğü de görülecektir.</p>
<p>Şimdi bir numara yapalım, iki tarafa ters Gaussian formülünü uygulayalım, yani <span class="math inline">\(\Phi^{-1}\)</span>.</p>
<p><span class="math display">\[ \Phi^{-1}(y_i) = \Phi^{-1}\bigg( \Phi\bigg(\frac{ x_i - \mu}{\sigma}\bigg)\bigg) \]</span></p>
<p><span class="math display">\[ \Phi^{-1}(y_i) = \frac{ x_i - \mu}{\sigma}\]</span></p>
<p><span class="math display">\[ x_i = \Phi^{-1}(y_i) \sigma + \mu  \]</span></p>
<p>Bu demektir ki elimizdeki verileri <span class="math inline">\(\Phi^{-1}(y_i)\)</span> bazında grafiklersek, bu noktalar eğimi <span class="math inline">\(\sigma\)</span>, kesisi (intercept, y ekseninin kesildiği yer) <span class="math inline">\(\mu\)</span> olan bir düz çizgi olmalıdır. Eğer kabaca noktalar düz çizgi oluşturmuyorsa, verimizin Gaussian dağılıma sahip olmadığına karar verebiliriz.</p>
<p>Üstte tarif edilen grafik, olasılık grafiği (probabılıty plot) olarak bilinir.</p>
<p>Ters Gaussian teorik fonksiyonunu burada vermeyeceğiz, Scipy <code>scipy.stats.ınvgauss</code> hesaplar için kullanılabilir. Fakat <span class="math inline">\(y_i\)</span>'nin kendisi nereden geliyor? Eğer <span class="math inline">\(y_i\)</span>, CDF'in bir sonucu ise, pür veriye bakarak bir CDF değeri de hesaplayabilmemiz gerekir. Bunu yapmak için bir başka numara lazım.</p>
<ol style="list-style-type: decimal">
<li><p>Eldeki sayıları artan şekilde sıralayın</p></li>
<li><p>Her veri noktasına bir derece (rank) atayın (sıralama sonrası hangi seviyede olduğu yeterli, 1'den başlayarak).</p></li>
<li><p>Çeyrek değeri <span class="math inline">\(y_i\)</span> bu sıra / <span class="math inline">\(n+1\)</span>, <span class="math inline">\(n\)</span> eldeki verinin büyüklüğü.</p></li>
</ol>
<p>Bu teknik niye işliyor? <span class="math inline">\(x\)</span>'in CDF'i <span class="math inline">\(x_i &lt; x\)</span> şartına uyan <span class="math inline">\(x_i\)</span>'lerin oranı değil midir? Yani bir sıralama söz konusu ve üstteki teknik te bu sıralamayı biz elle yapmış olduk, ve bu sıralamadan gereken bilgiyi aldık.</p>
<p>Basit bir Gaussian kontrolü, <code>qqplot</code> kullanarak.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> statsmodels.api <span class="im">as</span> sm
fig <span class="op">=</span> sm.qqplot(arr)
plt.savefig(<span class="st">&#39;stat_tests_01.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="stat_tests_01.png" />

</div>
<p>Gerçekten Gaussian olan bir veri şöyle gözükür,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">fig <span class="op">=</span> sm.qqplot(arr2)
plt.savefig(<span class="st">&#39;stat_tests_02.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="stat_tests_02.png" />

</div>
<p>Kaynaklar</p>
<p>[1] Dalgaard, <em>Introductory Statistics with R</em></p>
<p>[2] Kerns, <em>Introduction to Probability and Statistics Using R</em></p>
<p>[3] Blondel, <em>t-test and wilcoxon-test examples in Python</em>, url{https://gist.github.com/mblondel/1761714}</p>
<p>[4] Runger, <em>Applied Statistics and Probability for Engineers</em></p>
<p>[5] Stack Exchange, <em>Sample variance converge almost surely</em>, <a href="http://math.stackexchange.com/questions/243348/sample-variance-converge-almost-surely" class="uri">http://math.stackexchange.com/questions/243348/sample-variance-converge-almost-surely</a></p>
<p>[6] Haslwanter, <em>Introduction to Statistics using Python</em></p>
<p>[7] Bayramlı, İstatistik, <em>Giris</em>)</p>
<p>[8] Bayramlı, Istatistik, <em>Örneklem Büyüklüğü</em></p>
</body>
</html>
