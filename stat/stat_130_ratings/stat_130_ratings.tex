\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Pivotlama

Örnek olarak film isimleri ve o filmlere verilmiþ beðeni notlarýný
taþýyan bir veri tabanýný iþleyeceðiz. Verimiz üç ayrý dosyaya
yayýlmýþ halde. Üç tabloyu alttaki þekilde, \verb!merge! komutu
ile birleþtiriyoruz - Pandas otomatik olarak ortak kolon ismini
bulacak ve onun üzerinden birleþtirimi yapacak.

\begin{minted}[fontsize=\footnotesize]{python}
import pandas as pd, zipfile
unames = ['user_id', 'gender', 'age', 'occupation', 'zip']
rnames = ['user_id', 'movie_id', 'rating', 'timestamp']
mnames = ['movie_id', 'title', 'genres']
with zipfile.ZipFile('ml1m.zip', 'r') as z:
    users = pd.read_table(z.open('users.dat'), sep='::', header=None,names=unames)
    ratings = pd.read_table(z.open('ratings.dat'), sep='::', header=None,names=rnames)
    movies = pd.read_table(z.open('movies.dat'), sep='::', header=None,names=mnames)
data = pd.merge(pd.merge(ratings, users), movies)
\end{minted}

Eðer erkeklerin en çok sevdiði ama kadýnlarýn en az sevdiði (ve
hanýmlar için tam tersi olan) filmleri bulmak istiyorsak, bu iþlemi
nasýl yaparýz? Bu iþlemi Pandas ile yapmak için ilginç bir takla
atacaðýz. "Bir grubun en çok diðerinin en az" sorusu, onlarýn bir
filme verdiði ortalama notun farkýnýn en büyük olmasý demektir. Bunu
düþünebilmek önemli.

Ýkinci olarak bu iþlemin kodlamasý için ne gerekir? Bir çýkartma
iþlemi lazým. Ýdeal olarak bir kolonu (ya da satýrý) diðerinden
çýkartmak - bu tür toptan iþlemler zaten Pandas ile çok hýzlý.

Fakat verimiz halen o formatta deðil.  Her satýr, tek bir film, tek bir
kiþi (cinsiyet) ve tek bir not için kaydedilmiþ. Bizim ilgilendiðimiz
analiz için film bazýnda cinsiyet verisini {\em yanyana, deðiþik
  kolonlarda} görmeliyiz.

Peki nasýl? Cevap pivotlamak.

Pivotlamak bir kolonu (hatta birkaç kolonu) alýp onu x ekseni yapmak,
ayný þekilde bir (veya birkaç) kolonu y ekseni yapmak anlamýna
gelir. Yani bir kolon üzerindeki tüm deðerler okunur, ve kordinatmýþ
gibi o eksene yayýlýr. Ayný þekilde diðer kordinat halledilir. Daha
sonra bu iki kordinattaki kesiþim deðerleri için bir üçüncü nümerik
kolon seçilir (ve onun üzerinden ek bir nümerik iþlem de
tanýmlanabilir), ve böylece pivotlama gerçekleþmiþ olur.

Bizim pivot için cinsiyet kolona yayýlacak, film ismi satýra
yayýlacak. Kesiþim ise not ortalamasý (rating mean) olacak.

\begin{minted}[fontsize=\footnotesize]{python}
mean_ratings = data.pivot_table('rating', rows='title', cols='gender',
                                aggfunc='mean')
print mean_ratings[:5]
\end{minted}

\begin{verbatim}
gender                                F         M
title                                            
$1,000,000 Duck (1971)         3.375000  2.761905
'Night Mother (1986)           3.388889  3.352941
'Til There Was You (1997)      2.675676  2.733333
'burbs, The (1989)             2.793478  2.962085
...And Justice for All (1979)  3.828571  3.689024
\end{verbatim}

Daha fazla ilerlemeden ufak bir ek iþlem daha yapalým, 250'den daha az
not almýþ olan filmleri eleyelim.

\begin{minted}[fontsize=\footnotesize]{python}
ratings_by_title = data.groupby('title').size()
active_titles = ratings_by_title.index[ratings_by_title >= 250]
print active_titles[:10]
\end{minted}

\begin{verbatim}
Index([u''burbs, The (1989)', u'10 Things I Hate About You (1999)', u'101 Dalmatians (1961)', u'101 Dalmatians (1996)', u'12 Angry Men (1957)', u'13th Warrior, The (1999)', u'2 Days in the Valley (1996)', u'20,000 Leagues Under the Sea (1954)', u'2001: A Space Odyssey (1968)', u'2010 (1984)'], dtype=object)
\end{verbatim}

Yapýlan harekete dikkat: \verb!ratings_by_title.index! üzerinde bir boolean
filtreleme yaptýk, yani \verb![True, False..., True]!  gibi bir
filtreleyiciyi \verb!Index! {\em objesi} üzerinde kullandýk. Bu niye
iþledi? Çünkü \verb!.index! çaðrýsý da sonuçta bir dizindir, ve dizinler
üzerinde istenen boolean filtrelemesi yapýlabilir (her iki taraf ta ayný
boyutta olduðu sürece).

Devam edelim, þimdi ortalama notlarý üstteki yeni Index'e göre
azaltalým (ve \verb!.ix! kullanacaðýz, çünkü Index objesi
satýrlar üzerinde iþlem yapar ve \verb!.ix! çaðrýsý satýrlara
eriþmek için kullanýlýr), ve hanýmlarýn en çok sevdiði filmlere
bakalým,

\begin{minted}[fontsize=\footnotesize]{python}
mean_ratings = mean_ratings.ix[active_titles]
top_female_ratings = mean_ratings.sort_index(by='F', ascending=False)
print top_female_ratings[:4]
\end{minted}

\begin{verbatim}
gender                                                         F         M
title                                                                     
Close Shave, A (1995)                                   4.644444  4.473795
Wrong Trousers, The (1993)                              4.588235  4.478261
Sunset Blvd. (a.k.a. Sunset Boulevard) (1950)           4.572650  4.464589
Wallace & Gromit: The Best of Aardman Animation (1996)  4.563107  4.385075
\end{verbatim}

Baylara pek tanýdýk gelmeyen bir liste. Þimdi erkekler ve hanýmlar
beðeni farkýný hesaplayalým ve en büyük farklar en üstte olacak
þekilde sýralama (sort) yapalým,

\begin{minted}[fontsize=\footnotesize]{python}
mean_ratings['diff'] = mean_ratings['M'] - mean_ratings['F']
sorted_by_diff = mean_ratings.sort_index(by='diff')
print sorted_by_diff[:6] 
\end{minted}

\begin{verbatim}
gender                            F         M      diff
title                                                  
Dirty Dancing (1987)       3.790378  2.959596 -0.830782
Jumpin' Jack Flash (1986)  3.254717  2.578358 -0.676359
Grease (1978)              3.975265  3.367041 -0.608224
Little Women (1994)        3.870588  3.321739 -0.548849
Steel Magnolias (1989)     3.901734  3.365957 -0.535777
Anastasia (1997)           3.800000  3.281609 -0.518391
\end{verbatim}

{\em Dirty Dancing}, {\em Grease} gibi romantik filmler üstte çýktý. Þimdi
listeyi ters çevirelim ve en alta bakalým, orada baylarýn en çok
hanýmlarýn en az sevdiði filmler olmalý,

\begin{minted}[fontsize=\footnotesize]{python}
print sorted_by_diff[::-1][:15]
\end{minted}

\begin{verbatim}
gender                                         F         M      diff
title                                                               
Good, The Bad and The Ugly, The (1966)  3.494949  4.221300  0.726351
Kentucky Fried Movie, The (1977)        2.878788  3.555147  0.676359
Dumb & Dumber (1994)                    2.697987  3.336595  0.638608
Longest Day, The (1962)                 3.411765  4.031447  0.619682
Cable Guy, The (1996)                   2.250000  2.863787  0.613787
Evil Dead II (Dead By Dawn) (1987)      3.297297  3.909283  0.611985
Hidden, The (1987)                      3.137931  3.745098  0.607167
Rocky III (1982)                        2.361702  2.943503  0.581801
Caddyshack (1980)                       3.396135  3.969737  0.573602
For a Few Dollars More (1965)           3.409091  3.953795  0.544704
Porky's (1981)                          2.296875  2.836364  0.539489
Animal House (1978)                     3.628906  4.167192  0.538286
Exorcist, The (1973)                    3.537634  4.067239  0.529605
Fright Night (1985)                     2.973684  3.500000  0.526316
Barb Wire (1996)                        1.585366  2.100386  0.515020
\end{verbatim}

Burada da {\em Good, The Bad and The Ugly} gibi kovboy filmleri, ve buna
benzer vurdulu kýrdýlý filmler ya da enseye tokat türünden 
{\em Aptal ve Daha Aptal (Dumb and Dumber)} gibi filmler çýktý. Ýlginç 
bir analiz oldu. :)

Yapay Öðrenim geniþ bir alandýr, ama regresyon, sýnýflama gibi iþlemlerden
önce hala yapýlabilecek ilginç ve önemli, üstteki gibi veri analizler var.

Kaynaklar

[1] McKinney, W., {\em Python for Data Analysis}


\end{document}
