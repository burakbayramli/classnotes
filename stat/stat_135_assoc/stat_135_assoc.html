<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>İlişkisel Madencilik (Association Mining)</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="ilişkisel-madencilik-association-mining">İlişkisel Madencilik
(Association Mining)</h1>
<p>İkisel Matris Ayrıştırması (Binary Matrix Factorization)</p>
<p>Veri madenciliği denince pek çok kişinin aklına gelen ilk örnek,
aslında, sık bulunan öğe kümeleri (frequent itemsets) örneğidir:
“filanca ülkeden sitemize gelen müşterilerin aynı zamanda vs
özelliklerinin olduğunu da keşfettik” gibi.</p>
<p>Benzer bir örnek, ki bu alan öğe kümelerinin aslında en önemli çıkış
sebeplerinden birisidir, alışveriş sepeti analizidir. Müşterinin her
alışverişinde sepetinde belli mallar vardır, ve bu malların hangilerinin
aynı anda, aynı sepette olduğu analiz edilmeye uğraşılır. Eğer sürekli
ekmek ve reçel aynı anda alınıyorsa, bu bilgi kullanılarak belki
malların daha iyi konumlandırılması yapılacaktır, vs. Sık bulunan öğe
kümeleri teknikleri bazen değişik adlar altında da geçebiliyor, mesela
ilişki madenciliği (association mining) gibi. Algoritma olarak
kullanılan pek çok teknik var, APriori iyi bilinenlerden, FPGrowth ondan
daha hızlı çalışan ve daha tercih edilen bir teknik. İstatistiki bir
teknik olan Çok Boyutlu Bernoulli Karışımları da bu alanda kullanılan
bir yaklaşım.</p>
<p>Bir diğer alternatif ikisel matris ayrıştırması (binary matrix
factorızation -BMF-) kullanmaktır [3]. Aynen SVD’de olduğu gibi BMF de
bir matrisi ayrıştırır, fakat üç matris yerine iki matrise ayrıştırır ve
hem sonuç matrisi hem de ayrıştırılan matrisler sadece 0 ya da 1
değerini taşıyabilirler. Yani bu ayrıştırma sonuç matrislerinin ikisel
olmasını mecbur tutar, negatif olmayan matris ayrıştırmasının
(non-negative matrix factorızation) sonuç matrisinin pozitif değerler
taşımasını mecbur kılması gibi. Bunlar birer kısıtlama (constraint) ve
bu sonuç o kısıtlamalara göre ortaya çıkıyor. <em>Dikkat</em>: BMF için
toplama işlemi <span class="math inline">\(1+0 = 1, 1+1=1, 0+0 =
0\)</span> olarak tekrar tanımlanır, yani mantıksal OR işlemi haline
gelir.</p>
<p>Ayrıştırma öncesi hangi kerte (rank) <span
class="math inline">\(k\)</span> değerine geçmek istediğimizi biz
belirtiriz. BMF’nin öğe kümeleri madenciliği için faydası şurada: öğe
kümeleri ararken baktığımız öğeler kategorik şeylerdir, alışveriş sepeti
örneğinde mesela ekmek, reçel gibi. Kategorik öğeleri daha önce 1-hot
kodlaması (encoding) ile 1/0 değerleri taşıyan yeni kolonlara
geçirebildiğimizi görmüştük. Yani tamamen kategorik değerler taşıyan
veriler tamamen 1/0 taşıyacak şekilde tekrar kodlanabilir, yani ikisel
matris haline getirilebilir. Bu ikisel matrisi ayrıştırdığımız zaman ve
kendileri de ikisel olan iki yeni matris elde ettiğimizde ise bir
anlamda boyut indirgemesi yapmış oluruz, yani sanki ana matrisi
“özetleriz’‘. İşte bu özet, özellikle çarpılan “baz’’ matris, öğe
kümelerinin hangileri olduğu hakkında ipuçları içeriyor olabilir.</p>
<p>Bir örnek üzerinde görelim, mesela altta Alice (A), Bob Marley (B) ve
Prens Charles (C) verileri var. Bu kişiler için saçı uzun mu
(long-haired), ünlü mü (well-known) ve bay mı (male) verileri var.</p>
<p><img src="abc.png" /></p>
<p>Bu matris üzerinde ikisel ayrıştırma yaparsak, <span
class="math inline">\(k=2\)</span></p>
<p><img src="abc_res.png" /></p>
<p>Eğer kontrol etmek istersek, matris çarpımı yapmamız gerekir, bunun
için</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.array([[<span class="dv">1</span>,  <span class="dv">0</span>],</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>               [<span class="dv">1</span>,  <span class="dv">1</span>],</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>               [<span class="dv">0</span>,  <span class="dv">1</span>]], dtype<span class="op">=</span><span class="bu">bool</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> np.array([[<span class="dv">1</span>,  <span class="dv">1</span>,  <span class="dv">0</span>],</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>               [<span class="dv">0</span>,  <span class="dv">1</span>,  <span class="dv">1</span>]], dtype<span class="op">=</span><span class="bu">bool</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> np.dot(a,b)</span></code></pre></div>
<pre><code>[[ True  True False]
 [ True  True  True]
 [False  True  True]]</code></pre>
<p>0 ve 1 değerleri görmek için 1 ile çarpmak yeterli</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> <span class="dv">1</span><span class="op">*</span>np.dot(a,b)</span></code></pre></div>
<pre><code>[[1 1 0]
 [1 1 1]
 [0 1 1]]</code></pre>
<p>Sonuç başlangıç matrisi ile aynı, demek ki <code>bool</code> tipi
matris tanımlayınca Numpy çarpımı <code>dot</code>, çarpım sırasındaki
toplama işlemi için aritmetik toplama yerine VEYA (OR) kullanması
gerektiğini anladı.</p>
<p>Şimdi ayrıştırmayı analiz edelim, özellikle sol taraftaki çarpılan
“baz’’ matrise bakalım.. [6] yazısından hareketle, bu yazıdaki kolon
kombinasyon bakışını kullanalım (tabii toplamanın BMF için OR olduğunu
unutmadan), o zaman soldaki baz matrisin dikey, kolon bazlı olarak, bir
özet olduğunu görebiliyoruz. Çünkü çarpan sağ taraf bu kolonları alıp
onları belli şekillerde”kombine ederek’’ nihai (orijinal) matrisi ortaya
çıkartabilmeli. Bu sebeple soldaki çarpılan matris bir özet olmalı / baz
oluşturmalı, ve bunun yan etkisi olarak kolonlardaki değerlerde belli
bir kalıp / örüntü (pattern) olmalı. O zaman her baz kolonunda
birbiriyle alakalı olan ögeler aynı anda 1 değeri taşıyor olacaktır.</p>
<p>Sonuca göre uzun saçlı ve ünlü olmak (1. kolon) arasında bağlantı
varmış , ayrıca erkek olmak ve ünlü olmak (2. kolon) arasında da
bağlantı varmış :) Veriye göre böyle en azından.. Bu sonucu orijinal
matrise bakarak ta kontrol edebiliriz.</p>
<p>Ayrıştırma Kodlaması</p>
<p>BMF özel bir hesaptır ve Numpy / Scipy içinde mevcut değildir, ayrı
bir kütüphane kullanmak gereklidir, <code>nimfa</code> paketi içinde
gerekli kodlar var. Kurduktan sonra üstteki örneği şöyle
çözebiliriz;</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> nimfa</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.sparse <span class="im">as</span> sp</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> __fact_factor(X):</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> X.todense() <span class="cf">if</span> sp.isspmatrix(X) <span class="cf">else</span> X</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.array([[<span class="fl">1.</span>, <span class="fl">1.</span>, <span class="dv">0</span>],</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>              [<span class="fl">1.</span>, <span class="fl">1.</span>, <span class="fl">1.</span>],</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">0</span>, <span class="fl">1.</span>, <span class="fl">1.</span>]])</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>fctr <span class="op">=</span> nimfa.mf(A,</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>              seed <span class="op">=</span> <span class="st">&quot;nndsvd&quot;</span>, </span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>              rank <span class="op">=</span> <span class="dv">2</span>, </span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>              method <span class="op">=</span> <span class="st">&quot;bmf&quot;</span>, </span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>              max_iter <span class="op">=</span> <span class="dv">40</span>, </span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>              initialize_only <span class="op">=</span> <span class="va">True</span>,</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>              lambda_w <span class="op">=</span> <span class="fl">1.1</span>,</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>              lambda_h <span class="op">=</span> <span class="fl">1.1</span>)</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> nimfa.mf_run(fctr)</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>threshold <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>res1 <span class="op">=</span> __fact_factor(res.basis())</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>res2 <span class="op">=</span> __fact_factor(res.coef())</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>res1 <span class="op">=</span> np.<span class="bu">abs</span>(np.<span class="bu">round</span>(res1 <span class="op">-</span> <span class="fl">0.5</span> <span class="op">+</span> threshold))</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>res2 <span class="op">=</span> np.<span class="bu">abs</span>(np.<span class="bu">round</span>(res2 <span class="op">-</span> <span class="fl">0.5</span> <span class="op">+</span> threshold))</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>res1 <span class="op">=</span> pd.DataFrame(res1, index<span class="op">=</span>[<span class="st">&#39;long-haired&#39;</span>,<span class="st">&#39;well-known&#39;</span>,<span class="st">&#39;male&#39;</span>])</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>res2 <span class="op">=</span> pd.DataFrame(res2, columns<span class="op">=</span>[<span class="st">&#39;A&#39;</span>,<span class="st">&#39;B&#39;</span>,<span class="st">&#39;C&#39;</span>])</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> res1</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> res2</span></code></pre></div>
<pre><code>             0  1
long-haired  1  0
well-known   1  1
male         0  1


   A  B  C
0  1  0  0
1  0  1  1</code></pre>
<p>Sonuç neredeyse tıpatıp aynı; sadece çarpan matriste [0,B] kordinatı
1 değil, fakat bize lazım olan baz matris aynı çıktı.</p>
<p>BMF hakkında bazı ek bilgiler: [2]’ye göre en az hatalı BMF
hesaplamak NP-hard zorluğunda, yani 3SAT gibi, ya da Seyahat Eden Satış
Elemanı (Traveling Salesman) problemi gibi ki bu problemler
kombinatoryel (combinatorial) optimizasyon problemleridir; çözüm için
tüm olasılıklar denendiği ve kısayolun mevcut olmadığı çeşitten
problemler. Fakat yaklaşıksal BMF metotları oldukça hızlıdır, ayrıca
seyreklik çok fark yaratıyor (pozitif anlamda) ki kategorik veriler
gerçek dünyada çoğunlukla seyrek olarak görülüyor. Eldeki 2000 tane mal
çeşidi içinden bir sepette ancak 5-10 tane ürün oluyor mesela, tüm 2000
tane malı bir sepete koymak mümkün değil.</p>
<p>FPGrowth</p>
<p>Öğe kümeleri bulmak için BMF haricinde bir yöntem FPGrowth yöntemidir
[1,2]. Bu yöntem önce her ögeden (tek başına) kaç tane olduğunu sayar,
belli bir eşik değeri <code>minsup</code> altında olanları atar, sonucu
sıralar. Bu liste bir yapısına işaret eden bir başlık yapısı haline
gelir. Ağacın kendisini oluşturmak için veri satırları teker teker
işlenir, her satırdaki her öge için başlık yapısındaki en fazla değeri
taşıyan öğe önce olmak üzere tepeden başlanıp alta doğru uzayan bir ağaç
yapısı oluşturulur. Ağaçtaki her düğüm altındaki düğümün sayısal
toplamını taşır. Madencilik için alttan başlanarak yukarı doğru çıkılır
(amaç en üste ulaşmak) ve bu sırada öğeler <code>minsup</code> altında
ise, atılırlar. Sonuçta ulaşılan ve atılmayan yollar bir öğe kümesini
temsil ederler.</p>
<p>Örnek verisi olarak alttakini kullanalım,</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> [</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>[<span class="st">&#39;outlook=sunny&#39;</span>, <span class="st">&#39;temparature=hot&#39;</span>, <span class="st">&#39;humidity=high&#39;</span>, <span class="st">&#39;windy=false&#39;</span>, <span class="st">&#39;play=no&#39;</span>],</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>[<span class="st">&#39;outlook=sunny&#39;</span>, <span class="st">&#39;temparature=hot&#39;</span>, <span class="st">&#39;humidity=high&#39;</span>, <span class="st">&#39;windy=true&#39;</span>, <span class="st">&#39;play=no&#39;</span>],</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>[<span class="st">&#39;outlook=overcast&#39;</span>, <span class="st">&#39;temparature=hot&#39;</span>, <span class="st">&#39;humidity=high&#39;</span>, <span class="st">&#39;windy=false&#39;</span>, <span class="st">&#39;play=yes&#39;</span>],</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>[<span class="st">&#39;outlook=rainy&#39;</span>, <span class="st">&#39;temparature=mild&#39;</span>, <span class="st">&#39;humidity=high&#39;</span>, <span class="st">&#39;windy=false&#39;</span>, <span class="st">&#39;play=yes&#39;</span>],</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>[<span class="st">&#39;outlook=rainy&#39;</span>, <span class="st">&#39;temparature=cool&#39;</span>, <span class="st">&#39;humidity=normal&#39;</span>, <span class="st">&#39;windy=false&#39;</span>, <span class="st">&#39;play=yes&#39;</span>],</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>[<span class="st">&#39;outlook=rainy&#39;</span>, <span class="st">&#39;temparature=cool&#39;</span>, <span class="st">&#39;humidity=normal&#39;</span>, <span class="st">&#39;windy=true&#39;</span>, <span class="st">&#39;play=no&#39;</span>],</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>[<span class="st">&#39;outlook=overcast&#39;</span>, <span class="st">&#39;temparature=cool&#39;</span>, <span class="st">&#39;humidity=normal&#39;</span>, <span class="st">&#39;windy=true&#39;</span>, <span class="st">&#39;play=yes&#39;</span>],</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>[<span class="st">&#39;outlook=sunny&#39;</span>, <span class="st">&#39;temparature=mild&#39;</span>, <span class="st">&#39;humidity=high&#39;</span>, <span class="st">&#39;windy=false&#39;</span>, <span class="st">&#39;play=no&#39;</span>],</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>[<span class="st">&#39;outlook=sunny&#39;</span>, <span class="st">&#39;temparature=cool&#39;</span>, <span class="st">&#39;humidity=normal&#39;</span>, <span class="st">&#39;windy=false&#39;</span>, <span class="st">&#39;play=yes&#39;</span>],</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>[<span class="st">&#39;outlook=rainy&#39;</span>, <span class="st">&#39;temparature=mild&#39;</span>, <span class="st">&#39;humidity=normal&#39;</span>, <span class="st">&#39;windy=false&#39;</span>, <span class="st">&#39;play=yes&#39;</span>],</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>[<span class="st">&#39;outlook=sunny&#39;</span>, <span class="st">&#39;temparature=mild&#39;</span>, <span class="st">&#39;humidity=normal&#39;</span>, <span class="st">&#39;windy=true&#39;</span>, <span class="st">&#39;play=yes&#39;</span>],</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>[<span class="st">&#39;outlook=overcast&#39;</span>, <span class="st">&#39;temparature=mild&#39;</span>, <span class="st">&#39;humidity=high&#39;</span>, <span class="st">&#39;windy=true&#39;</span>, <span class="st">&#39;play=yes&#39;</span>],</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>[<span class="st">&#39;outlook=overcast&#39;</span>, <span class="st">&#39;temparature=hot&#39;</span>, <span class="st">&#39;humidity=normal&#39;</span>, <span class="st">&#39;windy=false&#39;</span>, <span class="st">&#39;play=yes&#39;</span>],</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>[<span class="st">&#39;outlook=rainy&#39;</span>, <span class="st">&#39;temparature=mild&#39;</span>, <span class="st">&#39;humidity=high&#39;</span>, <span class="st">&#39;windy=true&#39;</span>, <span class="st">&#39;play=no&#39;</span>]</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div>
<p>Hava ile alakalı bazı veriler [1] bunlar; bu veriler tahmin
(outlook), sıcaklık (temparature), nem (humidity), rüzgar (windy),
dışarıda oyun oynayan var mı (play). Mesela ilk satırda tahmin güneşli,
ısı sıcak, nem yüksek, rüzgar yok ve oyun oynayan yok. Bu şekilde bir
sürü satır. Biz bu veride bir kalıp olup olmadığına bakacağız. [2]’deki
kodu [1]’den aldığımız üstteki veriye uygularsak, sonuç şöyle:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> fp</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>items <span class="op">=</span> fp.fpgrowth(data, minsup<span class="op">=</span><span class="dv">6</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> items:</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(x) <span class="op">&gt;</span> <span class="dv">1</span>: <span class="bu">print</span> x</span></code></pre></div>
<pre><code>&lt;fp.node instance at 0x5017ef0&gt;
   Null Set   1
     play=yes   9
       humidity=high   1
         windy=true   1
           temparature=mild   1
       windy=false   6
         humidity=high   2
           temparature=mild   1
         humidity=normal   4
           temparature=mild   1
       humidity=normal   2
         windy=true   2
           temparature=mild   1
     humidity=high   2
       windy=true   2
         temparature=mild   1
     windy=false   2
       humidity=high   2
         temparature=mild   1
     humidity=normal   1
       windy=true   1
   Null Set   1
     play=yes   6
   Null Set   1
     play=yes   6
set([&#39;play=yes&#39;, &#39;humidity=normal&#39;])
set([&#39;play=yes&#39;, &#39;windy=false&#39;])</code></pre>
<p>Bulunan sonuçlar iki tane (tek öğeli sonuçlar da var ama onları
eledik). Bunlar hakikaten veri içindeki kalıpları temsil ediyorlar. Fena
değil.</p>
<p>Kıyas için BMF üzerinden madencilik yapalım. Önce 1-hot kodlaması
yapalım, ve örnek için bir veri satırını ekrana basalım,</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.feature_extraction <span class="im">import</span> DictVectorizer</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd, re</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> one_hot_dataframe(data, cols, replace<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    vec <span class="op">=</span> DictVectorizer()</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    mkdict <span class="op">=</span> <span class="kw">lambda</span> row: <span class="bu">dict</span>((col, row[col]) <span class="cf">for</span> col <span class="kw">in</span> cols)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    tmp <span class="op">=</span> data[cols].<span class="bu">apply</span>(mkdict, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    vecData <span class="op">=</span> pd.DataFrame(vec.fit_transform(tmp).toarray())</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    vecData.columns <span class="op">=</span> vec.get_feature_names()</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    vecData.index <span class="op">=</span> data.index</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> replace <span class="kw">is</span> <span class="va">True</span>:</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        data <span class="op">=</span> data.drop(cols, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        data <span class="op">=</span> data.join(vecData)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (data, vecData, vec)</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>cols <span class="op">=</span> [<span class="st">&#39;outlook&#39;</span>,<span class="st">&#39;temparature&#39;</span>,<span class="st">&#39;humidity&#39;</span>,<span class="st">&#39;windy&#39;</span>,<span class="st">&#39;play&#39;</span>]</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(data,columns<span class="op">=</span>cols)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span class="co"># kolon ismini veriden cikart, cunku tekrar geri koyulacak</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a><span class="co"># fpgrowth icin veri icinde olmasi lazim</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.applymap(<span class="kw">lambda</span> x: re.sub(<span class="st">&#39;.*?=&#39;</span>,<span class="st">&#39;&#39;</span>,x))</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>df2, _, _ <span class="op">=</span> one_hot_dataframe(df, cols, replace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a><span class="co"># tek ornek ekrana bas</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> df2.ix[<span class="dv">0</span>]</span></code></pre></div>
<pre><code>humidity=high       1
humidity=normal     0
outlook=overcast    0
outlook=rainy       0
outlook=sunny       1
play=no             1
play=yes            0
temparature=cool    0
temparature=hot     1
temparature=mild    0
windy=false         1
windy=true          0
Name: 0, dtype: float64</code></pre>
<p>Şimdi BMF işletelim, <span class="math inline">\(k=4\)</span></p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> nimfa</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.sparse <span class="im">as</span> sp</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> __fact_factor(X):</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> X.todense() <span class="cf">if</span> sp.isspmatrix(X) <span class="cf">else</span> X</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>fctr <span class="op">=</span> nimfa.mf(np.array(df2).T, seed <span class="op">=</span> <span class="st">&quot;nndsvd&quot;</span>, </span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>              rank <span class="op">=</span> <span class="dv">4</span>, method <span class="op">=</span> <span class="st">&quot;bmf&quot;</span>, </span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>              max_iter <span class="op">=</span> <span class="dv">40</span>, initialize_only <span class="op">=</span> <span class="va">True</span>,</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>              lambda_w <span class="op">=</span> <span class="fl">1.1</span>, lambda_h <span class="op">=</span> <span class="fl">1.1</span>)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> nimfa.mf_run(fctr)</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>threshold <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>res1 <span class="op">=</span> __fact_factor(res.basis())</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>res2 <span class="op">=</span> __fact_factor(res.coef())</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>res1 <span class="op">=</span> np.<span class="bu">abs</span>(np.<span class="bu">round</span>(res1 <span class="op">-</span> <span class="fl">0.5</span> <span class="op">+</span> threshold))</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>res2<span class="op">=</span>  np.<span class="bu">abs</span>(np.<span class="bu">round</span>(res2 <span class="op">-</span> <span class="fl">0.5</span> <span class="op">+</span> threshold))</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>res1 <span class="op">=</span> pd.DataFrame(res1,index<span class="op">=</span>df2.columns)</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> res1</span></code></pre></div>
<pre><code>                  0  1  2  3
humidity=high     1  0  0  1
humidity=normal   0  1  0  0
outlook=overcast  0  0  1  0
outlook=rainy     1  0  0  0
outlook=sunny     0  0  0  1
play=no           0  0  0  1
play=yes          0  1  1  0
temparature=cool  0  0  0  0
temparature=hot   0  0  0  0
temparature=mild  1  0  0  0
windy=false       0  0  1  0
windy=true        1  0  0  0</code></pre>
<p>Bu sonuçları kategoriksel hale çevirip tekrar ekrana basalım,</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span> np.array(df2.columns)[res1.ix[:,i] <span class="op">==</span> <span class="dv">1</span>]</span></code></pre></div>
<pre><code>[&#39;humidity=high&#39; &#39;outlook=rainy&#39; &#39;temparature=mild&#39; &#39;windy=true&#39;]
[&#39;humidity=normal&#39; &#39;play=yes&#39;]
[&#39;outlook=overcast&#39; &#39;play=yes&#39; &#39;windy=false&#39;]
[&#39;humidity=high&#39; &#39;outlook=sunny&#39; &#39;play=no&#39;]</code></pre>
<ol type="1">
<li><p>sonuç atlanabilir, buradaki “kalabalık’’ orada bir kalıp
olmadığına dair bir işaret. Ayrıştırma sonucu bu tür kolonlar ortaya
çıkabilir, diğer kolonlardaki kalıplar bütünü temsil etmeye <em>tam</em>
yetmemişse, arta kalan her türlü gereklilik bir yerlere tıkılabiliyor,
bu normal. 2. sonuç FPGrowth sonucunda var, güzel. 3. sonuç ta neredeyse
aynı, sadece ek olarak <code>outlook=overcast</code> var. Fakat, 3.
sonuç aslında önemli bir kalıp içeriyor olabilir, yani kalması daha iyi
olur.</p></li>
<li><p>sonuç ise çok önemli bir kalıp ve FPGrowth bunu tamamen
kaçırmış!</p></li>
</ol>
<p>Sebep FPGrowth’un çözüme lokal olarak erişmeye çalışıyor olması,
kıyasla BMF bütüne (global) bakıyor [3]. Bu ne demektir? Bir
ayrıştırmanın ne olduğunu düşünürsek, bir matrisi oluşturan çarpımı
ayrıştırıyoruz ve bu ayrıştırma olduktan sonra iki matris elde ediyoruz.
Bu iki matris özgündür (unique). Yani belli bir ikisel matrisi oluşturan
çarpım sadece tek bir şekilde olabilir. Buradan hareketle diyebiliriz ki
bu ayrıştırma bütünü göze alarak yapılmalıdır, sağı, solu tutan ama
köşesi tutmayan bir ayrıştırma olmaz. Bu sebeptendir ki ayrıştırma
çözümünden belli bir kapsayıcılık bekleyebiliriz.</p>
<p>FPGrowth ise olaya yerel bakıyor; ağaç oluştururken değişik bir sıra
takip edilirse mesela değişik ağaçlar ortaya çıkabilir. Ayrıca her
önemli ilişki muhakkak özgün bir dal yapısında olmayabilir. Madencilik
algoritması alt dallardan başlar ve yukarıya doğru çıkar, fakat bu her
zaman iyi bir yöntem midir?</p>
<p>Kodlama Notları</p>
<p>Şu kod <code>np.round(num - 0.5 + threshold)</code> kullanımı
yuvarlama (rounding) yapıyor, çünkü Nimfa 1 değeri yerine 0.9, 0.8 gibi
değerler üretebiliyor, ayrıca 0.1 gibi değerler de oluyor. Biz
bildiğimiz yuvarlama <code>.5</code> sonrası üzerini 1 yapmak yerine
belli bir eşik değeri (threshold) üzerinden yuvarlama yaptık. Yani
eşik=0.2 ise 0.7 alta yuvarlanır ve 0 olur, 0.9 eşik üstünde olduğu için
üste yuvarlanır 1 olur.</p>
<p>BMF için kerte <span class="math inline">\(k\)</span> kullanıcı
tarafından seçilmeli, ama bu durum SVD, ya da GMM ile kümeleme gibi
diğer yapay öğrenim metotlarından farklı değildir. Bu oynanması gereken,
keşfedilmesi gereken bir değer.</p>
<p>Çok Değişkenli Bernoulli Karışımı Kümelemesi ile İlişkisel
Madencilik</p>
<p>Bir diger yaklasim kümeleme üzerinden kural çıkartmak. Örnek veri
olarak [7] yazısındanki Movielens 1M verisini kullanacağız. Ayrıca bu
verideki posta kodu (zip) ve meslek (occupation) verisine README’ye ve
bir Internet sitesine [4] danışarak sözel açıklamalarını koyduk. Böylece
sonuçları yorumlamak çok daha kolay olacak.</p>
<p>İlişkilerin keşfi için çok değişkenli Bernoulli modelini
kullanacağız, ki [8] yazısında bu kümeleme yöntemi işlendi. CDBK
kullanmak için veriyi 0/1 bazına indirgeyeceğiz (ki verinin büyük bir
kısmı zaten bu durumda) ardından CDBK’yı veriye uyduracağız, ve karışım
öğeleri <span class="math inline">\(\theta_k\)</span>’lerin bir nevi
“şablon’’ oluşturması sebebiyle ilişki keşfini bu şablonlar üzerinden
yapmaya uğraşacağız.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd, zipfile</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys<span class="op">;</span> sys.path.append(<span class="st">&#39;../stat_mixbern&#39;</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> mixbern</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>unames <span class="op">=</span> [<span class="st">&#39;user_id&#39;</span>, <span class="st">&#39;gender&#39;</span>, <span class="st">&#39;age&#39;</span>, <span class="st">&#39;occupation&#39;</span>, <span class="st">&#39;zip&#39;</span>]</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>rnames <span class="op">=</span> [<span class="st">&#39;user_id&#39;</span>, <span class="st">&#39;movie_id&#39;</span>, <span class="st">&#39;rating&#39;</span>, <span class="st">&#39;timestamp&#39;</span>]</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>mnames <span class="op">=</span> [<span class="st">&#39;movie_id&#39;</span>, <span class="st">&#39;title&#39;</span>, <span class="st">&#39;genres&#39;</span>]</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> zipfile.ZipFile(<span class="st">&#39;../stat_ratings/ml1m.zip&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> z:</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    users <span class="op">=</span> pd.read_table(z.<span class="bu">open</span>(<span class="st">&#39;users.dat&#39;</span>), sep<span class="op">=</span><span class="st">&#39;::&#39;</span>, header<span class="op">=</span><span class="va">None</span>,names<span class="op">=</span>unames)</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    ratings <span class="op">=</span> pd.read_table(z.<span class="bu">open</span>(<span class="st">&#39;ratings.dat&#39;</span>), sep<span class="op">=</span><span class="st">&#39;::&#39;</span>, header<span class="op">=</span><span class="va">None</span>,names<span class="op">=</span>rnames)</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    movies <span class="op">=</span> pd.read_table(z.<span class="bu">open</span>(<span class="st">&#39;movies.dat&#39;</span>), sep<span class="op">=</span><span class="st">&#39;::&#39;</span>, header<span class="op">=</span><span class="va">None</span>,names<span class="op">=</span>mnames)</span></code></pre></div>
<div class="sourceCode" id="cb17"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>occup_map <span class="op">=</span> <span class="op">\</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>{ <span class="dv">0</span>:  <span class="st">&quot;other&quot;</span> <span class="kw">or</span> <span class="kw">not</span> specified,<span class="dv">1</span>:  <span class="st">&quot;academic/educator&quot;</span>,</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="dv">2</span>:  <span class="st">&quot;artist&quot;</span>,<span class="dv">3</span>:  <span class="st">&quot;clerical/admin&quot;</span>,</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="dv">4</span>:  <span class="st">&quot;college/grad student&quot;</span>,<span class="dv">5</span>:  <span class="st">&quot;customer service&quot;</span>,</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="dv">6</span>:  <span class="st">&quot;doctor/health care&quot;</span>,<span class="dv">7</span>:  <span class="st">&quot;executive/managerial&quot;</span>,</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span class="dv">8</span>:  <span class="st">&quot;farmer&quot;</span>,<span class="dv">9</span>:  <span class="st">&quot;homemaker&quot;</span>,</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  <span class="dv">10</span>:  <span class="st">&quot;K-12 student&quot;</span>, <span class="dv">11</span>:  <span class="st">&quot;lawyer&quot;</span>,</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span class="dv">12</span>:  <span class="st">&quot;programmer&quot;</span>,<span class="dv">13</span>:  <span class="st">&quot;retired&quot;</span>,</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>  <span class="dv">14</span>:  <span class="st">&quot;sales/marketing&quot;</span>,<span class="dv">15</span>:  <span class="st">&quot;scientist&quot;</span>,</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>  <span class="dv">16</span>:  <span class="st">&quot;self-employed&quot;</span>,<span class="dv">17</span>:  <span class="st">&quot;technician/engineer&quot;</span>,</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>  <span class="dv">18</span>:  <span class="st">&quot;tradesman/craftsman&quot;</span>,<span class="dv">19</span>:  <span class="st">&quot;unemployed&quot;</span>,</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>  <span class="dv">20</span>:  <span class="st">&quot;writer&quot;</span>}</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>zip_map <span class="op">=</span> <span class="op">\</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>{ <span class="dv">0</span>: <span class="st">&#39;Northeast&#39;</span>, <span class="dv">1</span>: <span class="st">&#39;NY Area&#39;</span>, <span class="dv">2</span>: <span class="st">&#39;DC&#39;</span>, <span class="dv">3</span>: <span class="st">&#39;Florida&#39;</span>, <span class="dv">4</span>: <span class="st">&#39;Michigan/Ohio&#39;</span>, </span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>  <span class="dv">5</span>: <span class="st">&#39;North&#39;</span>, <span class="dv">6</span>: <span class="st">&#39;Illinois&#39;</span>, <span class="dv">7</span>: <span class="st">&#39;Texas / Arkansas&#39;</span>, <span class="dv">8</span>: <span class="st">&#39;Nevada / Utah&#39;</span>, </span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>  <span class="dv">9</span>: <span class="st">&#39;California / Alaska&#39;</span>}</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.feature_extraction <span class="im">import</span> DictVectorizer</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> one_hot_dataframe(data, cols):</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>    vec <span class="op">=</span> DictVectorizer()</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>    mkdict <span class="op">=</span> <span class="kw">lambda</span> row: <span class="bu">dict</span>((col, row[col]) <span class="cf">for</span> col <span class="kw">in</span> cols)</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>    tmp <span class="op">=</span> vec.fit_transform(data[cols].to_dict(outtype<span class="op">=</span><span class="st">&#39;records&#39;</span>)).toarray()</span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>    vecData <span class="op">=</span> pd.DataFrame(tmp)</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>    vecData.columns <span class="op">=</span> vec.get_feature_names()</span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>    vecData.index <span class="op">=</span> data.index</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> data.drop(cols, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> data.join(vecData)</span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> data</span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> users.copy()</span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;occupation&#39;</span>] <span class="op">=</span> df.<span class="bu">apply</span>(<span class="kw">lambda</span> x: occup_map[x[<span class="st">&#39;occupation&#39;</span>]], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;zip2&#39;</span>] <span class="op">=</span> users[<span class="st">&#39;zip&#39;</span>].<span class="bu">map</span>(<span class="kw">lambda</span> x: <span class="bu">int</span>(<span class="bu">str</span>(x)[<span class="dv">0</span>]))</span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;zip2&#39;</span>] <span class="op">=</span> df.<span class="bu">apply</span>(<span class="kw">lambda</span> x: zip_map[x[<span class="st">&#39;zip2&#39;</span>]], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;age2&#39;</span>] <span class="op">=</span> pd.qcut(df[<span class="st">&#39;age&#39;</span>],<span class="dv">5</span>)</span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> one_hot_dataframe(df,[<span class="st">&#39;occupation&#39;</span>,<span class="st">&#39;gender&#39;</span>,<span class="st">&#39;zip2&#39;</span>,<span class="st">&#39;age2&#39;</span>])</span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.drop([<span class="st">&#39;zip&#39;</span>,<span class="st">&#39;age&#39;</span>],axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.set_index(<span class="st">&#39;user_id&#39;</span>)</span></code></pre></div>
<p>ZIP kodları altta gösteriliyor</p>
<p><img src="zip_code_zones.png" /></p>
<p>Şimdi hangi film genre’sinin (türünün) kullanıcı tarafından kaç kez
alınmış olduğunu özetleyip kullanıcı verisine bitişik olarak
ekleyeceğiz.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>genre_iter <span class="op">=</span> (<span class="bu">set</span>(x.split(<span class="st">&#39;|&#39;</span>)) <span class="cf">for</span> x <span class="kw">in</span> movies.genres)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>genres <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">set</span>.union(<span class="op">*</span>genre_iter))</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>dummies <span class="op">=</span> pd.DataFrame(np.zeros((<span class="bu">len</span>(movies), <span class="bu">len</span>(genres))), columns<span class="op">=</span>genres)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, gen <span class="kw">in</span> <span class="bu">enumerate</span>(movies.genres):</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>   dummies.ix[i, gen.split(<span class="st">&#39;|&#39;</span>)] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>movies_windic <span class="op">=</span> movies.join(dummies.add_prefix(<span class="st">&#39;Genre_&#39;</span>))</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>movies_windic <span class="op">=</span> movies_windic.drop([<span class="st">&#39;title&#39;</span>,<span class="st">&#39;genres&#39;</span>],axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>joined <span class="op">=</span> ratings.merge(movies_windic, left_on<span class="op">=</span><span class="st">&#39;movie_id&#39;</span>,right_on<span class="op">=</span><span class="st">&#39;movie_id&#39;</span>)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>genres <span class="op">=</span> joined.groupby(<span class="st">&#39;user_id&#39;</span>).<span class="bu">sum</span>()</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>genres <span class="op">=</span> genres.drop([<span class="st">&#39;movie_id&#39;</span>,<span class="st">&#39;rating&#39;</span>,<span class="st">&#39;timestamp&#39;</span>],axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> pd.merge(df, genres, left_index<span class="op">=</span><span class="va">True</span>, right_index<span class="op">=</span><span class="va">True</span>,how<span class="op">=</span><span class="st">&#39;left&#39;</span>)</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> X.shape</span></code></pre></div>
<pre><code>(6040, 56)</code></pre>
<p>En iyi küme sayısı nedir? Bunun için mümkün tüm küme sayılarını
deneriz, AIC sonuçlarına bakarız, sonuçlar arasından düşüş ardından ilk
çıkış olduğu anı en iyi küme sayısı olarak kullanırız.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="bu">iter</span><span class="op">=</span><span class="dv">40</span><span class="op">;</span> eps<span class="op">=</span><span class="fl">1e-15</span><span class="op">;</span> attempts<span class="op">=</span><span class="dv">5</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> K <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>,<span class="dv">16</span>):</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    lR,lPi,lP,lbest,aic <span class="op">=</span> mixbern.EMmixtureBernoulli(X,K,<span class="bu">iter</span>,eps,attempts)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span> K,aic</span></code></pre></div>
<pre><code>5,173126.633281
6,172007.606772
7,170285.383519
8,169043.301004
9,168457.12051
10,167463.532805
11,167253.486012
12,166290.598818
13,165764.506989
14,164964.964083
15,164989.85056
16,164321.25051</code></pre>
<p>Sonuçlara göre <span class="math inline">\(K=14\)</span> bu çıkış
anını yakalar. Bu sayıyla tekrar kümelemeyi işletelim,</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="bu">iter</span><span class="op">=</span><span class="dv">40</span><span class="op">;</span> eps<span class="op">=</span><span class="fl">1e-15</span><span class="op">;</span> attempts<span class="op">=</span><span class="dv">5</span><span class="op">;</span> K<span class="op">=</span><span class="dv">14</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>lR,lPi,lP,lbest,aic <span class="op">=</span> mixbern.EMmixtureBernoulli(X,K,<span class="bu">iter</span>,eps,attempts)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>rules <span class="op">=</span> np.exp(lP)</span></code></pre></div>
<div class="sourceCode" id="cb23"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> print_rule(j):</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i,r <span class="kw">in</span> <span class="bu">enumerate</span>(rules[j]): </span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>         <span class="cf">if</span> r <span class="op">&gt;</span> <span class="fl">0.5</span>: <span class="bu">print</span> X.columns[i], r</span></code></pre></div>
<p>Şimdi bazı kuralları ekrana basalım,</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>print_rule(<span class="dv">0</span>)</span></code></pre></div>
<pre><code>age2=(25, 35] 1.0
gender=M 1.0
Genre_Action 0.997646429789
Genre_Adventure 0.976908591072
Genre_Animation 0.73312197406
Genre_Children&#39;s 0.815806962254
Genre_Comedy 1.0
Genre_Crime 0.888200034236
Genre_Drama 1.0
Genre_Fantasy 0.759168898223
Genre_Film-Noir 0.535819148049
Genre_Horror 0.859145011653
Genre_Musical 0.704293299334
Genre_Mystery 0.735085517947
Genre_Romance 0.999999999621
Genre_Sci-Fi 0.98865549819
Genre_Thriller 1.0
Genre_War 0.948000910806
Genre_Western 0.590038323721</code></pre>
<p>25 ila 35 yaş arasındaki erkekler komedi ve aksiyon çok seviyorlar,
en çok beğendiklerinin arasında en alt sırada Western var. İlginç.</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>print_rule(<span class="dv">1</span>)</span></code></pre></div>
<pre><code>age2=(18, 25] 1.0
gender=M 1.0
Genre_Action 0.999999916342
Genre_Adventure 0.968035357641
Genre_Animation 0.618607301467
Genre_Children&#39;s 0.733114850427
Genre_Comedy 1.0
Genre_Crime 0.895303009556
Genre_Drama 1.0
Genre_Fantasy 0.621607330213
Genre_Horror 0.826409070694
Genre_Mystery 0.667105230382
Genre_Romance 0.962487486107
Genre_Sci-Fi 0.981703990034
Genre_Thriller 0.999998477836
Genre_War 0.884260074733</code></pre>
<p>Daha dar bir yaş aralığı 18-25 yaş grubu, komedi, dram, aksiyon,
gerilim var, en az sevilen filmler bu sefer animasyon.</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>print_rule(<span class="dv">2</span>)</span></code></pre></div>
<pre><code>gender=F 1.0
Genre_Action 1.0
Genre_Adventure 0.997753376918
Genre_Animation 0.925605697933
Genre_Children&#39;s 0.989223061984
Genre_Comedy 0.999411653044
Genre_Crime 0.978893423529
Genre_Drama 1.0
Genre_Fantasy 0.890898944372
Genre_Film-Noir 0.810452619282
Genre_Horror 0.901607018088
Genre_Musical 0.93690169152
Genre_Mystery 0.949990841295
Genre_Romance 1.0
Genre_Sci-Fi 0.999467975234
Genre_Thriller 0.997148167548
Genre_War 0.987837234705
Genre_Western 0.801075654907</code></pre>
<p>Bayanlar için (yaş grubu yok dikkat), üstte aksiyon var, ama romantik
filmler de en üstte.</p>
<p>Şu da ilginç bir bulgu; meslek kolları ve adres verilerini analize
dahil etmiş olmamıza rağmen kümelerin şablonu içinde hiçbiri yok! Demek
ki meslekler, adresler film beğenisinde fark yaratmıyor.</p>
<p>Üstteki analiz müşteri bilgisine müşteri seviyesinde baktı. Eğer
işlemsel (transactional) bir analiz yapıyor olsaydık, yaklaşım benzer
olacaktı, sadece veri odağı biraz farklı olurdu; müşterilerin her
alışveriş sepetlerine bakılacaktı mesela, bir sepete koyulan mesela
ekmek, çikolata, su, bir diğerine koyulan ekmek, su, biberon gibi
alımlar bir satırda 1 ile işaretli, diğerleri 0 ile işaretli olacaktı,
ve kümeleme algoritması bu çok boyutlu Bernoulli veriye bir uyum yapıp
şablonları raporlayacaktı.</p>
<p>İlginçlik - İstatistiki Ölçüt</p>
<p>Kümeleri uydurduktan sonra bile bu kümelerin içinde hangisinin “daha
iyi’’ olduğunu bulmak için istatistiki ölçüt kullanmak faydalı olabilir.
Hatta birazdan bahsedeceğimiz teknik aslında her türlü ilişki
madenciliği yaklaşımı için faydalı, çünkü hangi teknik olursa olsun bize
verinin belli bir grubunu”önemli’’ olarak gösterecek. Ardından biz bu
grubu alıp onun ne kadar önemli olduğunun ölçütünü
hesaplayabileceğiz.</p>
<p>Teknik şöyle: İstatistiki testlerden [9] yazı bölümünü hatırlarsak,
bir ideal dağılım vardı, ve eldeki verinin bu ideale olan yakınlığını
ölçüyorduk. Chi Kare testi ayrıksal bazda işliyordu, eğer eldeki sürekli
fonksiyon bazlı bir dağılım ise onun ideal hesaplarını kutucuklara
bölüştürüyorduk.</p>
<p>İlişkisel madencilikte elde ettiğimiz kural bir vektör içinde 0/1
değerleri olacak. Yaklaşım şöyle; önce verideki her kolonun tek başına
oranını buluruz. Bu oranlar her kolon “dağılımının’’ birbirinden
bağımsız farz edildiği”idealize’’ ortamın ölçütleri olacaklar. Veri
mesela şöyle,</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> [[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>],</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>],</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>],</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>],</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>],</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>        ]</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.array(data)</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>sums <span class="op">=</span> data.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>means <span class="op">=</span> data.mean(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> <span class="st">&#39;toplam&#39;</span>, sums</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> <span class="st">&#39;ortalama&#39;</span>, means</span></code></pre></div>
<pre><code>toplam [5 4 3 3 4]
ortalama [ 0.71428571  0.57142857  0.42857143  0.42857143  0.57142857]</code></pre>
<p>Şimdi bulunan kurallardan birini, diyelim <code>[1,1,0,0,1]</code>,
ana veride en fazla 1 sayısına tekabül eden kolonunu seçeriz, ve bu
kolonun 1 olduğu tüm satırları bir alt küme olarak toparlarız. Bu alt
kümede diyelim 5 tane satır var, ve kuralın diğer ögeleri 1. haricinde
2. ve 5. kolonun da ‘1’ değerinde olması. O zaman, toplam 5 satır için
2. ve sonuncu satırda 5<em>0.57 ve 5</em>0.57 tane satır olmalı. Sıfır
hipotezi bağımsızlık olduğu için bu “beklenen (expected)’’ sayı. Diğer
yandan gerçek rakamlar var, bu rakamlar alt kümedeki ‘1’ değerlerinin
toplamı, ki bu da”görünen (observed)’’ sayı. Bu iki vektör üzerinden chi
kare değerini hesaplıyoruz [5, sf. 391],</p>
<p><span class="math display">\[ \chi^2 = \sum_i \frac{(O_i-E_i)^2}{E_i}
\]</span></p>
<p><span class="math inline">\(\chi^2\)</span>’nin serbestlik derecesi
3-1=2 (çünkü kuralda 3 tane kolon var, 1. kolonu alt kümeyi bulmak için
kullandık). p-değeri ne kadar yüksek ise kural o kadar ilginç
diyebiliriz.</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats.distributions <span class="im">import</span> chi2</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> interesting(rule): </span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>     idx <span class="op">=</span> (sums<span class="op">*</span>rule).argmax()</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>     subset <span class="op">=</span> data[data[:,idx] <span class="op">==</span> <span class="dv">1</span>]</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>     <span class="bu">print</span> subset</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>     <span class="bu">print</span> subset[:,rule<span class="op">==</span><span class="dv">1</span>]</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>     obs <span class="op">=</span> subset[:,rule<span class="op">==</span><span class="dv">1</span>].<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>     exp <span class="op">=</span> <span class="bu">len</span>(subset)<span class="op">*</span>means[rule<span class="op">==</span><span class="dv">1</span>]</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>     <span class="bu">print</span> <span class="st">&#39;gorunen (observed)&#39;</span>, obs</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>     <span class="bu">print</span> <span class="st">&#39;beklenen (expected)&#39;</span>, exp</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>     chi <span class="op">=</span> np.<span class="bu">sum</span>((obs<span class="op">-</span>exp)<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> exp)</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>     dof <span class="op">=</span> rule.<span class="bu">sum</span>()<span class="op">-</span><span class="dv">1</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>     <span class="bu">print</span> <span class="dv">1</span><span class="op">-</span>chi2.cdf(chi,dof)</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>rule <span class="op">=</span> np.array([<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>])</span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>interesting(rule)</span></code></pre></div>
<pre><code>[[1 1 0 0 1]
 [1 0 0 0 0]
 [1 0 0 1 1]
 [1 1 0 1 1]
 [1 1 1 0 1]]
[[1 1 1]
 [1 0 0]
 [1 0 1]
 [1 1 1]
 [1 1 1]]
gorunen (observed) [5 3 4]
beklenen (expected) [ 3.57142857  2.85714286  2.85714286]
0.595795886519</code></pre>
<p>Bir başka kural deneyelim,</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>rule <span class="op">=</span> np.array([<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>])</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>interesting(rule)</span></code></pre></div>
<pre><code>[[1 1 0 0 1]
 [1 0 0 0 0]
 [1 0 0 1 1]
 [1 1 0 1 1]
 [1 1 1 0 1]]
[[1 1]
 [1 0]
 [1 1]
 [1 1]
 [1 1]]
gorunen (observed) [5 4]
beklenen (expected) [ 3.57142857  2.85714286]
0.310494434317</code></pre>
<p>Bu daha az ilginçmiş. Hakikaten de ilk kuralın veriye bakarak daha
ilginç olduğunu söyleyebiliriz.</p>
<p>Gösterdiğimiz tekniği film sonuçlarında kullanmadık, bunu ödev olarak
okuyucuya bırakıyoruz.</p>
<p>Kaynaklar</p>
<p>[1] Ian H. Witten, Eibe Frank, Mark A. Hall, <em>Data Mining
Practical Machine Learning Tools and Techniques</em></p>
<p>[2] Harrington, P., <em>Machine Learning in Action</em></p>
<p>[3] Miettinen, <em>Boolean Matrix Factorizations</em>, <a
href="http://www.mpi-inf.mpg.de/~pmiettin/slides/BooleanMatrixFactorizationsForDataMining_Antwerp_slides.pdf">http://www.mpi-inf.mpg.de/~pmiettin/slides/BooleanMatrixFactorizationsForDataMining_Antwerp_slides.pdf</a></p>
<p>[4] Zip boundary, <em>ZIP Code FAQs</em>, <a
href="http://www.zipboundary.com/zipcode_faqs.html">http://www.zipboundary.com/zipcode_faqs.html</a></p>
<p>[5] Rao, <em>Linear Statistical Inference and Its
Applications</em></p>
<p>[6] Bayramlı, Lineer Cebir, <em>Matris Çarpımı, Ders 1</em></p>
<p>[7] Bayramlı, Istatistik, <em>Pivotlama</em></p>
<p>[8] Bayramlı, Istatistik, <em>Çok Değişkenli Bernoulli
Karışımı</em></p>
<p>[9] Bayramlı, Istatistik, <em>Pearson Chi Kare Uyum Derecesi
Testi</em></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
