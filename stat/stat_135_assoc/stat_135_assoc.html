<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>İlişkisel Madencilik (Association Mining)</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<h1 id="ilişkisel-madencilik-association-mining">İlişkisel Madencilik (Association Mining)</h1>
<p>İkisel Matris Ayrıştırması (Binary Matrix Factorization)</p>
<p>Veri madenciliği denince pek çok kişinin aklına gelen ilk örnek, aslında, sık bulunan öğe kümeleri (frequent itemsets) örneğidir: &quot;filanca ülkeden sitemize gelen müşterilerin aynı zamanda vs özelliklerinin olduğunu da keşfettik&quot; gibi.</p>
<p>Benzer bir örnek, ki bu alan öğe kümelerinin aslında en önemli çıkış sebeplerinden birisidir, alışveriş sepeti analizidir. Müşterinin her alışverişinde sepetinde belli mallar vardır, ve bu malların hangilerinin aynı anda, aynı sepette olduğu analiz edilmeye uğraşılır. Eğer sürekli ekmek ve reçel aynı anda alınıyorsa, bu bilgi kullanılarak belki malların daha iyi konumlandırılması yapılacaktır, vs. Sık bulunan öğe kümeleri teknikleri bazen değişik adlar altında da geçebiliyor, mesela ilişki madenciliği (association mining) gibi. Algoritma olarak kullanılan pek çok teknik var, APriori iyi bilinenlerden, FPGrowth ondan daha hızlı çalışan ve daha tercih edilen bir teknik. İstatistiki bir teknik olan Çok Boyutlu Bernoulli Karışımları da bu alanda kullanılan bir yaklaşım.</p>
<p>Bir diğer alternatif ikisel matris ayrıştırması (binary matrix factorızation -BMF-) kullanmaktır [3]. Aynen SVD'de olduğu gibi BMF de bir matrisi ayrıştırır, fakat üç matris yerine iki matrise ayrıştırır ve hem sonuç matrisi hem de ayrıştırılan matrisler sadece 0 ya da 1 değerini taşıyabilirler. Yani bu ayrıştırma sonuç matrislerinin ikisel olmasını mecbur tutar, negatif olmayan matris ayrıştırmasının (non-negative matrix factorızation) sonuç matrisinin pozitif değerler taşımasını mecbur kılması gibi. Bunlar birer kısıtlama (constraint) ve bu sonuç o kısıtlamalara göre ortaya çıkıyor. <em>Dikkat</em>: BMF için toplama işlemi <span class="math inline">\(1+0 = 1, 1+1=1, 0+0 = 0\)</span> olarak tekrar tanımlanır, yani mantıksal OR işlemi haline gelir.</p>
<p>Ayrıştırma öncesi hangi kerte (rank) <span class="math inline">\(k\)</span> değerine geçmek istediğimizi biz belirtiriz. BMF'nin öğe kümeleri madenciliği için faydası şurada: öğe kümeleri ararken baktığımız öğeler kategorik şeylerdir, alışveriş sepeti örneğinde mesela ekmek, reçel gibi. Kategorik öğeleri daha önce 1-hot kodlaması (encoding) ile 1/0 değerleri taşıyan yeni kolonlara geçirebildiğimizi görmüştük. Yani tamamen kategorik değerler taşıyan veriler tamamen 1/0 taşıyacak şekilde tekrar kodlanabilir, yani ikisel matris haline getirilebilir. Bu ikisel matrisi ayrıştırdığımız zaman ve kendileri de ikisel olan iki yeni matris elde ettiğimizde ise bir anlamda boyut indirgemesi yapmış oluruz, yani sanki ana matrisi &quot;özetleriz''. İşte bu özet, özellikle çarpılan &quot;baz'' matris, öğe kümelerinin hangileri olduğu hakkında ipuçları içeriyor olabilir.</p>
<p>Bir örnek üzerinde görelim, mesela altta Alice (A), Bob Marley (B) ve Prens Charles (C) verileri var. Bu kişiler için saçı uzun mu (long-haired), ünlü mü (well-known) ve bay mı (male) verileri var.</p>
<div class="figure">
<img src="abc.png" />

</div>
<p>Bu matris üzerinde ikisel ayrıştırma yaparsak, <span class="math inline">\(k=2\)</span></p>
<div class="figure">
<img src="abc_res.png" />

</div>
<p>Eğer kontrol etmek istersek, matris çarpımı yapmamız gerekir, bunun için</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">a <span class="op">=</span> np.array([[<span class="dv">1</span>,  <span class="dv">0</span>],
               [<span class="dv">1</span>,  <span class="dv">1</span>],
               [<span class="dv">0</span>,  <span class="dv">1</span>]], dtype<span class="op">=</span><span class="bu">bool</span>)
b <span class="op">=</span> np.array([[<span class="dv">1</span>,  <span class="dv">1</span>,  <span class="dv">0</span>],
               [<span class="dv">0</span>,  <span class="dv">1</span>,  <span class="dv">1</span>]], dtype<span class="op">=</span><span class="bu">bool</span>)

<span class="bu">print</span> np.dot(a,b)</code></pre></div>
<pre><code>[[ True  True False]
 [ True  True  True]
 [False  True  True]]</code></pre>
<p>0 ve 1 değerleri görmek için 1 ile çarpmak yeterli</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> <span class="dv">1</span><span class="op">*</span>np.dot(a,b)</code></pre></div>
<pre><code>[[1 1 0]
 [1 1 1]
 [0 1 1]]</code></pre>
<p>Sonuç başlangıç matrisi ile aynı, demek ki <code>bool</code> tipi matris tanımlayınca Numpy çarpımı <code>dot</code>, çarpım sırasındaki toplama işlemi için aritmetik toplama yerine VEYA (OR) kullanması gerektiğini anladı.</p>
<p>Şimdi ayrıştırmayı analiz edelim, özellikle sol taraftaki çarpılan &quot;baz'' matrise bakalım.. [6] yazısından hareketle, bu yazıdaki kolon kombinasyon bakışını kullanalım (tabii toplamanın BMF için OR olduğunu unutmadan), o zaman soldaki baz matrisin dikey, kolon bazlı olarak, bir özet olduğunu görebiliyoruz. Çünkü çarpan sağ taraf bu kolonları alıp onları belli şekillerde &quot;kombine ederek'' nihai (orijinal) matrisi ortaya çıkartabilmeli. Bu sebeple soldaki çarpılan matris bir özet olmalı / baz oluşturmalı, ve bunun yan etkisi olarak kolonlardaki değerlerde belli bir kalıp / örüntü (pattern) olmalı. O zaman her baz kolonunda birbiriyle alakalı olan ögeler aynı anda 1 değeri taşıyor olacaktır.</p>
<p>Sonuca göre uzun saçlı ve ünlü olmak (1. kolon) arasında bağlantı varmış , ayrıca erkek olmak ve ünlü olmak (2. kolon) arasında da bağlantı varmış :) Veriye göre böyle en azından.. Bu sonucu orijinal matrise bakarak ta kontrol edebiliriz.</p>
<p>Ayrıştırma Kodlaması</p>
<p>BMF özel bir hesaptır ve Numpy / Scipy içinde mevcut değildir, ayrı bir kütüphane kullanmak gereklidir, <code>nimfa</code> paketi içinde gerekli kodlar var. Kurduktan sonra üstteki örneği şöyle çözebiliriz;</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> nimfa
<span class="im">import</span> pandas <span class="im">as</span> pd
<span class="im">import</span> scipy.sparse <span class="im">as</span> sp

<span class="kw">def</span> __fact_factor(X):
    <span class="cf">return</span> X.todense() <span class="cf">if</span> sp.isspmatrix(X) <span class="cf">else</span> X

A <span class="op">=</span> np.array([[<span class="fl">1.</span>, <span class="fl">1.</span>, <span class="dv">0</span>],
              [<span class="fl">1.</span>, <span class="fl">1.</span>, <span class="fl">1.</span>],
              [<span class="dv">0</span>, <span class="fl">1.</span>, <span class="fl">1.</span>]])

fctr <span class="op">=</span> nimfa.mf(A,
              seed <span class="op">=</span> <span class="st">&quot;nndsvd&quot;</span>, 
              rank <span class="op">=</span> <span class="dv">2</span>, 
              method <span class="op">=</span> <span class="st">&quot;bmf&quot;</span>, 
              max_iter <span class="op">=</span> <span class="dv">40</span>, 
              initialize_only <span class="op">=</span> <span class="va">True</span>,
              lambda_w <span class="op">=</span> <span class="fl">1.1</span>,
              lambda_h <span class="op">=</span> <span class="fl">1.1</span>)

res <span class="op">=</span> nimfa.mf_run(fctr)

threshold <span class="op">=</span> <span class="fl">0.2</span>
res1 <span class="op">=</span> __fact_factor(res.basis())
res2 <span class="op">=</span> __fact_factor(res.coef())
res1 <span class="op">=</span> np.<span class="bu">abs</span>(np.<span class="bu">round</span>(res1 <span class="op">-</span> <span class="fl">0.5</span> <span class="op">+</span> threshold))
res2 <span class="op">=</span> np.<span class="bu">abs</span>(np.<span class="bu">round</span>(res2 <span class="op">-</span> <span class="fl">0.5</span> <span class="op">+</span> threshold))
res1 <span class="op">=</span> pd.DataFrame(res1, index<span class="op">=</span>[<span class="st">&#39;long-haired&#39;</span>,<span class="st">&#39;well-known&#39;</span>,<span class="st">&#39;male&#39;</span>])
res2 <span class="op">=</span> pd.DataFrame(res2, columns<span class="op">=</span>[<span class="st">&#39;A&#39;</span>,<span class="st">&#39;B&#39;</span>,<span class="st">&#39;C&#39;</span>])
<span class="bu">print</span> res1
<span class="bu">print</span> <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>
<span class="bu">print</span> res2</code></pre></div>
<pre><code>             0  1
long-haired  1  0
well-known   1  1
male         0  1


   A  B  C
0  1  0  0
1  0  1  1</code></pre>
<p>Sonuç neredeyse tıpatıp aynı; sadece çarpan matriste [0,B] kordinatı 1 değil, fakat bize lazım olan baz matris aynı çıktı.</p>
<p>BMF hakkında bazı ek bilgiler: [2]'ye göre en az hatalı BMF hesaplamak NP-hard zorluğunda, yani 3SAT gibi, ya da Seyahat Eden Satış Elemanı (Traveling Salesman) problemi gibi ki bu problemler kombinatoryel (combinatorial) optimizasyon problemleridir; çözüm için tüm olasılıklar denendiği ve kısayolun mevcut olmadığı çeşitten problemler. Fakat yaklaşıksal BMF metotları oldukça hızlıdır, ayrıca seyreklik çok fark yaratıyor (pozitif anlamda) ki kategorik veriler gerçek dünyada çoğunlukla seyrek olarak görülüyor. Eldeki 2000 tane mal çeşidi içinden bir sepette ancak 5-10 tane ürün oluyor mesela, tüm 2000 tane malı bir sepete koymak mümkün değil.</p>
<p>FPGrowth</p>
<p>Öğe kümeleri bulmak için BMF haricinde bir yöntem FPGrowth yöntemidir [1,2]. Bu yöntem önce her ögeden (tek başına) kaç tane olduğunu sayar, belli bir eşik değeri <code>minsup</code> altında olanları atar, sonucu sıralar. Bu liste bir yapısına işaret eden bir başlık yapısı haline gelir. Ağacın kendisini oluşturmak için veri satırları teker teker işlenir, her satırdaki her öge için başlık yapısındaki en fazla değeri taşıyan öğe önce olmak üzere tepeden başlanıp alta doğru uzayan bir ağaç yapısı oluşturulur. Ağaçtaki her düğüm altındaki düğümün sayısal toplamını taşır. Madencilik için alttan başlanarak yukarı doğru çıkılır (amaç en üste ulaşmak) ve bu sırada öğeler <code>minsup</code> altında ise, atılırlar. Sonuçta ulaşılan ve atılmayan yollar bir öğe kümesini temsil ederler.</p>
<p>Örnek verisi olarak alttakini kullanalım,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">data <span class="op">=</span> [
[<span class="st">&#39;outlook=sunny&#39;</span>, <span class="st">&#39;temparature=hot&#39;</span>, <span class="st">&#39;humidity=high&#39;</span>, <span class="st">&#39;windy=false&#39;</span>, <span class="st">&#39;play=no&#39;</span>],
[<span class="st">&#39;outlook=sunny&#39;</span>, <span class="st">&#39;temparature=hot&#39;</span>, <span class="st">&#39;humidity=high&#39;</span>, <span class="st">&#39;windy=true&#39;</span>, <span class="st">&#39;play=no&#39;</span>],
[<span class="st">&#39;outlook=overcast&#39;</span>, <span class="st">&#39;temparature=hot&#39;</span>, <span class="st">&#39;humidity=high&#39;</span>, <span class="st">&#39;windy=false&#39;</span>, <span class="st">&#39;play=yes&#39;</span>],
[<span class="st">&#39;outlook=rainy&#39;</span>, <span class="st">&#39;temparature=mild&#39;</span>, <span class="st">&#39;humidity=high&#39;</span>, <span class="st">&#39;windy=false&#39;</span>, <span class="st">&#39;play=yes&#39;</span>],
[<span class="st">&#39;outlook=rainy&#39;</span>, <span class="st">&#39;temparature=cool&#39;</span>, <span class="st">&#39;humidity=normal&#39;</span>, <span class="st">&#39;windy=false&#39;</span>, <span class="st">&#39;play=yes&#39;</span>],
[<span class="st">&#39;outlook=rainy&#39;</span>, <span class="st">&#39;temparature=cool&#39;</span>, <span class="st">&#39;humidity=normal&#39;</span>, <span class="st">&#39;windy=true&#39;</span>, <span class="st">&#39;play=no&#39;</span>],
[<span class="st">&#39;outlook=overcast&#39;</span>, <span class="st">&#39;temparature=cool&#39;</span>, <span class="st">&#39;humidity=normal&#39;</span>, <span class="st">&#39;windy=true&#39;</span>, <span class="st">&#39;play=yes&#39;</span>],
[<span class="st">&#39;outlook=sunny&#39;</span>, <span class="st">&#39;temparature=mild&#39;</span>, <span class="st">&#39;humidity=high&#39;</span>, <span class="st">&#39;windy=false&#39;</span>, <span class="st">&#39;play=no&#39;</span>],
[<span class="st">&#39;outlook=sunny&#39;</span>, <span class="st">&#39;temparature=cool&#39;</span>, <span class="st">&#39;humidity=normal&#39;</span>, <span class="st">&#39;windy=false&#39;</span>, <span class="st">&#39;play=yes&#39;</span>],
[<span class="st">&#39;outlook=rainy&#39;</span>, <span class="st">&#39;temparature=mild&#39;</span>, <span class="st">&#39;humidity=normal&#39;</span>, <span class="st">&#39;windy=false&#39;</span>, <span class="st">&#39;play=yes&#39;</span>],
[<span class="st">&#39;outlook=sunny&#39;</span>, <span class="st">&#39;temparature=mild&#39;</span>, <span class="st">&#39;humidity=normal&#39;</span>, <span class="st">&#39;windy=true&#39;</span>, <span class="st">&#39;play=yes&#39;</span>],
[<span class="st">&#39;outlook=overcast&#39;</span>, <span class="st">&#39;temparature=mild&#39;</span>, <span class="st">&#39;humidity=high&#39;</span>, <span class="st">&#39;windy=true&#39;</span>, <span class="st">&#39;play=yes&#39;</span>],
[<span class="st">&#39;outlook=overcast&#39;</span>, <span class="st">&#39;temparature=hot&#39;</span>, <span class="st">&#39;humidity=normal&#39;</span>, <span class="st">&#39;windy=false&#39;</span>, <span class="st">&#39;play=yes&#39;</span>],
[<span class="st">&#39;outlook=rainy&#39;</span>, <span class="st">&#39;temparature=mild&#39;</span>, <span class="st">&#39;humidity=high&#39;</span>, <span class="st">&#39;windy=true&#39;</span>, <span class="st">&#39;play=no&#39;</span>]
]</code></pre></div>
<p>Hava ile alakalı bazı veriler [1] bunlar; bu veriler tahmin (outlook), sıcaklık (temparature), nem (humidity), rüzgar (windy), dışarıda oyun oynayan var mı (play). Mesela ilk satırda tahmin güneşli, ısı sıcak, nem yüksek, rüzgar yok ve oyun oynayan yok. Bu şekilde bir sürü satır. Biz bu veride bir kalıp olup olmadığına bakacağız. [2]'deki kodu [1]'den aldığımız üstteki veriye uygularsak, sonuç şöyle:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> fp
items <span class="op">=</span> fp.fpgrowth(data, minsup<span class="op">=</span><span class="dv">6</span>)
<span class="cf">for</span> x <span class="kw">in</span> items:
    <span class="cf">if</span> <span class="bu">len</span>(x) <span class="op">&gt;</span> <span class="dv">1</span>: <span class="bu">print</span> x</code></pre></div>
<pre><code>&lt;fp.node instance at 0x5017ef0&gt;
   Null Set   1
     play=yes   9
       humidity=high   1
         windy=true   1
           temparature=mild   1
       windy=false   6
         humidity=high   2
           temparature=mild   1
         humidity=normal   4
           temparature=mild   1
       humidity=normal   2
         windy=true   2
           temparature=mild   1
     humidity=high   2
       windy=true   2
         temparature=mild   1
     windy=false   2
       humidity=high   2
         temparature=mild   1
     humidity=normal   1
       windy=true   1
   Null Set   1
     play=yes   6
   Null Set   1
     play=yes   6
set([&#39;play=yes&#39;, &#39;humidity=normal&#39;])
set([&#39;play=yes&#39;, &#39;windy=false&#39;])</code></pre>
<p>Bulunan sonuçlar iki tane (tek öğeli sonuçlar da var ama onları eledik). Bunlar hakikaten veri içindeki kalıpları temsil ediyorlar. Fena değil.</p>
<p>Kıyas için BMF üzerinden madencilik yapalım. Önce 1-hot kodlaması yapalım, ve örnek için bir veri satırını ekrana basalım,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> sklearn.feature_extraction <span class="im">import</span> DictVectorizer
<span class="im">import</span> pandas <span class="im">as</span> pd, re

<span class="kw">def</span> one_hot_dataframe(data, cols, replace<span class="op">=</span><span class="va">False</span>):
    vec <span class="op">=</span> DictVectorizer()
    mkdict <span class="op">=</span> <span class="kw">lambda</span> row: <span class="bu">dict</span>((col, row[col]) <span class="cf">for</span> col <span class="kw">in</span> cols)
    tmp <span class="op">=</span> data[cols].<span class="bu">apply</span>(mkdict, axis<span class="op">=</span><span class="dv">1</span>)
    vecData <span class="op">=</span> pd.DataFrame(vec.fit_transform(tmp).toarray())
    vecData.columns <span class="op">=</span> vec.get_feature_names()
    vecData.index <span class="op">=</span> data.index
    <span class="cf">if</span> replace <span class="kw">is</span> <span class="va">True</span>:
        data <span class="op">=</span> data.drop(cols, axis<span class="op">=</span><span class="dv">1</span>)
        data <span class="op">=</span> data.join(vecData)
    <span class="cf">return</span> (data, vecData, vec)

cols <span class="op">=</span> [<span class="st">&#39;outlook&#39;</span>,<span class="st">&#39;temparature&#39;</span>,<span class="st">&#39;humidity&#39;</span>,<span class="st">&#39;windy&#39;</span>,<span class="st">&#39;play&#39;</span>]
df <span class="op">=</span> pd.DataFrame(data,columns<span class="op">=</span>cols)
<span class="co"># kolon ismini veriden cikart, cunku tekrar geri koyulacak</span>
<span class="co"># fpgrowth icin veri icinde olmasi lazim</span>
df <span class="op">=</span> df.applymap(<span class="kw">lambda</span> x: re.sub(<span class="st">&#39;.*?=&#39;</span>,<span class="st">&#39;&#39;</span>,x))
df2, _, _ <span class="op">=</span> one_hot_dataframe(df, cols, replace<span class="op">=</span><span class="va">True</span>)
<span class="co"># tek ornek ekrana bas</span>
<span class="bu">print</span> df2.ix[<span class="dv">0</span>]</code></pre></div>
<pre><code>humidity=high       1
humidity=normal     0
outlook=overcast    0
outlook=rainy       0
outlook=sunny       1
play=no             1
play=yes            0
temparature=cool    0
temparature=hot     1
temparature=mild    0
windy=false         1
windy=true          0
Name: 0, dtype: float64</code></pre>
<p>Şimdi BMF işletelim, <span class="math inline">\(k=4\)</span></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> nimfa
<span class="im">import</span> scipy.sparse <span class="im">as</span> sp

<span class="kw">def</span> __fact_factor(X):
    <span class="cf">return</span> X.todense() <span class="cf">if</span> sp.isspmatrix(X) <span class="cf">else</span> X

fctr <span class="op">=</span> nimfa.mf(np.array(df2).T, seed <span class="op">=</span> <span class="st">&quot;nndsvd&quot;</span>, 
              rank <span class="op">=</span> <span class="dv">4</span>, method <span class="op">=</span> <span class="st">&quot;bmf&quot;</span>, 
              max_iter <span class="op">=</span> <span class="dv">40</span>, initialize_only <span class="op">=</span> <span class="va">True</span>,
              lambda_w <span class="op">=</span> <span class="fl">1.1</span>, lambda_h <span class="op">=</span> <span class="fl">1.1</span>)

res <span class="op">=</span> nimfa.mf_run(fctr)

threshold <span class="op">=</span> <span class="fl">0.2</span>
res1 <span class="op">=</span> __fact_factor(res.basis())
res2 <span class="op">=</span> __fact_factor(res.coef())
res1 <span class="op">=</span> np.<span class="bu">abs</span>(np.<span class="bu">round</span>(res1 <span class="op">-</span> <span class="fl">0.5</span> <span class="op">+</span> threshold))
res2<span class="op">=</span>  np.<span class="bu">abs</span>(np.<span class="bu">round</span>(res2 <span class="op">-</span> <span class="fl">0.5</span> <span class="op">+</span> threshold))
res1 <span class="op">=</span> pd.DataFrame(res1,index<span class="op">=</span>df2.columns)
<span class="bu">print</span> res1</code></pre></div>
<pre><code>                  0  1  2  3
humidity=high     1  0  0  1
humidity=normal   0  1  0  0
outlook=overcast  0  0  1  0
outlook=rainy     1  0  0  0
outlook=sunny     0  0  0  1
play=no           0  0  0  1
play=yes          0  1  1  0
temparature=cool  0  0  0  0
temparature=hot   0  0  0  0
temparature=mild  1  0  0  0
windy=false       0  0  1  0
windy=true        1  0  0  0</code></pre>
<p>Bu sonuçları kategoriksel hale çevirip tekrar ekrana basalım,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):
    <span class="bu">print</span> np.array(df2.columns)[res1.ix[:,i] <span class="op">==</span> <span class="dv">1</span>]</code></pre></div>
<pre><code>[&#39;humidity=high&#39; &#39;outlook=rainy&#39; &#39;temparature=mild&#39; &#39;windy=true&#39;]
[&#39;humidity=normal&#39; &#39;play=yes&#39;]
[&#39;outlook=overcast&#39; &#39;play=yes&#39; &#39;windy=false&#39;]
[&#39;humidity=high&#39; &#39;outlook=sunny&#39; &#39;play=no&#39;]</code></pre>
<ol style="list-style-type: decimal">
<li><p>sonuç atlanabilir, buradaki &quot;kalabalık'' orada bir kalıp olmadığına dair bir işaret. Ayrıştırma sonucu bu tür kolonlar ortaya çıkabilir, diğer kolonlardaki kalıplar bütünü temsil etmeye <em>tam</em> yetmemişse, arta kalan her türlü gereklilik bir yerlere tıkılabiliyor, bu normal. 2. sonuç FPGrowth sonucunda var, güzel. 3. sonuç ta neredeyse aynı, sadece ek olarak <code>outlook=overcast</code> var. Fakat, 3. sonuç aslında önemli bir kalıp içeriyor olabilir, yani kalması daha iyi olur.</p></li>
<li><p>sonuç ise çok önemli bir kalıp ve FPGrowth bunu tamamen kaçırmış!</p></li>
</ol>
<p>Sebep FPGrowth'un çözüme lokal olarak erişmeye çalışıyor olması, kıyasla BMF bütüne (global) bakıyor [3]. Bu ne demektir? Bir ayrıştırmanın ne olduğunu düşünürsek, bir matrisi oluşturan çarpımı ayrıştırıyoruz ve bu ayrıştırma olduktan sonra iki matris elde ediyoruz. Bu iki matris özgündür (unique). Yani belli bir ikisel matrisi oluşturan çarpım sadece tek bir şekilde olabilir. Buradan hareketle diyebiliriz ki bu ayrıştırma bütünü göze alarak yapılmalıdır, sağı, solu tutan ama köşesi tutmayan bir ayrıştırma olmaz. Bu sebeptendir ki ayrıştırma çözümünden belli bir kapsayıcılık bekleyebiliriz.</p>
<p>FPGrowth ise olaya yerel bakıyor; ağaç oluştururken değişik bir sıra takip edilirse mesela değişik ağaçlar ortaya çıkabilir. Ayrıca her önemli ilişki muhakkak özgün bir dal yapısında olmayabilir. Madencilik algoritması alt dallardan başlar ve yukarıya doğru çıkar, fakat bu her zaman iyi bir yöntem midir?</p>
<p>Kodlama Notları</p>
<p>Şu kod <code>np.round(num - 0.5 + threshold)</code> kullanımı yuvarlama (rounding) yapıyor, çünkü Nimfa 1 değeri yerine 0.9, 0.8 gibi değerler üretebiliyor, ayrıca 0.1 gibi değerler de oluyor. Biz bildiğimiz yuvarlama <code>.5</code> sonrası üzerini 1 yapmak yerine belli bir eşik değeri (threshold) üzerinden yuvarlama yaptık. Yani eşik=0.2 ise 0.7 alta yuvarlanır ve 0 olur, 0.9 eşik üstünde olduğu için üste yuvarlanır 1 olur.</p>
<p>BMF için kerte <span class="math inline">\(k\)</span> kullanıcı tarafından seçilmeli, ama bu durum SVD, ya da GMM ile kümeleme gibi diğer yapay öğrenim metotlarından farklı değildir. Bu oynanması gereken, keşfedilmesi gereken bir değer.</p>
<p>Çok Değişkenli Bernoulli Karışımı Kümelemesi ile İlişkisel Madencilik</p>
<p>Bir diger yaklasim kümeleme üzerinden kural çıkartmak. Örnek veri olarak [7] yazısındanki Movielens 1M verisini kullanacağız. Ayrıca bu verideki posta kodu (zip) ve meslek (occupation) verisine README'ye ve bir Internet sitesine [4] danışarak sözel açıklamalarını koyduk. Böylece sonuçları yorumlamak çok daha kolay olacak.</p>
<p>İlişkilerin keşfi için çok değişkenli Bernoulli modelini kullanacağız, ki [8] yazısında bu kümeleme yöntemi işlendi. CDBK kullanmak için veriyi 0/1 bazına indirgeyeceğiz (ki verinin büyük bir kısmı zaten bu durumda) ardından CDBK'yı veriye uyduracağız, ve karışım öğeleri <span class="math inline">\(\theta_k\)</span>'lerin bir nevi &quot;şablon'' oluşturması sebebiyle ilişki keşfini bu şablonlar üzerinden yapmaya uğraşacağız.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pandas <span class="im">as</span> pd, zipfile
<span class="im">import</span> sys<span class="op">;</span> sys.path.append(<span class="st">&#39;../stat_mixbern&#39;</span>)
<span class="im">import</span> mixbern

unames <span class="op">=</span> [<span class="st">&#39;user_id&#39;</span>, <span class="st">&#39;gender&#39;</span>, <span class="st">&#39;age&#39;</span>, <span class="st">&#39;occupation&#39;</span>, <span class="st">&#39;zip&#39;</span>]
rnames <span class="op">=</span> [<span class="st">&#39;user_id&#39;</span>, <span class="st">&#39;movie_id&#39;</span>, <span class="st">&#39;rating&#39;</span>, <span class="st">&#39;timestamp&#39;</span>]
mnames <span class="op">=</span> [<span class="st">&#39;movie_id&#39;</span>, <span class="st">&#39;title&#39;</span>, <span class="st">&#39;genres&#39;</span>]
<span class="cf">with</span> zipfile.ZipFile(<span class="st">&#39;../stat_ratings/ml1m.zip&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> z:
    users <span class="op">=</span> pd.read_table(z.<span class="bu">open</span>(<span class="st">&#39;users.dat&#39;</span>), sep<span class="op">=</span><span class="st">&#39;::&#39;</span>, header<span class="op">=</span><span class="va">None</span>,names<span class="op">=</span>unames)
    ratings <span class="op">=</span> pd.read_table(z.<span class="bu">open</span>(<span class="st">&#39;ratings.dat&#39;</span>), sep<span class="op">=</span><span class="st">&#39;::&#39;</span>, header<span class="op">=</span><span class="va">None</span>,names<span class="op">=</span>rnames)
    movies <span class="op">=</span> pd.read_table(z.<span class="bu">open</span>(<span class="st">&#39;movies.dat&#39;</span>), sep<span class="op">=</span><span class="st">&#39;::&#39;</span>, header<span class="op">=</span><span class="va">None</span>,names<span class="op">=</span>mnames)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">occup_map <span class="op">=</span> <span class="op">\</span>
{ <span class="dv">0</span>:  <span class="st">&quot;other&quot;</span> <span class="kw">or</span> <span class="kw">not</span> specified,<span class="dv">1</span>:  <span class="st">&quot;academic/educator&quot;</span>,
  <span class="dv">2</span>:  <span class="st">&quot;artist&quot;</span>,<span class="dv">3</span>:  <span class="st">&quot;clerical/admin&quot;</span>,
  <span class="dv">4</span>:  <span class="st">&quot;college/grad student&quot;</span>,<span class="dv">5</span>:  <span class="st">&quot;customer service&quot;</span>,
  <span class="dv">6</span>:  <span class="st">&quot;doctor/health care&quot;</span>,<span class="dv">7</span>:  <span class="st">&quot;executive/managerial&quot;</span>,
  <span class="dv">8</span>:  <span class="st">&quot;farmer&quot;</span>,<span class="dv">9</span>:  <span class="st">&quot;homemaker&quot;</span>,
  <span class="dv">10</span>:  <span class="st">&quot;K-12 student&quot;</span>, <span class="dv">11</span>:  <span class="st">&quot;lawyer&quot;</span>,
  <span class="dv">12</span>:  <span class="st">&quot;programmer&quot;</span>,<span class="dv">13</span>:  <span class="st">&quot;retired&quot;</span>,
  <span class="dv">14</span>:  <span class="st">&quot;sales/marketing&quot;</span>,<span class="dv">15</span>:  <span class="st">&quot;scientist&quot;</span>,
  <span class="dv">16</span>:  <span class="st">&quot;self-employed&quot;</span>,<span class="dv">17</span>:  <span class="st">&quot;technician/engineer&quot;</span>,
  <span class="dv">18</span>:  <span class="st">&quot;tradesman/craftsman&quot;</span>,<span class="dv">19</span>:  <span class="st">&quot;unemployed&quot;</span>,
  <span class="dv">20</span>:  <span class="st">&quot;writer&quot;</span>}

zip_map <span class="op">=</span> <span class="op">\</span>
{ <span class="dv">0</span>: <span class="st">&#39;Northeast&#39;</span>, <span class="dv">1</span>: <span class="st">&#39;NY Area&#39;</span>, <span class="dv">2</span>: <span class="st">&#39;DC&#39;</span>, <span class="dv">3</span>: <span class="st">&#39;Florida&#39;</span>, <span class="dv">4</span>: <span class="st">&#39;Michigan/Ohio&#39;</span>, 
  <span class="dv">5</span>: <span class="st">&#39;North&#39;</span>, <span class="dv">6</span>: <span class="st">&#39;Illinois&#39;</span>, <span class="dv">7</span>: <span class="st">&#39;Texas / Arkansas&#39;</span>, <span class="dv">8</span>: <span class="st">&#39;Nevada / Utah&#39;</span>, 
  <span class="dv">9</span>: <span class="st">&#39;California / Alaska&#39;</span>}

<span class="im">from</span> sklearn.feature_extraction <span class="im">import</span> DictVectorizer
<span class="kw">def</span> one_hot_dataframe(data, cols):
    vec <span class="op">=</span> DictVectorizer()
    mkdict <span class="op">=</span> <span class="kw">lambda</span> row: <span class="bu">dict</span>((col, row[col]) <span class="cf">for</span> col <span class="kw">in</span> cols)
    tmp <span class="op">=</span> vec.fit_transform(data[cols].to_dict(outtype<span class="op">=</span><span class="st">&#39;records&#39;</span>)).toarray()
    vecData <span class="op">=</span> pd.DataFrame(tmp)
    vecData.columns <span class="op">=</span> vec.get_feature_names()
    vecData.index <span class="op">=</span> data.index
    data <span class="op">=</span> data.drop(cols, axis<span class="op">=</span><span class="dv">1</span>)
    data <span class="op">=</span> data.join(vecData)
    <span class="cf">return</span> data

df <span class="op">=</span> users.copy()
df[<span class="st">&#39;occupation&#39;</span>] <span class="op">=</span> df.<span class="bu">apply</span>(<span class="kw">lambda</span> x: occup_map[x[<span class="st">&#39;occupation&#39;</span>]], axis<span class="op">=</span><span class="dv">1</span>)
df[<span class="st">&#39;zip2&#39;</span>] <span class="op">=</span> users[<span class="st">&#39;zip&#39;</span>].<span class="bu">map</span>(<span class="kw">lambda</span> x: <span class="bu">int</span>(<span class="bu">str</span>(x)[<span class="dv">0</span>]))
df[<span class="st">&#39;zip2&#39;</span>] <span class="op">=</span> df.<span class="bu">apply</span>(<span class="kw">lambda</span> x: zip_map[x[<span class="st">&#39;zip2&#39;</span>]], axis<span class="op">=</span><span class="dv">1</span>)
df[<span class="st">&#39;age2&#39;</span>] <span class="op">=</span> pd.qcut(df[<span class="st">&#39;age&#39;</span>],<span class="dv">5</span>)
df <span class="op">=</span> one_hot_dataframe(df,[<span class="st">&#39;occupation&#39;</span>,<span class="st">&#39;gender&#39;</span>,<span class="st">&#39;zip2&#39;</span>,<span class="st">&#39;age2&#39;</span>])
df <span class="op">=</span> df.drop([<span class="st">&#39;zip&#39;</span>,<span class="st">&#39;age&#39;</span>],axis<span class="op">=</span><span class="dv">1</span>)
df <span class="op">=</span> df.set_index(<span class="st">&#39;user_id&#39;</span>)</code></pre></div>
<p>ZIP kodları altta gösteriliyor</p>
<div class="figure">
<img src="zip_code_zones.png" />

</div>
<p>Şimdi hangi film genre'sinin (türünün) kullanıcı tarafından kaç kez alınmış olduğunu özetleyip kullanıcı verisine bitişik olarak ekleyeceğiz.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">genre_iter <span class="op">=</span> (<span class="bu">set</span>(x.split(<span class="st">&#39;|&#39;</span>)) <span class="cf">for</span> x <span class="kw">in</span> movies.genres)
genres <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">set</span>.union(<span class="op">*</span>genre_iter))
dummies <span class="op">=</span> pd.DataFrame(np.zeros((<span class="bu">len</span>(movies), <span class="bu">len</span>(genres))), columns<span class="op">=</span>genres)
<span class="cf">for</span> i, gen <span class="kw">in</span> <span class="bu">enumerate</span>(movies.genres):
   dummies.ix[i, gen.split(<span class="st">&#39;|&#39;</span>)] <span class="op">=</span> <span class="dv">1</span>
movies_windic <span class="op">=</span> movies.join(dummies.add_prefix(<span class="st">&#39;Genre_&#39;</span>))
movies_windic <span class="op">=</span> movies_windic.drop([<span class="st">&#39;title&#39;</span>,<span class="st">&#39;genres&#39;</span>],axis<span class="op">=</span><span class="dv">1</span>)
joined <span class="op">=</span> ratings.merge(movies_windic, left_on<span class="op">=</span><span class="st">&#39;movie_id&#39;</span>,right_on<span class="op">=</span><span class="st">&#39;movie_id&#39;</span>)
genres <span class="op">=</span> joined.groupby(<span class="st">&#39;user_id&#39;</span>).<span class="bu">sum</span>()
genres <span class="op">=</span> genres.drop([<span class="st">&#39;movie_id&#39;</span>,<span class="st">&#39;rating&#39;</span>,<span class="st">&#39;timestamp&#39;</span>],axis<span class="op">=</span><span class="dv">1</span>)
X <span class="op">=</span> pd.merge(df, genres, left_index<span class="op">=</span><span class="va">True</span>, right_index<span class="op">=</span><span class="va">True</span>,how<span class="op">=</span><span class="st">&#39;left&#39;</span>)
<span class="bu">print</span> X.shape</code></pre></div>
<pre><code>(6040, 56)</code></pre>
<p>En iyi küme sayısı nedir? Bunun için mümkün tüm küme sayılarını deneriz, AIC sonuçlarına bakarız, sonuçlar arasından düşüş ardından ilk çıkış olduğu anı en iyi küme sayısı olarak kullanırız.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">iter</span><span class="op">=</span><span class="dv">40</span><span class="op">;</span> eps<span class="op">=</span><span class="fl">1e-15</span><span class="op">;</span> attempts<span class="op">=</span><span class="dv">5</span>
<span class="cf">for</span> K <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>,<span class="dv">16</span>):
    lR,lPi,lP,lbest,aic <span class="op">=</span> mixbern.EMmixtureBernoulli(X,K,<span class="bu">iter</span>,eps,attempts)
    <span class="bu">print</span> K,aic</code></pre></div>
<pre><code>5,173126.633281
6,172007.606772
7,170285.383519
8,169043.301004
9,168457.12051
10,167463.532805
11,167253.486012
12,166290.598818
13,165764.506989
14,164964.964083
15,164989.85056
16,164321.25051</code></pre>
<p>Sonuçlara göre <span class="math inline">\(K=14\)</span> bu çıkış anını yakalar. Bu sayıyla tekrar kümelemeyi işletelim,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">iter</span><span class="op">=</span><span class="dv">40</span><span class="op">;</span> eps<span class="op">=</span><span class="fl">1e-15</span><span class="op">;</span> attempts<span class="op">=</span><span class="dv">5</span><span class="op">;</span> K<span class="op">=</span><span class="dv">14</span>
lR,lPi,lP,lbest,aic <span class="op">=</span> mixbern.EMmixtureBernoulli(X,K,<span class="bu">iter</span>,eps,attempts)
rules <span class="op">=</span> np.exp(lP)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> print_rule(j):
    <span class="cf">for</span> i,r <span class="kw">in</span> <span class="bu">enumerate</span>(rules[j]): 
         <span class="cf">if</span> r <span class="op">&gt;</span> <span class="fl">0.5</span>: <span class="bu">print</span> X.columns[i], r</code></pre></div>
<p>Şimdi bazı kuralları ekrana basalım,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">print_rule(<span class="dv">0</span>)</code></pre></div>
<pre><code>age2=(25, 35] 1.0
gender=M 1.0
Genre_Action 0.997646429789
Genre_Adventure 0.976908591072
Genre_Animation 0.73312197406
Genre_Children&#39;s 0.815806962254
Genre_Comedy 1.0
Genre_Crime 0.888200034236
Genre_Drama 1.0
Genre_Fantasy 0.759168898223
Genre_Film-Noir 0.535819148049
Genre_Horror 0.859145011653
Genre_Musical 0.704293299334
Genre_Mystery 0.735085517947
Genre_Romance 0.999999999621
Genre_Sci-Fi 0.98865549819
Genre_Thriller 1.0
Genre_War 0.948000910806
Genre_Western 0.590038323721</code></pre>
<p>25 ila 35 yaş arasındaki erkekler komedi ve aksiyon çok seviyorlar, en çok beğendiklerinin arasında en alt sırada Western var. İlginç.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">print_rule(<span class="dv">1</span>)</code></pre></div>
<pre><code>age2=(18, 25] 1.0
gender=M 1.0
Genre_Action 0.999999916342
Genre_Adventure 0.968035357641
Genre_Animation 0.618607301467
Genre_Children&#39;s 0.733114850427
Genre_Comedy 1.0
Genre_Crime 0.895303009556
Genre_Drama 1.0
Genre_Fantasy 0.621607330213
Genre_Horror 0.826409070694
Genre_Mystery 0.667105230382
Genre_Romance 0.962487486107
Genre_Sci-Fi 0.981703990034
Genre_Thriller 0.999998477836
Genre_War 0.884260074733</code></pre>
<p>Daha dar bir yaş aralığı 18-25 yaş grubu, komedi, dram, aksiyon, gerilim var, en az sevilen filmler bu sefer animasyon.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">print_rule(<span class="dv">2</span>)</code></pre></div>
<pre><code>gender=F 1.0
Genre_Action 1.0
Genre_Adventure 0.997753376918
Genre_Animation 0.925605697933
Genre_Children&#39;s 0.989223061984
Genre_Comedy 0.999411653044
Genre_Crime 0.978893423529
Genre_Drama 1.0
Genre_Fantasy 0.890898944372
Genre_Film-Noir 0.810452619282
Genre_Horror 0.901607018088
Genre_Musical 0.93690169152
Genre_Mystery 0.949990841295
Genre_Romance 1.0
Genre_Sci-Fi 0.999467975234
Genre_Thriller 0.997148167548
Genre_War 0.987837234705
Genre_Western 0.801075654907</code></pre>
<p>Bayanlar için (yaş grubu yok dikkat), üstte aksiyon var, ama romantik filmler de en üstte.</p>
<p>Şu da ilginç bir bulgu; meslek kolları ve adres verilerini analize dahil etmiş olmamıza rağmen kümelerin şablonu içinde hiçbiri yok! Demek ki meslekler, adresler film beğenisinde fark yaratmıyor.</p>
<p>Üstteki analiz müşteri bilgisine müşteri seviyesinde baktı. Eğer işlemsel (transactional) bir analiz yapıyor olsaydık, yaklaşım benzer olacaktı, sadece veri odağı biraz farklı olurdu; müşterilerin her alışveriş sepetlerine bakılacaktı mesela, bir sepete koyulan mesela ekmek, çikolata, su, bir diğerine koyulan ekmek, su, biberon gibi alımlar bir satırda 1 ile işaretli, diğerleri 0 ile işaretli olacaktı, ve kümeleme algoritması bu çok boyutlu Bernoulli veriye bir uyum yapıp şablonları raporlayacaktı.</p>
<p>İlginçlik - İstatistiki Ölçüt</p>
<p>Kümeleri uydurduktan sonra bile bu kümelerin içinde hangisinin &quot;daha iyi'' olduğunu bulmak için istatistiki ölçüt kullanmak faydalı olabilir. Hatta birazdan bahsedeceğimiz teknik aslında her türlü ilişki madenciliği yaklaşımı için faydalı, çünkü hangi teknik olursa olsun bize verinin belli bir grubunu &quot;önemli'' olarak gösterecek. Ardından biz bu grubu alıp onun ne kadar önemli olduğunun ölçütünü hesaplayabileceğiz.</p>
<p>Teknik şöyle: İstatistiki testlerden [9] yazı bölümünü hatırlarsak, bir ideal dağılım vardı, ve eldeki verinin bu ideale olan yakınlığını ölçüyorduk. Chi Kare testi ayrıksal bazda işliyordu, eğer eldeki sürekli fonksiyon bazlı bir dağılım ise onun ideal hesaplarını kutucuklara bölüştürüyorduk.</p>
<p>İlişkisel madencilikte elde ettiğimiz kural bir vektör içinde 0/1 değerleri olacak. Yaklaşım şöyle; önce verideki her kolonun tek başına oranını buluruz. Bu oranlar her kolon &quot;dağılımının'' birbirinden bağımsız farz edildiği &quot;idealize'' ortamın ölçütleri olacaklar. Veri mesela şöyle,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">data <span class="op">=</span> [[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>],
        [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],
        [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>],
        [<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>],
        [<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>],
        [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>],
        [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>]
        ]
data <span class="op">=</span> np.array(data)
sums <span class="op">=</span> data.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>)
means <span class="op">=</span> data.mean(axis<span class="op">=</span><span class="dv">0</span>)
<span class="bu">print</span> <span class="st">&#39;toplam&#39;</span>, sums
<span class="bu">print</span> <span class="st">&#39;ortalama&#39;</span>, means</code></pre></div>
<pre><code>toplam [5 4 3 3 4]
ortalama [ 0.71428571  0.57142857  0.42857143  0.42857143  0.57142857]</code></pre>
<p>Şimdi bulunan kurallardan birini, diyelim <code>[1,1,0,0,1]</code>, ana veride en fazla 1 sayısına tekabül eden kolonunu seçeriz, ve bu kolonun 1 olduğu tüm satırları bir alt küme olarak toparlarız. Bu alt kümede diyelim 5 tane satır var, ve kuralın diğer ögeleri 1. haricinde 2. ve 5. kolonun da '1' değerinde olması. O zaman, toplam 5 satır için 2. ve sonuncu satırda 5<em>0.57 ve 5</em>0.57 tane satır olmalı. Sıfır hipotezi bağımsızlık olduğu için bu &quot;beklenen (expected)'' sayı. Diğer yandan gerçek rakamlar var, bu rakamlar alt kümedeki '1' değerlerinin toplamı, ki bu da &quot;görünen (observed)'' sayı. Bu iki vektör üzerinden chi kare değerini hesaplıyoruz [5, sf. 391],</p>
<p><span class="math display">\[ \chi^2 = \sum_i \frac{(O_i-E_i)^2}{E_i} \]</span></p>
<p><span class="math inline">\(\chi^2\)</span>'nin serbestlik derecesi 3-1=2 (çünkü kuralda 3 tane kolon var, 1. kolonu alt kümeyi bulmak için kullandık). p-değeri ne kadar yüksek ise kural o kadar ilginç diyebiliriz.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> scipy.stats.distributions <span class="im">import</span> chi2

<span class="kw">def</span> interesting(rule): 
     idx <span class="op">=</span> (sums<span class="op">*</span>rule).argmax()
     subset <span class="op">=</span> data[data[:,idx] <span class="op">==</span> <span class="dv">1</span>]
     <span class="bu">print</span> subset
     <span class="bu">print</span> subset[:,rule<span class="op">==</span><span class="dv">1</span>]
     obs <span class="op">=</span> subset[:,rule<span class="op">==</span><span class="dv">1</span>].<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>)
     exp <span class="op">=</span> <span class="bu">len</span>(subset)<span class="op">*</span>means[rule<span class="op">==</span><span class="dv">1</span>]
     <span class="bu">print</span> <span class="st">&#39;gorunen (observed)&#39;</span>, obs
     <span class="bu">print</span> <span class="st">&#39;beklenen (expected)&#39;</span>, exp
     chi <span class="op">=</span> np.<span class="bu">sum</span>((obs<span class="op">-</span>exp)<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> exp)
     dof <span class="op">=</span> rule.<span class="bu">sum</span>()<span class="op">-</span><span class="dv">1</span>
     <span class="bu">print</span> <span class="dv">1</span><span class="op">-</span>chi2.cdf(chi,dof)

rule <span class="op">=</span> np.array([<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>])
interesting(rule)</code></pre></div>
<pre><code>[[1 1 0 0 1]
 [1 0 0 0 0]
 [1 0 0 1 1]
 [1 1 0 1 1]
 [1 1 1 0 1]]
[[1 1 1]
 [1 0 0]
 [1 0 1]
 [1 1 1]
 [1 1 1]]
gorunen (observed) [5 3 4]
beklenen (expected) [ 3.57142857  2.85714286  2.85714286]
0.595795886519</code></pre>
<p>Bir başka kural deneyelim,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">rule <span class="op">=</span> np.array([<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>])
interesting(rule)</code></pre></div>
<pre><code>[[1 1 0 0 1]
 [1 0 0 0 0]
 [1 0 0 1 1]
 [1 1 0 1 1]
 [1 1 1 0 1]]
[[1 1]
 [1 0]
 [1 1]
 [1 1]
 [1 1]]
gorunen (observed) [5 4]
beklenen (expected) [ 3.57142857  2.85714286]
0.310494434317</code></pre>
<p>Bu daha az ilginçmiş. Hakikaten de ilk kuralın veriye bakarak daha ilginç olduğunu söyleyebiliriz.</p>
<p>Gösterdiğimiz tekniği film sonuçlarında kullanmadık, bunu ödev olarak okuyucuya bırakıyoruz.</p>
<p>Kaynaklar</p>
<p>[1] Ian H. Witten, Eibe Frank, Mark A. Hall, <em>Data Mining Practical Machine Learning Tools and Techniques</em></p>
<p>[2] Harrington, P., <em>Machine Learning in Action</em></p>
<p>[3] Miettinen, <em>Boolean Matrix Factorizations</em>, <a href="http://www.mpi-inf.mpg.de/~pmiettin/slides/BooleanMatrixFactorizationsForDataMining_Antwerp_slides.pdf" class="uri">http://www.mpi-inf.mpg.de/~pmiettin/slides/BooleanMatrixFactorizationsForDataMining_Antwerp_slides.pdf</a></p>
<p>[4] Zip boundary, <em>ZIP Code FAQs</em>, <a href="http://www.zipboundary.com/zipcode_faqs.html" class="uri">http://www.zipboundary.com/zipcode_faqs.html</a></p>
<p>[5] Rao, <em>Linear Statistical Inference and Its Applications</em></p>
<p>[6] Bayramlı, Lineer Cebir, <em>Matris Çarpımı, Ders 1</em></p>
<p>[7] Bayramlı, Istatistik, <em>Pivotlama</em></p>
<p>[8] Bayramlı, Istatistik, <em>Çok Değişkenli Bernoulli Karışımı</em></p>
<p>[9] Bayramlı, Istatistik, <em>Pearson Chi Kare Uyum Derecesi Testi</em></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
