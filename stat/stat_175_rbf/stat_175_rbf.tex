\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Dairesel Baz Fonksiyonlarý (Radial Basis Functions -RBF-), Yükseklik Verisi, Daðlar

Ara deðerlemek (interpolation), yani elde olan veriyi kullanýp olmayan hakkýnda
tahmin yapmaya uðraþmak için çok boyutlu ortamda RBF iyi iþleyen bir
yaklaþým. Belki de zihinde en rahat canlandýrýlabilecek örnek yeryüzünde daðlara
ovalara tekabül eden yükseklik (elevation) verilerini alarak onlara sürekli tepe
fonksiyonlarý ``uydurmak'' böylece daðlarýn nerede olduðunu sürekli þekilde
saptamak. Temsil etmek istediðimiz (ama bilmediðimiz) fonksiyon $z=g(x,y)$
olarak gösterilebilecek bir fonksiyon, bir düzlemde herhangi bir $x,y$
noktasýndaki yükseklik $z$. Bu fonksiyondan örneklenerek alýnmýþ verilerle onu
yaklaþýk olarak temsil etmek istiyoruz.

Düz verinin kendisini kullanmak baðlamýnda düþük çözünürlükte yükseklik verisi
ise yaramayabilir, mesela bir örneklem noktasý daðýn bir eteðinden diðeri öteki
yanýndaki eteðinden alýnmýþsa bu dað yok anlamýna gelecektir. Peki o zaman niye
yükseklik verisinýn geldiði yerden daha yüksek çözünürlüklü veri almýyoruz?  Bu
hem eriþim hem de tutacaðý yer baðlamýnda pahalý olabilir. 1 derecelik enlem /
boylam içinde, mesela 36-37 ve 32-33 arasý diyelim, 100 metrelik çözünürlük
demek 0.001 derece deðiþimine tekabül eder, ve bu durumda 1 milyon veri noktasý
alýnmasý gerekecektir. Halbuki yükseklik verisinden yüzde 3 miktarýnda bile [2]
bir rasgele örneklem alýrsak, bu noktalara RBF ile tepe fonksiyonlarý uydurarak
matematiksel, sürekli olan bir genel fonksiyon elde ederiz, ve uydurma iyi
iþlerse artýk istediðimiz çözünürlükte yükseklik verisi elde edebiliriz çünkü
elimizdeki sürekli fonksiyona istediðimiz her nokta için yükseliðin ne olduðunu
artýk hesaplattýrabiliriz. 

Bu örneði 3 boyutta herhangi bir baþka veri için de düþünmek mümkün; ama
yükseklik verisinde daha rahat, her örneklem noktasýna konulan tepeler ve
onlarýn birleþimi bize pürüzsüz, sürekli bir engebe þekli verir. RBF baz
fonksiyonlarý $\Phi(x) = f(||x-c||)$ þeklindedir, $f$ tepe, ya da farklý bir
fonksiyon olabilir, $||\cdot||$ norm fonksiyonudur, Öklitsel norm olabilir
mesela.

Burada $c$ üstüne baz fonksiyon konulan nokta, her örneklem veri noktasý
yani. RBF eðitimi / uydurma metadolijisine göre herhangi bir veri noktasý
dýþýndaki tüm diðer örneklem verileri o veri noktasýnýn oluþumunu etkiler. Bu
anormal bir faraziye deðil, bir daðýn baþýnda, ortasýnda, tepesinden alýnmýþ
örneklemler varsa, mesela en alt ve en tepedeki veri ortadakini etkiler, yani o
baðlantýyý, iliþkiyi farzetmek normaldir. Orta nokta zirveyi tanýmlayan
fonksiyona belli bir aðýrlýkla baðlý, en alttakine baþka bir þekilde baðlý,
vs. Bu aðýrlýklarýn ne olacaðýný genel çözüm belirleyecektir. Eðer $f$ için
Gaussian'ýmsý bir tepe fonksiyonu seçersek, yeni gözlemin baz fonksiyonlarý ile
arasýndaki iliþki,

$$
h(x) = \sum_{i=1}^N w_n \times exp(-\gamma \|x-m_i\|^2)
$$

olarak gösterilebilir, $\gamma$ her noktanýn etkisinin ne olduðunu
dýþarýdan ayarlamak için genel bir sabit, ne kadar küçükse konulan tepe o
kadar kenarlara yayýlýr, daha büyük deðerler daha noktasal olur. $N$ tane
baz fonksiyonu olacak, $N$ tane $m_i,y_i$, ya da $x_i,y_i$ verisine bakarak
bu fonksiyonlarý bulacaðýz. 

Ýki üstteki formüldeki $x-c$ kullanýmýna dikkat, bu aslýnda ``diðer noktalarý''
temsil etmenin akýllýca bir yolu, $c$ üzerinde $x-c$ sýfýr deðerdedir, bu o
noktayý temsil için diðer noktalar üzerindeki bazlarýn devreye girmesi
gerektiðini modelde söyler.

Her bazýn etkisi $w_n$ aðýrlýðý üzerinden modele yansýtýlýr. Bu aðýrlýklarýn ne
olduðunu bulmak, nihai genel fonksiyonu bulmuþ olmak anlamýna gelir. Farklý
indislerle tekrar belirtmek gerekirse her veri noktasý için þu doðru olmalý,

Bu bize $N$ tane veri noktasý için $N$ tane denklem ve $N$ tane bilinmeyen
saðlar. Eldeki $(x_1,y_1),...,(x_N,y_N)$ verileri ile $w$'yi bulmamýzý
saðlayacak regresyonu matris formunda þöyle gösterebiliriz,

$$
\underbrace{
\left[\begin{array}{rrr} 
    \exp(-\gamma \|x_1-m_1\|^2) & \cdots & \exp(-\gamma \|x_1-m_N\|^2)\\ 
    \exp(-\gamma \|x_2-m_1\|^2) & \cdots & \exp(-\gamma \|x_2-m_N\|^2)\\ 
    \vdots & \ddots & \vdots \\ 
    \exp(-\gamma \|x_N-m_1\|^2) & \cdots & \exp(-\gamma \|x_N-m_N\|^2)
\end{array}\right]
}_{\Phi}
\underbrace{
\left[\begin{array}{r}
 w_1  \\ w_2  \\ \vdots \\  w_N
\end{array}\right]}_{w}
=
\underbrace{
\left[\begin{array}{rrr} y_1  \\
 y_2  \\ \vdots \\  y_N
\end{array}\right]}_{y}
$$

Tabii aslýnda verilerin kendisi RBF merkezleriyle ayný þey olduðu için
þunu da söyleyebilirdik, 

$$
\underbrace{
\left[\begin{array}{rrr} 
    \exp(-\gamma \|x_1-x_1\|^2) & \cdots & \exp(-\gamma \|x_1-x_N\|^2)\\ 
    \exp(-\gamma \|x_2-x_1\|^2) & \cdots & \exp(-\gamma \|x_2-x_N\|^2)\\ 
    \vdots & \ddots & \vdots \\ 
    \exp(-\gamma \|x_N-x_1\|^2) & \cdots & \exp(-\gamma \|x_N-x_N\|^2)
\end{array}\right]
}_{\Phi}
\underbrace{
\left[\begin{array}{r}
 w_1  \\ w_2  \\ \vdots \\  w_N
\end{array}\right]}_{w}
=
\underbrace{
\left[\begin{array}{rrr} y_1  \\
 y_2  \\ \vdots \\  y_N
\end{array}\right]}_{y}
$$

Bu durumda $w = \Phi^{-1}y$ bize $w$ aðýrlýklarýný, yani nihai çözümü
verecektir. 

Bir örnek üzerinde görelim,

\begin{minted}[fontsize=\footnotesize]{python}
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
from matplotlib import cm
import numpy as np
import matplotlib.pyplot as plt
import numpy.linalg as lin
from scipy.spatial.distance import cdist
\end{minted}

Þimdi direk bilinen iki RBF kullanalým, böylece her þeyin nasýl biraraya
geldiði ileride daha iyi anlaþýlýr. Bizim tanýmladýðýmýz aðýrlýklar, ve iki
RBF ile þu þekilde bir grafik oluþturabilirdik,

\begin{minted}[fontsize=\footnotesize]{python}
D = 50
gamma = 2.0

x = np.linspace(36,37,D)
y = np.linspace(32,33,D)

xx,yy = np.meshgrid(x,y)

xm = np.array([[36.06122449],
               [36.71428571]])
ym = np.array([[32.67346939],
               [32.32653061]])
	       
X = np.hstack((xm,ym))

Phi = np.exp(-gamma*cdist(X,X,metric='euclid'))

w = np.array([[0.5],[0.5]])

xxx = xx.reshape(D*D)
yyy = yy.reshape(D*D)

a = np.vstack((xxx,yyy))
d = cdist(X,a.T)
d = np.exp(-gamma * d)
dd = np.dot(w.T,d)
znew = dd.reshape(D,D)

fig = plt.figure()
ax = fig.gca(projection='3d')
surf = ax.plot_surface(xx, yy, znew, cmap=cm.coolwarm,linewidth=0, antialiased=False)
plt.savefig('linear_app88rbf_04.png')
\end{minted}

\includegraphics[width=20em]{linear_app88rbf_04.png}

Bu kod üzerinde oynayarak farklý $\gamma$, aðýrlýklar $w$ deðerlerinin
grafikte deðiþime yol açtýðý görülebilir. 

Burada RBF ile aslýnda analitik bir fonksiyon yaratmýþ olduk. Bir kez
aðýrlýklarýný aldýktan sonra (RBF merkezlerini zaten biliyoruz) herhangi
bir $x,y$ deðeri için o noktadaki birleþik RBF sonucunu hesaplatabiliriz,
mesela üstteki fonksiyon için

$$
x_{m1} = [36.06, 32.67],
x_{m2} = [36.71, 32.32], 
x_{test} = [36.16, 32.77]
$$


$$
y = 0.5 \exp (-\gamma || x_{test} - x_{m1} ||^2) + 0.5 \exp (-\gamma || x_{test} - x_{m2} ||^2 )
$$

\begin{minted}[fontsize=\footnotesize]{python}
x_test = [36.16, 32.77]
w1 = 0.5; w2 = 0.5
d1 = (x_test[0]-xm[0])**2 + (x_test[1]-ym[0])**2
d2 = (x_test[0]-xm[1])**2 + (x_test[1]-ym[1])**2
y_new = w1*np.exp(-gamma * d1) + w2*np.exp(-gamma * d2) 
print (y_new)
\end{minted}

\begin{verbatim}
[0.6637959]
\end{verbatim}

Gerçek dünya þartlarýna yaklaþýrsak; bu tür durumlarda çok daha fazla baz
fonksiyon, örneklem kullanýlýr, altta \verb!func! fonksiyonu örneklem
üretmek için kullanýlacak, normal þartlarda bu fonksiyonu bilmiyoruz,
sadece ondan gelen örneklem verilerini biliyoruz. Bir örnek amaçlý, belli
bir þekli zorlamak için bunu yaptýk.

\begin{minted}[fontsize=\footnotesize]{python}
np.random.seed(0)

def func(x, y):
    s1 = 0.2; x1 = 36.5; y1 = 32.5
    s2 = 0.4; x2 = 36.1; y2 = 32.8
    g1 = np.exp( -4 *np.log(2) * ((x-x1)**2+(y-y1)**2) / s1**2)
    g2 = np.exp( -2 *np.log(2) * ((x-x2)**2+(y-y2)**2) / s2**2)    
    return g1 + g2 

D = 50
S = 100
gamma = 2.0

x = np.linspace(36,37,D)
y = np.linspace(32,33,D)

xx,yy = np.meshgrid(x,y)
zz = func(xx,yy)

fig = plt.figure()
ax = fig.gca(projection='3d')
surf = ax.plot_surface(xx, yy, zz, cmap=cm.coolwarm,linewidth=0, antialiased=False)
plt.savefig('linear_app88rbf_01.png')
\end{minted}

\includegraphics[width=20em]{linear_app88rbf_01.png}

Ýki tane tepe var. Þimdi bu fonksiyondan rasgele örneklem alalým, ve $\Phi$
üzerinden RBF aðýrlýklarýný hesaplayalým,

\begin{minted}[fontsize=\footnotesize]{python}
xxx = xx.reshape(D*D)
yyy = yy.reshape(D*D)
zzz = zz.reshape(D*D)

idx = np.random.choice(range(D*D),S)

xr = xxx[idx].reshape(S,1)
yr = yyy[idx].reshape(S,1)
zr = zzz[idx].reshape(S,1)
X = np.hstack((xr,yr))

Phi = np.exp(-gamma*cdist(X,X,metric='euclid'))

w = np.dot(lin.pinv(Phi),zr)
\end{minted}

Aðýrlýklarla fonksiyonu tekrar yaratmaya uðraþalým,

\begin{minted}[fontsize=\footnotesize]{python}
a = np.vstack((xxx,yyy))
d = cdist(X,a.T)
d = np.exp(-gamma * d)
dd = np.dot(w.T,d)
znew = dd.reshape(D,D)

fig = plt.figure()
ax = fig.gca(projection='3d')
surf = ax.plot_surface(xx, yy, znew, cmap=cm.coolwarm,linewidth=0, antialiased=False)
plt.savefig('linear_app88rbf_02.png')
\end{minted}

\includegraphics[width=20em]{linear_app88rbf_02.png}

Pek optimizasyon yapmadýk, ama orijinale benzidiði söylenebilir.

Not: \verb!cdist! bir veri matrisindeki her satýr ile her diðer satýr arasýnda
(tüm kombinasyonlar) mesafe hesabý yapar.

Yeni tek bir veri noktasý için

\begin{minted}[fontsize=\footnotesize]{python}
xnew = np.array([[36.5,32.5]])

print (np.multiply(w.T,np.exp(-gamma*lin.norm(X-xnew,axis=1))).sum())
\end{minted}

\begin{verbatim}
0.6423871447150892
\end{verbatim}

Bu yaklaþýmý tüm dünyanýn yeryüzü dað, tepe veri tabanýný oluþturmak için
kullanabiliriz. 1 milyon veri yerine onun yüzden 3'u üzerinden RBF iþlettikten
sonra $x,y,w$ deðerlerini tutarýz, gerisini atarýz. Bu üç deðer geniþ bir
bölgeyi pürüzsüz fonksiyonlarla yaklaþýk temsil etmenin en iyi yolu. Veri tabaný
sadece bu deðerleri taþýyacak.

Bizim bu konuya girmemizin sebebi Google Elevation API ile aldýðýmýz yükseklik
verilerini verimli þekilde kullanma ihtiyacý idi.

Simdi \verb!scipy! ile ayni isleri yapalim,

\begin{minted}[fontsize=\footnotesize]{python}
np.random.seed(0)

S = 200

x = np.linspace(36,37,D)
y = np.linspace(32,33,D)

xx,yy = np.meshgrid(x,y)
znew = func(xx,yy)
xx = xx.reshape(D*D)
yy = yy.reshape(D*D)
znew = znew.reshape(D*D)

from scipy.interpolate import Rbf
rbfi = Rbf(xx,yy,znew,function='gaussian')
znew = rbfi(xx,yy)

xx = xx.reshape(D,D)
yy = yy.reshape(D,D)
znew = znew.reshape(D,D)

fig = plt.figure()
ax = fig.gca(projection='3d')
surf = ax.plot_surface(xx, yy, znew, cmap=cm.coolwarm,linewidth=0, antialiased=False)
plt.savefig('linear_app88rbf_05.png')
\end{minted}

\includegraphics[width=20em]{linear_app88rbf_05.png}

Not: \verb!scipy! ile bize döndürülen ve ara deðerleme için direk
çaðýrýlabilen objeyi gerekli her türlü bilgiyi içinde taþýyor. Yani modeli
çýkartýp veriyi atýp, sadece bu objeyi (mesela \verb!pickle! ile) diskte
saklayabiliriz, bu tek baþýna yeterlidir.

Modelleme \verb!scipy! Ýle, Tekrar Yaratmak Elle Yazýlan Fonksiyon Ýle

Bir diðer yaklaþým veriyi örneklemek, \verb!scipy! ile RBF'leri yaratmak,
ama \verb!sciy! parametrelerini kullanarak modeli kendimizin tekrar
yaratmasý. Bunun deðiþik sebepleri olabilir, belki veriyi modelleyen bir
yükseklik fonksiyonu üzerinde otomatik türev almak istiyoruz, ama
\verb!scipy! içindeki versiyon ile bunu yapamýyoruz. Ya da motor kapaðý
altýnda nelerin olup bittiðini daha iyi anlamak istiyoruz. 

Her neyse, yine iki tepeli ortamý yaratýyoruz, 

\begin{minted}[fontsize=\footnotesize]{python}
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
from matplotlib import cm

np.random.seed(0)

def func(x, y):
    s1 = 0.2; x1 = 36.5; y1 = 32.5
    s2 = 0.4; x2 = 36.1; y2 = 32.8
    g1 = np.exp( -4 *np.log(2) * ((x-x1)**2+(y-y1)**2) / s1**2)
    g2 = np.exp( -2 *np.log(2) * ((x-x2)**2+(y-y2)**2) / s2**2)    
    return g1 + g2 

D = 100

x = np.linspace(36,37,D)
y = np.linspace(32,33,D)

xx,yy = np.meshgrid(x,y)
zz = func(xx,yy)
\end{minted}

Ve grafiklemeyi yapýyoruz,

\begin{minted}[fontsize=\footnotesize]{python}
xx = xx.reshape(D,D)
yy = yy.reshape(D,D)
zz = func(xx,yy)

fig = plt.figure()
ax = fig.gca(projection='3d')
ax.view_init(elev=29, azim=29)
surf = ax.plot_surface(xx, yy, zz, cmap=cm.coolwarm,linewidth=0, antialiased=False)
plt.savefig('linear_app88rbf_03.png')
\end{minted}

Þimdi örneklem alýp RBF yaratalým,

\begin{minted}[fontsize=\footnotesize]{python}
from scipy.interpolate import Rbf

S = 50
np.random.seed(0)
idx = np.random.choice(range(D*D),S)
xr = xx.reshape(D*D)[idx].reshape(S,1)
yr = yy.reshape(D*D)[idx].reshape(S,1)
zr = zz.reshape(D*D)[idx].reshape(S,1)

rbfi = Rbf(xr,yr,zr,function='gaussian',epsilon=0.15)
\end{minted}


Modelleme Gaussian RBF'ler üzerinden yapýldý, bu formül neye benziyor?
Dokümantasyona bakýnca 

\verb!'gaussian': exp(-(r/self.epsilon)**2)!

ifadesini görüyoruz, burada \verb!r! yeni nokta ile bir RBF baz fonksiyonu
arasýndaki mesafe. Bir test noktasý ile üstteki RBF'leri (D*D tane)
arasýndaki mesafe þöyle hesaplanabilir,

\begin{minted}[fontsize=\footnotesize]{python}
def dist_matrix(X, Y):
    sx = np.sum(X**2, 1)
    sy = np.sum(Y**2, 1)
    D2 =  sx[:, np.newaxis] - 2.0*X.dot(Y.T) + sy[np.newaxis, :] 
    D2[D2 < 0] = 0
    D = np.sqrt(D2)
    return D
    
test_1 = np.array([[36.0,32.0]])
test_1_dist = dist_matrix(test_1, rbfi.xi.T)
print (test_1_dist.shape)
print (test_1_dist[0][:10])
\end{minted}

\begin{verbatim}
(1, 50)
[0.4229176  1.08927112 0.72276945 0.76827462 0.96299239 1.21064725
 0.85578867 0.94970984 0.80965755 0.76794254]
\end{verbatim}

O mesafeyi alýp eksi karesini hesaplayýp \verb!exp!'ye vermek lazým. Tüm
RBF'leri de bir þekilde dahil etmek lazým tabii, o da hesaplanan aðýrlýklar
ile üstteki sonucu çarpýp hepsini toplamakla olur. Gerekli parametreler
\verb!rbfi! içinde,

\begin{minted}[fontsize=\footnotesize]{python}
print (rbfi.epsilon)
print (rbfi.smooth)
print (rbfi.xi.shape)
print (rbfi.nodes.shape)
\end{minted}

\begin{verbatim}
0.15
0.0
(2, 50)
(50,)
\end{verbatim}

Aðýrlýklar \verb!nodes!, RBF merkezleri \verb!xi!, \verb!epsilon! genel bir
pürüz parametresi. Ýki test noktasý üzerinde görelim, dikkat burada {\em
  tüm} RBF'ler gözönüne alýnacak,

\begin{minted}[fontsize=\footnotesize]{python}
nodes = rbfi.nodes.reshape(1,len(rbfi.nodes))
def gaussian(r,eps): return np.exp(-(r/eps)**2)

def f_interp(newp, rbfi):
    nodes = rbfi.nodes.reshape(1,len(rbfi.nodes))
    newp_dist = dist_matrix(newp, rbfi.xi.T)
    return np.dot(gaussian(newp_dist, rbfi.epsilon), nodes.T)

test_2 = np.array([[36.0,32.0],[36.1,31.9]])
print (f_interp(test_2,rbfi))
\end{minted}

\begin{verbatim}
[[-0.00387063]
 [-0.00337065]]
\end{verbatim}

Þimdi iki tepeli fonksiyonu RBF'ler üzerinde yaratalým,

\begin{minted}[fontsize=\footnotesize]{python}
test_3 = np.column_stack((xx.ravel(), yy.ravel()))
znewnew = f_interp(test_3,rbfi).reshape(xx.shape)

fig = plt.figure()
ax = fig.gca(projection='3d')
ax.view_init(elev=29, azim=29)
surf = ax.plot_surface(xx, yy, znewnew, cmap=cm.coolwarm,linewidth=0, antialiased=False)
plt.savefig('linear_app88rbf_06.png')
\end{minted}

\includegraphics[width=20em]{linear_app88rbf_06.png}

RBF Türev ve Hessian Matrisi

Ana formülü hatýrlayalým, 

$$
f(x) = \sum _{i=1}^{m} \beta_i \phi(|| x-x_i||)
$$

ki $\beta_1,...,\beta_m$ öyle seçiliyor ki 

$$
f(x_i) = F(x_i), \quad i=1,2,...,m
$$

eþitliði tatmin edilsin. Burada $F$ modellenen ana fonksiyondur, ve $\phi$
bizim seçtiðimiz baz fonksiyondur. RBF'in türevi nedir? Analitik olarak
hesaplayabiliriz,

$$
\frac{\partial f(x)}{\partial x} = \beta^T \frac{\partial g}{\partial x} =
\sum_{i=1}^{m} \beta_i \phi'(r_i) \frac{\partial r_i}{\partial x} 
$$

öyle ki $\phi'(r) = \ud \phi / \ud r$, ve 

$$
r_i(x) = ||x-x_i|| = \sqrt{(x-x_i)^T(x-x_i)} 
\mlabel{1}
$$

Ayrýca

$$
\frac{\partial r_i}{\partial x} = \frac{1}{r_i(x)} (x-x_i)^T
$$

Hepsi bir arada [4]

$$
\frac{\partial f(x)}{\partial x} = \sum_{i=1}^{m} \frac{\beta_i\phi'(r_i)}{r_i(x)}
(x-x_i)^T
$$

Hessian'ý alttaki gibi hesaplayabiliriz [3]. [4]'teki formül

$$
\frac{\partial^2 f(x)}{\partial x^2} = 
\sum_{i=1}^{m} \bigg\{ 
\phi'(r_i) I + \bigg[\phi''(r_i) - \frac{\phi'(r_i)}{r_i(x)} \bigg] 
(x-x_i) \frac{\partial r_i}{\partial x}
\bigg\}
\mlabel{2}
$$

Türetmek için, radyal vektörler $\,w_k = (x - x_k)\in{\mathbb R}^n\,$
tanýmlanýr, dikkat bunlarýn $\,dw_k = dx$ türevleri ayný. Þimdi vektörleri
tek bir matriste birleþtirelim,

$$
\Omega = \big[\,w_1\;w_2\;\ldots\;w_m\big] \in {\mathbb R}^{n\times m} 
$$

$$
d\Omega = \big[\,dx\;dx\;\ldots\;dx\big] =  dx\,{\tt\large 1}^T 
$$

Dikkat $\,r_j=\|w_j\|\,$ öðelerinin kendisi $\,r\in{\mathbb R}^m$
vektörünün ayný zamanda ögesi.  Kartezyen baz vektörleri
$\,e_k\in{\mathbb R}^m$ üsttekini

$$w_k=\Omega\,e_k,\quad dx=d\Omega\,e_k,\quad r_j=e_j^Tr$$

þeklinde yazmamýza izin veriyor. RBF'i öðesel bazda uygulayarak indisli
toplam notasyonundan kurtulmuþ oluyoruz. Þimdi türevleri, diferansiyelleri 

$$
g=\phi(r),\quad g'=\phi'(r),\quad g''=\phi''(r)\; \in{\mathbb R}^m 
$$

$$
dg=g'\odot dr,\quad dg'=g''\odot dr \; \in{\mathbb R}^m 
$$

ile yazabiliriz, ki $\odot$ öðesel bazlý Hadamard çarpýmýdýr.

Ayrýca vektörler köþegen matrisler arasýnda geçiþ yapabilmek faydalýdýr, ki
bu matrisleri büyük harfle belirteceðiz, mesela

$$
 R={\rm Diag}(r),\quad G=
{\rm Diag}(g),\quad G''={\rm Diag}(g'')\;\in{\mathbb R}^{m\times m} 
$$

$$
r = {\rm diag}(R),\quad g = {\rm diag}(G),\quad g''=\ldots 
$$

$$
r  = R{\tt\large 1},\quad g = G{\tt\large 1},\quad g''=\ldots 
$$

$$
dg = G'dr,\quad dg' = G''dr 
$$

ayrýca iþ kolaylaþtýrmasý için alttaki taným faydalý,

$$
P=R^{-1}\quad\implies PR=I,\;\;p\odot r = {\tt\large 1}
$$

Þimdi ana iliþkiyi yazalým ve türevini alalým,

$$
r\odot r = {\rm diag}(\Omega^T\Omega) 
$$

$$
2r\odot dr = {\rm diag}(\Omega^Td\Omega+d\Omega^T\Omega)
\;=\; 2{\,\rm {diag}}(\Omega^Td\Omega) 
$$

$$
R\,dr = {\rm diag}(\Omega^Tdx\,{\tt\large 1}^T) \;=\; \Omega^Tdx 
$$

$$
dr = P\Omega^Tdx 
$$

$$
\frac{\partial r}{\partial x} = P\Omega^T 
$$

$i^{th}$ bileþeni kontrol edersek (1) formülünü ortaya çýkartabileceðimizi
görüyoruz, demek ki doðru yoldayýz,

$$
e_i^T\bigg(\frac{\partial r}{\partial x}\bigg) = e_i^TP\Omega^T 
$$

$$
\frac{\partial r_i}{\partial x} 
\;=\; \frac{1}{r_i}\;e_i^T\Omega^T
\;=\; \frac{w_i^T}{\|w_i\|} 
$$

Model fonksiyonu ($\beta$ $b$ kullandýk daha kýsa) 

$$f = b^Tg = b:g$$

Ýki nokta üst üste iz (trace) için Frobenius çarpým notasyonudur, mesela
$\;A:B = {\rm Tr}(A^TB)$. 

Þimdi Hessian

$$
dJ = d\Omega\,PG'B{\tt\large 1} + \Omega PdG'B{\tt\large 1} + \Omega\,dP\,G'B{\tt\large 1} 
$$

$$
= dx\,{\tt\large 1}^TPG'B{\tt\large 1} + \Omega PB\,dg' - \Omega (P\,dR\,P)G'B{\tt\large 1}
$$

$$
 = dx\,({\tt\large 1}^TPG'B{\tt\large 1}) +\Omega PB\,dg' -\Omega PG'PB\,dr
$$

$$
 = (G':PB)\,dx +\Omega PBG''\,dr -\Omega PG'PB\,dr
$$

$$
 = \Big((G':PB)I +\Omega PB(G'' - PG')P\Omega^T\Big)\,dx
$$

$$
H = \frac{\partial J}{\partial x}
 = (G':PB)I + \Omega PB(G''-PG')P\Omega^T
$$

$$
= \Big((p\odot b):g'\Big)\,I \;+\; 
\bigg(\frac{\partial r}{\partial x}\bigg)^T\Big(BG''-BPG'\Big)\bigg(\frac{\partial r}{\partial x}\bigg) 
$$

Pek öyle durmasa da bu formül (2) formülü ile ayný.

Akýlda tutalým $(R,G,B)$ matrisleri köþegen ve birbirleri ile sýrabaðýmsýz
iliþkileri var, ama $\,\Omega\,$ matrisi tam matris ve diðer matrislerle
sýrabaðýmsýz iliþkiye giremiyor.

Autograd ile Gradyan ve Hessian

Otomatik türev üzerinden de üstteki hesaplarý yapabiliriz. Daha önceki
kodlarda iki daðlý veriden örneklem alýp RBF yaratmýþtýk, bu obje
\verb!rbfi! içinde, oradan devam edersek,

\begin{minted}[fontsize=\footnotesize]{python}
import autograd.numpy as anp
import autograd

def dist_matrix(X, Y):
    X = X.reshape(1, X.shape[0])
    sx = anp.sum(X**2, 1)
    sy = anp.sum(Y**2, 1)
    D2 =  sx[:, anp.newaxis] - 2.0*anp.dot(X,Y.T) + sy[anp.newaxis, :] 
    D = anp.sqrt(D2)
    return D
    
nodes = rbfi.nodes.reshape(1,len(rbfi.nodes))
def gaussian(r,eps): return anp.exp(-(r/eps)**2)

def f_interp(newp):
    nodes = rbfi.nodes.reshape(1,len(rbfi.nodes))    
    newp_dist = dist_matrix(newp, rbfi.xi.T)
    return anp.dot(gaussian(newp_dist, rbfi.epsilon), nodes.T)

test_1 = anp.array([36.0,32.0])
test_1_dist = dist_matrix(test_1, rbfi.xi.T)
print ('f',f_interp(test_1))

grbf = autograd.grad(f_interp)
hrbf = autograd.hessian(f_interp)
print ('gradyan',grbf(test_1))
print ('hessian',hrbf(test_1))
\end{minted}

\begin{verbatim}
f [[-0.00387063]]
gradyan [0.02331737 0.08191414]
hessian [[[[0.6466522  0.74921925]
   [0.74921925 1.92847522]]]]
\end{verbatim}

Rasgele Noktalar Seçmek

Fonksiyonu RBF ile temsil etmek için gereken Rasgele noktalarý Hammersley
noktalarý adý verilen bir rasgele sayý üretme tekniði ile seçmek mümkün, bu
þekilde son derece çetrefil fonksiyonlar bile az sayýda örneklem noktalarý
üzerinden temsil edilebiliyor [5]. Mesela altta 10 tane bu tür noktayý 2
boyut için seçtik. Sayýlar 0 ile 1 arasýnda ama gereken aralýða
ölçeklenerek, toplanarak taþýnabilir.

\begin{minted}[fontsize=\footnotesize]{python}
import hammer
print (hammer.hammersley([2,3],10))
\end{minted}

\begin{verbatim}
[[0.     0.    ]
 [0.1    0.    ]
 [0.2    0.5   ]
 [0.3    0.25  ]
 [0.4    0.75  ]
 [0.5    0.125 ]
 [0.6    0.625 ]
 [0.7    0.375 ]
 [0.8    0.875 ]
 [0.9    0.0625]]
\end{verbatim}

Mesela

\begin{minted}[fontsize=\footnotesize]{python}
from mpl_toolkits.mplot3d import Axes3D

def peaks(x,y):
    z =  (3*(1-x)**2 * np.exp(-(x**2) - (y+1)**2) 
          - 10*(x/5 - x**3 - y**5) * np.exp(-x**2 - y**2)
          - 1/3 * np.exp(-(x+1)**2 - y**2)) 
    return(z)
 
n = 20
x = -3 + 6*hammer.hammersley([2,3],n)
z = peaks(x[:,0],x[:,1])
xx, yy = np.mgrid[-3:3:150j,-3:3:150j]
zz = peaks(xx,yy)
fig=plt.figure()
ax = fig.add_subplot(111,projection='3d')
ax.plot_surface(xx,yy,zz,rstride=1,cstride=1,color='c',alpha=0.3,linewidth=0)
ax.scatter(x[:,0],x[:,1],z,color='k',s=20)
plt.savefig('linear_app88rbf_07.png')
\end{minted}

\includegraphics[width=20em]{linear_app88rbf_07.png}

Görüldüðü gibi oldukca çetrefil bir fonksiyon bu, 

$$
f(x_1,x_2) = 3 (1 - x_1)^2 e^{-x_1^2-(-x_2^2 + 1)^2} - 
10 \bigg( \frac{x_1}{5} - x_1^3-x_2^5 \bigg) e^{-x_1^2 -x_2^2} - 
\frac{1}{3} e^{-(x_1 + 1)^2 - x_2^2}
$$

ama Hammersley tekniði ile kritik noktalarýndan örneklem
alýnabiliyor. [5]'te bu teknik ile üretilen yeni fonsiyonun gerçeðine çok
yakýn olacaðýný görüyoruz, 20 tane nokta ile!


Kaynaklar

[1] Neto, {\em Radial Basis Functions}, \url{http://www.di.fc.ul.pt/~jpn/r/rbf/rbf.html}

[2] Pouderoux, {\em Adaptive Hierarchical RBF Interpolation for Creating Smooth Digital Elevation Models}
    \url{https://hal.archives-ouvertes.fr/hal-00308008/document}    

[3] Math Stackexchange, {\em The Hessian of a Radial Basis Function}, 
    \url{https://math.stackexchange.com/questions/3417706/the-hessian-of-a-radial-basis-function}

[4] Mcdonald, {\em Global and local optimization using radial basis function response surface models}, 
    \url{https://www.sciencedirect.com/science/article/pii/S0307904X06002009}

[5] Kroese, {\em Data Science and Machine Learning: Mathematical and Statistical Methods}

\end{document}
