<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Coğrafi İstatistiki Hesaplar, Oranlar</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="coğrafi-istatistiki-hesaplar-oranlar">Coğrafi İstatistiki
Hesaplar, Oranlar</h1>
<h3 id="savaş-sırasında-londra">Savaş Sırasında Londra</h3>
<p>Daha önce istatistik testler konusunda gördük, bir dağılım
varlığlığını test için o dağılımın analitik yoğunluk fonksiyonunu
veriden gelen tahmin ediciler üzerinden tanımlayıp, veriyi bu fonksiyon
ile üretmeyi deneyebiliriz, ve bu sonuç ile veri arasında uyumluluğa
bakabiliriz.</p>
<p>Mesela olayların coğrafi olarak dağılımına bakalım.. Bu tür olayları
nasıl modelleriz? Olaylar depremler, yangınlar, ya da bir savaşta bir
alana atılan bombalar olabilir, ve bu tür sayılar Poisson dağılımı ile
modellenir. Bu dağılım ilk bölümde gördüğümüz gibi,</p>
<p><span class="math display">\[ f(x) = P(X=x) =
e^{-\lambda}\frac{\lambda^{x}}{x!} \]</span></p>
<p>olay sayısı <span class="math inline">\(x=1\)</span>, <span
class="math inline">\(x=2\)</span>, vs.. olacak şekilde, ki önceden
tanımlı belli bir zaman aralığında <span
class="math inline">\(x\)</span> tane olayın olma olasılığını bu
yoğunluk veriyor. Coğrafi olay sayılarını ölçmek için biraz farklı
düşünmek gerekiyor, mesela 2’inci Dünya Savaşı sırasında Almanların
Londra’ya attıkları bombaları düşünelim, analizi [2]’de var; Merak
edilen şuydu, acaba bombalar belli bir yerde kümeleniyor muydu
(clustering)? Cevap önemli olabilirdi, belki özel bir yer vurulmak
isteniyordu? Analizde olayların doğal oluş sayısını modelleyen Poisson
varlığı ispatlanırsa, kümelenme hipotezi reddedilmiş olacaktı.
İstatistikçi Clarke Londra’yı 536 tane ızgaraya böldü, ve her öğe içine
düşen bombaları saydı. Bu bittikten sonra 1 tane bomba, 2 tane bomba,
vs.. şeklinde olan hücrelerin sayısını aldı, ki yoğunluğa <span
class="math inline">\(x\)</span> ile geçilecek olan bu sayıydı.</p>
<p>Sonra Clarke yoğunluğu <span class="math inline">\(\lambda\)</span>
tahmin edici hücre sayısı bölü bomba sayısı üzerinden tanımladı, ve bu
yoğunluktan tüm sayılar için bir tahmini bomba sayısı ürettirdi,
sonuçları gerçek bomba sayıları ile karşılaştırdı.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="fl">576.</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>lam <span class="op">=</span> <span class="dv">537</span><span class="op">/</span>N</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> N<span class="op">*</span>np.exp(<span class="op">-</span>lam)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>probs <span class="op">=</span> [d<span class="op">*</span><span class="dv">1</span>, d<span class="op">*</span>lam, d<span class="op">*</span>lam<span class="op">**</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>, d<span class="op">*</span>(lam<span class="op">**</span><span class="dv">3</span>)<span class="op">/</span>(<span class="dv">3</span><span class="op">*</span><span class="dv">2</span>), d<span class="op">*</span>(lam<span class="op">**</span><span class="dv">4</span>)<span class="op">/</span>(<span class="dv">4</span><span class="op">*</span><span class="dv">3</span><span class="op">*</span><span class="dv">2</span>)]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(<span class="bu">map</span>(<span class="kw">lambda</span> x: <span class="bu">float</span>(np.<span class="bu">round</span>(x,<span class="dv">2</span>)), probs))</span></code></pre></div>
<pre class="text"><code>Out[1]: [226.74, 211.39, 98.54, 30.62, 7.14]</code></pre>
<p>Gerçek sayılar 229, 211, 93, 35, 7, .. idi, görüldüğü gibi oldukca
yakın sayılar. Bir adım daha atılıp bunun üzerinde bir istatistik testi
uygulanınca Poisson varlığı, ve dolaylı olarak kümelemenin olmadığı
ispatlanmış oldu.</p>
<h3 id="zaman-serileri-sayım-verisi">Zaman Serileri, Sayım Verisi</h3>
<p>Üstteki örnekte tek bir Poisson dağılımı modellendi. Peki ya zamana
yayılmış (sene bazında), ve bir A grubu ile bir diğer B grubunun sayım
verisini karşılaştırmak isteseydik? Problem şu şekilde ortaya
çıkabilir:</p>
<p>Ülke bazında spesifik bir olaya bağlı bir sayım verisine bakıyoruz,
bu veri sene bazında toplanıyor. Bir veri mesela yıllık “dört yol
kavşaklarında olan kaza sayısı” olabilir. Kavşaklar tabii ki ülkenin her
tarafında, hepsine bakıp her sene için orada olan kazaları topluyoruz.
Sonra diyelim ki bu kazaların normal (!) kazalardan daha yüksek / farklı
olup olmadığını merak ediyoruz, o zaman diğer bir ölçüm sene bazlı dört
yol kavşakları <em>dışındaki</em> kazalar olur.</p>
<p>O zaman elimizde iki zaman serisi olacak, her sene için iki tane
ölçüm. Her ölçüm rakamının, bir sayım olduğu için, Poisson dağılımından
geldiğini kabul edebiliriz. Fakat dikkat, her sene <em>aynı</em> Poisson
dağılımından mı geliyor? Büyük ihtimalle hayır çünkü kaza sayılarında
sene bazlı değişim olabilir: araç sayıları farklı olabilir, yol şartları
değişmiş olabilir. Karşılaştırma mekanizmasının bunu hesaba katması
gerekir.</p>
<p>Bir diğer problem ölçekleme (scaling) problemi olabilir, kavşaklar
yolların ufak bir alanını temsil eder, kıyasla yolların tamamı fiziksel
olarak daha fazla yer kaplar bu sebeple kavşak olmayan yol bölümünde
olan kazaların sayıca daha fazla olması muhtemeldir. Bu fazlalık
karşılaştırmayı yanıltabilir, elmalar ve armutları karşılaştırmış
oluruz. Eğer elmalar ile elmaları karşılaştırmak istiyorsak kavşak
dışındaki sayımları ölçekleyip diğer ölçüme skalasına yaklaştırmamız
gerekir. Bu çok zor olmasa gerek, basit bir toplam ve bölme işlemi ile
bunu başarabiliriz.</p>
<p>Şimdi üzerinde karşılaştırma yapmak için sentetik veri üretelim. İlk
veri birbirine yakın iki zaman serisi gösteriyor.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pymc <span class="im">as</span> pm</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> arviz <span class="im">as</span> az</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> data</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> np.arange(<span class="dv">1950</span>, <span class="dv">2011</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>sim <span class="op">=</span> data.generate_synthetic(years<span class="op">=</span>years,</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>                              alpha_log<span class="op">=</span><span class="fl">3.2</span>,</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>                              beta_log<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>                              sigma_year<span class="op">=</span><span class="fl">0.4</span>,</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>                              obs_model<span class="op">=</span><span class="st">&quot;poisson&quot;</span>,</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>                              trend<span class="op">=</span>data.slow_trend)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame({</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;year&quot;</span>: sim[<span class="st">&quot;years&quot;</span>],</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;A&quot;</span>: sim[<span class="st">&quot;A&quot;</span>],</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;B&quot;</span>: sim[<span class="st">&quot;B&quot;</span>]</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>SEED <span class="op">=</span> <span class="dv">333</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>np.random.seed(SEED)</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="co"># quick plot of generated counts</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">4</span>))</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>plt.plot(df.year, df.A, label<span class="op">=</span><span class="st">&quot;kavsak&quot;</span>, marker<span class="op">=</span><span class="st">&quot;o&quot;</span>)</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>plt.plot(df.year, df.B, label<span class="op">=</span><span class="st">&quot;diger&quot;</span>, marker<span class="op">=</span><span class="st">&quot;x&quot;</span>)</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&quot;Sene&quot;</span>)<span class="op">;</span> plt.ylabel(<span class="st">&quot;Sayim&quot;</span>)</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&quot;Sentetik sayim (Poisson)&quot;</span>)</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;stat_082_rapoi_01.jpg&#39;</span>)</span></code></pre></div>
<p><img src="stat_082_rapoi_01.jpg" /></p>
<p>Verinin modeli ne olacak? Her sene farklı bir Poisson dağılımı olsun
demiştik, ama bu dağılımların birbirine bazı yönlerden benzerlikleri de
olmalı. Bir Poisson GLM (genel lineer model -generalized linear model-)
yaratabiliriz, her iki zaman serisindeki her sene ölçümü farklı bir
<span class="math inline">\(\lambda\)</span> ile üretiliyor olabilir,
parametrelerde kavşak için A diğeri için B dersek,</p>
<p><span class="math display">\[
\lambda_{A,t} = e^{\alpha + \beta + u_t}
\]</span></p>
<p><span class="math display">\[
\lambda_{B,t} = e^{\alpha + u_t}
\]</span></p>
<p>Üstteki parametreleri kullanarak <span
class="math inline">\(y\)</span> verisinin şu şekilde üretildiğini farz
edebiliriz,</p>
<p><span class="math display">\[
y_{A,t} \sim Poisson(\lambda_{A,t})
\]</span></p>
<p><span class="math display">\[
y_{B,t} \sim Poisson(\lambda_{B,t})
\]</span></p>
<p>Denklemlerde <span class="math inline">\(\beta\)</span> dolaylı
olarak <span class="math inline">\(\lambda\)</span> oranlarını
hesaplayacak, dikkat edelim bir formülde var, diğerinde yok. Bunun
sebebini birazdan göreceğiz. Peki niye üstel <span
class="math inline">\(e\)</span> kullanımı var? Eğer <span
class="math inline">\(\log\)</span> alsaydık mesela ilk denklem için</p>
<p><span class="math display">\[
\log(\lambda_{A,t}) = \alpha + \beta + u_t
\]</span></p>
<p>elde ediyoruz, bu standart lineer regresyondan tanıdık bir format.
Log bağlantının sebebi (ya da dolaylı <span
class="math inline">\(e\)</span> kullanımı)</p>
<p><span class="math display">\[
\lambda_{A,t} = e^{\alpha} \cdot e^{\beta} \cdot e^{u_t}
\]</span></p>
<p>yapısına izin vermek / onu aktıve etmek. Böylece <span
class="math inline">\(\lambda\)</span>’nin pozitif olmasını sağlıyoruz
(çünkü Poisson oran <span class="math inline">\(\lambda\)</span> pozitif
olmalıdır), ayrıca oran hesapları çarpımsal parametreler içerdiği için
bu varsayımı modele dahil etmiş oluyoruz. Tıpta bir ilaç uygulaması
hastalık oranını katlayarak etkiler, hava kirliliği astim hastalığı
oranını katlayarak arttırır, vb. Bu tür faraziyeler üstel hesap
üzerinden formülasyona dahil edilmiş oldu.</p>
<p>Peki aradığımız oran <span class="math inline">\(\beta\)</span> nasıl
hesaplanacak? Bu hesap aslında <em>dolaylı</em> bir hesap. Biraz cebir
ile <span class="math inline">\(\beta\)</span>’nin neye eşit olduğunu
görünce bunu anlayacağız, <span class="math inline">\(\beta\)</span>’i
bir eşitliğin sağında olacak şekilde bildiğimiz denklemleri
düzenlersek,</p>
<p><span class="math display">\[
\lambda_{A,t} - \lambda_{B,t} = \alpha + \beta + u_t - (\alpha + u_t)
\]</span></p>
<p><span class="math display">\[
= \alpha + \beta + u_t - \alpha - u_t = \beta
\]</span></p>
<p>Yani,</p>
<p><span class="math display">\[
\lambda_{A,t} - \lambda_{B,t} = \beta
\]</span></p>
<p>Eğer iki tarafın üstelini alırsak</p>
<p><span class="math display">\[
\frac{e^{A,t}}{e^{B,t}} = e^{\beta}
\]</span></p>
<p>Yani <span class="math inline">\(\beta\)</span> parametresi otomatik
olarak A ve B farklı iki Poisson <span
class="math inline">\(\lambda\)</span> parametrelerinin oranını
hesaplıyor! Dikkat bu hesabın yapılabilmesi için GLM’in spesifik bir
oran hesabı yapması gerekli değil. Tek gereken GLM Poisson için gereken
temel veri GLM regresyonuna, ya da Bayes MCMC hesabına verilirken, tüm
verinin, yani A ve B birleşmiş olarak şu şekilde sunulması,</p>
<p><span class="math display">\[
\log(\lambda_{A,t}) = \alpha + \beta \cdot g_t + u_t
\]</span></p>
<p>Tabii üsttekinin hemen ardından <span
class="math inline">\(\lambda\)</span> kullanılarak bir Poisson üretimi
yapıldığını düşünüyoruz, geri yönde ise eldeki veri üzerinden MCMC ile
sonsal -posterior- elde edip o dağılımdan örneklem alıyoruz, bunlar
standart yaklaşımlar.</p>
<p>Konuya dönersek <span class="math inline">\(\beta \cdot g_t\)</span>
ifadesindeki <span class="math inline">\(g_t\)</span>’ye dikkat, bu
parametre A grup verisi için 1, B grup verisi için 0 diyecek. Yani bu
formülasyonun doğal sonucu olarak elde ettiğimiz <span
class="math inline">\(\beta\)</span> iki <span
class="math inline">\(\lambda\)</span> parametresinin oranı haline
gelecek. Her veri noktası <span class="math inline">\(\beta\)</span>’yi
kendi tarafına doğru çekmeye uğraşacak, bu al-ver itme-çekme arasında
<span class="math inline">\(\beta\)</span>’nin varacağı yer onun tüm
zaman dilimleri için geçerli bir orana ulaşmasıdır.</p>
<p>Senesel farklar, eğer var ise, her sene için farklı olmasına izin
verdiğimiz <span class="math inline">\(u_t\)</span> ile olabilir, bu
parametre ile o farklılığı “yakalayabiliyoruz”.</p>
<p>Verinin nasıl oluşturulduğunu görelim,</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_stacked_arrays(simdict):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    years <span class="op">=</span> np.array(simdict[<span class="st">&quot;years&quot;</span>])</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> np.array(simdict[<span class="st">&quot;A&quot;</span>])</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    B  <span class="op">=</span> np.array(simdict[<span class="st">&quot;B&quot;</span>])</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    n_years <span class="op">=</span> <span class="bu">len</span>(years)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    counts <span class="op">=</span> np.concatenate([A, B])</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    group <span class="op">=</span> np.concatenate([np.ones(n_years, dtype<span class="op">=</span><span class="bu">int</span>), np.zeros(n_years, dtype<span class="op">=</span><span class="bu">int</span>)])</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    year_idx <span class="op">=</span> np.concatenate([np.arange(n_years), np.arange(n_years)])</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> years, counts, group, year_idx, A, B</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>years, counts_pois, group_pois, year_idx_pois, A_arr, B_arr <span class="op">=</span> build_stacked_arrays(sim)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="bu">len</span>(A_arr), A_arr[:<span class="dv">5</span>], <span class="st">&#39;..&#39;</span>)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="bu">len</span>(B_arr), B_arr[:<span class="dv">5</span>], <span class="st">&#39;..&#39;</span>)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="bu">len</span>(counts_pois), counts_pois)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;A mi B mi?&#39;</span>)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (group_pois)</span></code></pre></div>
<pre class="text"><code>61 [14 24 38 15 13] ..
61 [10 24 26 13 12] ..
122 [14 24 38 15 13 47  7 17 28 13 14 22 43 19 26 18 53 46 30 25 33 44 14 37
 15 26 22 12 24 15 21  8 10 23 51 19 22 24 16 23 14 16 20 34 34 21 67 26
 44 57 20 16 54 18 26 49 35 51 50 25 18 10 24 26 13 12 39 10 22 41 15 15
 24 33 18 18 17 64 57 35 22 32 44 15 31  8 14 35 14 27 22 26 10 13 17 41
 27 31 42 11 27 19 12 31 27 28 25 69 36 30 69 20 17 52 15 33 53 38 51 44
 37 27]
A mi B mi?
[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0 0]</code></pre>
<p>Şimdi oranın sonsal dağılımını PyMC ile ortaya çıkartalım ve ondan
örneklem alalım.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fit_poisson_ratio(years, A_arr, B_arr, fout):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    n_years <span class="op">=</span> <span class="bu">len</span>(years)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> pm.Model() <span class="im">as</span> model_synth:</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        sigma_year <span class="op">=</span> pm.HalfNormal(<span class="st">&quot;sigma_year&quot;</span>, sigma<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        year_offset <span class="op">=</span> pm.Normal(<span class="st">&quot;year_offset&quot;</span>, <span class="fl">0.0</span>, <span class="fl">1.0</span>, shape<span class="op">=</span>n_years)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        year_effect <span class="op">=</span> pm.Deterministic(<span class="st">&quot;year_effect&quot;</span>, year_offset <span class="op">*</span> sigma_year)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        alpha <span class="op">=</span> pm.Normal(<span class="st">&quot;alpha&quot;</span>, <span class="fl">0.0</span>, <span class="fl">2.0</span>)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        beta  <span class="op">=</span> pm.Normal(<span class="st">&quot;beta&quot;</span>, <span class="fl">0.0</span>, <span class="fl">1.0</span>)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        log_lambda <span class="op">=</span> alpha <span class="op">+</span> beta <span class="op">*</span> group_pois <span class="op">+</span> year_effect[year_idx_pois]</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        lambda_ <span class="op">=</span> pm.math.exp(log_lambda)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        obs <span class="op">=</span> pm.Poisson(<span class="st">&quot;obs&quot;</span>, mu<span class="op">=</span>lambda_, observed<span class="op">=</span>counts_pois)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        rate_ratio <span class="op">=</span> pm.Deterministic(<span class="st">&quot;rate_ratio&quot;</span>, pm.math.exp(beta))</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>        idata <span class="op">=</span> pm.sample(<span class="dv">1000</span>, tune<span class="op">=</span><span class="dv">1000</span>, target_accept<span class="op">=</span><span class="fl">0.9</span>, return_inferencedata<span class="op">=</span><span class="va">True</span>, random_seed<span class="op">=</span>SEED)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        graphviz <span class="op">=</span> pm.model_to_graphviz(model_synth)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        graphviz.graph_attr.update(dpi<span class="op">=</span><span class="st">&quot;100&quot;</span>)</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>        graphviz.render(fout, <span class="bu">format</span><span class="op">=</span><span class="st">&quot;jpg&quot;</span>)</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(az.summary(idata, var_names<span class="op">=</span>[<span class="st">&quot;alpha&quot;</span>, <span class="st">&quot;beta&quot;</span>, <span class="st">&quot;sigma_year&quot;</span>, <span class="st">&quot;rate_ratio&quot;</span>], round_to<span class="op">=</span><span class="dv">3</span>))</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        rr_samples <span class="op">=</span> idata.posterior[<span class="st">&quot;rate_ratio&quot;</span>].values.flatten()</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>        p_gt_1 <span class="op">=</span> (rr_samples <span class="op">&gt;</span> <span class="fl">1.0</span>).mean()</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;</span><span class="ch">\n</span><span class="ss">P(rate_ratio &gt; 1) = </span><span class="sc">{</span>p_gt_1<span class="sc">:.3f}</span><span class="ss">&quot;</span>)    </span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> idata</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>idata <span class="op">=</span> fit_poisson_ratio(years, A_arr, B_arr, <span class="st">&quot;stat_082_rapoi_03&quot;</span>)</span></code></pre></div>
<pre class="text"><code>                                                                                
                              Step      Grad      Sampli…                       
  Progre…   Draws   Diverg…   size      evals     Speed     Elapsed   Remaini…  

     2000    0         0.229     15        639.58    0:00:03   0:00:00   
                                           draws/s                       
     2000    0         0.306     15        676.39    0:00:02   0:00:00   
                                           draws/s                       
     2000    0         0.217     15        625.81    0:00:03   0:00:00   
                                           draws/s                       
     2000    0         0.278     15        660.10    0:00:03   0:00:00   
                                                  draws/s                       
                                                                                
             mean     sd  hdi_3%  hdi_97%  ...  mcse_sd  ess_bulk  ess_tail  r_hat
alpha       3.234  0.068   3.107    3.366  ...    0.002   480.667   818.932  1.012
beta       -0.040  0.035  -0.107    0.023  ...    0.001  6166.596  2749.392  1.000
sigma_year  0.489  0.050   0.397    0.582  ...    0.001   615.175  1211.197  1.011
rate_ratio  0.961  0.033   0.899    1.024  ...    0.001  6166.596  2749.392  1.000

[4 rows x 9 columns]

P(rate_ratio &gt; 1) = 0.121</code></pre>
<p><img src="stat_082_rapoi_03.jpg" /></p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>rr_samples <span class="op">=</span> idata.posterior[<span class="st">&quot;rate_ratio&quot;</span>].values.flatten()</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>,<span class="dv">3</span>))</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>az.plot_posterior(rr_samples, hdi_prob<span class="op">=</span><span class="fl">0.95</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&quot;Hesaplanan oran (Poisson)&quot;</span>)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;stat_082_rapoi_02.jpg&#39;</span>)</span></code></pre></div>
<p><img src="stat_082_rapoi_02.jpg" /></p>
<p>Görüyoruz ki oranın dağılımı 1 etrafında kümelenmiş, o zaman iki
sayım zaman serisinin birbirine yakın olduğuna karar verebiliriz çünkü
oranları 1’e yakın.</p>
<p>Şimdi yakın olmayan iki zaman serisi yaratalım,</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> np.arange(<span class="dv">1980</span>, <span class="dv">2020</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="bu">len</span>(years)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>u_t <span class="op">=</span> np.random.normal(<span class="dv">0</span>, <span class="fl">0.4</span>, size<span class="op">=</span>T)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>alpha <span class="op">=</span> <span class="fl">3.0</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>beta_true <span class="op">=</span> np.log(<span class="fl">1.3</span>)   <span class="co"># 30% higher A rate</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>mu_B <span class="op">=</span> np.exp(alpha <span class="op">+</span> u_t)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>mu_A <span class="op">=</span> np.exp(alpha <span class="op">+</span> beta_true <span class="op">+</span> u_t)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> np.random.poisson(mu_B)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.random.poisson(mu_A)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>sim <span class="op">=</span> {<span class="st">&quot;years&quot;</span>: years, <span class="st">&quot;A&quot;</span>: A, <span class="st">&quot;B&quot;</span>: B}</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>years, counts_pois, group_pois, year_idx_pois, A_arr, B_arr <span class="op">=</span> build_stacked_arrays(sim)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>idata <span class="op">=</span> fit_poisson_ratio(years, A_arr, B_arr, <span class="st">&quot;stat_082_rapoi_03&quot;</span>)</span></code></pre></div>
<pre class="text"><code>                                                                                
                              Step      Grad      Sampli…                       
  Progre…   Draws   Diverg…   size      evals     Speed     Elapsed   Remaini…  

     2000    0         0.346     7         693.28    0:00:02   0:00:00   
                                           draws/s                       
     2000    0         0.305     15        707.15    0:00:02   0:00:00   
                                           draws/s                       
     2000    0         0.314     15        658.19    0:00:03   0:00:00   
                                           draws/s                       
     2000    0         0.278     15        651.81    0:00:03   0:00:00   
                                                  draws/s                       
                                                                                
             mean     sd  hdi_3%  hdi_97%  ...  mcse_sd  ess_bulk  ess_tail  r_hat
alpha       2.879  0.073   2.736    3.011  ...    0.001  1030.075  1813.990  1.002
beta        0.317  0.047   0.229    0.408  ...    0.001  8153.224  2749.679  1.000
sigma_year  0.379  0.053   0.277    0.474  ...    0.001  1173.341  1764.667  1.003
rate_ratio  1.375  0.065   1.258    1.503  ...    0.001  8153.224  2749.679  1.000

[4 rows x 9 columns]

P(rate_ratio &gt; 1) = 1.000</code></pre>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>rr_samples <span class="op">=</span> idata.posterior[<span class="st">&quot;rate_ratio&quot;</span>].values.flatten()</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>,<span class="dv">3</span>))</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>az.plot_posterior(rr_samples, hdi_prob<span class="op">=</span><span class="fl">0.95</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&quot;Hesaplanan oran (Poisson)&quot;</span>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;stat_082_rapoi_04.jpg&#39;</span>)</span></code></pre></div>
<p><img src="stat_082_rapoi_04.jpg" /></p>
<p>Bu zaman serileri birbirine yakın değiller. Sonsal dağılımın
kümelendiği yer 1’den çok uzakta.</p>
<p>Kaynaklar</p>
<p>[1] Bayramli, Istatistik, <em>Sayım, Poisson ve Negatif Binom Bazlı
Genel Lineer Modelleri (GLM)</em></p>
<p>[2] Clarke, <em>An application of the Poisson distribution</em>, <a
href="https://www.actuaries.org.uk/system/files/documents/pdf/0481.pdf">https://www.actuaries.org.uk/system/files/documents/pdf/0481.pdf</a></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
