\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Geometrik Anahtarlama ile En Yakın Noktaları Bulmak

Grafik, fiziksel simülasyonlarda pek çok sayıda obje 3 boyutlu ortamda dünyaya
salınıp, ayrı ayrı onlara fiziksel kurallar uygulanır ve nereye geldiklerine
bakılır. Bu hesap sırasında objelerin birbirine çarpıp çarpmadığını hesaplamak
gerekir fakat böyle bir hesap, eğer mesela $n$ tane obje var ise, her görüntü
karesinde her $n$ tane objenin her $n-1$ diğer objenin yakınında olup olmadığı
kontrolü anlamına gelir, ki hesapsal yük $O(n^2)$ olurdu. Eğer $n$ milyonlar ise
bu ağır bir yük oluştururdu.

Böleç tekniğini burada da kullanabiliriz. Öyle bir sihirli böleç fonksiyonumuz
olsun ki her kordinat için bir böleç değeri üretsin ve birbirine yakın
kordinatlar için bu değer aynı olsun. Böylece basit eşitlik kontrolü ile iki
kordinatın birbirine yakın olup olmadığını hemen anlayabilirdik. Tabii daha
detaylı kontrol için böleçleri aynı olan kordinatları daha detaylı teste tabi
tutardık, ama detaylı kontrolün yapılacağı obje sayısını çok daha azaltmış
olurduk.

Yerelliğe Hassas Böleç (Locality Sensitive Hashing, -LSH-)

Bu alandaki tekniklerden biri LSH tekniği. LSH ile çok boyutlu bir kordinate
sistemindeki noktaların yaklaşık olarak birbirine yakın olup olmadığını böleç
üzerinden hesaplayabiliyoruz. En yaygın LSH yaklaşımının temeli rasgele
izdüşümdür (random projection). [3]'te anlatıldığı gibi rasgele izdüşümün ilginç
bir özelliği mesafeleri koruması, yani orijinal kordinate sistemindeki noktalar
birbirine uzaksa yansıtıldıktan sonra da uzak kalmaya meyilliler.

Bunu herhangi bir (yani rasgele) 2 boyutlu düzlem üzerinde yansıtılan alttaki
noktalarda görebiliriz. Uzak olan noktalar duzlem uzerinde hala birbirine uzak.

\includegraphics[width=10em]{algs_073_hash_01.png}

Tabii ki her (rasgele) düzlem her iki orijinal nokta arasındaki uzaklığı
mükemmel olarak göstermeyebilir. Fakat, eğer birkaç tane farklı düzleme yapılan
yansımların bir birleşiminden bir ölçüt / böleç yaratabilirsek, o zaman bu ölçüt
ile bazı hızlı sonuçlara varabiliriz.

Alttaki yaklaşımda 2 boyuta yansıtma yapılacak. Bu yansıtma yeni reel sayısal
değerler ortaya çıkartır, bölec için bize ayrıksal ``kutular'' lazım, bu
kutuları alttaki yöntem 0'dan büyük olma ya da olmama üzerinden tanımlamış.

\includegraphics[width=20em]{algs_073_hash_02.png}

Yani 2. boyuta indirgedikten sonra her eksen üzerinde üstteki irdeleme
yapılıyor, nokta sıfırdan büyük mü küçük mü? Bu evet / hayır sonuçlar yanyana
koyuluyor, ve 10, 01, vs şeklinde bitlerden oluşan bir sayı ortaya çıkıyor. Bu
sayıyı onluğa çevirip artık direk karşılaştırma için kullanabiliriz.

Altta üç tane örnek vektör görüyoruz. Bu vektörler bir şarkının ses
seviyelerini, bir müşterinin yer, alışveriş, gezinti bilgilerini temsil ediyor
olabilir. Acaba bu vektörler birbirine ne kadar yakın? Rasgele bir matris
\verb!projections! içinde (rasgele izdüşüm için her ögesi $N(0,1)$ dağılımından
gelen bir matris üretmek yeterlidir, altta bunu kütüphane çağrısı ile yapmadık,
[2] ile sonuçlar uysun diye direk oradan aldık),

\begin{minted}[fontsize=\footnotesize]{python}
vec1 = np.array([[-0.99137472, 0.61572851, -0.37733555, 0.0363575, -0.71647706]])
vec2 = np.array([[-0.16737788, 0.83147812, -2.06947369, -0.48174425, -1.60276846]])
vec3 = np.array([[-0.9074722, 0.75953396, 1.10696926, -0.8773451, -1.11589595]])

projections = np.array([[0.58834302, 0.24020825, 2.21323827, -0.21147486, 1.18477223],\
                        [-0.31146359, -1.88214137, -0.37489443, -0.58475914, -1.57121651]])
print (projections)
\end{minted}

\begin{verbatim}
[[ 0.58834302  0.24020825  2.21323827 -0.21147486  1.18477223]
 [-0.31146359 -1.88214137 -0.37489443 -0.58475914 -1.57121651]]
\end{verbatim}

Birinci vektörü rasgele düzleme yansıtıyoruz,

\begin{minted}[fontsize=\footnotesize]{python}
print (vec1.shape)
print (np.dot(vec1, projections.T))
\end{minted}

\begin{verbatim}
(1, 5)
[[-2.12704963  0.39583023]]
\end{verbatim}

Her ögeyi sıfırdan büyük olma / olmama filtresinden geçiriyoruz,

\begin{minted}[fontsize=\footnotesize]{python}
print (np.dot(vec1, projections.T) > 0)
print (  ''.join(((np.dot(vec1, projections.T) > 0)[0]).astype(int).astype(str))  )
\end{minted}

\begin{verbatim}
[[False  True]]
01
\end{verbatim}

Diğer vektörler için de aynı işlem,

\begin{minted}[fontsize=\footnotesize]{python}
print (  ''.join(((np.dot(vec2, projections.T) > 0)[0]).astype(int).astype(str))  )
print (  ''.join(((np.dot(vec3, projections.T) > 0)[0]).astype(int).astype(str))  )
\end{minted}

\begin{verbatim}
01
11
\end{verbatim}

Üstteki sonuçlara bakarak \verb!vec1! ve \verb!vec2!'nin birbirine \verb!vec2! ve
\verb!vec3!'ün birbirine olduğundan daha yakın olacağını kestirebiliriz. Kosinüs
yakınlık hesabını bu vektörler üzerinde uygulayınca bunun doğrulandığını görüyoruz,

\begin{minted}[fontsize=\footnotesize]{python}
def cosine_sim(vec1, vec2):
   return np.dot(vec1, vec2) / (np.linalg.norm(vec1)*np.linalg.norm(vec2))

print (cosine_sim(vec1[0], vec2[0]))   
print (cosine_sim(vec1[0], vec3[0]))   
print (cosine_sim(vec2[0], vec3[0]))   
\end{minted}

\begin{verbatim}
0.6524342023889728
0.5610062492540248
0.1169500241078299
\end{verbatim}

Tekniğin sezgisel temeli eğer iki nokta tamamen birbirine yakın ise, yani
orijine olan konumları mükemmel korelasyon halinde, o zaman bu teknikle aynı
kutuya düşme olasılıkları artıyor. İşin içinde rasgelelik olduğu için ve bir
noktayı pek çok farklı düzlemlere yansıttığımız için aynı kutuya düşme ihtimali
oldukca azalıyor, sadece hakikaten yakın olan noktalar aynı kutuya
düşüyorlar. Eğer o noktada hatalar ortaya çıkarsa, yaygın bir yaklaşım birden
yansıtma seçeneklerini gruplar altında toplamak ve en az bir grup aynı kutuya
düşmeyi bulmuşsa, o iki noktayı yakın olarak kabul etmek.

Notlar

0'dan küçük ya da büyük irdelemesi bir kutulama yaratıyor, iki tane kutu
sadece. İlla iki kutu olması şart değil, \verb!numpy.digitize! ile istediğimiz
büyüklükte kutu yaratabilirdik.

Bir diğer konu bölecin yakın olan bazı noktalar için mükemmel olmayacağı. Bu
durumda ikinci bir yansıtma matrisi üzerinden ikinci, hatta üçüncü bir bölecleme
kodu yaratabiliriz, eğer bölec değerleri hem 1'inci hem 2'inci hem de 3'uncu,
vs. böleclerde aynı değerde ise iki noktayı yakın kabul etmek. Bu yöntem
yakınlık kontrolüne ek olarak yakın diğer noktaların listesini almak için de
faydalı, bir sözlük içinde her bölec değeri için bir nokta listesi tutulur, eğer
birden fazla yansıtma yapılmışsa, bu sözlüklerde iki, üç tane olabilir. Bir
noktanın komşularını almak istersek her sözlükte bu kordinatın bölec değerine
bakarız, ve alınan komşuları bir özgünlük filtresinden geçirerek nihai sonucu
donduruz. Bu yaklaşım parçacık simülasyonları ile uğraşanlar için faydalı
olabilir.

Test

Altta üç tane farklı rasgele izdüşüm üzerinden bölecleyen bir kod görüyoruz. Bir
3 boyutlu kordinat sisteminde rasgele yerlerde toplar yarattık, bunların
bazıları birbirine yakın, bazılar değil, kodda LSH ile geometrik yakınlığı
gerçek yakınlık ile ne kadar benzediğini kontrol ediyoruz. LSH bölec kontrol üç
sözlükte kontrol ediliyor.

Tekrarlamak gerekirse, B tane topu rasgele bir şekilde her ekseni 0 ve 200
arasında olan bir uzaya dağıttık. Topların bazıları yakın düştü tabii, bazılar
düşmedi. Önce tüm topları böleçledik ve sözlüğe koyduk. Sonra tüm topların
birbiri ile olan mesafesini ayrı ayrı teker teker külfetli yoldan yaptık, ve
bölecin bu durum hakkında ne söylediğine baktık. Pozitif böleç(ler) yakın diyor,
negatif böleç uzak diyor anlamında, tabii yakınlık ve uzaklık böleç anahtar
değerinin aynı olup olmadığı ile ölçülüyor.

Kontrolün doğru pozitif bulması mesela bölecin yakın dediğinin gerçekten de
yakın olması. Yanlış negatif tam tersi, bölec uzak diyor ama aslında toplar
yakın.

\begin{minted}[fontsize=\footnotesize]{python}
from collections import defaultdict 
import numpy as np, datetime
import numpy.linalg as lin

np.random.seed(0)

mmin,mmax=0,200
B = 400; L = (mmax / 10);
balls = []
geo_hash_list = defaultdict(list)
    
for b in range(B):
    p = np.array([np.random.uniform(mmin,mmax,1)[0],
                  np.random.uniform(mmin,mmax,1)[0],
                  np.random.uniform(mmin,mmax,1)[0] ])
    balls.append({'pos':p, 'i': b})

k = 9; bnum = 7
bins = np.linspace(-500.0,500.0,bnum)

P1 = np.random.normal(0,1,3*k).reshape(3,k)
def spatial_hash1(x):
    X1 = np.dot(x,P1)
    h1 = np.digitize(X1, bins)
    return int("".join([str(x) for x in h1[0]]))

P2 = np.random.normal(0,1,3*k).reshape(3,k)
def spatial_hash2(x):
    X2 = np.dot(x,P2)
    h2 = np.digitize(X2, bins)
    return int("".join([str(x) for x in h2[0]]))

P3 = np.random.normal(0,1,3*k).reshape(3,k)
def spatial_hash3(x):
    X3 = np.dot(x,P3)
    h3 = np.digitize(X3, bins)
    return int("".join([str(x) for x in h3[0]]))

tp = 0; tn = 0; fp = 0; fn = 0

for i,b1 in enumerate(balls):
    for j,b2 in enumerate(balls):
        if i==j: continue
        d = lin.norm(b1['pos']-b2['pos'])
        h11 = spatial_hash1([b1['pos']])
        h12 = spatial_hash1([b2['pos']])
        h21 = spatial_hash2([b1['pos']])
        h22 = spatial_hash2([b2['pos']])
        h31 = spatial_hash3([b1['pos']])
        h32 = spatial_hash3([b2['pos']])
        if d <= L and (h11==h12 or h21==h22 or h31==h32): tp += 1        
        elif d > L and not (h11==h12 or h21==h22 or h31==h32): tn+=1
        elif d <= L and not (h11==h12 or h21==h22 or h31==h32): fn+=1
        elif d > L and (h11==h12 or h21==h22 or h31==h32): fp+=1

print ('dogru pozitif', tp)
print ('dogru negatif', tn)

print ('yanlis pozitif', fp)
print ('yanlis negatif', fn)

print (tp+tn+fp+fn)
print ("Yanlis Negatif Yuzde %0.2f" % (fn / (tp+tn+fp+fn) * 100.0))
print ("Yanlis Pozitif Yuzde %0.2f" % (fp / (tp+tn+fp+fn) * 100.0))
print ("Yanlis Negatif / Dogru Pozitif %0.2f" % (fn / tp * 100.0))
\end{minted}

\begin{verbatim}
dogru pozitif 564
dogru negatif 151336
yanlis pozitif 7656
yanlis negatif 44
159600
Yanlis Negatif Yuzde 0.03
Yanlis Pozitif Yuzde 4.80
Yanlis Negatif / Dogru Pozitif 7.80
\end{verbatim}

Tabii ki istediğimiz doğru olan değerlerin yüksek olması. Ama yanlış pozitifin
hala çaresi var, bölecin yakın dediklerini bir kontrolden daha geçirirsek bu
kontrol yanlış pozitifleri eleyecektir, tabii gene de yanlış pozitiflerin de
toplama kıyasla az olmasını isteriz. Tek problem yanlış negatif, topların çoğu
birbirinden uzakta olduğu için bu yanlıştan dönmek zor, fakat bu tür topların
oldukça az olduğunu görüyoruz.

Asal Sayılar ile Böleç (Hash) Tekniği

Bir diğer böleç bazlı teknik [1]'den. Teknik ile kordinat sistemini $l$
büyüklüğünde kutulara bölüyor, her eksen değerini bu büyüklük ile bölüyoruz,
bölüm sonrası elde edilen sayıyı taban (floor) tamsayıya indirgiyoruz, ardından
her eksen için farklı bir asal sayıyla çarpıp sonuçları XOR ile birleştiriyoruz
(ki XOR yaygın kullanılan bir böleç birleştirme yaklaşımı).

\begin{minted}[fontsize=\footnotesize]{python}
l = 5
n = 5
p1,p2,p3 = 73856093, 19349663, 83492791

x1 = [33,4,11]
x2 = [31,1,14]
x3 = [10,44,19]

def spatial_hash(x):
    ix,iy,iz = np.floor(x[0]/l), np.floor(x[1]/l), np.floor(x[2]/l)
    return (int(ix*p1) ^ int(iy*p2) ^ int(iz*p3)) % n

print (spatial_hash(x1))
print (spatial_hash(x2))
print (spatial_hash(x3))
\end{minted}

\begin{verbatim}
1
1
3
\end{verbatim}

Görüldüğü gibi ilk iki kordinat aynı böleç anahtarına düştü, ki bu iki kordinat
birbirine yakın.

Genel algoritma şöyle olabilir. Her görüntü karesi için iki faz düşünebiliriz,
ilk fazda tüm objelerin kordinat böleçi hesaplanır, her böleç değeri altında bir
liste vardır, ve her obje anahtarının değerine tekabül eden o listeye
eklenir. İkinci fazda bir objeye bakarken onun üzerinde daha detaylı çarpışma
hesabı gerekip gerekmediğini anlamak için böleç anahtarındaki listeye bakarız,
listede sadece bir öğe var ise çarpışma yok, birden fazla ise o listedeki her
diğer obje için detaylı çarpışma hesabına devam edilebilir.

Bazı istatistikleri toplayalım. Acaba yaklaşım ne kadar başarılı?

\begin{minted}[fontsize=\footnotesize]{python}
from collections import defaultdict 
import numpy as np, datetime
import numpy.linalg as lin

mmin,mmax=0,400
p1,p2,p3 = 73856093, 19349663, 83492791
B = 500; L = 50; n = int(B/3)

def spatial_hash(x):
    ix,iy,iz = int(x[0]/L), int(x[1]/L), int(x[2]/L)
    tmp = (ix*p1) ^ (iy*p2) ^ (iz*p3)
    return tmp % n
    
balls = []
geo_hash_list = defaultdict(list)

for b in range(B):
    p = np.array([np.random.uniform(mmin,mmax,1)[0],
                  np.random.uniform(mmin,mmax,1)[0],
                  np.random.uniform(mmin,mmax,1)[0] ])
    balls.append({'pos':p, 'i': b})

for j,b in enumerate(balls):
    geo_hash_list[spatial_hash(b['pos'])].append(b)

tp = 0; tn = 0; fp = 0; fn = 0
for i,b1 in enumerate(balls):
    for j,b2 in enumerate(balls):
        if i==j: continue
        d = lin.norm(b1['pos']-b2['pos'])
        h1 = spatial_hash(b1['pos'])
        h2 = spatial_hash(b2['pos'])
        
        if d <= L and h1 == h2: tp += 1        
        elif d > L and h1 != h2: tn+=1
        elif d > L and h1 == h2: fp+=1
        elif d <= L and h1 != h2: fn+=1

print ('dogru pozitif', tp)
print ('dogru negatif', tn)

print ('yanlis pozitif', fp)
print ('yanlis negatif', fn)

print (tp+tn+fp+fn)
print ("Yanlis Negatif Yuzde %0.2f" % (fn / (tp+tn+fp+fn) * 100.0))
\end{minted}

\begin{verbatim}
dogru pozitif 456
dogru negatif 246340
yanlis pozitif 1340
yanlis negatif 1364
249500
Yanlis Negatif Yuzde 0.55
\end{verbatim}






Kaynaklar

[1] {\em Optimized Spatial Hashing for Collision Detection of Deformable Objects}
    \url{https://matthias-research.github.io/pages/publications/tetraederCollision.pdf}

[2] Hari, {\em Locality Sensitive Hashing for Similar Item Search},
    \url{https://towardsdatascience.com/locality-sensitive-hashing-for-music-search-f2f1940ace23}

[3] Bayramli, {\em Rasgele İzdüşümü (Random Projection) ile SVD}

[4] Slaney, {\em Locality-Sensitive Hashing for Finding Nearest Neighbors},
    \url{https://www.slaney.org/malcolm/yahoo/Slaney2008-LSHTutorial.pdf}
    
\end{document}
