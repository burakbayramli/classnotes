<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Evrişimsel Ağlar, Derin Öğrenim (Convolutional Nets -Convnet-, Deep Learning)</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="evrişimsel-ağlar-derin-öğrenim-convolutional-nets--convnet--deep-learning">Evrişimsel Ağlar, Derin Öğrenim (Convolutional Nets -Convnet-, Deep Learning)</h1>
<p>Convnet'ler YSA'lara yeni bazı özellikler ekledi. Öncelikle gizli katman artık ikiden daha fazla derinliğe gidebiliyor. Diğer bir ek, mesela veriye ilk dokunan katmanı sadece evrişim operasyonu için kullanmak.</p>
<p>Evrişim boyutu önceden belli bir matrisi tüm veri üzerinde kaydırarak sonuç değerleri kaydetmekten ibaret, görüntü işlemede yapılan çoğu filtreleme işlemi bir evrişim operasyonu. Mesela 2 x 2 boyutlu bir filtre matrisini tüm veri üzerinde kaydırırız, her kaydırma sırasında o bölgede filtre matrisini değerler ile çarparız, sonucu hatırlarız, çarpılan bölgeye tekabül eden sonuç matrisinde sonucu yazarız. Evrişim matrisi</p>
<p><span class="math display">\[ A = \left[\begin{array}{rrr}
1 &amp;  0 &amp; 1 \\ 0 &amp; 1 &amp; 0 \\ 1 &amp; 0 &amp; 1
\end{array}\right]\]</span></p>
<p>olsun, görüntü (image) üzerinde çarpım işlemini adım adım gösterelim, sonuç evriştirilmiş özellik (convolved feature) içinde,</p>
<div class="figure">
<img src="conv-0.png" />

</div>
<div class="figure">
<img src="conv-1.png" />

</div>
<div class="figure">
<img src="conv-2.png" />

</div>
<div class="figure">
<img src="conv-3.png" />

</div>
<div class="figure">
<img src="conv-4.png" />

</div>
<div class="figure">
<img src="conv-5.png" />

</div>
<div class="figure">
<img src="conv-6.png" />

</div>
<div class="figure">
<img src="conv-7.png" />

</div>
<div class="figure">
<img src="conv-8.png" />

</div>
<p>Üstteki örnekte kaydırma (stride) sayısı 1. Kaydırma sayısı evrişim matrisini uyguladıktan sonra bir sonraki işlem için kaç hücre yana kayacağımızı kontrol eder. Evrişim matrisinin boyutunun, kaydırma sayısının sonuç matrisin boyutu üzerinde etkileri olacaktır. 5 x 5 matrisi üzerinden 1 kaydırma ile 3 x 3 evrişim uygulayınca 3 x 3 boyutunda bir sonuç elde ettik.</p>
<p>Görüntü işlemede yatay, dikey çizgileri daha belirgin hale getiren, ortaya çıkartan türden, bilinen filtreler vardır, diğer türler de mevcuttur. Fakat derin öğrenim bu evrişim matrisinin içeriğini, ayrıca onu diğer katmanlara bağlayan ağırlıkları da otomatik olarak öğrenir! Çünkü eğer çizgileri ortaya çıkartmak öğrenme işleminin bütününe fayda getiriyorsa öğrenme süreci sırasında evrişim matrisinin değerleri o değerlere evrilir. Evrişimleri bu şekilde ağda kullanmanın convnet'lerin alt katmanlarındaki hata düzeltme işlemini daha rahatlaştırdığı keşfedildi.</p>
<p>Bir yenilik aktivasyon için ReLu (doğrultan lineer ünite -rectified linear unit-) kullanmak, bir diğer katman &quot;aşağı örnekleme (downsampling)'' yapan katman, mesela <span class="math inline">\(2 \times 2\)</span> içindeki bir pencere içine düşen öğelerin maksimumunu almak. Bir başkası &quot;veri atma (dropout)'' katmanı, veri içinde bir katmandan gelen bağlantıların bir kısmı (dışarıdan ayarlanabilir) rasgele şekilde yoksayılıyor, bu durumda model elde kalanlar ile uydurma işlemini yapmaya uğraşacak, böylece modelde aşırı uygunluk (överfitting) problemlerinden kaçınılmış olunuyor, potansiyel olarak daha sağlam (robust) bir modelin ortaya çıkması sağlanıyor.</p>
<div class="figure">
<img src="convnet_06.png" />

</div>
<p>Böyle gide gide bir derin ağ yapısı ortaya çıkartmış oluyoruz.</p>
<p>Not: Çoğunlukla evrişim tabakasından sonra ReLu aktviyasyonuna bağlantı yapılır, çünkü eğer aktivasyon olmasa, evrişim sonuçta ağırlıklarla çarpım ve toplam işlemidir, ve bu bir lineer işlemdir, o zaman tüm NN'in işlemi ardı ardına matrislerin çarpımı olarak ta görülebilirdi, ve bu bir lineer işlem olurdu, o zaman NN gayri-lineerligi modelleyemezdi.</p>
<p>TensorFlow ile Evrişim</p>
<p>Şimdi TF kullanarak evrişim yapalım, iki resim üzerinde örneği görelim,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np
<span class="im">import</span> tensorflow <span class="im">as</span> tf
<span class="im">from</span> sklearn.datasets <span class="im">import</span> load_sample_images

<span class="co"># Load sample images</span>
dataset <span class="op">=</span> np.array(load_sample_images().images, dtype<span class="op">=</span>np.float32)
batch_size, height, width, channels <span class="op">=</span> dataset.shape
<span class="bu">print</span> <span class="st">&#39;veri tensor boyutu&#39;</span>, dataset.shape
plt.imshow(dataset[<span class="dv">0</span>,:,:,:] <span class="op">/</span> <span class="fl">255.</span>) 
plt.savefig(<span class="st">&#39;conv-9.png&#39;</span>)
plt.imshow(dataset[<span class="dv">1</span>,:,:,:] <span class="op">/</span> <span class="fl">255.</span>) 
plt.savefig(<span class="st">&#39;conv-10.png&#39;</span>)</code></pre></div>
<pre><code>veri tensor boyutu (2, 427, 640, 3)</code></pre>
<p><img src="conv-9.png" /> <img src="conv-10.png" /></p>
<p>Bu iki resmi bir &quot;tensor'' yani çok boyutlu matris içine koyduk, resmin boyutları 640 x 427, eğer tek bir resme bakıyor olsaydık (640,427) boyutlu tek bir matris ile iş yapabilirdik, fakat TF ardı ardına gelen verileri de bir tensorun ayrı boyutları olarak kabul edebiliyor. Ayrıca tensorun son boyutu renk kanalları, üç tane var, RGB renk sistemı için kırmızı (red), yeşil (green) ve mavi (blue) için. Böylece üstteki tensor boyutlarını elde ettik.</p>
<p>Evrişim için 4 tane filtre tanımlayacağız. Bu filtrelerin içeriğinin elle burada tanımlayacağız, yapay öğrenme bağlamında bu içerik eğitim sırasında otomatik olarak öğrenilir, şimdi örnek amaçlı olarak filtre değerlerini biz atıyoruz. Ayrıca istediğimiz kadar filtre tanımlayabilirdik, yapay öğrenmede istenen o'dur ki bu filtreler doğru değerlere doğru evrilir, her filtre görüntünün değişik yerlerine, biçimlerine odaklanmaya başlayabilirler.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">in_channels <span class="op">=</span> channels
out_channels <span class="op">=</span> <span class="dv">4</span>
W <span class="op">=</span> np.zeros(shape<span class="op">=</span>(<span class="dv">7</span>, <span class="dv">7</span>, in_channels, out_channels), dtype<span class="op">=</span>np.float32)
W[:, <span class="dv">3</span>, :, <span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># yatay cizgi</span>
W[<span class="dv">3</span>, :, :, <span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># dikey cizgi</span>
W[<span class="dv">5</span>, :, :, <span class="dv">2</span>] <span class="op">=</span> <span class="dv">1</span>  
W[<span class="dv">2</span>, :, :, <span class="dv">3</span>] <span class="op">=</span> <span class="dv">1</span>  

X <span class="op">=</span> tf.placeholder(tf.float32, shape<span class="op">=</span>(<span class="va">None</span>, height, width, channels))
convolution <span class="op">=</span> tf.nn.conv2d(X, W, strides<span class="op">=</span>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">1</span>], padding<span class="op">=</span><span class="st">&quot;SAME&quot;</span>)
<span class="cf">with</span> tf.Session() <span class="im">as</span> sess:
    output <span class="op">=</span> sess.run(convolution, feed_dict<span class="op">=</span>{X: dataset})
    <span class="bu">print</span> <span class="st">u&#39;evrişimden gelen tensor&#39;</span>, output.shape</code></pre></div>
<pre><code>evrişimden gelen tensor (2, 214, 320, 4)</code></pre>
<p>Filtrelerin ilkinde mesela sadece yatay bir çizgi var, bu filtre yatay piksellerin bir ortalamasını alıyor olacak, vs. Parametrelerden kaydırma yatay 2 dikey olarak tanımlı, o zaman her imaj kabaca yarısına inecek, dolgu (padding) için <code>SAME</code> diyerek dolgu yap demişiz, yani kaydırma olmasaydı giren çıkan tensor aynı olurdu. Peki 3 tane ayrı kanal bilgisine ne oldu? Görüntü boyutlar azalarak (320,214) oldu, 4 tane filtre çıkışı var, 2 tane imaj. Kanallar üzerinden bir toplam alındı, yani ayrı kanal bilgisi artık yok. Bu aslında istenen bir şey çünkü bir görüntünün R,G,B kanalları üzerinde ayrı ayrı irdeleme yapmak istemeyiz, sınıflama, karar mekanizmasını tüm imaj üzerinden işletmek isteriz.</p>
<p>Sonuçlar altta, iki tane filtre sonucu örnek olarak seçildi.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> plot_image(image):
    plt.imshow(image, cmap<span class="op">=</span><span class="st">&quot;gray&quot;</span>, interpolation<span class="op">=</span><span class="st">&quot;nearest&quot;</span>)
    plt.axis(<span class="st">&quot;off&quot;</span>)
    
image_index <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> feature_map_index <span class="op">=</span> <span class="dv">2</span>
plot_image(output[image_index, :, :, feature_map_index])
plt.savefig(<span class="st">&#39;conv-out-</span><span class="sc">%d</span><span class="st">-</span><span class="sc">%d</span><span class="st">.png&#39;</span> <span class="op">%</span> (image_index,feature_map_index))

image_index <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> feature_map_index <span class="op">=</span> <span class="dv">1</span>
plot_image(output[image_index, :, :, feature_map_index])
plt.savefig(<span class="st">&#39;conv-out-</span><span class="sc">%d</span><span class="st">-</span><span class="sc">%d</span><span class="st">.png&#39;</span> <span class="op">%</span> (image_index,feature_map_index))</code></pre></div>
<p><img src="conv-out-0-2.png" /> <img src="conv-out-1-1.png" /></p>
<p>Cok kanallı durum için açık olmadıysa bir daha vurgulayalım, evrişim katmanı evrişim operatörünü imaj ya da başka bir tensor üzerinde gezdirirken üzerinde olduğu tüm girdi tabakalarını, tüm kanalları kapsayacak şekilde, çarpıp sonucu tek bir öğeye götürür. Bu çarpım için herhalde kanallar bir şekilde düzleştirilip ağırlıklara eşleniyor. Neyse, filtreyi kaydırdıkça çarpım sonucu çıktıda farklı öğeler elde edilir, ve bu bize tek boyutlu bir sonuç kesiti verir. Eğer birden fazla evrişim filtresi uygularsak onların sonuçları farklı sonuç tabakaları olarak diğer tabakaların üzerinde istiflenir.</p>
<div class="figure">
<img src="conv-11.png" />

</div>
<p>Mesela altta 20x30 boyutlu ve 3 kanallı bir tensor girdimiz olsun, bu tensorlardan kaç tane olduğunu şimdilik tanımlamadık (mini girdi yığınında yani). Şimdi girdi üzerinde 16 tane filtre gezdiriyoruz, ve 20x30x16 boyutlu çıktı elde ediyoruz.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> tensorflow <span class="im">as</span> tf
tf.reset_default_graph()
<span class="bu">input</span> <span class="op">=</span> tf.placeholder(tf.float32, [<span class="va">None</span>, <span class="dv">20</span>, <span class="dv">30</span>, <span class="dv">3</span>])
conv_layer <span class="op">=</span> tf.layers.conv2d(inputs<span class="op">=</span><span class="bu">input</span>, filters<span class="op">=</span><span class="dv">16</span>, 
                              kernel_size<span class="op">=</span>(<span class="dv">2</span>,<span class="dv">2</span>), padding<span class="op">=</span><span class="st">&#39;same&#39;</span>)
<span class="bu">print</span> conv_layer</code></pre></div>
<pre><code>Tensor(&quot;conv2d/BiasAdd:0&quot;, shape=(?, 20, 30, 16), dtype=float32)</code></pre>
<p>MNIST</p>
<p>Altta MNIST verisini işleyebilen mimarının TF olmadan pür Python kullanan kodunu görüyoruz. Bu yapı ünlü YSA araştırmacısı Yann LeCun'un LeNet adı verilen mimarisi. Veri [5]'ten indirilebilir.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">&quot;&quot;&quot;Convolutional neural net on MNIST, modeled on &#39;LeNet-5&#39;,</span>
<span class="co">http://yann.lecun.com/exdb/publis/pdf/lecun-98.pdf&quot;&quot;&quot;</span>
<span class="im">from</span> __future__ <span class="im">import</span> absolute_import
<span class="im">from</span> __future__ <span class="im">import</span> print_function

<span class="im">import</span> autograd.numpy <span class="im">as</span> np
<span class="im">import</span> autograd.numpy.random <span class="im">as</span> npr
<span class="im">import</span> autograd.scipy.signal
<span class="im">from</span> autograd <span class="im">import</span> grad
<span class="im">from</span> builtins <span class="im">import</span> <span class="bu">range</span>
<span class="im">import</span> gzip
<span class="im">import</span> struct
<span class="im">import</span> array

convolve <span class="op">=</span> autograd.scipy.signal.convolve

<span class="kw">class</span> WeightsParser(<span class="bu">object</span>):
    <span class="co">&quot;&quot;&quot;A helper class to index into a parameter vector.&quot;&quot;&quot;</span>
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):
        <span class="va">self</span>.idxs_and_shapes <span class="op">=</span> {}
        <span class="va">self</span>.N <span class="op">=</span> <span class="dv">0</span>

    <span class="kw">def</span> add_weights(<span class="va">self</span>, name, shape):
        start <span class="op">=</span> <span class="va">self</span>.N
        <span class="va">self</span>.N <span class="op">+=</span> np.prod(shape)
        <span class="va">self</span>.idxs_and_shapes[name] <span class="op">=</span> (<span class="bu">slice</span>(start, <span class="va">self</span>.N), shape)

    <span class="kw">def</span> get(<span class="va">self</span>, vect, name):
        idxs, shape <span class="op">=</span> <span class="va">self</span>.idxs_and_shapes[name]
        <span class="cf">return</span> np.reshape(vect[idxs], shape)

<span class="kw">def</span> make_batches(N_total, N_batch):
    start <span class="op">=</span> <span class="dv">0</span>
    batches <span class="op">=</span> []
    <span class="cf">while</span> start <span class="op">&lt;</span> N_total:
        batches.append(<span class="bu">slice</span>(start, start <span class="op">+</span> N_batch))
        start <span class="op">+=</span> N_batch
    <span class="cf">return</span> batches

<span class="kw">def</span> logsumexp(X, axis, keepdims<span class="op">=</span><span class="va">False</span>):
    max_X <span class="op">=</span> np.<span class="bu">max</span>(X)
    <span class="cf">return</span> max_X <span class="op">+</span> np.log(np.<span class="bu">sum</span>(np.exp(X <span class="op">-</span> max_X), axis<span class="op">=</span>axis, keepdims<span class="op">=</span>keepdims))

<span class="kw">def</span> make_nn_funs(input_shape, layer_specs, L2_reg):
    parser <span class="op">=</span> WeightsParser()
    cur_shape <span class="op">=</span> input_shape
    <span class="cf">for</span> layer <span class="kw">in</span> layer_specs:
        N_weights, cur_shape <span class="op">=</span> layer.build_weights_dict(cur_shape)
        parser.add_weights(layer, (N_weights,))

    <span class="kw">def</span> predictions(W_vect, inputs):
        <span class="co">&quot;&quot;&quot;Outputs normalized log-probabilities.</span>
<span class="co">        shape of inputs : [data, color, y, x]&quot;&quot;&quot;</span>
        cur_units <span class="op">=</span> inputs
        <span class="cf">for</span> layer <span class="kw">in</span> layer_specs:
            cur_weights <span class="op">=</span> parser.get(W_vect, layer)
            cur_units <span class="op">=</span> layer.forward_pass(cur_units, cur_weights)
        <span class="cf">return</span> cur_units

    <span class="kw">def</span> loss(W_vect, X, T):
        log_prior <span class="op">=</span> <span class="op">-</span>L2_reg <span class="op">*</span> np.dot(W_vect, W_vect)
        log_lik <span class="op">=</span> np.<span class="bu">sum</span>(predictions(W_vect, X) <span class="op">*</span> T)
        <span class="cf">return</span> <span class="op">-</span> log_prior <span class="op">-</span> log_lik

    <span class="kw">def</span> frac_err(W_vect, X, T):
        <span class="cf">return</span> np.mean(np.argmax(T, axis<span class="op">=</span><span class="dv">1</span>) <span class="op">!=</span> <span class="op">\</span>
                       np.argmax(predictions(W_vect, X), axis<span class="op">=</span><span class="dv">1</span>))

    <span class="cf">return</span> parser.N, predictions, loss, frac_err

<span class="kw">class</span> conv_layer(<span class="bu">object</span>):
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, kernel_shape, num_filters):
        <span class="va">self</span>.kernel_shape <span class="op">=</span> kernel_shape
        <span class="va">self</span>.num_filters <span class="op">=</span> num_filters

    <span class="kw">def</span> forward_pass(<span class="va">self</span>, inputs, param_vector):
        <span class="co"># Input dimensions:  [data, color_in, y, x]</span>
        <span class="co"># Params dimensions: [color_in, color_out, y, x]</span>
        <span class="co"># Output dimensions: [data, color_out, y, x]</span>
        params <span class="op">=</span> <span class="va">self</span>.parser.get(param_vector, <span class="st">&#39;params&#39;</span>)
        biases <span class="op">=</span> <span class="va">self</span>.parser.get(param_vector, <span class="st">&#39;biases&#39;</span>)
        conv <span class="op">=</span> convolve(inputs, params,
                        axes<span class="op">=</span>([<span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">2</span>, <span class="dv">3</span>]),
                        dot_axes <span class="op">=</span> ([<span class="dv">1</span>], [<span class="dv">0</span>]),
                        mode<span class="op">=</span><span class="st">&#39;valid&#39;</span>)
        <span class="cf">return</span> conv <span class="op">+</span> biases

    <span class="kw">def</span> build_weights_dict(<span class="va">self</span>, input_shape):
        <span class="co"># Input shape : [color, y, x] (don&#39;t need to know number of data yet)</span>
        <span class="va">self</span>.parser <span class="op">=</span> WeightsParser()
        <span class="va">self</span>.parser.add_weights(<span class="st">&#39;params&#39;</span>, (input_shape[<span class="dv">0</span>], <span class="va">self</span>.num_filters)
                                          <span class="op">+</span> <span class="va">self</span>.kernel_shape)
        <span class="va">self</span>.parser.add_weights(<span class="st">&#39;biases&#39;</span>, (<span class="dv">1</span>, <span class="va">self</span>.num_filters, <span class="dv">1</span>, <span class="dv">1</span>))
        output_shape <span class="op">=</span> (<span class="va">self</span>.num_filters,) <span class="op">+</span> <span class="op">\</span>
                       <span class="va">self</span>.conv_output_shape(input_shape[<span class="dv">1</span>:], <span class="va">self</span>.kernel_shape)
        <span class="cf">return</span> <span class="va">self</span>.parser.N, output_shape

    <span class="kw">def</span> conv_output_shape(<span class="va">self</span>, A, B):
        <span class="cf">return</span> (A[<span class="dv">0</span>] <span class="op">-</span> B[<span class="dv">0</span>] <span class="op">+</span> <span class="dv">1</span>, A[<span class="dv">1</span>] <span class="op">-</span> B[<span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>)

<span class="kw">class</span> maxpool_layer(<span class="bu">object</span>):
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, pool_shape):
        <span class="va">self</span>.pool_shape <span class="op">=</span> pool_shape

    <span class="kw">def</span> build_weights_dict(<span class="va">self</span>, input_shape):
        <span class="co"># input_shape dimensions: [color, y, x]</span>
        output_shape <span class="op">=</span> <span class="bu">list</span>(input_shape)
        <span class="cf">for</span> i <span class="kw">in</span> [<span class="dv">0</span>, <span class="dv">1</span>]:
            <span class="cf">assert</span> input_shape[i <span class="op">+</span> <span class="dv">1</span>] <span class="op">%</span> <span class="va">self</span>.pool_shape[i] <span class="op">==</span> <span class="dv">0</span>, <span class="op">\</span>
                <span class="co">&quot;maxpool shape should tile input exactly&quot;</span>
            output_shape[i <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> input_shape[i <span class="op">+</span> <span class="dv">1</span>] <span class="op">/</span> <span class="va">self</span>.pool_shape[i]
        <span class="cf">return</span> <span class="dv">0</span>, output_shape

    <span class="kw">def</span> forward_pass(<span class="va">self</span>, inputs, param_vector):
        new_shape <span class="op">=</span> inputs.shape[:<span class="dv">2</span>]
        <span class="cf">for</span> i <span class="kw">in</span> [<span class="dv">0</span>, <span class="dv">1</span>]:
            pool_width <span class="op">=</span> <span class="va">self</span>.pool_shape[i]
            img_width <span class="op">=</span> inputs.shape[i <span class="op">+</span> <span class="dv">2</span>]
            new_shape <span class="op">+=</span> (pool_width, img_width <span class="op">//</span> pool_width)
        result <span class="op">=</span> inputs.reshape(new_shape)
        <span class="cf">return</span> np.<span class="bu">max</span>(np.<span class="bu">max</span>(result, axis<span class="op">=</span><span class="dv">2</span>), axis<span class="op">=</span><span class="dv">3</span>)

<span class="kw">class</span> full_layer(<span class="bu">object</span>):
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, size):
        <span class="va">self</span>.size <span class="op">=</span> size

    <span class="kw">def</span> build_weights_dict(<span class="va">self</span>, input_shape):
        <span class="co"># Input shape is anything (all flattened)</span>
        input_size <span class="op">=</span> np.prod(input_shape, dtype<span class="op">=</span><span class="bu">int</span>)
        <span class="va">self</span>.parser <span class="op">=</span> WeightsParser()
        <span class="va">self</span>.parser.add_weights(<span class="st">&#39;params&#39;</span>, (input_size, <span class="va">self</span>.size))
        <span class="va">self</span>.parser.add_weights(<span class="st">&#39;biases&#39;</span>, (<span class="va">self</span>.size,))
        <span class="cf">return</span> <span class="va">self</span>.parser.N, (<span class="va">self</span>.size,)

    <span class="kw">def</span> forward_pass(<span class="va">self</span>, inputs, param_vector):
        params <span class="op">=</span> <span class="va">self</span>.parser.get(param_vector, <span class="st">&#39;params&#39;</span>)
        biases <span class="op">=</span> <span class="va">self</span>.parser.get(param_vector, <span class="st">&#39;biases&#39;</span>)
        <span class="cf">if</span> inputs.ndim <span class="op">&gt;</span> <span class="dv">2</span>:
            inputs <span class="op">=</span> inputs.reshape((inputs.shape[<span class="dv">0</span>], np.prod(inputs.shape[<span class="dv">1</span>:])))
        <span class="cf">return</span> <span class="va">self</span>.nonlinearity(np.dot(inputs[:, :], params) <span class="op">+</span> biases)

<span class="kw">class</span> tanh_layer(full_layer):
    <span class="kw">def</span> nonlinearity(<span class="va">self</span>, x):
        <span class="cf">return</span> np.tanh(x)

<span class="kw">class</span> softmax_layer(full_layer):
    <span class="kw">def</span> nonlinearity(<span class="va">self</span>, x):
        <span class="cf">return</span> x <span class="op">-</span> logsumexp(x, axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)

<span class="kw">def</span> mnist():
    <span class="kw">def</span> parse_labels(filename):
        <span class="cf">with</span> gzip.<span class="bu">open</span>(filename, <span class="st">&#39;rb&#39;</span>) <span class="im">as</span> fh:
            magic, num_data <span class="op">=</span> struct.unpack(<span class="st">&quot;&gt;II&quot;</span>, fh.read(<span class="dv">8</span>))
            <span class="cf">return</span> np.array(array.array(<span class="st">&quot;B&quot;</span>, fh.read()), dtype<span class="op">=</span>np.uint8)

    <span class="kw">def</span> parse_images(filename):
        <span class="cf">with</span> gzip.<span class="bu">open</span>(filename, <span class="st">&#39;rb&#39;</span>) <span class="im">as</span> fh:
            magic, num_data, rows, cols <span class="op">=</span> struct.unpack(<span class="st">&quot;&gt;IIII&quot;</span>, fh.read(<span class="dv">16</span>))
            <span class="cf">return</span> np.array(array.array(<span class="st">&quot;B&quot;</span>, fh.read()),
                            dtype<span class="op">=</span>np.uint8).reshape(num_data, rows, cols)

    base_dir <span class="op">=</span> <span class="st">&#39;/home/burak/Documents/Dropbox/Public/data&#39;</span>
    train_images <span class="op">=</span> parse_images(base_dir <span class="op">+</span> <span class="st">&#39;/train-images-idx3-ubyte.gz&#39;</span>)
    train_labels <span class="op">=</span> parse_labels(base_dir <span class="op">+</span> <span class="st">&#39;/train-labels-idx1-ubyte.gz&#39;</span>)
    test_images  <span class="op">=</span> parse_images(base_dir <span class="op">+</span> <span class="st">&#39;/t10k-images-idx3-ubyte.gz&#39;</span>)
    test_labels  <span class="op">=</span> parse_labels(base_dir <span class="op">+</span> <span class="st">&#39;/t10k-labels-idx1-ubyte.gz&#39;</span>)

    <span class="cf">return</span> train_images, train_labels, test_images, test_labels
    

<span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>:
    np.random.seed(<span class="dv">0</span>)
    <span class="co"># Network parameters    </span>
    L2_reg <span class="op">=</span> <span class="fl">1.0</span>
    input_shape <span class="op">=</span> (<span class="dv">1</span>, <span class="dv">28</span>, <span class="dv">28</span>)
    layer_specs <span class="op">=</span> [conv_layer((<span class="dv">5</span>, <span class="dv">5</span>), <span class="dv">6</span>),
                   maxpool_layer((<span class="dv">2</span>, <span class="dv">2</span>)),
                   conv_layer((<span class="dv">5</span>, <span class="dv">5</span>), <span class="dv">16</span>),
                   maxpool_layer((<span class="dv">2</span>, <span class="dv">2</span>)),
                   tanh_layer(<span class="dv">12</span>),
                   tanh_layer(<span class="dv">84</span>),
                   softmax_layer(<span class="dv">10</span>)]

    <span class="co"># Training parameters</span>
    param_scale <span class="op">=</span> <span class="fl">0.1</span>
    learning_rate <span class="op">=</span> <span class="fl">1e-3</span>
    momentum <span class="op">=</span> <span class="fl">0.9</span>
    batch_size <span class="op">=</span> <span class="dv">500</span>
    num_epochs <span class="op">=</span> <span class="dv">50</span>

    <span class="co"># Load and process MNIST data</span>
    <span class="bu">print</span>(<span class="st">&quot;Loading training data...&quot;</span>)
    add_color_channel <span class="op">=</span> <span class="kw">lambda</span> x : x.reshape((x.shape[<span class="dv">0</span>], <span class="dv">1</span>, x.shape[<span class="dv">1</span>], x.shape[<span class="dv">2</span>]))
    one_hot <span class="op">=</span> <span class="kw">lambda</span> x, K : np.array(x[:,<span class="va">None</span>] <span class="op">==</span> np.arange(K)[<span class="va">None</span>, :], dtype<span class="op">=</span><span class="bu">int</span>)
    train_images, train_labels, test_images, test_labels <span class="op">=</span> mnist()
    train_images <span class="op">=</span> add_color_channel(train_images) <span class="op">/</span> <span class="fl">255.0</span>
    test_images  <span class="op">=</span> add_color_channel(test_images)  <span class="op">/</span> <span class="fl">255.0</span>
    train_labels <span class="op">=</span> one_hot(train_labels, <span class="dv">10</span>)
    test_labels <span class="op">=</span> one_hot(test_labels, <span class="dv">10</span>)

    test_sampler <span class="op">=</span> np.random.permutation(<span class="bu">len</span>(test_labels))[:<span class="dv">100</span>]
    train_sampler <span class="op">=</span> np.random.permutation(<span class="bu">len</span>(train_labels))[:<span class="dv">1000</span>]
    train_images <span class="op">=</span> train_images[train_sampler]
    train_labels <span class="op">=</span> train_labels[train_sampler]
    test_images <span class="op">=</span> test_images[test_sampler]
    test_labels <span class="op">=</span> test_labels[test_sampler]
    N_data <span class="op">=</span> train_images.shape[<span class="dv">0</span>]
    
    <span class="im">from</span> sklearn <span class="im">import</span> neighbors
    train_images_3 <span class="op">=</span> np.reshape(train_images, (<span class="dv">1000</span>,<span class="dv">28</span><span class="op">*</span><span class="dv">28</span>))
    test_images_3 <span class="op">=</span> np.reshape(test_images, (<span class="dv">100</span>,<span class="dv">28</span><span class="op">*</span><span class="dv">28</span>))
    clf <span class="op">=</span> neighbors.KNeighborsClassifier()
    clf.fit(train_images_3,train_labels)
    res <span class="op">=</span> clf.predict(test_images_3)
    res2 <span class="op">=</span> [np.<span class="bu">all</span>(x) <span class="cf">for</span> x <span class="kw">in</span> (res<span class="op">==</span>test_labels)]
    <span class="bu">print</span> (<span class="st">&#39;KNN&#39;</span>)
    <span class="bu">print</span> ( np.<span class="bu">sum</span>(res2) <span class="op">/</span> <span class="fl">100.</span>)
    
    <span class="co"># Make neural net functions</span>
    N_weights, pred_fun, loss_fun, <span class="op">\</span>
        frac_err <span class="op">=</span> make_nn_funs(input_shape, layer_specs, L2_reg)
    loss_grad <span class="op">=</span> grad(loss_fun)

    <span class="co"># Initialize weights</span>
    rs <span class="op">=</span> npr.RandomState()
    W <span class="op">=</span> rs.randn(N_weights) <span class="op">*</span> param_scale

    <span class="bu">print</span>(<span class="st">&quot;    Epoch      |    Train err  |   Test error  &quot;</span>)
    <span class="kw">def</span> print_perf(epoch, W):
        test_perf  <span class="op">=</span> frac_err(W, test_images, test_labels)
        train_perf <span class="op">=</span> frac_err(W, train_images, train_labels)
        <span class="bu">print</span>(<span class="st">&quot;</span><span class="sc">{0:15}</span><span class="st">|</span><span class="sc">{1:15}</span><span class="st">|</span><span class="sc">{2:15}</span><span class="st">&quot;</span>.<span class="bu">format</span>(epoch, train_perf, test_perf))

    <span class="co"># Train with sgd</span>
    batch_idxs <span class="op">=</span> make_batches(N_data, batch_size)
    cur_dir <span class="op">=</span> np.zeros(N_weights)

    <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(num_epochs):
        print_perf(epoch, W)
        <span class="cf">for</span> idxs <span class="kw">in</span> batch_idxs:
            grad_W <span class="op">=</span> loss_grad(W, train_images[idxs], train_labels[idxs])
            cur_dir <span class="op">=</span> momentum <span class="op">*</span> cur_dir <span class="op">+</span> (<span class="fl">1.0</span> <span class="op">-</span> momentum) <span class="op">*</span> grad_W
            W <span class="op">-=</span> learning_rate <span class="op">*</span> cur_dir

    np.savetxt(<span class="st">&#39;W&#39;</span>,W)</code></pre></div>
<pre><code>Loading training data...
KNN
0.82
    Epoch      |    Train err  |   Test error  
              0|           0.92|           0.93
              1|           0.89|            0.9
              2|          0.798|           0.82
              3|          0.767|           0.74
              4|          0.727|           0.67
              5|          0.678|           0.71
              6|          0.627|           0.65
              7|          0.563|           0.56
              8|          0.503|           0.53
              9|          0.445|           0.49
             10|          0.418|           0.45
             11|          0.357|           0.41
             12|           0.34|           0.39
             13|          0.322|           0.36
             14|          0.287|           0.32
             15|          0.258|           0.29
             16|          0.261|           0.33
             17|          0.232|           0.27
             18|          0.216|           0.25
             19|          0.206|           0.25
             20|          0.188|           0.22
             21|          0.171|           0.23
             22|          0.164|           0.23
             23|          0.175|           0.25
             24|          0.121|           0.21
             25|          0.152|           0.19
             26|          0.169|           0.21
             27|          0.145|           0.18
             28|          0.119|           0.22
             29|          0.099|           0.18
             30|          0.073|           0.16
             31|          0.083|            0.2
             32|          0.066|           0.17
             33|           0.06|           0.18
             34|          0.052|           0.18
             35|          0.042|           0.18
             36|          0.034|           0.16
             37|          0.034|           0.18
             38|          0.027|           0.17
             39|          0.023|           0.15
             40|          0.026|           0.18
             41|          0.017|           0.16
             42|          0.012|           0.16
             43|          0.011|           0.14
             44|          0.011|           0.12
             45|          0.008|           0.14
             46|          0.009|           0.13
             47|          0.007|           0.15
             48|          0.006|           0.12
             49|          0.005|           0.15</code></pre>
<p>Tarih</p>
<p>Convnet'lerin son zamanlarda başarılı olmaya başlamasında bazı etkenler şunlar: en önemlisi araştırmacıların dışbükey olmayan kayıp fonksiyonlarından (non-convex loss functions) korkmadan (!) onların minimumunu rasgele gradyan inişi üzerinden bulabilmeye başlamaları. Convnet, HMM, Gaussian karışımlar gibi pek çok alanda dışbükey olmayan bir durum vardır, hatta bir bakıma ciddi her yapay öğrenim alanında bu durum ortaya çıkar. Bu optimizasyon problemi rasgele gradyan inişi ile çözülmeye başlandı. Gerçi rasgele gradyan inişi çok basit bir yöntemdir, fakat araştırmacılar yıllarca bu yöntemi dışbükey olmayan yerlerde kullanmadılar çünkü yakınsama (convergence) garantileri teorik olarak mümkün değildi. Kıyasla bir dışbükey fonksiyonun minimumuna varmak doğru yöntemler ile garantidir. Fakat son araştırmalara göre rasgele gradyan inişi ile optimizasyon eğitim verisi üzerinden yakınsama garantisi olmasa bile test verisi üzerinde bazı garantilerin olduğu ortaya çıktı, ki test skoru eğitim skorundan daha önemli.</p>
<p>Bir diğer gelişme ağ yapısında gizli katmandaki nöron sayısını genişletince, minimum noktasının pek çok yerde ortaya çıkabilmesi, ve bu noktaların birbiriyle aşağı yukarı aynı olması. Yani gradyan inişi bu noktalardan birini bulduğunda iş bitmiş sayılabiliyor. Ayrıca çok boyut olunca yerel minima'da takılıp kalmadan bir yan boyuta atlayıp önümüzdeki tepenin etrafından dolaşabilme şansı ortaya çıkıyor [4].</p>
<p>Ek bir gelişme herhangi bir yazılım fonksiyonun türevinin alınabilmesini sağlayan otomatik türev alma (automatic differentiation) tekniğinin yaygınlaşması, ki bu teknik çetrefil nöron fonksiyonları içerebilen convnet'ler için faydalı oldu. Not: dikkat otomatik türev ile {} fonksiyon hatta <code>if, while</code> komutları içeren bir kod parçasının bile türevi alınabiliyor (bkz [2] yazısı). Türevler önemli çünkü gradyan inişi minimuma gidebilmek için türev kullanmalı. Üstteki kodda dikkat çekmiş olabilir, sinir ağında aslında yaptığımız tek hesap ileri doğru beslemeli (feed-forward) olan hesap; her veri noktası için ağın başından başlayarak girdi / işlem / sonuçları ardı ardına bir sonraki katmana aktarıyoruz, otomatik türev pek çok katmanlı bu işlemlerin türevini alarak bize o gidişin yaptığı tahminlerin hatasını düzeltmek için gidilmesi gereken gradyan yönünü veriyor.</p>
<p>Bazı negatifler: Convnet'lerin eğitimi hızlı değildir, ciddi kullanımlar için GPU, ya da paralel CPU kullanmak şart. Ayrıca convnet'lerin bir fark yaratması için oldukça çok veriye ihtiyaçları var, normal ölçek veri ortamında diğer yaklaşımlar da convnet'ten çok daha kötü değiller. Bir diğeri bir YSA'nın, yapı olarak, istatistiki bir anlamının olmaması: Bir ağ yapısı var, fakat bu ağın tamamının olasılıksal olarak irdelenmesi mümkün değil. Kıyasla bir GMM bir olasılığı temsil eder, bu sebeple yaptığı hesapların mesela güven aralığını hesaplamak mümkündür. Diğer yanda mesela tıbbi bir uygulama bağlamında YSA bir tahmin yapınca bundan &quot;ne kadar emin olduğu'' sorusunun direk cevabı alınamıyor. Bu alanda araştırmalar var tabii, ilginç bazı buluşlar bunu mümkün kılabilir.</p>
<p>Kaynaklar</p>
<p>[2] Bayramlı, Bilgisayar Bilim, <em>Otomatik Türev</em></p>
<p>[3] <em>Machine learning algorithms</em>, https://github.com/rushter/MLAlgorithms</p>
<p>[4] LeCun, <em>Who is Afraid of Non-Convex Loss Functions?</em>, <a href="https://youtu.be/8zdo6cnCW2w" class="uri">https://youtu.be/8zdo6cnCW2w</a></p>
<p>[5] LeCun, <em>MNIST Verisi</em>, <a href="http://yann.lecun.com/exdb/mnist" class="uri">http://yann.lecun.com/exdb/mnist</a></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
