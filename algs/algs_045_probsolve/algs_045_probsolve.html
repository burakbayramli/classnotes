<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>

  <title>Yapay Zeka ile Problem Çözümü</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  
  
  
  
</head>
<body>
<h1 id="yapay-zeka-ile-problem-çözümü">Yapay Zeka ile Problem Çözümü</h1>
<p>Zeka nedir? Bu kavramın tanımı uzun süre filozofları, matematikçileri ve en sonunda yazılım bilim adamlarını uğraştırdı.</p>
<p>Yapay Zeka olgusu, uzun bir değişim ve ne olduğunu tam bilmeyen bir süreçten geçerek bu günlere geldi. En sonunda üzerinde mutabakat kurulan tanım, yapay zekayı genel ve temel olarak iki kategoriye ayırdı.</p>
<p>Genel zeka altında, insanların bütün zihni güçlerini ve özelliklerini birgün bilgisayar ile kopyalama, yapabilme çabası var. Tabii ki bu arayış uzun bir zaman alacak.</p>
<p>Öteki dal temel zeka adı altında &quot;sadece belli problemler için özel&quot; algoritmalar yaratarak, problem çözebilen bir zeka türü peşinde koşmaktadır. Yani zeki bir vekil yaratıp onu problemin üzerine atmak, ya da ufak bir temsilcimizi, bize benzeyen ufak bir kısmımızı yaratıp, onu problem çözmek ile görevlendirmek diye nitelendirebileceğimiz bir zeka türüdür aranan.</p>
<p>Teknik olarak detaya inersek, gerçek zamanda, sürekli girdi bilgisi işleyerek hareket etmek zorunda olan zeka şeklini temel zeka altında inceliyoruz. Karar verme olgusu bu vekil zeka için çok önemlidir, özellikle belirsizlik altında bile karar verebilmek, vekil sistemler hayati önem taşır.</p>
<p>Örnek Problem</p>
<p>Araştırmacılar, yapay zeka kodlarını denemek için bir deney ortamı ararken, şunu düşündüler. Eğer hayat bir problemler dizisi, çözüm bekleyen sorunlar, takip etmemiz gereken kurallar, ve plan gerektiren çözümler içeriyorsa, bu ortamı benzetimlemenin en rahat yolu nedir?</p>
<p>Şans oyunları! Öyle ya, bir oyun hayatın ufak bir kopyası gibidir, kurallar içerir, bir amaç vardır, plan gerektirir. Yapay zeka araştırmalarının oyun oynamak üzerinde bu kadar durmasının sebebi budur.</p>
<p>8 Taş Oyunu</p>
<div class="figure">
<img src="8-puzzle-start.png" />

</div>
<p>Yukarıdaki 8 taş oyununu, bilgisayara şöyle tanımlayabiliriz. Başlangıç durumu olan taşları (solda) sonuç durumuna (sağa) dönüştürmek için gerekli olan taş hareketleri bul ve raporla kullanıcıya bildir. Bilgisayar bu sonuca birkac değişik algoritma takip ederek ulaşabilir.</p>
<p>Kör Arama</p>
<p>Kör, ya da mekanik, bir şekilde arama algoritmaları, başlangıç tahta durumu üzerinde yapılabilecek bütün taş hareketlerini işletir ve sonuç tahtasını kayıt eder. Mesela, başlangıç tahtasında 8 yukarı çıkabilir, 4 sağa gidebilir. (Not: Kodlama açısından daha rahat olması için her taşın hareketini değil, boşluğun hareketini baz almak daha rahat olur. Sonuç aynı, ama kodlama daha rahat. Yani, boşluk sola gidebilir, aşagı inebilir). Bu iki mümkün işlemden sonuç olarak iki yeni tahta çıkacak. Onların da üzerinde olası bütün işlemleri yaparsak, daha da fazla tahtalar çıkacak, vs. Bunu yaparken bir yandan sonuç tahtasına gelip gelmediğimizi kontrol edersek, kör bir arama algoritması yazmış olacağız.</p>
<p>Bu işlemlerin sonuçlarını bir ağaç veri yapısı olarak temsil etmek uygun olacak. Yani resimde görülen soldaki tahta üst düğüm, iki hareketten çıkan olası yeni tahtalar o üst düğümün iki çocuğu olarak gösterilebilir. Böyle giderek elimize bir ağaç yapısı çıkacak. Örneği aşağıda,</p>
<div class="figure">
<img src="8-puzzle-tree.png" />

</div>
<p>Ağaç yapısı, birazdan göreceğimiz bütün arama algoritmalarının temelini oluşturacak. Ama, bu ağacı yaratmanın değişik yolları var. Mesela, ağacın her katını mı önce oluşturmak istersiniz, yoksa bir dalı sonuna kadar derinliğine takip etmek, yoksa geri dönüp başka bir dalı mı tekrar derinliğine aramak istersiniz.</p>
<p>LISP'e Giriş</p>
<p>Bu iki yolu, LİSP örnek kodu ile derinliğine inceleyelim. LİSP en eski 2. bilgisayar dilidir, ve Yapay Zeka araştırmaları için yaratılmıştır. LİSP, fonksiyonları bile dinamik olarak yaratıp bildirgeç olarak işlemlere verebilen bir dildir. Bu esnek yapısı yapay zeka araştırmacılarının çok işine yaramıştır.</p>
<p>LISP dilinde temel veri yapısı &quot;listedir&quot;. Mesela, yukarıdaki başlangıç tahtasını LISP'de şöyle tanımlanabiliriz.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">(setf tahta<span class="op">-</span>baslangic <span class="st">&#39;((5 4 nil)(6 1 8)(7 3 2)))</span></code></pre></div>
<p>Bu kullanımda dikkat ederseniz, bir listenin listesini tanımladık. Yani, liste içeren bir liste. LISP referans kaynaklarından rahatça öğrenilebilir, böylece LISP'in çoğu işleminin liste yapısı üzerinde tanımlanan işlemler için olduğunu göreceksiniz. Zaten LISP'in ismi bile buradan gelir, LIST Processing, türkçesi &quot;liste işlemek&quot;.</p>
<p>Örnek diğer bazı liste işlemleri: (car liste) komutu listenin başındaki değeri, (cdr liste) listenin geri kalan kısmını verir. (nth 2 liste) listenin baştan 3. değerini getirir, (setf liste (append 'a liste)) liste değişkenine 'a harfini ekler, vs..</p>
<p>Ağac yapısındaki her düğümün, arama algoritması için, üst düğümünü hatırlaması gerekiyor. Ayrıca hangi taş kaydırma ile o tahta durumuna geldiğini de hatırlaması gerekiyor. Çünkü sonuca geldiğimizde, oradan tekrar başlangıca dönerek (üstü izleyerek) kaydırma işlemlerini ekrana basarak göstereceğiz. Algoritmanın da amacı bu değil mi? Bilgisayarın sonuca nasıl geldiğini bize göstermesi!</p>
<p>Bu sebeple, yeni büyütülmüş liste (listenin listesi) şu hale geldi. Örnek olarak boşluğu aşağı kaydırarak, geldiğimiz bir tahtayı şöyle gösterelim.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">;;</span> listenin icine bakabilen islemler
(Defun Durum (dugum) (first dugum))
(Defun Kaydir (dugum) (second dugum))
(Defun Ust (dugum) (third dugum))

<span class="op">;;</span> ornek bir tahta
(setq baslangic (((<span class="dv">1</span> <span class="dv">3</span> <span class="dv">2</span>)(<span class="dv">5</span> <span class="dv">4</span> <span class="dv">6</span>)(<span class="dv">7</span> <span class="dv">8</span> nil)) 
  <span class="st">&#39;asagi (((1 3 2)(5 4 nil)(7 8 6))))</span>

<span class="st">;; tahtayi ve islemleri kullanarak dugum hakkinda bazi raporlar</span>
<span class="st">(print &quot;kaydir islemi&quot;)</span>
<span class="st">(kaydir baslangic)</span>

<span class="st">(print &quot;ust dugum&quot;)</span>
<span class="st">(ust baslangic)</span>

<span class="st">(print &quot;tahta durumu&quot;)</span>
<span class="st">(durum baslangic)</span></code></pre></div>
<p>&quot;Üst&quot; düğümün, çocuk düğümü içine nasıl konduğunu görüyoruz. Ağaçta daha derine indikçe, liste içinde liste, onun içinde liste, onun da içinde liste gibi bu yapı daha da derinleşecektir. C ya da Java gibi dillerinde imleç (pointer) kullanarak aynı şey yapılabilir. Ama LISP bu ağaç yapısı için bile liste kullanıyor. Merak etmeyin, imleç kullanımı kadar da etkili oluyor.</p>
<p>Önce Genişliğine (Breadth-First) ve Önce Derinliğine (Depth-First) Arama</p>
<p>Ağaç yapısını tanımladıktan sonra, algoritmaya gelelim. Kat kat arama algoritmasında, çocuk düğümleri yarattıktan sonra onları &quot;işlenmek üzere beklettiğimiz&quot; bir listeye koyarız. (gene mi liste?) :)</p>
<p>Evet. Bu yapı üzerine ekleme yaparken, ya sonra, ya başa ekleme yapmak mümkün. Eğer sona koyarsak, çocuklar en son girdiği yerden en son çıkacak, eğer başa koyarsak girdiği gibi hemen çıkacaktır. Bu şekilde kullanımın birincisi, listeyi kuyruk (queue) olarak, ikincisi yığıt (stack) olarak kullanmak anlamına gelir. Yazılım bilimde bu iki olgu çok temeldir. Her algoritma kitabında kuyruklar ve yığıtlar hakkında bilgi alabilirsiniz. Sonuçta, çocukları yığıt üzerinde bekletmişsek, arama önce genişliğine arama olur, kuyruk olarak bekletmişsek arama &quot;önce derinliğine&quot; arama olur.</p>
<p>Bu iki arama şeklinin farkı niçin önemlidir? Burada esas sormamız gereken şu olacak. Hangi arama şekli daha başarılıdır?</p>
<p>Bu sorunun cevabı algoritmik analiz ile verilebilir, fakat özet olarak belirtmek gerekir ki, önce genişliğine aramak istatistiki olarak daha başarılı oluyor. Derinliğine arama, ek başka algoritmalar ile destekli olarak da başarılı olabiliyor.</p>
<p>Gereken Kodlar ve Programlar</p>
<p>Ekteki dosyalar LISP derleyicisi/yorumlayıcısi ve örnek kodlar içeriyor.</p>
<p>Önce genişliğine aramayı, derinliğine aramaya çevirmek için tek yapmanız gereken yığıtı, kuyruğa çevirmektir.</p>
<p>Bir önceki yapay zeka yazısı, akıllı bilgisayarlar hakkında hayal kırıklığı yaratmış olabilir. Sonuçta gösterdiğimiz algoritma, derinliğine ya da önce genişliğine arasa bile, &quot;bütün&quot; sonuçları deniyor! Yani insan ile yarışmak için aslında hafıza genişliğinden ve hesap hızından yararlanıyor. Peki nerede zeka?</p>
<p>Bunu düşündüyseniz haklısınız. Hakikaten de, bu ilk bahsettiğimiz algoritmalar &quot;kaba-kuvvet algoritmaları&quot; diye anılır. Direk ileri giderler, ve gayet mekanik şekilde sonuca ulaşmaya uğraşırlar.</p>
<p>Fakat, bir insan olarak biliyoruz ki, akıllı olmanın bir özelliği de öğrenmektir. Yani, bazı kısa yollar bulmak, bir takım dersler çıkartarak sonuca daha hızlı ulaşmayı sağlamak insanların gayet doğal yaptığı şeylerdir. Eğer bunlar kodlanmamışsa, oyun oynayan algoritmamız kaba kuvvetten daha ileri gidemeyecek. Üstelik büyük problemler için o üstün hızı bile yetişmeyebilir!</p>
<p>Pekala. Hadi o zaman şu programa biraz akıl verelim.</p>
<p>İzlenen Yolun Fiyatı</p>
<p>Algoritmamızın &quot;arama&quot; algoritmasını olarak isimlendirilmesinin sebebi, mümkün olan birçok seçenek arasından kısa olanı bulmak için &quot;arama&quot; yapmasıdır. Bilgisayarın önünde olan birçok seçeneğin her birinin fiyatı, yani uzunluğu, birbirinden farklıdır. Akıllı bir programa lazım olan, bu yollardan en kısa olanını bulmaktır. İnsanlar da, kendi düşüncelerini hızlandırmak için birtakım yan algoritmalar geliştirirler ve çabuk sonuca ulaşmaya uğraşırlar.</p>
<p>Bu fiyatı iki türlü ölçebiliriz. Birincisi, karar ağacında çözümü ararken o an üzerinde bulunduğumuz düğüme gelmek için ödediğimiz fiyat (katedilen yol), öteki de önümüzde katedeceğimiz geri kalan yoldur.</p>
<p>Katedilen yolun seçimde (arayışta) ne yararı var diye düşünebilirsiniz. Eklemek gerekir ki, özellikle önce-derinliğine arama algoritması bazen aynı düğüme değişik yollardan ulaşabiliyor. Bu gibi durumlarda tuttuğumuz kayıtlarda aynı düğümü bulursak, ve bu düğümün içerdiği yol daha pahalı ise, eskiyi listeden atıp, yerine yeni düğümü koymamız gerekiyor.</p>
<p>Nihayet akıllı bir &quot;seçim&quot; yaptık.</p>
<p>Fakat hala geriye bakıyoruz. İleriye bakarak, bilgili bir tahminde hala bulunmadık. İleriye dönük bir tahmin fonksiyonunu nasıl bilgisayarda kodlarız? 8'li Bulmaca oyununu düşünürsek; oyunun herhangi bir seviyesinde tahtaya bakarak, en iyi yapılacak hareketi nasıl bulabiliriz?</p>
<p>Akıllı Tahmin</p>
<p>Öyle bir fonksiyon bulalım ki, elimizde olan düğümden yarattığımız çocuk düğümler arasında hangisini takip edeceğimizi bize söylesin. Sözde program şöyle olabilir.</p>
<ul>
<li>Düğümü al</li>
<li>Düğümün bütün olası çocuklarını yarat</li>
<li>Her çocuk için, sonuç tahtasına olan tahmini bir uzaklık değeri hesapla</li>
<li>Bu çocuk düğümler arasında sonuca en yakın olanı seç</li>
</ul>
<p>Pekala, nedir bu uzaklık değeri? İşte akıl devreye burada giriyor.</p>
<p>Her tahta durumunun sonuca uzaklığı, tahmini olarak şöyle hesaplanabilir. Mesela, başlangıçtaki her taşı, sonuç tahtasına bakarak bulalım. Eğer sonuç tahtasındaki taş, başlangıçtaki aynı yerde değil ise, ne kadar uzakta olduğunu bulalım.</p>
<div class="figure">
<img src="8-puzzle-start.png" />

</div>
<p>Üstteki iki tahta arasında, bu uzaklık değeri &quot;5&quot; taşı için &quot;4&quot; olacaktır. Çünkü 1,1 eksen konumundan 3,3 konumuna gitmiştir. Ve aradaki fark 2 aşağı 2 sağa gittiğimiz için 4'tür. Bu tür uzaklık hesabına Manhattan uzaklığı deniyor, çünkü hepsi eşit bloklar arasında yürüyerek giderken ölçülen türden bir hesap çeşididir.</p>
<p>Bu uzaklık hesabı, bir nevi şunu beyan etmektir - bu tahtayı, sonuç tahtasına çevirmek için bu kadar hamle yapmak gerekiyor. Tabii ki bu hesap kesin bir hesap değildir. Tam doğru da değildir, ama, olması da gerekmez. Yeteri kadar doğru, ve en önemlisi, hiç bir zaman fazla keseden atmayan bir hesap doğru seçim için yeterlidir. Çünkü, aynı şekilde &quot;tam doğru olmayan hesapları&quot; öteki seçenekler için de yapıyoruz! Yani, birbirine olan izafi bir doğruluk, sayının tamamen doğru olması etkisi yapar.</p>
<p>LISP kodu</p>
<p>Ekteki kodlarda göreceğiniz gibi, LISP kodu için 2 tane fonksiyon tanımlamak gerekti. G-güncel değişkeni 'geriye bakan' türden olan fiyatı-sabit-arama algoritması için zaten gerekiyordu. Ekte olmayan, ama konu hakkında görebileceğiniz bir algoritma sırf tahmine dayanarak seçim yapmaya uğraşır, yani sadece t-guncel değerini kullanır. En güçlü olan yöntem, g-guncel ve t-guncel'in 'toplamına' dayanarak seçim yapmaktır. Böylece hem o ana kadar gözlediğimiz ölçümü, hem de ileriye bakarak yaptığımız tahmini aynı anda gözönüne almıs oluyoruz.</p>
<p>İki hesabın birleşimine dayanarak seçim yapan arama algoritmasına A* (a yıldız) algoritması denir. Bu kodu da a-yildiz-arama.lisp altında bulabilirsiniz.</p>
<p>Ayrıca, ödev olarak (yapay zeka dersi için) bizim kodladığımız, A*'ı kendi akıl fonksiyonu ile genişletip, kendi t-guncel kodunu yazmamız gerekiyordu.</p>
<p>Bu yeni A* t-guncel hesabı, hem taş uzaklığına dayanıyor, fakat bir toplam daha ekliyor. Eğer iki taşı değiş tokuş yaptırmamız gerekiyorsa, bu normal uzaklıktan çok daha pahalı bir işlemdir, ve 2 sayılması gerekir! Bu şekilde yapılan toplamın, ve akabinde t-guncel değerinin, algoritmayı daha geliştirdiğini göreceksiniz.</p>
<p>Yani biraz daha akıl kullanarak, işimizi kolaylaştırmış oluyoruz.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">(defvar s0)
(defvar s1)
(defvar hata<span class="op">-</span>bulma<span class="op">-</span>seansi nil)
(defvar kaydir<span class="op">-</span>sayisi <span class="dv">0</span>)

(Defun Durum (dugum) (first dugum)) 
(Defun Kaydir (dugum) (second dugum)) 
(Defun Ust (dugum) (third dugum)) 
(defun nx (durum) (nth <span class="dv">0</span> (nth <span class="dv">4</span> durum)) )
(defun ny (durum) (nth <span class="dv">1</span> (nth <span class="dv">4</span> durum)) )

(defun nil<span class="op">-</span>yerini<span class="op">-</span>guncellestir (dugum x y)
  (setf dugum (remove (<span class="bu">list</span> (nx dugum) (ny dugum)) 
              dugum :test <span class="co">#&#39;equal ))</span>
  (setf dugum (append dugum (<span class="bu">list</span> (<span class="bu">list</span> x y))))
  )

<span class="op">;;</span>
<span class="op">;;</span> X ve Y eksen degerlerine bore liste uzerinde degis tokus 
<span class="op">;;</span> yap. Boylece LISP<span class="st">&#39;de cok kullanilan bir suru car ve cdr </span>
<span class="st">;; kullanmaya gerek kalmiyor. </span>
<span class="st">;;</span>
<span class="st">(defun degis-tokus-xy (matris x1 y1 x2 y2)</span>
<span class="st">  (let (( gecici (nth y1 (nth x1 matris))))</span>
<span class="st">    (setf (nth y1 (nth x1 matris)) (nth y2 (nth x2 matris)))</span>
<span class="st">    (setf (nth y2 (nth x2 matris)) gecici)</span>
<span class="st">    matris</span>
<span class="st">  ))</span>

<span class="st">;;</span>
<span class="st">;; Eger verilen noktada MIL var ise, geriye T (dogru) cevabi gonder.</span>
<span class="st">(defun null-xy(matris x y)</span>
<span class="st">  (null (nth y (nth x matris))))</span>


<span class="st">;;</span>
<span class="st">;; cocuklari toplayan (yaratan) islem.</span>
<span class="st">;;</span>
<span class="st">(defun cocuklari-getiren-islem (dugum) </span>
<span class="st">(let ( (result-son-dugums nil) (son-durum nil) (durum (first dugum)) )</span>

<span class="st">  (setf son-durum (kaydir-yukari durum))</span>
<span class="st">  (setf result-son-dugums (list (list son-durum &#39;</span>yukari dugum)))
  
  (setf son<span class="op">-</span>durum (kaydir<span class="op">-</span>asagi durum))
  (setf result<span class="op">-</span>son<span class="op">-</span>dugums
    (append result<span class="op">-</span>son<span class="op">-</span>dugums (<span class="bu">list</span> (<span class="bu">list</span> son<span class="op">-</span>durum <span class="st">&#39;asagi dugum))))</span>
<span class="st">  </span>
<span class="st">  (setf son-durum (kaydir-saga durum))</span>
<span class="st">  (setf result-son-dugums</span>
<span class="st">    (append result-son-dugums (list (list son-durum &#39;</span>saga dugum))))
  
  (setf son<span class="op">-</span>durum (kaydir<span class="op">-</span>sola durum))
  (setf result<span class="op">-</span>son<span class="op">-</span>dugums
    (append result<span class="op">-</span>son<span class="op">-</span>dugums (<span class="bu">list</span> (<span class="bu">list</span> son<span class="op">-</span>durum <span class="st">&#39;sola dugum))))</span>

<span class="st">  (setq kaydir-sayisi (+ kaydir-sayisi (length result-son-dugums)))</span>
<span class="st">  </span>
<span class="st">  result-son-dugums)) ;;and that&#39;</span>s it Son<span class="op">-</span>dugums <span class="kw">is</span> returned  
                      <span class="op">;;</span>by the function 

<span class="op">;;</span>
<span class="op">;;</span> copy wan<span class="st">&#39;t provided in my version of lisp.</span>
<span class="st">;;</span>
<span class="st">(defun copy (obj)</span>
<span class="st"> (cond ( (null obj) nil)</span>
<span class="st">       ( (listp obj)  (cons  (copy (first obj)) (copy (rest obj))))</span>
<span class="st">       ( t obj) ) )</span>

<span class="st">;;</span>
<span class="st">;; My lisp has not defined this macro</span>
<span class="st">;;</span>
<span class="st">(defun caadddr (x)</span>
<span class="st">  (car(car(cdr(cdr(cdr x))))))</span>

<span class="st">;;</span>
<span class="st">;; the yukari kaydir</span>
<span class="st">(defun kaydir-yukari (Ust-durum)</span>
<span class="st">  (let ((durum (copy Ust-durum))) </span>
<span class="st">    (cond </span>
<span class="st">     ((eql (nx durum) 0) nil) </span>
<span class="st">     (t</span>
<span class="st">      (degis-tokus-xy durum</span>
<span class="st">           (- (nx durum) 1)</span>
<span class="st">           (ny durum)</span>
<span class="st">           (nx durum)</span>
<span class="st">           (ny durum))</span>
<span class="st">      (setf durum (nil-yerini-guncellestir durum (- (nx durum) 1) </span>
<span class="st">                       (ny durum)))</span>
<span class="st">      )</span>
<span class="st">     )</span>
<span class="st">    durum))</span>

<span class="st">;;</span>
<span class="st">;; the asagi kaydir</span>
<span class="st">(defun kaydir-asagi (Ust-durum)</span>
<span class="st">  (let ((durum (copy Ust-durum))) </span>
<span class="st">    (cond </span>
<span class="st">     ((eql (nx durum) 3) nil)</span>
<span class="st">     (t</span>
<span class="st">      (degis-tokus-xy durum</span>
<span class="st">           (+ 1 (nx durum))</span>
<span class="st">           (ny durum)</span>
<span class="st">           (nx durum)</span>
<span class="st">           (ny durum))</span>
<span class="st">      (setf durum (nil-yerini-guncellestir </span>
<span class="st">           durum (+ (nx durum) 1) (ny durum)))))</span>
<span class="st">    durum))</span>

<span class="st">;;</span>
<span class="st">;; the saga kaydir</span>
<span class="st">(defun kaydir-saga (Ust-durum)</span>
<span class="st">  (let ((durum (copy Ust-durum))) </span>
<span class="st">    (cond </span>
<span class="st">     ((eql (ny durum) 3) nil)</span>
<span class="st">     (t</span>
<span class="st">      (degis-tokus-xy durum</span>
<span class="st">           (nx durum)</span>
<span class="st">           (+ 1 (ny durum))</span>
<span class="st">           (nx durum)</span>
<span class="st">           (ny durum))</span>
<span class="st">    (setf durum (nil-yerini-guncellestir </span>
<span class="st">         durum (nx durum) (+ 1 (ny durum))))))</span>

<span class="st">    durum))</span>

<span class="st">;;</span>
<span class="st">;; the sola kaydir</span>
<span class="st">(defun kaydir-sola (Ust-durum) </span>
<span class="st">  (let ((durum (copy Ust-durum))) </span>
<span class="st">    (cond </span>
<span class="st">     ((eql (ny durum) 0) nil)</span>
<span class="st">     (t</span>
<span class="st">      (degis-tokus-xy durum</span>
<span class="st">           (nx durum)</span>
<span class="st">           (- (ny durum) 1)</span>
<span class="st">           (nx durum)</span>
<span class="st">           (ny durum))</span>
<span class="st">      (setf durum (nil-yerini-guncellestir </span>
<span class="st">           durum (nx durum) (- (ny durum) 1) ))))</span>
<span class="st">    durum))</span>

<span class="st">;;</span>
<span class="st">;; Trace</span>
<span class="st">(defun sonuc-izini-bul (dugum)</span>
<span class="st">  (cond ((null dugum) (print &quot;Cozumun Baslangici&quot;) nil) </span>
<span class="st">    (t </span>
<span class="st">     (sonuc-izini-bul (Ust dugum)) </span>
<span class="st">     (print (Kaydir dugum)))))</span>

<span class="st">;;</span>
<span class="st">;; funds the difference between two sets</span>
<span class="st">(defun diff (x y)</span>
<span class="st">  (cond ((null x) nil)</span>
<span class="st">    ((not (member (first x) y  :test #&#39;</span>equal ))
     (cons (first x)
           (diff (rest x) y)))
    (t (diff (rest x) y))))

<span class="op">;;</span>
<span class="op">;;</span> show <span class="co"># of elements in lists and number of dugums generated.</span>
(defun sonuc<span class="op">-</span>raporu<span class="op">-</span>ver (acik tamamlanan baslangic)
  (<span class="bu">print</span> <span class="st">&quot;ACIK listesindeki dugum sayisi&quot;</span>)
  (<span class="bu">print</span> (length acik))
  (<span class="bu">print</span> <span class="st">&quot;TAMAMLANAN listesindeki dugum sayisi&quot;</span>)
  (<span class="bu">print</span> (length tamamlanan))
  (<span class="bu">print</span> <span class="st">&quot;Toplam Yaratilan Dugum Sayisi&quot;</span>)
  (<span class="bu">print</span> kaydir<span class="op">-</span>sayisi)
  )

<span class="op">;;</span>
<span class="op">;;</span> show <span class="co"># of elements depending on the debug flag status</span>
(defun kac<span class="op">-</span>dugum<span class="op">-</span>yarattik()
  (when (eql hata<span class="op">-</span>bulma<span class="op">-</span>seansi T)
    (<span class="bu">print</span> <span class="st">&quot;Su anda hafizada bu kadar dugum var&quot;</span>)
    (<span class="bu">print</span> kaydir<span class="op">-</span>sayisi))
  )

<span class="op">;;</span>
<span class="op">;;</span> test evaluator function
(defun test (isim exp sonuc)
  (cond
   ((equal exp sonuc) t)
   (t (<span class="bu">print</span> isim) (error <span class="st">&quot;HATA! Birim test calismadi! &quot;</span>))  
   ))

<span class="op">;;</span>
<span class="op">;;</span> tests
<span class="op">;;</span>
(setq s0 <span class="st">&#39;((1 3 3 1) (2 6 4 1) (5 8 2 1)))</span>
<span class="st">(test &quot;copy&quot; (copy s0) &#39;</span>((<span class="dv">1</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">1</span>) (<span class="dv">2</span> <span class="dv">6</span> <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">5</span> <span class="dv">8</span> <span class="dv">2</span> <span class="dv">1</span>)))

(setq s0 <span class="st">&#39;((1 3 3) (2 6 4) (5 8 nil)(2 2)))</span>
<span class="st">(test &quot;degis-tokus xy 1&quot; (degis-tokus-xy s0 2 2 1 2) </span>
<span class="st">      &#39;</span>((<span class="dv">1</span> <span class="dv">3</span> <span class="dv">3</span>) (<span class="dv">2</span> <span class="dv">6</span> NIL) (<span class="dv">5</span> <span class="dv">8</span> <span class="dv">4</span>)(<span class="dv">2</span> <span class="dv">2</span>)))

(setq s0 <span class="st">&#39;((1 3 3) (2 6 4) (5 8 nil)(2 2)))</span>
<span class="st">(test &quot;null xy&quot; (null-xy s0 2 2) t)</span>

<span class="st">(setq s0 &#39;</span>((<span class="dv">1</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">1</span>) (<span class="dv">2</span> <span class="dv">6</span> <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">5</span> <span class="dv">8</span> nil <span class="dv">1</span>)(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>)(<span class="dv">2</span> <span class="dv">2</span>)))
(test <span class="st">&quot;yukari kaydir 1 test&quot;</span> (kaydir<span class="op">-</span>yukari s0)
      <span class="st">&#39;((1 3 3 1)(2 6 nil 1)(5 8 4 1)(1 1 1 1)(1 2)))</span>

<span class="st">(setq s0 &#39;</span>((<span class="dv">1</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">1</span>) (<span class="dv">2</span> <span class="dv">6</span> <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">5</span> nil <span class="dv">4</span> <span class="dv">1</span>)(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>)(<span class="dv">2</span> <span class="dv">1</span>)))
(test <span class="st">&quot;yukari kaydir 2 test&quot;</span> (kaydir<span class="op">-</span>yukari s0)
      <span class="st">&#39;((1 3 3 1)(2 nil 4 1)(5 6 4 1)(1 1 1 1)(1 1)))</span>

<span class="st">(setq s0 &#39;</span>((<span class="dv">1</span> <span class="dv">3</span> nil <span class="dv">1</span>) (<span class="dv">2</span> <span class="dv">6</span> <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">5</span> <span class="dv">8</span> <span class="dv">4</span> <span class="dv">1</span>)(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>)(<span class="dv">0</span> <span class="dv">2</span>)))
(test <span class="st">&quot;asagi kaydir 1 test&quot;</span> (kaydir<span class="op">-</span>asagi s0)
      <span class="st">&#39;((1 3 4 1)(2 6 nil 1)(5 8 4 1)(1 1 1 1)(1 2)))</span>

<span class="st">(setq s0 &#39;</span>((<span class="dv">1</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">1</span>)(<span class="dv">2</span> <span class="dv">6</span> <span class="dv">4</span> <span class="dv">1</span>)(<span class="dv">5</span> <span class="dv">8</span> nil <span class="dv">1</span>)(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>)(<span class="dv">2</span> <span class="dv">2</span>)))
(test <span class="st">&quot;degis-tokus xy 2&quot;</span> (degis<span class="op">-</span>tokus<span class="op">-</span>xy s0 <span class="dv">1</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">1</span>)
      <span class="st">&#39;((1 3 3 1)(2 8 4 1)(5 6 nil 1)(1 1 1 1)(2 2)))</span>

<span class="st">(setq s0 &#39;</span>((<span class="dv">1</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">1</span>) (<span class="dv">2</span> nil <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">5</span> <span class="dv">5</span> <span class="dv">4</span> <span class="dv">1</span>)(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>)(<span class="dv">1</span> <span class="dv">1</span>)))
(test <span class="st">&quot;asagi kaydir 2 test&quot;</span> (kaydir<span class="op">-</span>asagi s0)
      <span class="st">&#39;((1 3 3 1)(2 5 4 1)(5 nil 4 1)(1 1 1 1)(2 1)))</span>

<span class="st">(setq s0 &#39;</span>((<span class="dv">1</span> nil <span class="dv">3</span> <span class="dv">1</span>) (<span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">5</span> <span class="dv">5</span> <span class="dv">4</span> <span class="dv">1</span>)(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>)(<span class="dv">0</span> <span class="dv">1</span>)))
(test <span class="st">&quot;saga kaydir 1 test&quot;</span> (kaydir<span class="op">-</span>saga s0)
      <span class="st">&#39;((1 3 nil 1)(2 3 4 1)(5 5 4 1)(1 1 1 1)(0 2)))</span>

<span class="st">(setq s0 &#39;</span>((<span class="dv">1</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">1</span>) (<span class="dv">2</span> nil <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">5</span> <span class="dv">5</span> <span class="dv">4</span> <span class="dv">1</span>)(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>)(<span class="dv">1</span> <span class="dv">1</span>)))
(test <span class="st">&quot;saga kaydir 2 test&quot;</span> (kaydir<span class="op">-</span>saga s0)
      <span class="st">&#39;((1 3 3 1)(2 4 nil 1)(5 5 4 1)(1 1 1 1)(1 2)))</span>

<span class="st">(setq s0 &#39;</span>((<span class="dv">1</span> nil <span class="dv">3</span> <span class="dv">1</span>) (<span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">5</span> <span class="dv">5</span> <span class="dv">4</span> <span class="dv">1</span>)(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>)(<span class="dv">0</span> <span class="dv">1</span>)))
(test <span class="st">&quot;sola kaydir 1 test&quot;</span> (kaydir<span class="op">-</span>sola s0)
      <span class="st">&#39;((nil 1 3 1)(2 3 4 1)(5 5 4 1)(1 1 1 1)(0 0)))</span>

<span class="st">(setq s0 &#39;</span>((<span class="dv">1</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">1</span>) (<span class="dv">2</span> nil <span class="dv">4</span> <span class="dv">1</span>)(<span class="dv">5</span> <span class="dv">5</span> <span class="dv">4</span> <span class="dv">1</span>)(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>)(<span class="dv">1</span> <span class="dv">1</span>)))
(test <span class="st">&quot;sola kaydir 2 test&quot;</span> (kaydir<span class="op">-</span>sola s0)
      <span class="st">&#39;((1 3 3 1)(nil 2 4 1)(5 5 4 1)(1 1 1 1)(1 0)))</span>

<span class="st">(setq s0 &#39;</span>((<span class="dv">1</span> <span class="dv">3</span> <span class="dv">3</span>) (<span class="dv">2</span> nil <span class="dv">4</span>) (<span class="dv">5</span> <span class="dv">5</span> <span class="dv">4</span>)))
(setq s0 (append s0 <span class="st">&#39;((2 3 4))))</span>
<span class="st">(test &quot;ekleme testi&quot; s0 &#39;</span>((<span class="dv">1</span> <span class="dv">3</span> <span class="dv">3</span>) (<span class="dv">2</span> nil <span class="dv">4</span>) (<span class="dv">5</span> <span class="dv">5</span> <span class="dv">4</span>)(<span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>)) )

(setq s0 <span class="st">&#39;((1 3 3 1) (2 nil 4 1) (5 5 4 1)(1 1 1 1)(1 1)))</span>
<span class="st">(setq s0 (list s0 nil nil))</span>
<span class="st">(setq s1 &#39;</span>((((<span class="dv">1</span> NIL <span class="dv">3</span> <span class="dv">1</span>) (<span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">5</span> <span class="dv">5</span> <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>) (<span class="dv">0</span> <span class="dv">1</span>)) YUKARI
        (((<span class="dv">1</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">1</span>) (<span class="dv">2</span> NIL <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">5</span> <span class="dv">5</span> <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>) (<span class="dv">1</span> <span class="dv">1</span>)) NIL NIL))
       (((<span class="dv">1</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">1</span>) (<span class="dv">2</span> <span class="dv">5</span> <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">5</span> NIL <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>) (<span class="dv">2</span> <span class="dv">1</span>)) ASAGI
        (((<span class="dv">1</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">1</span>) (<span class="dv">2</span> NIL <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">5</span> <span class="dv">5</span> <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>) (<span class="dv">1</span> <span class="dv">1</span>)) NIL NIL))
       (((<span class="dv">1</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">1</span>) (<span class="dv">2</span> <span class="dv">4</span> NIL <span class="dv">1</span>) (<span class="dv">5</span> <span class="dv">5</span> <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>) (<span class="dv">1</span> <span class="dv">2</span>)) SAGA
        (((<span class="dv">1</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">1</span>) (<span class="dv">2</span> NIL <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">5</span> <span class="dv">5</span> <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>) (<span class="dv">1</span> <span class="dv">1</span>)) NIL NIL))
       (((<span class="dv">1</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">1</span>) (NIL <span class="dv">2</span> <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">5</span> <span class="dv">5</span> <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>) (<span class="dv">1</span> <span class="dv">0</span>)) SOLA
        (((<span class="dv">1</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">1</span>) (<span class="dv">2</span> NIL <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">5</span> <span class="dv">5</span> <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>) (<span class="dv">1</span> <span class="dv">1</span>)) NIL NIL))))
(test <span class="st">&quot;cocuk dugum bulucu islemi test&quot;</span> (cocuklari<span class="op">-</span>getiren<span class="op">-</span>islem s0) s1)


(setq s0 <span class="st">&#39;((1 NIL 3 1) (2 3 4 1) (5 5 4 1)(1 1 1 1)(0 1)))</span>
<span class="st">(setq s1 &#39;</span>((<span class="dv">1</span> NIL <span class="dv">3</span> <span class="dv">1</span>) (<span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">5</span> <span class="dv">5</span> <span class="dv">4</span> <span class="dv">1</span>)(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>)(<span class="dv">0</span> <span class="dv">1</span>)))
(test <span class="st">&quot;durum equality&quot;</span> (equal s0 s1) t)

(setq s0 <span class="st">&#39;(((1 NIL 3 1) (2 3 4 1) (5 5 4 1)(1 1 1 1))</span>
<span class="st">       YUKARI (((1 3 3 1) (2 NIL 4 1) (5 5 4 1)(1 1 1 1)) NIL NIL)))</span>
<span class="st">(test &quot;durum test&quot; (equal (durum s0)</span>
<span class="st">              &#39;</span>((<span class="dv">1</span> NIL <span class="dv">3</span> <span class="dv">1</span>) (<span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">5</span> <span class="dv">5</span> <span class="dv">4</span> <span class="dv">1</span>)(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>))) t)

(setf s0 <span class="st">&#39;((((1 3 3 1) (2 NIL 4 1) (5 5 4 1)(1 1 1 1 )(1 1)) NIL NIL)</span>
<span class="st">       (((1 3 3 1) (2 3 4 1) (5 5 4 1)(1 1 1 1)(1 1)) NIL NIL)</span>
<span class="st">       (((1 3 3 1) (2 5 4 1) (5 5 4 1)(1 1 1 1)(1 1)) NIL NIL)))</span>
<span class="st">(setq s1 &#39;</span>((((<span class="dv">1</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">1</span>) (<span class="dv">2</span> NIL <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">5</span> <span class="dv">5</span> <span class="dv">4</span> <span class="dv">1</span>)(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>)(<span class="dv">1</span> <span class="dv">1</span>)) NIL NIL)
       (((<span class="dv">1</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">1</span>) (<span class="dv">2</span> <span class="dv">5</span> <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">6</span> <span class="dv">6</span> <span class="dv">6</span> <span class="dv">1</span>)(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>)(<span class="dv">1</span> <span class="dv">1</span>)) NIL NIL)) )
(test <span class="st">&quot;diff test&quot;</span> (diff s1 s0)
      <span class="st">&#39;((((1 3 3 1) (2 5 4 1) (6 6 6 1)(1 1 1 1)(1 1)) NIL NIL))   )</span>

<span class="st">(print &quot;OLDU. Ortak Birim Testler Basari Ile Calisti&quot;)</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">(load <span class="st">&quot;ortak.lisp&quot;</span>)

<span class="op">;;</span>
<span class="op">;;</span> her kati arayip, bitince sonraki katta arama yapmak. 
(defun kat<span class="op">-</span>kat<span class="op">-</span>ara (d0 ds cocuklar)

  <span class="op">;;</span> dikkat edin, icerideki liste bir dugum
  (let ( ( acik (<span class="bu">list</span> (<span class="bu">list</span> d0 nil nil) ) ) 
     ( tamamlanmis nil ) 
     ( n nil ) 
     ( kizlar nil )) 
    (setq kaydir<span class="op">-</span>sayisi <span class="dv">0</span>)
    (loop 
     (<span class="cf">if</span> (null acik) (<span class="cf">return</span> <span class="st">&#39;hata)) ;;hata var, geri rapor ver</span>
<span class="st">       </span>
<span class="st">     (setf n (pop acik)) ;; ilk dugumu cikart</span>

<span class="st">     ;; tamamlanmis listesine n dugumunu koy, cunku birazdan onu </span>
<span class="st">     ;; isleyecegiz</span>
<span class="st">     (push n tamamlanmis) </span>

<span class="st">     ;; sonuc dugumune geldik mi? (bulduk mu?)</span>
<span class="st">     (when (equal (durum n) ds)</span>
<span class="st">       (print &quot;Sonuc bulundu. Nasil buldugumuz asagida&quot;)</span>
<span class="st">       (sonuc-raporu-ver acik tamamlanmis d0)</span>
<span class="st">       (return (sonuc-izini-bul n))</span>
<span class="st">       )</span>

<span class="st">     ;; iste burada yeni cocuk dugumler cikartiyoruz</span>
<span class="st">     (setf kizlar (apply cocuklar (list n)))</span>

<span class="st">     ;; hata ayiklama icin lazim olabilir</span>
<span class="st">     (kac-dugum-yarattik)</span>

<span class="st">     ;; iki kere tekrar eden dugumleri cikar. (DIFF=fark demektir, iki</span>
<span class="st">     ;; liste arasindaki benzerleri cikartir, farki getirir.</span>
<span class="st">     (setf kizlar </span>
<span class="st">       (DIFF kizlar (append acik tamamlanmis))) </span>

<span class="st">     ;; dikkat: yeni dugumleri listenin SONUNA koyuyoruz yazilim</span>
<span class="st">     ;; bilimde buna &#39;</span>kuyruk<span class="st">&#39; veri yapisi denir. Yani, kuyruga son</span>
<span class="st">     ;; giren, son cikar. Yukarida &#39;</span>pop (cikart)<span class="st">&#39; deyince su anda</span>
<span class="st">     ;; koydugumuz deger gelmeyecek. (liste dolu ise). Eger bu noktada</span>
<span class="st">     ;; kuyruk yapisi kullaniliyorsa, bu algoritmayi kat-kat arama</span>
<span class="st">     ;; haline cevirecek.</span>
<span class="st">     (setf acik (append acik kizlar))   </span>

<span class="st">    )))</span>

<span class="st">;;</span>
<span class="st">;; testler</span>
<span class="st">;;</span>
<span class="st">(setq d0 &#39;</span>((<span class="dv">1</span> NIL <span class="dv">3</span> <span class="dv">1</span>) (<span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">5</span> <span class="dv">5</span> <span class="dv">4</span> <span class="dv">1</span>)(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>)(<span class="dv">0</span> <span class="dv">1</span>)))
(setq ds <span class="st">&#39;((1 3 4 1) (2 3 NIL 1) (5 5 4 1)(1 1 1 1)(1 2)))</span>
<span class="st">(test &quot;basit kat-kat-ara&quot;</span>
<span class="st">      (not (eql (kat-kat-ara d0 ds #&#39;</span>cocuklari<span class="op">-</span>getiren<span class="op">-</span>islem) <span class="st">&#39;hata)) t )</span>

<span class="st">(print &quot;OLDU. KAT-KAT-ARA Testleri Calisti&quot;)</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">(load <span class="st">&quot;ortak.lisp&quot;</span>)

(defun kat<span class="op">-</span>engelli<span class="op">-</span>da (node goal succesors depth)

  <span class="op">;;</span>Hmmmm...where did Open, Closed <span class="kw">and</span> N go?
  (block
   DBDFS (let ((daughters nil) )
       
       (<span class="cf">if</span> (equal (durum node) goal)
           (<span class="cf">return</span><span class="op">-</span><span class="im">from</span> DBDFS (sonuc<span class="op">-</span>izini<span class="op">-</span>bul node)))

       <span class="op">;;</span>bottomed out <span class="kw">in</span> the search space
       (<span class="cf">if</span> (<span class="op">=</span> depth <span class="dv">1</span>) (<span class="cf">return</span><span class="op">-</span><span class="im">from</span> DBDFS nil)) 
       <span class="op">;;</span>without finding a goal down this path

       <span class="op">;;</span>presumably we have a LIST of derived
       (setf daughters (cocuklari<span class="op">-</span>getiren<span class="op">-</span>islem node))
       <span class="op">;;</span>here we generate new derived durums

       <span class="op">;;</span> debugging
       (kac<span class="op">-</span>dugum<span class="op">-</span>yarattik)

       (loop <span class="op">;;</span>so we iterate down them looking <span class="cf">for</span> 
        <span class="op">;;</span>a solution path...this could easily
        <span class="op">;;</span>be changed to a do form....

        <span class="op">;;</span>failed to find a solution
        (<span class="cf">if</span> (null daughters) (<span class="cf">return</span><span class="op">-</span><span class="im">from</span> DBDFS nil))

        (<span class="cf">if</span> (kat<span class="op">-</span>engelli<span class="op">-</span>da <span class="op">;;</span>recursive call <span class="cf">with</span>
         (pop daughters) <span class="op">;;</span>the first of daughters<span class="op">&amp;</span> daughters updated
         goal <span class="op">;;</span>same old goal durum
         daughters <span class="op">;;</span>same old <span class="bu">set</span> of operators
         (<span class="op">-</span> depth <span class="dv">1</span>)) <span class="op">;;</span>but a shallower depth<span class="op">!</span>

        <span class="op">;;</span>here we did find a solution so we leave happy
        (<span class="cf">return</span><span class="op">-</span><span class="im">from</span> DBDFS t)

          ) <span class="op">;;;;</span>end <span class="cf">if</span>
        ) <span class="op">;;;;</span>ends loop
       ) <span class="op">;;</span>ends let
   ) <span class="op">;;</span> ends block
  ) <span class="op">;;</span>ends defun  {otherwise known <span class="im">as</span> <span class="st">&quot;]&quot;</span>  :)  }


<span class="op">;;</span>
<span class="op">;;</span> outside method
<span class="op">;;</span>
(defun kat<span class="op">-</span>kat<span class="op">-</span>arama (d0 ds cocuklar derinlik<span class="op">-</span>limiti)
  (setf kaydir<span class="op">-</span>sayisi <span class="dv">0</span>)
  (kat<span class="op">-</span>engelli<span class="op">-</span>da (<span class="bu">list</span> d0 nil nil) ds cocuklar derinlik<span class="op">-</span>limiti)
  (<span class="bu">print</span> <span class="st">&quot;kac dugum yaratildi&quot;</span>)
  (<span class="bu">print</span> kaydir<span class="op">-</span>sayisi)
  )

<span class="op">;;</span>
<span class="op">;;</span> outside method <span class="cf">for</span> iterative deepening
<span class="op">;;</span>
(defun gitgide<span class="op">-</span>icin<span class="op">-</span>kka (d0 dg cocuklar derinlik<span class="op">-</span>limiti)
  (kat<span class="op">-</span>engelli<span class="op">-</span>da (<span class="bu">list</span> d0 nil nil) ds cocuklar derinlik<span class="op">-</span>limiti)
  )


<span class="op">;;</span>
<span class="op">;;</span> tests
<span class="op">;;</span>
(setq s0 <span class="st">&#39;((1 NIL 3 1) (2 3 4 1) (5 5 4 1)(1 1 1 1)(0 1)))</span>
<span class="st">(setq s1 &#39;</span>((<span class="dv">1</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">2</span> <span class="dv">3</span> NIL <span class="dv">1</span>) (<span class="dv">5</span> <span class="dv">5</span> <span class="dv">4</span> <span class="dv">1</span>)(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>)(<span class="dv">1</span> <span class="dv">2</span>)))
(test <span class="st">&quot;kka derinlik limiti&quot;</span> (<span class="kw">not</span> (eql (kat<span class="op">-</span>kat<span class="op">-</span>arama s0 s1 nil <span class="dv">3</span>) <span class="st">&#39;fail)) t )</span>

<span class="st">(print &quot;OLDU. Kat Engelli Kat-Kat Arama Basari Ile Gecti&quot;)</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">(load <span class="st">&quot;ortak.lisp&quot;</span>)

(defun iki<span class="op">-</span>yonlu<span class="op">-</span>ara (di ds ileriden<span class="op">-</span>cocuklar geriden<span class="op">-</span>cocuklar)
  (let ( ( acik<span class="op">-</span>i   (<span class="bu">list</span>  (<span class="bu">list</span> di nil nil) ) ) <span class="op">;;</span>dikkat ic liste bir
                         <span class="op">;;</span>dugum
     ( acik<span class="op">-</span>g   (<span class="bu">list</span>  (<span class="bu">list</span> ds nil nil) ) ) 
     <span class="op">;;</span>tamamlanan listesine ihtiyac yok
     ( nf      nil )
     ( nb      nil )
     ( kizlar<span class="op">-</span>i nil )
     ( kizlar<span class="op">-</span>g nil )
     ( ortak<span class="op">-</span>dugum nil  ))

    (setq kaydir<span class="op">-</span>sayisi <span class="dv">0</span>)
    
    (loop
     (cond
      ((<span class="kw">or</span> (null acik<span class="op">-</span>i) (null acik<span class="op">-</span>g)) <span class="op">;;</span>arama uzayini bitirdik mi?
       (<span class="bu">print</span> <span class="st">&quot;Sorry, the problem posed is insoluable&quot;</span>)
       (<span class="cf">return</span> nil)))

     <span class="op">;;</span>Evet. Ilk dugumu cikart ve Acik listeyi guncellestir
     (setf nf (pop acik<span class="op">-</span>i)) 

     <span class="op">;;</span>agaclar icin tamamlanan listesine ihtiyac yok
     (setf ortak<span class="op">-</span>dugum (member nf acik<span class="op">-</span>g :test <span class="co">#&#39;durum-karsilastirici))</span>
     (when ortak<span class="op">-</span>dugum
       <span class="op">;;</span> bu dugumu, geri gelen tarafta bulduk mu?
       (<span class="bu">print</span> <span class="st">&quot;Harika. Sonuc Bulundu:&quot;</span>)
       (sonuc<span class="op">-</span>izini<span class="op">-</span>bul nf)
       (sonuc<span class="op">-</span>izini<span class="op">-</span>bul<span class="op">-</span>geri (first ortak<span class="op">-</span>dugum))
       (sonuc<span class="op">-</span>raporu<span class="op">-</span>ver acik<span class="op">-</span>i acik<span class="op">-</span>g nil nil)
       (<span class="cf">return</span> ortak<span class="op">-</span>dugum))
     
     <span class="op">;;</span> burada yeni dugumler cikartiyoruz
     (setf kizlar<span class="op">-</span>i (<span class="bu">apply</span> ileriden<span class="op">-</span>cocuklar (<span class="bu">list</span> nf)))

     <span class="op">;;</span> hata bulmak icin rapor
     (kac<span class="op">-</span>dugum<span class="op">-</span>yarattik)
     
     <span class="op">;;</span> acik liste kuyruk olarak kullaniliyor, o yuzden algoritma
     <span class="op">;;</span> esasen kat<span class="op">-</span>kat arama.
     (setf acik<span class="op">-</span>i (append acik<span class="op">-</span>i kizlar<span class="op">-</span>i)) 

     <span class="op">;;</span>Tamam, ilk dugumu cikar, acik listeyi guncellestir
     (setf nb (pop acik<span class="op">-</span>g)) 

     (setf ortak<span class="op">-</span>dugum (member nb acik<span class="op">-</span>i  :test <span class="co">#&#39;durum-karsilastirici))</span>
     (when ortak<span class="op">-</span>dugum
       <span class="op">;;</span> durum, ileri giden kisimda bulundu mu?
       (<span class="bu">print</span> <span class="st">&quot;Harika. Sonuc Bulundu:&quot;</span>)
       (sonuc<span class="op">-</span>izini<span class="op">-</span>bul nb)
       (sonuc<span class="op">-</span>izini<span class="op">-</span>bul<span class="op">-</span>geri (first ortak<span class="op">-</span>dugum))
       (sonuc<span class="op">-</span>raporu<span class="op">-</span>ver acik<span class="op">-</span>i acik<span class="op">-</span>g nil nil)
       (<span class="cf">return</span> ortak<span class="op">-</span>dugum))

     <span class="op">;;</span>burada yeni cocuklar yaratiyoruz
     (setf kizlar<span class="op">-</span>g (<span class="bu">apply</span> geriden<span class="op">-</span>cocuklar (<span class="bu">list</span> nb))) 

     <span class="op">;;</span> hata bulmak icin rapor
     (kac<span class="op">-</span>dugum<span class="op">-</span>yarattik)
     
     <span class="op">;;</span>acik kuyruk olarak kullaniliyor, o yuzden kat<span class="op">-</span>kat arama yapmis
     <span class="op">;;</span>oluyoruz
     (setf acik<span class="op">-</span>g (append acik<span class="op">-</span>g kizlar<span class="op">-</span>g)) 
     
     ) <span class="op">;;</span>closes loop
    ) <span class="op">;;</span>closes let
  ) <span class="op">;;</span> closes defun

<span class="op">;;</span>
<span class="op">;;</span> geri giden algorithmanin izini buluyor
<span class="op">;;</span>
(defun sonuc<span class="op">-</span>izini<span class="op">-</span>bul<span class="op">-</span>geri (dugum)
  (cond ((null dugum) (<span class="bu">print</span> <span class="st">&quot;Geri giden sonucu izliyoruz&quot;</span>) nil) 
    (t 
     (<span class="cf">if</span> (equal <span class="st">&#39;north (Kaydir dugum)) (print &#39;</span>asagi))
     (<span class="cf">if</span> (equal <span class="st">&#39;east (Kaydir dugum)) (print &#39;</span>sola))
     (<span class="cf">if</span> (equal <span class="st">&#39;west (Kaydir dugum)) (print &#39;</span>saga))
     (<span class="cf">if</span> (equal <span class="st">&#39;south (Kaydir dugum)) (print &#39;</span>yukari))
     (sonuc<span class="op">-</span>izini<span class="op">-</span>bul<span class="op">-</span>geri (Ust dugum)) 
     )))


<span class="op">;;</span>
<span class="op">;;</span> iki dugumun <span class="st">&#39;icine bakarak&#39;</span> durumlarini karsilastiriyor
<span class="op">;;</span>
(defun durum<span class="op">-</span>karsilastirici (a b)
  (<span class="cf">if</span> (equal (durum a)(durum b)) b))

<span class="op">;;</span>
<span class="op">;;</span> iki yonlu arama icin bu islemi tekrar tanimlamak gerekti..
<span class="op">;;</span>
(defun sonuc<span class="op">-</span>raporu<span class="op">-</span>ver (acik<span class="op">-</span>i acik<span class="op">-</span>g start end)
  (<span class="bu">print</span> <span class="st">&quot;# of items in OPEN FORWARD&quot;</span>)
  (<span class="bu">print</span> (length acik<span class="op">-</span>i))
  (<span class="bu">print</span> <span class="st">&quot;# of items in OPEN BACKWARD&quot;</span>)
  (<span class="bu">print</span> (length acik<span class="op">-</span>g))
  (<span class="bu">print</span> <span class="st">&quot;# of items in TOTAL nodes&quot;</span>)  
  (<span class="bu">print</span> kaydir<span class="op">-</span>sayisi)  
  )

<span class="op">;;</span>
<span class="op">;;</span> testler
<span class="op">;;</span>
(setq d0 <span class="st">&#39;((1 2 3 4) (5 6 0 8) (9 10 7 11) (13 14 15 12) (1 2)))</span>
<span class="st">(setq ds &#39;</span>((<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>) (<span class="dv">5</span> <span class="dv">6</span> <span class="dv">7</span> <span class="dv">8</span>) (<span class="dv">9</span> <span class="dv">10</span> <span class="dv">11</span> <span class="dv">12</span>) (<span class="dv">13</span> <span class="dv">14</span> <span class="dv">15</span> <span class="dv">0</span>) (<span class="dv">3</span> <span class="dv">3</span>)))
(test <span class="st">&quot;bi-directional&quot;</span> 
      (<span class="kw">not</span> (eql (iki<span class="op">-</span>yonlu<span class="op">-</span>ara d0
                   ds
                   <span class="st">&#39;cocuklari-getiren-islem</span>
<span class="st">                   &#39;</span>cocuklari<span class="op">-</span>getiren<span class="op">-</span>islem) <span class="st">&#39;hata)) t )</span>

<span class="st">(print &quot;Oldu. Iki Yonlu Arama Testleri Gecti&quot;)</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">(load <span class="st">&quot;ortak.lisp&quot;</span>)
(load <span class="st">&quot;kat-engelli-da.lisp&quot;</span>)

<span class="op">;;</span>
<span class="op">;;</span> Bu sekilde kat<span class="op">-</span>kat arama, kat<span class="op">-</span>engelli<span class="op">-</span>kka islemini cagiriyor. Bu
<span class="op">;;</span> cagirmayi yaparken, her seferinde yeni bir derinlik limiti veriyor. 
<span class="op">;;</span> Yani, kat engeli <span class="dv">1</span> ile cagiriyoruz, sonuc bulursak guzel.
<span class="op">;;</span> Bulamazsak, kat engeli <span class="dv">2</span> ile.. vs, vs. 
(defun gitgide<span class="op">-</span>derinlesen<span class="op">-</span>kka (s0 sg sons depth ARTIS<span class="op">-</span>OLCUSU)
  
  (block B
   (<span class="cf">if</span> (gitgide<span class="op">-</span>icin<span class="op">-</span>kka s0 sg sons depth) <span class="op">;</span>call dfs directly to depth
       (<span class="cf">return</span><span class="op">-</span><span class="im">from</span> B t)) <span class="op">;</span>solution found <span class="cf">if</span> dfs <span class="kw">is</span> true, so <span class="cf">return</span> t

   (gitgide<span class="op">-</span>derinlesen<span class="op">-</span>kka       <span class="op">;</span><span class="cf">else</span>, <span class="cf">try</span> again but more deeply<span class="op">!</span>
    s0                  <span class="op">;</span>the same initial state
    sg                  <span class="op">;</span>the same old goal state
    sons                <span class="op">;</span>the same old <span class="bu">set</span> of operators
    (<span class="op">+</span> depth ARTIS<span class="op">-</span>OLCUSU)          <span class="op">;</span>but now a deeper search<span class="op">!</span>
    ARTIS<span class="op">-</span>OLCUSU)    <span class="op">;</span><span class="kw">and</span> increment again later <span class="cf">if</span> you don<span class="st">&#39;t succeed</span>

<span class="st">   ) ;; ends block</span>
<span class="st">   </span>
<span class="st">  );ends defun</span>

<span class="st">(defun gitgide-derinlesen-kka-disyuz (s0 sg sons depth ARTIS-OLCUSU)</span>
<span class="st">  (setf kaydir-sayisi 0)</span>
<span class="st">  (gitgide-derinlesen-kka s0 sg sons depth ARTIS-OLCUSU)</span>
<span class="st">  (print &quot;# of nodes&quot;)</span>
<span class="st">  (print kaydir-sayisi)  </span>
<span class="st">)</span>

<span class="st">;;</span>
<span class="st">;; tests</span>
<span class="st">;;</span>
<span class="st">(setq s0 &#39;</span>((<span class="dv">1</span> NIL <span class="dv">3</span> <span class="dv">1</span>) (<span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">5</span> <span class="dv">5</span> <span class="dv">4</span> <span class="dv">1</span>)(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>)(<span class="dv">0</span> <span class="dv">1</span>)))
(setq s1 <span class="st">&#39;((1 3 4 1) (2 3 NIL 1) (5 5 4 1)(1 1 1 1)(1 2)))</span>
<span class="st">(test &quot;dfs iterative deepening&quot;</span>
<span class="st">      (not (eql (gitgide-derinlesen-kka-disyuz s0 s1 nil 1 1) &#39;</span>fail)) t )


(<span class="bu">print</span> <span class="st">&quot;OK. Gitgide Derinlesen DA Testleri Isliyor&quot;</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">(load <span class="st">&quot;ortak.lisp&quot;</span>)


<span class="op">;;</span> Fiyati sabit arama islemi, baslangictan sonuca giden en kisa yolu
<span class="op">;;</span> bulmaya ugrasir. En kisa derken, bahsettigimiz, algoritmanin daldan
<span class="op">;;</span> dala atlarken (dugumleri takip ederken) her dal fiyatinin <span class="dv">1</span> degeri
<span class="op">;;</span> tasidigi algoritmadan bahsediyoruz. Bu <span class="st">&#39;1&#39;</span> degerleri her atlayista
<span class="op">;;</span> toplanir, ve, ayni dugume degisik bir yoldan gelinecek olursa, eski
<span class="op">;;</span> deger (ve eski dugumun) atilip, en kisa dugumun, yani yolun,
<span class="op">;;</span> kullanilmasi gerekir.  Katedilen yol miktari, G<span class="op">-</span>Guncel
<span class="op">;;</span> degiskeninde, her dugum icinde saklanir.

<span class="op">;;</span> Dugum temsil seklini
<span class="op">;;</span> (Durum Kaydir<span class="op">-</span>Ismi G<span class="op">-</span>Guncel Ust<span class="op">-</span>Dugum)
<span class="op">;;</span> olarak degistirmemiz gerekiyor.

<span class="op">;;</span> bu yuzden yeni erisim islemlerini tanimlayalim.
(Defun Durum (node) (first node))
(Defun Kaydir (node) (second node))
(Defun G<span class="op">-</span>guncel (node) (third node))
(Defun Ust (node) (fourth node))

<span class="op">;;</span>
<span class="op">;;</span> Fiyati sabit arama sirasinda her dugumun fiyati, ust dugum
<span class="op">;;</span> fiyati <span class="op">+</span> <span class="dv">1</span> olarak hesaplanir. Burada sadece <span class="dv">1</span> degeri geri veriyoruz. 
(defun FIYAT (ust cocuk) <span class="dv">1</span>)

<span class="op">;;</span>
<span class="op">;;</span> Unutmayalim<span class="op">;</span> cocuklari<span class="op">-</span>yaratan islemi de degistirmemiz gerekecek. 
<span class="op">;;</span> Cunku artik FIYAT degeri, problem cozumunun bir parcasi oldu.
<span class="op">;;</span>

(defun fiyati<span class="op">-</span>sabit<span class="op">-</span>arama (d0 ds cocuklar)
  (let ( ( acik   <span class="op">;;</span> ic<span class="op">-</span>liste aslinda bir dugum
       (<span class="bu">list</span>  (<span class="bu">list</span> s0 nil <span class="dv">0</span> nil)))
     <span class="op">;;</span>g<span class="op">-</span>guncel burada <span class="dv">0</span> 
     ( tamamlanan nil )
     ( n      nil )
     ( kizlar nil )) 

    (setq kaydir<span class="op">-</span>sayisi <span class="dv">0</span>)
    (loop
     (<span class="cf">if</span> (null acik) (<span class="cf">return</span> <span class="st">&#39;hata)) </span>
<span class="st">     </span>
<span class="st">     (setf n (pop acik)) ;; Oldu. Ilk dugumu cikart.</span>

<span class="st">     ;; acik listesini guncellestir</span>
<span class="st">     (push n tamamlanan) ;; n dugumunu tamamlanan listesine ekle</span>

<span class="st">     ;; Dikkat ederseniz, acik ve tamamlanan listelerini tutmamizin</span>
<span class="st">     ;; sebebi, ayni dugumlere tekrar tekrar gelmeyi engellemek.  Bu</span>
<span class="st">     ;; listelerde kaydedilmis dugumleri bir daha islemiyoruz.</span>
<span class="st">     (if (equal (durum n) ds) ;;have we found our goal state?</span>
<span class="st">     (let () </span>
<span class="st">       (print &quot;Sonuc Bulundu. Iste Asagida:&quot;)</span>
<span class="st">       (return (sonuc-izini-bul n)))) </span>

<span class="st">     ;; yeni cocuk dugumler yaratiyoruz</span>
<span class="st">     (setf kizlar (apply cocuklar (list n))) </span>
<span class="st">     </span>
<span class="st">     ;; rapor verme kismi</span>
<span class="st">     (kac-dugum-yarattik)</span>

<span class="st">     (setf kizlar</span>
<span class="st">       (DIFF kizlar tamamlanan)) ;; Tekrar eden dugumleri cikart.</span>

<span class="st">     ;; Unutmayin, ayni dugume tekrar geldiysek, bu yeni yol</span>
<span class="st">     ;; mutlaka eskisinden daha uzun olacaktir. Boylece, tek yapmamiz</span>
<span class="st">     ;; gereken bu dugumu acik listesinden cikartmak.</span>

<span class="st">     (setf acik (UPDATE kizlar acik)) </span>

<span class="st">     ;; Acik listesini her dugumun G-guncel degerine gore</span>
<span class="st">     ;; siraya diz. En azdan, en coga gore.</span>
<span class="st">     (setf acik </span>
<span class="st">       (sort acik #&#39;</span>(<span class="kw">lambda</span>(dugum1 dugum2)
              (<span class="op">&lt;</span> (g<span class="op">-</span>guncel dugum1) (g<span class="op">-</span>guncel dugum2))) ))

     <span class="op">;;</span> Boylece ilk dugumu aldigimizda, bu dugumun fiyati en az
     <span class="op">;;</span> olan dugum oldugu garanti.

     ) <span class="op">;;</span> loop sonu
    ) <span class="op">;;</span>let sonu
  ) <span class="op">;;</span>defun sonu


(defun UPDATE (kizlar acik)
 
  (let  ( ( m  nil ) (bulunmus<span class="op">-</span>eski<span class="op">-</span>m nil) )

    (loop 

     <span class="op">;;</span> hepsini islediysek, isimiz bitti..
     (<span class="cf">if</span> (null kizlar) (<span class="cf">return</span> acik)) 

     (setf m (pop kizlar)) <span class="op">;;</span>ilk dugum uzerinde islem yapalim
  
     (setf bulunmus<span class="op">-</span>eski<span class="op">-</span>m 
       (MEMBER<span class="op">-</span>DURUM (durum m) acik)) <span class="op">;;</span> acikta bulduk mu?

     <span class="op">;;</span> oyle ise, bulunmus<span class="op">-</span>eski<span class="op">-</span>m degeri acik listesinin bir
     <span class="op">;;</span> alt<span class="op">-</span>listesi olacak.
     (<span class="cf">if</span> bulunmus<span class="op">-</span>eski<span class="op">-</span>m <span class="op">;;</span> eski m acik listede bulundu ise
     <span class="op">;;</span> durum degeri ayni olan dugumu al
     (let ((old<span class="op">-</span>m (first bulunmus<span class="op">-</span>eski<span class="op">-</span>m))) 
       <span class="op">;;</span>yeni cocuk degeri g<span class="op">-</span>guncel degeri 
       (<span class="cf">if</span> (<span class="op">&lt;</span> (g<span class="op">-</span>guncel m) (g<span class="op">-</span>guncel old<span class="op">-</span>m)) 
           <span class="op">;;</span> daha ucuz ise yeni dugumu tutmak lazim
           <span class="op">;;</span> eski dugumu ise yaramaz haline cevir
           <span class="op">;;</span> yeni cocuk m ile degistir
           <span class="op">;;</span> Dikkat edelim, bu sonuc ACIK listesine 
           <span class="op">;;</span> kalici bir degisiklik yapacak.
           (setf (first bulunmus<span class="op">-</span>eski<span class="op">-</span>m) m) ))

       <span class="op">;;</span> yoksa ayni degerde eski dugum bulamadik
       (push m acik)     
       )

     <span class="op">;;</span> o zaman m dugumunu acik listeye ekle. 

     ) <span class="op">;;</span> loop sonu, sonraki dugumu dene
    ) <span class="op">;;</span>let sonu
  ) <span class="op">;;</span>defun sonu

<span class="op">;;</span>
<span class="op">;;</span>Bu islem, sadece icinde dugum bulunan alt<span class="op">-</span>listeyi geri getiriyor.
<span class="op">;;</span>Yani bu listenin icindeki <span class="st">&#39;durum&#39;</span> bildirgec olarak verilen durum
<span class="op">;;</span>ile ayni ise geri veriliyor
(Defun MEMBER<span class="op">-</span>DURUM (durum dugum<span class="op">-</span>listesi)
  (<span class="cf">if</span> (null dugum<span class="op">-</span>listesi) <span class="op">;;</span><span class="cf">if</span> exhausted then
      nil <span class="op">;;</span><span class="cf">return</span> nil
    (<span class="cf">if</span> (equal durum (first dugum<span class="op">-</span>listesi)) <span class="op">;;</span><span class="cf">else</span> <span class="cf">if</span> we find one
    dugum<span class="op">-</span>listesi <span class="op">;;</span><span class="cf">return</span> where we found it
      <span class="op">;;</span><span class="cf">else</span> keep looking recursively      
      (MEMBER<span class="op">-</span>DURUM durum (rest dugum<span class="op">-</span>listesi))))) 


(defun cocuklari<span class="op">-</span>getiren<span class="op">-</span>islem (dugum)
  (let ( (butun<span class="op">-</span>cocuk<span class="op">-</span>dugumler nil)
     (cocuk<span class="op">-</span>dugumler nil)
     (cocuk<span class="op">-</span>durumlar nil)
     (durum (first dugum)) )

    <span class="op">;;</span>Dikkat: Yeni ogul dugumun G<span class="op">-</span>guncel degeri nasil degistiriliyor.
    <span class="op">;;</span>Ust dugumun g<span class="op">-</span>guncel degeri, arti oglan dugume gelmenin fiyati
    <span class="op">;;</span>Bu FIYAT formulu her algoritmaya gore degisik
    <span class="op">;;</span>olabilir. Fiyati<span class="op">-</span>sabit<span class="op">-</span>arama icin tanim boyledir.

    <span class="op">;;</span> yukari
    <span class="op">;;</span><span class="bu">apply</span> problem dependent operator <span class="dv">1</span>
    (setf cocuk<span class="op">-</span>durumlar (kaydir<span class="op">-</span>yukari durum)) 

    (setf cocuk<span class="op">-</span>dugumler (<span class="bu">list</span> (<span class="bu">list</span>
               cocuk<span class="op">-</span>durumlar <span class="st">&#39;north</span>
<span class="st">               (+ (g-guncel dugum)</span>
<span class="st">                  (FIYAT (durum dugum) cocuk-durumlar))</span>
<span class="st">               dugum)))        </span>

<span class="st">    (setf butun-cocuk-dugumler (append butun-cocuk-dugumler cocuk-dugumler))</span>


<span class="st">    ;; south</span>
<span class="st">    ;;apply problem dependent operator 1</span>
<span class="st">    (setf cocuk-durumlar (kaydir-asagi durum)) </span>

<span class="st">    (setf cocuk-dugumler (list (list</span>
<span class="st">               cocuk-durumlar &#39;</span>south
               (<span class="op">+</span> (g<span class="op">-</span>guncel dugum)
                  (FIYAT (durum dugum) cocuk<span class="op">-</span>durumlar))
               dugum)))        

    (setf butun<span class="op">-</span>cocuk<span class="op">-</span>dugumler 
      (append butun<span class="op">-</span>cocuk<span class="op">-</span>dugumler cocuk<span class="op">-</span>dugumler))


    <span class="op">;;</span> east
    <span class="op">;;</span><span class="bu">apply</span> problem dependent operator <span class="dv">1</span>
    (setf cocuk<span class="op">-</span>durumlar (kaydir<span class="op">-</span>saga durum)) 

    (setf cocuk<span class="op">-</span>dugumler (<span class="bu">list</span> (<span class="bu">list</span>
               cocuk<span class="op">-</span>durumlar <span class="st">&#39;east</span>
<span class="st">               (+ (g-guncel dugum)</span>
<span class="st">                  (FIYAT (durum dugum) cocuk-durumlar))</span>
<span class="st">               dugum)))        </span>

<span class="st">    (setf butun-cocuk-dugumler (append butun-cocuk-dugumler cocuk-dugumler))</span>

<span class="st">    ;; west</span>
<span class="st">    ;;apply problem dependent operator 1</span>
<span class="st">    (setf cocuk-durumlar (kaydir-sola durum)) </span>

<span class="st">    (setf cocuk-dugumler (list (list</span>
<span class="st">               cocuk-durumlar &#39;</span>west
               (<span class="op">+</span> (g<span class="op">-</span>guncel dugum)
                  (FIYAT (durum dugum) cocuk<span class="op">-</span>durumlar))
               dugum)))        

    (setf butun<span class="op">-</span>cocuk<span class="op">-</span>dugumler 
      (append butun<span class="op">-</span>cocuk<span class="op">-</span>dugumler cocuk<span class="op">-</span>dugumler))
    
    (setq kaydir<span class="op">-</span>sayisi 
      (<span class="op">+</span> kaydir<span class="op">-</span>sayisi (length butun<span class="op">-</span>cocuk<span class="op">-</span>dugumler)))

    <span class="op">;;</span><span class="kw">and</span> that<span class="st">&#39;s it. cocuk-dugumler is returned by the function</span>
<span class="st">    butun-cocuk-dugumler))</span>

<span class="st">;;</span>
<span class="st">;; tests</span>
<span class="st">;;</span>
<span class="st">(setq s0 &#39;</span>((<span class="dv">1</span> NIL <span class="dv">3</span> <span class="dv">1</span>) (<span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">1</span>) (<span class="dv">5</span> <span class="dv">5</span> <span class="dv">4</span> <span class="dv">1</span>)(<span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span>)(<span class="dv">0</span> <span class="dv">1</span>)))
(setq s1 <span class="st">&#39;((1 3 4 1) (2 3 NIL 1) (5 5 4 1)(1 1 1 1)(1 2)))</span>
<span class="st">(test &quot;uniform cost search&quot;</span>
<span class="st">      (not (eql (fiyati-sabit-arama s0 s1 #&#39;</span>cocuklari<span class="op">-</span>getiren<span class="op">-</span>islem) <span class="st">&#39;fail)) t)</span>

<span class="st">(print &quot;OK. Uniform Cost Tests Passed&quot;)</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">(load <span class="st">&quot;ortak.lisp&quot;</span>)

(Defun Durum (dugum) (first dugum))
(Defun Kaydir (dugum) (second dugum))
(Defun G<span class="op">-</span>guncel (dugum) (third dugum))
<span class="op">;;</span> tguncel <span class="st">&#39;tahmin guncel&#39;</span> den
<span class="op">;;</span> geliyor.
(Defun t<span class="op">-</span>guncel (dugum) (fourth dugum)) 
(Defun Ust (dugum) (fifth dugum))

(defun FIYAT (ust cocuk) <span class="dv">1</span>) 

<span class="op">;;</span>
<span class="op">;;</span> sinifta tanimlanan tahmin islevi (function). baslangic 
<span class="op">;;</span> tahtasindaki her tas icin, ayni tasin sonuc tahtasindaki 
<span class="op">;;</span> pozisyonuna olan uzakliklari toplayan bir islev.
<span class="op">;;</span>
(defun tguncel<span class="op">-</span>hesapla (su<span class="op">-</span>anki<span class="op">-</span>durum sonuc<span class="op">-</span>durumu)
  (let ((i <span class="dv">0</span>)(j <span class="dv">0</span>)(toplam <span class="dv">0</span>)(su<span class="op">-</span>anki nil)(uzaklik <span class="dv">0</span>))
    (loop
     (setq i <span class="dv">0</span>)
     (loop
      (setf su<span class="op">-</span>anki (nth i (nth j su<span class="op">-</span>anki<span class="op">-</span>durum)))
      
      (cond ((member su<span class="op">-</span>anki (first sonuc<span class="op">-</span>durumu))
         (setf 
          uzaklik
          (<span class="op">+</span> (<span class="bu">abs</span> (<span class="op">-</span> <span class="dv">0</span> j))
         (<span class="bu">abs</span> (<span class="op">-</span> i (position su<span class="op">-</span>anki 
                     (first sonuc<span class="op">-</span>durumu)))))))
    
        ((member su<span class="op">-</span>anki (second sonuc<span class="op">-</span>durumu))
         (setf 
          uzaklik
          (<span class="op">+</span> (<span class="bu">abs</span> (<span class="op">-</span> <span class="dv">1</span> j))
         (<span class="bu">abs</span> (<span class="op">-</span> i (position su<span class="op">-</span>anki 
                     (second sonuc<span class="op">-</span>durumu)))))))

        ((member su<span class="op">-</span>anki (third sonuc<span class="op">-</span>durumu))
         (setf 
          uzaklik
          (<span class="op">+</span> (<span class="bu">abs</span> (<span class="op">-</span> <span class="dv">2</span> j))
         (<span class="bu">abs</span> (<span class="op">-</span> i (position su<span class="op">-</span>anki 
                     (third sonuc<span class="op">-</span>durumu)))))))
         
        ((member su<span class="op">-</span>anki (fourth sonuc<span class="op">-</span>durumu))
         (setf 
          uzaklik
          (<span class="op">+</span> (<span class="bu">abs</span> (<span class="op">-</span> <span class="dv">3</span> j))
         (<span class="bu">abs</span> (<span class="op">-</span> i (position su<span class="op">-</span>anki 
                     (fourth sonuc<span class="op">-</span>durumu)))))))
        )
     
      (setf toplam (<span class="op">+</span> toplam uzaklik))
      
      (setq i (incf i)) <span class="op">;;</span> increment
      (<span class="cf">if</span> (eql i <span class="dv">4</span>) (<span class="cf">return</span>)))
     (setq j (incf j))
     (<span class="cf">if</span> (eql j <span class="dv">4</span>) (<span class="cf">return</span>))
     ) toplam)
  )

<span class="op">;;</span> bu algoritma, fiyati<span class="op">-</span>sabit<span class="op">-</span>arama islevi temel alinarak yazilmistir.
<span class="op">;;</span> yani, algoritma asagi yukari aynidir. Tek fark, FIYAT islevinin
<span class="op">;;</span> hesaplanmasi.
(defun a<span class="op">-</span>yildiz<span class="op">-</span>arama (s0 sg sons)
  (let ( ( acik   (<span class="bu">list</span>  (<span class="bu">list</span> s0 nil <span class="dv">0</span> <span class="dv">0</span> nil) ) ) 
     <span class="op">;;</span>g<span class="op">-</span>guncel <span class="bu">set</span> to <span class="dv">0</span>
     ( tamamlanan nil )
     ( n      nil )
     ( kizlar nil )) 
    (setq kaydir<span class="op">-</span>count <span class="dv">0</span>)
    (loop
     (<span class="cf">if</span> (null acik) (<span class="cf">return</span> <span class="st">&#39;hata))</span>
<span class="st">     </span>
<span class="st">     (setf n (pop acik)) </span>

<span class="st">     (push n tamamlanan)</span>

<span class="st">     (if (equal (durum n) sg) </span>

<span class="st">     (let () </span>
<span class="st">       (print &quot;Great. I found a solution. Here it is:&quot;)</span>
<span class="st">       (sonuc-raporu-ver acik tamamlanan s0)</span>
<span class="st">       (return (sonuc-izini-bul n)))) </span>

<span class="st">     (setf kizlar (cocuklari-getiren-islem n))</span>

<span class="st">     (kac-dugum-yarattik)</span>

<span class="st">     (setf kizlar</span>
<span class="st">       (DIFF kizlar tamamlanan)) </span>


<span class="st">     (setf acik (UPDATE kizlar acik)) </span>
<span class="st">     (setf acik </span>
<span class="st">       (sort acik #&#39;</span>(<span class="kw">lambda</span>(dugum1 dugum2)
              (<span class="op">&lt;</span> (<span class="op">+</span> (g<span class="op">-</span>guncel dugum1) (t<span class="op">-</span>guncel dugum1))
                 (<span class="op">+</span> (g<span class="op">-</span>guncel dugum2) (t<span class="op">-</span>guncel dugum2)) 
                 ))))
                

     ) 
    ) 
  ) 

(defun UPDATE (kizlar acik)
 
  (let  ( ( m  nil ) (bulunan<span class="op">-</span>eski<span class="op">-</span>d nil) )

    (loop 

     (<span class="cf">if</span> (null kizlar) (<span class="cf">return</span> acik))

     (setf m (pop kizlar)) 
  
     (setf bulunan<span class="op">-</span>eski<span class="op">-</span>d (MEMBER<span class="op">-</span>DURUM (durum m) acik)) 

     (<span class="cf">if</span> bulunan<span class="op">-</span>eski<span class="op">-</span>d 
     (let ((eski<span class="op">-</span>d (first bulunan<span class="op">-</span>eski<span class="op">-</span>d)))

       (<span class="cf">if</span> (<span class="op">&lt;</span> (g<span class="op">-</span>guncel m) (g<span class="op">-</span>guncel eski<span class="op">-</span>d)) 
           (setf (first bulunan<span class="op">-</span>eski<span class="op">-</span>d) m) ))

       (push m acik)     
       )
     

     ) 
    )
  ) 

(Defun MEMBER<span class="op">-</span>DURUM (durum <span class="bu">list</span><span class="op">-</span>of<span class="op">-</span>nodes)
  (<span class="cf">if</span> (null <span class="bu">list</span><span class="op">-</span>of<span class="op">-</span>nodes) 
      nil 
    (<span class="cf">if</span> (equal durum (first <span class="bu">list</span><span class="op">-</span>of<span class="op">-</span>nodes))
    <span class="bu">list</span><span class="op">-</span>of<span class="op">-</span>nodes 
      (MEMBER<span class="op">-</span>DURUM durum (rest <span class="bu">list</span><span class="op">-</span>of<span class="op">-</span>nodes))))) 

(defun cocuklari<span class="op">-</span>getiren<span class="op">-</span>islem (dugum)
  (let ( (butun<span class="op">-</span>cocuklar nil)
     (cocuk<span class="op">-</span>dugumler nil)
     (ogul<span class="op">-</span>dugumler nil)
     (durum (first dugum)) )

    (setf ogul<span class="op">-</span>dugumler (kaydir<span class="op">-</span>yukari durum)) 
    (setf cocuk<span class="op">-</span>dugumler (<span class="bu">list</span> (<span class="bu">list</span>
                ogul<span class="op">-</span>dugumler
                <span class="st">&#39;yukari</span>
<span class="st">                (+ (g-guncel dugum)</span>
<span class="st">                   (FIYAT (durum dugum) ogul-dugumler))</span>
<span class="st">                (tguncel-hesapla (durum dugum) sg )</span>
<span class="st">                dugum)))        </span>

<span class="st">    (setf butun-cocuklar (append butun-cocuklar cocuk-dugumler))</span>

<span class="st">    (setf ogul-dugumler (kaydir-asagi durum)) </span>

<span class="st">    (setf cocuk-dugumler (list (list</span>
<span class="st">                ogul-dugumler</span>
<span class="st">                &#39;</span>asagi
                (<span class="op">+</span> (g<span class="op">-</span>guncel dugum)
                   (FIYAT (durum dugum) ogul<span class="op">-</span>dugumler))
                (tguncel<span class="op">-</span>hesapla (durum dugum) sg)
                dugum)))        

    (setf butun<span class="op">-</span>cocuklar (append butun<span class="op">-</span>cocuklar cocuk<span class="op">-</span>dugumler))

    (setf ogul<span class="op">-</span>dugumler (kaydir<span class="op">-</span>saga durum)) 

    (setf cocuk<span class="op">-</span>dugumler (<span class="bu">list</span> (<span class="bu">list</span>
                ogul<span class="op">-</span>dugumler
                <span class="st">&#39;saga</span>
<span class="st">                (+ (g-guncel dugum)</span>
<span class="st">                   (FIYAT (durum dugum) ogul-dugumler))</span>
<span class="st">                (tguncel-hesapla (durum dugum) sg)</span>
<span class="st">                dugum)))        </span>

<span class="st">    (setf butun-cocuklar (append butun-cocuklar cocuk-dugumler))</span>

<span class="st">    (setf ogul-dugumler (kaydir-sola durum)) </span>

<span class="st">    (setf cocuk-dugumler (list (list</span>
<span class="st">                ogul-dugumler</span>
<span class="st">                &#39;</span>sola
                (<span class="op">+</span> (g<span class="op">-</span>guncel dugum)
                   (FIYAT (durum dugum) ogul<span class="op">-</span>dugumler))
                (tguncel<span class="op">-</span>hesapla (durum dugum) sg)
                dugum)))        

    (setf butun<span class="op">-</span>cocuklar (append butun<span class="op">-</span>cocuklar cocuk<span class="op">-</span>dugumler))

    (setq kaydir<span class="op">-</span>count (<span class="op">+</span> kaydir<span class="op">-</span>count (length butun<span class="op">-</span>cocuklar)))
    
    butun<span class="op">-</span>cocuklar))



(setq s0 <span class="st">&#39;((1 2 3 4) (5 6 0 8) (9 10 7 11) (13 14 15 12) (1 2)))</span>
<span class="st">(setq sg &#39;</span>((<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>) (<span class="dv">5</span> <span class="dv">6</span> <span class="dv">7</span> <span class="dv">8</span>) (<span class="dv">9</span> <span class="dv">10</span> <span class="dv">11</span> <span class="dv">12</span>) (<span class="dv">13</span> <span class="dv">15</span> <span class="dv">14</span> <span class="dv">0</span>) (<span class="dv">3</span> <span class="dv">3</span>)))
(test <span class="st">&quot;calc hhat test A*&quot;</span> (tguncel<span class="op">-</span>hesapla s0 sg) <span class="dv">8</span>)

(setq s0 <span class="st">&#39;((1 2 3 4) (5 6 0 8) (9 10 7 11) (13 14 15 12) (1 2)))</span>
<span class="st">(setq sg &#39;</span>((<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>) (<span class="dv">5</span> <span class="dv">6</span> <span class="dv">7</span> <span class="dv">8</span>) (<span class="dv">9</span> <span class="dv">10</span> <span class="dv">11</span> <span class="dv">12</span>) (<span class="dv">13</span> <span class="dv">14</span> <span class="dv">15</span> <span class="dv">0</span>) (<span class="dv">3</span> <span class="dv">3</span>)))
(test <span class="st">&quot;A* Search test&quot;</span>
      (<span class="kw">not</span> (eql (a<span class="op">-</span>yildiz<span class="op">-</span>arama s0 sg nil) <span class="st">&#39;hata)) t )</span>

<span class="st">(print &quot;OK. A*  Tests Passed&quot;)</span></code></pre></div>
<p>Yapay Zeka ve Müsabaka</p>
<p>Bilgisayarlar bir problemi yapay zeka kullanarak çözerken, kullandıkları teknikler; Karar ağacı, akıllı tahmin yeteneği ve o ana kadar geçilen yolu hatırlamaktır.</p>
<p>Karar ağacı kullanırken, seçeceğimiz yolun doğru yol mu olup olmadığı tahmin etmek için değerlendirme fonksiyonuna sorarız. Bu fonksiyon gerçek bir tahmin mantığına ne kadar yakın ise, (yani uzman bir insana) arama da o kadar başarılı olur.</p>
<p>Bu örnekten yola çıkarsak, karşılıklı müsabakalar da bir arama problemi gibi görülebilir. Bir başlangıç noktası vardır, belli seçenekler vardır, bu seçenekleri takip etmek için karar ağacı tekniği uygulanabilir.</p>
<p>Tek bir değişiklik ile: Artık kararların hepsi bize ait değil.</p>
<p>Altüst (Minimax) Algoritması</p>
<p>Mesela müsabaka, bir dama oyunu olsun. Oyun sırasında sıra bir bilgisayara, bir karşı tarafa geçer. Bu yüzden iyi bir yapay zeka algoritması, hem kendi hareketlerinin arasında &quot;değerlendirme fonksiyonunun&quot; en iyi bulduğunu seçmeli, hem de, aynı zamanda rakibi için en kötü olacak yolu takip etmelidir.</p>
<p>Bu iki seçeneğe göre karar arama yapan algoritmaya altüst algoritması diyoruz. Çünkü rakip için an alt değer ile, bilgisayar için en üst değeri aynı anda arıyoruz.</p>
<p>Normal tek kişili arama algoritmalarında sadece &quot;bir&quot; ileriye bakarak değerlendirme yapmış, ve en fazla olan seçeneği takip etmiştik. Altüst için arama yaparken derinliğine ineceğiz, ve bu derinliği hafızamızın elverdiği kadar yapabileceğiz. Çünkü, hamleye karşı hamle, ona karşı hamle derken en iyi seçeneği bulabilmek için bazen oldukça derinlere inmek gerekebilir. 10 seviye altta çok iyi gözüken bir birleşim olabilir, ama belki de 11. seviyede maçı kaybediyoruz! Tabii dallanma seviyesi fazla olan oyunlarda (mesela satranç) bu şekilde derinlik birçok bilgisayarı donanım olarak zorlayacaktır. Bu yüzden Kasparov gibi bir ustayla ancak IBM'in satranç için özel yapılmış makinesi rekabet edebiliyor.</p>
<p>Oyun: İtalyan Daması</p>
<p>Altüst algoritmasını dallanma faktörünün fazla olmadığı bir oyun üzerinde göreceğiz. Bu oyunun ismi italyan daması. Bildiğimiz dama oyununa çok benziyor, sadece taşlar düz olarak ileri, geri, sağa, sola gitmek yerine çapraz hareket ediyorlar. Aynen damada olduğu gibi, en sona ulaşan taş kral oluyor ve uzun sıçramalar yapabiliyor.</p>
<p>Ekte verilen LISP kodu üzerinde göreceğimiz gibi, programı temel hareketler, değerlendirme fonksiyonu, algoritma ve ekrandan giriş yaparak oynanabilen kısımlara ayırdık.</p>
<p>Altüst algoritması, özyineli olarak çalışan bir algoritmadır. Altüst, önce derinliğine bir sekilde müsaade edildiği kadar (programcı tarafından) derinliğe iner, ve vardığı en uç noktalardaki tahtaları değerlendirir. Geri dönerken, bu değerlerden bazen &quot;en az&quot; olanı bazen &quot;en fazla&quot; olanı seçer. En az/en fazla kıstası her seviyede bir değişir. Rakip hareketlerini gösteren seviyede bulunuyorsak, enalt, kendi seviyemizde bulunuyorsak enüst seçimi yaparız.</p>
<p>Üzerinde karşılaştırma yaptığımız sayı, değerlendirme fonksiyonunun tahta hakkında biçtiği değerden başkası değildir. Bu tür değerlendirme fonksiyonlarını A* algoritması altında görmüştük.</p>
<p>Tahta değerlerinin arasındaki seçimi özyineden geriye &quot;dönerken&quot; yaptığımıza özellikle dikkat edin. Yani, 10. seviyeye indiysek ve bütün önce-derinliğine olarak bir dalı açmış isek, ancak ondan sonra değerleri birbirleri ile karşılaştırarak ve seçerek döndürmeye başlıyoruz. Değerlendirme işleminin kendisi, derinliğin en sonundaki tahtalar üzerinde yapılıyor. &quot;Ara tahtaların&quot; üzerinde değerlendirme yapmıyoruz. (Bkz. <code>tahta-degerlendir</code> fonksiyonu).</p>
<div class="figure">
<img src="altust.jpg" />

</div>
<p>Örnekteki resimde 2. seviyeye 99 ve 100'ün dönmüş olduğunu görüyoruz. 1. seviye de sırasıyla önce 99, sonra 100'ün dönmesi gerekir, ve bunlardan 100 değeri 99'un üzerine çıkacaktır. Çünkü 1. seviye 'üst' seviyesidir. Alt seviyesi olsa idi, 99 seçilecekti.</p>
<p>Ayrıca, seviyeye göre bazen alt, bazen üst değerler aradığımız için, hangi seviyede olduğumuza bağlı olarak &lt;&gt; operatörlerini kullanmak yerine, hep aynı operatörü (&gt;) kullansak, ve karşılaştırma yaptığımız değeri sonraki seviyeye aktarmadan önce eksi (-) ile çarpsak kod daha temiz olacak. Bunu ufak bir algoritma numarası olarak görebilirsiniz. Değeri eksiye dönen bir değerin üzerinde uygulanan büyüktür/küçüktür karşılaştırmalarının sonucu otomatikman tersine döner (basit aritmetik). Eksiyi eksi ile çarpınca sayı tekrar artıya döndüğü için özyineli olarak bu çarpımı tekrar tekrar yapmamız mümkün olabiliyor. Ne güzel. Böylece iki tane if (ya da LISP cond) ifadesi yazmaktan kurtulmuş olduk. Kod daha temiz hale geldi. Bahsedilen çağırım şekli dama-alg.lisp dosyasındaki aşağıdaki satırda.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">(setf dene (eniyi<span class="op">-</span>hareket (tas<span class="op">-</span>oynat 
   (first hareket<span class="op">-</span>listesi) konumn)
(<span class="op">-</span> derinlik <span class="dv">1</span>)
(<span class="op">*</span> onun<span class="op">-</span>eniyi <span class="dv">-1</span>) <span class="op">;;</span> eksi carpimina dikkat
(<span class="op">*</span> enyuksek<span class="op">-</span>deger <span class="dv">-1</span>))) <span class="op">;;</span> <span class="op">;;</span> eksi carpimina dikkat</code></pre></div>
<p>Bir başka ilginç bir nokta da şudur: Rakibimizin tahtalarını ve kendi tahtalarına değer biçerken hep aynı fonksiyonu kullanıyoruz. (Kod üzerinde <code>tahta-degeri(tahta)</code> LISP fonksiyonu). Bunun demektir ki Kendi oyun bilgimize dayanarak rakibimizin ne yapacağını tahmin etmeye uğraşıyoruz. Yani zihnen, sanal bir alemde &quot;rakibimizin yerine&quot; hamle yapıyoruz ve bu sanal hamleye kendimize göre bir cevap veriyoruz. Hakikaten de satranç, dama, kağıt oynarken yaptığımız da bu değil midir?</p>
<p>Eniyileştirme</p>
<p>Gördüğümüz gibi, altüst'ün temeli oldukça basit. Bundan sonrası, altüst'ü hız ve hafıza bakımından eniyileştirme için yapılmıştır. Alfa-beta budaması denen altüst uzantısı bu çerçevede düşünülmüştür.</p>
<p>Dama tahtaları arasında alt/üst irdelemesi yaparken, şunu düşünebiliriz: Ağacın herhangi yerindeki oyuncunun varabileceği bir yer olarak bir n adlı bir düğüm olduğunu düşünün; Eğer oyuncunun n'in bir üstü ya da daha tepesinde (dallanma olarak) m adında daha iyi seçeneği var ise, n düğümü oyun sırasında asla erişilmeyecektir. Bu yüzden n hakkında yeteri kadar bilgiye sahip olduğumuzda (cocuklarından birkaçına bakarak), bu düğümü tümden budayabiliriz.</p>
<p>Daha detaylı (ve matematiksel) bir örnekte göstermemiz gerekirse:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">altust<span class="op">-</span>degeri(en tepe) <span class="op">=</span> 
   üst ( alt(<span class="dv">3</span>, <span class="dv">12</span>, <span class="dv">8</span>), alt(<span class="dv">2</span>, x, y), alt(<span class="dv">14</span>, <span class="dv">5</span>, <span class="dv">2</span>) )
altust<span class="op">-</span>degeri(en tepe) <span class="op">=</span> 
   üst ( <span class="dv">3</span>, alt(<span class="dv">2</span>, x, y), <span class="dv">2</span>)
altust<span class="op">-</span>degeri(en tepe) <span class="op">=</span> 
   üst ( <span class="dv">3</span>, z, <span class="dv">2</span>)
altust<span class="op">-</span>degeri(en tepe) <span class="op">=</span> <span class="dv">3</span></code></pre></div>
<p>Alt (2, x, y) fonksiyonunun değeri Z'ye eşitlendi (ve atıldı), x ve y'nin ne olduğuna bile bakılmadan. Çünkü alt(2, x, y) dediğimiz zaman aynı anda şunu söylemiş oluyoruz: &quot;alt (2, x, y) en fazla 2 olabilir&quot;. Değil mi? Çünkü alt fonksiyonunun gereği olarak zaten en aşağı olan değeri seçeceğiz. X ya da y daha az olsa, onları seçerdik, daha fazla olsalar 2'yi seçeceğiz. Fakat, elimizde KESİN bir 2 değeri &quot;zaten&quot; var ise, alt(2, x, y)'yi bir tarafa atabiliriz, çünkü nasıl olsa alt(2, x, y)'nin sonucu 2'den daha iyi olamazdı. DAHA İYİ'den kastımız üst fonksiyonu bakımından daha iyi demektir, çünkü alt() fonksiyonlarının sonucu üst() fonksiyonuna gidiyor, biliyorsunuz.</p>
<p>Sonuçta, soyut olarak düşünerek alt(2, x, y)'nin üzerinde 2 yönlü bir traşlama yapıyoruz denebilir. X ve Y'nin 2'den fazla olmasını fonksiyonun kendisi traşlıyor. Daha az olabilme ihtimallerini'de, elimizde zaten olan 2 değeri traşlıyor, çünkü bu iki değerinin ne yaparsak yapalım üstüne çıkamayacağız. Alt değerleri, üstte toplandığı için...</p>
<p>Alfa beta budaması ismini ağaçta gezinirken o ana kadar en üst bulunmuş olan değeri alfa değişkeninde, ve en alt bulunmuş değeri beta değişkeninde sürekli olarak yanında gezdirmesinden alır. En alt ve en üst değerler aranırken sürekli alfa ve beta'ya karşılaştırma yapılır. Alfa/beta penceresinin içine düşmeyen seçenekler ve onların alt-ağaçları tamamen budanır. Bu şekilde yer ve zamandan oldukça istifade etmemiz mümkündür.</p>
<div class="figure">
<img src="altust_budama_1.jpg" />

</div>
<div class="figure">
<img src="altust_budama_2.jpg" />

</div>
<div class="figure">
<img src="altust_budama_3.jpg" />

</div>
<div class="figure">
<img src="altust_budama_4.jpg" />

</div>
<div class="figure">
<img src="altust_budama_5.jpg" />

</div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">(load <span class="st">&quot;dama-temel.lisp&quot;</span>)

<span class="op">;;</span>
<span class="op">;;</span> Cok basit bir degerlendirme fonksiyonu.  Degerlendirme islemleri
<span class="op">;;</span> tahtaya bakarak bu tahtanin bilgisayar icin ne kadar iyi durdugunu
<span class="op">;;</span> (oldugunu) bir rakam ile rapor ederler. <span class="op">*</span>enust<span class="op">-</span>renk<span class="op">*</span> bilgisayarin
<span class="op">;;</span> hangi oyuncuyu oynadigini gosterir. Burada kullanilan degerlendirme
<span class="op">;;</span> cok basit, <span class="st">&quot;daha zoru&quot;</span> degerlendirme icin ozel olan dosyada olacak.
<span class="op">;;</span> Bu islevin raporladigi rakam, zaten tahtanin en sonunda tutulmakta.
(defun tahta<span class="op">-</span>degeri(tahta)
  (cond ((equal <span class="op">*</span>enust<span class="op">-</span>renk<span class="op">*</span> <span class="op">*</span>beyaz<span class="op">*</span>)
     (caadr tahta))
    (t (cadadr tahta))
  ))

<span class="op">;;</span>
<span class="op">;;</span> disardan cagirilan islev
(defun altust<span class="op">-</span>arama(dugum)
  (setf benim<span class="op">-</span>eniyi <span class="dv">-999999</span>)
  (setf onun<span class="op">-</span>eniyi <span class="op">+</span><span class="dv">999999</span>)
  (eniyi<span class="op">-</span>hareket (copy<span class="op">-</span>tree dugum) <span class="dv">10</span> benim<span class="op">-</span>eniyi onun<span class="op">-</span>eniyi)
  )

<span class="op">;;</span> Simdi, altust (minimax) algoritmasinin alfa<span class="op">-</span>beta seklini gosteriyoruz. 
(defun eniyi<span class="op">-</span>hareket(konumn derinlik benim<span class="op">-</span>eniyi onun<span class="op">-</span>eniyi)

  <span class="op">;;</span> Dikkat ederseniz normal altust algoritmasina iki yeni
  <span class="op">;;</span> bildirgec ekledik. Baslarken Benim<span class="op">-</span>Eniyi <span class="op">-</span>sonsuz<span class="st">&#39;a (eksi sonsuz)</span>
<span class="st">  ;; esitlenmeli. Onun-eniyi ise +sonsuz&#39;</span>a esitlenmeli.
  (let ((hareket<span class="op">-</span>listesi nil)(enyuksek<span class="op">-</span>deger nil)
    (eniyim nil)(dene nil)(denenen<span class="op">-</span>deger nil))

    <span class="op">;;</span> Bu kontrol, ozyineli cagirimi karar agacin sonuna geldigimizde
    <span class="op">;;</span> bitirebilmek icindir. Iki elemanli bir liste geriye
    <span class="op">;;</span> getiriyoruz. 
    (<span class="cf">if</span> (eql derinlik <span class="dv">0</span>)
    (<span class="cf">return</span><span class="op">-</span><span class="im">from</span> eniyi<span class="op">-</span>hareket (<span class="bu">list</span> (tahta<span class="op">-</span>degeri konumn) nil)))

    <span class="op">;;</span> Oyun kurallarina gore uygun olan, tahta<span class="st">&#39;nin o anki konumuna</span>
<span class="st">    ;; gore olan butun muhtemel hareketleri buluyoruz. </span>
<span class="st">    (setq hareket-listesi (hareket-listesi-hesapla *enust-renk* konumn))</span>
<span class="st">    </span>
<span class="st">    (setq enyuksek-deger benim-eniyi)</span>
<span class="st">    (setq eniyim nil)</span>

<span class="st">    ;; Artik hareket-listesi&#39;</span>ni taramaya haziriz. En iyi
    <span class="op">;;</span> hareketi bu listeden sececegiz. Enyuksek<span class="op">-</span>deger ve eniyim
    <span class="op">;;</span> degerlerini nasil yukledigimize dikkat edin.

    (do () ((equal hareket<span class="op">-</span>listesi nil))
      
      <span class="op">;;</span> Burasi ana ozyineli cagirimin yapildigi yer. Bu cagiri ile
      <span class="op">;;</span> siradaki hareketin arama alanini <span class="st">&#39;aciyoruz&#39;</span>. Iki yeni
      <span class="op">;;</span> bildirgeci gectigimize dikkat edin. 
      (setf dene (eniyi<span class="op">-</span>hareket (tas<span class="op">-</span>oynat (first hareket<span class="op">-</span>listesi) konumn)
              (<span class="op">-</span> derinlik <span class="dv">1</span>)
              (<span class="op">*</span> onun<span class="op">-</span>eniyi <span class="dv">-1</span>)
              (<span class="op">*</span> enyuksek<span class="op">-</span>deger <span class="dv">-1</span>)))
      
      <span class="op">;;</span> eniyi<span class="op">-</span>hareket iki deger geri getirir, unutmayin..
      (setq denenen<span class="op">-</span>deger (first dene))

      <span class="op">;;</span> Simdi, elimizdeki hareketin otekilere daha iyi olup olmadigina
      <span class="op">;;</span> karar verelim. Elimizdeki hareketi <span class="st">&#39;su ana kadar en iyi&#39;</span> olarak
      <span class="op">;;</span> secip secmeyecegimiz buna bagli.

      (<span class="cf">if</span> (<span class="op">&gt;</span> denenen<span class="op">-</span>deger enyuksek<span class="op">-</span>deger)
      (progn
        (setq enyuksek<span class="op">-</span>deger denenen<span class="op">-</span>deger)
        (setq eniyim (first hareket<span class="op">-</span>listesi))
        ))      

      <span class="op">;;</span> Iste <span class="st">&#39;kesit&#39;</span> islemi alfa<span class="op">-</span>beta algoritmasi icin burada
      <span class="op">;;</span> yapilir. Eger iyi bir hareket bulamadiysak, arayisi burada
      <span class="op">;;</span> durduruyoruz. Return fonksiyonu, donguyu yarida kesiyor
      <span class="op">;;</span> ve bir onceki ozyine seviyesine donuyor. 

      (<span class="cf">if</span> (<span class="op">&gt;</span> enyuksek<span class="op">-</span>deger onun<span class="op">-</span>eniyi)
      (<span class="cf">return</span><span class="op">-</span><span class="im">from</span> eniyi<span class="op">-</span>hareket (<span class="bu">list</span> enyuksek<span class="op">-</span>deger eniyim)))

      <span class="op">;;</span> Listede taramaya devam ediyoruz, bakalim elimizdekinden daha
      <span class="op">;;</span> iyi bir hareket bulabilecekmiyiz
      (setq hareket<span class="op">-</span>listesi (cdr hareket<span class="op">-</span>listesi))
      
      ) 

    <span class="op">;;</span> Butun hareket<span class="op">-</span>liste<span class="st">&#39;sini aradiktan sonra, en iyi</span>
<span class="st">    ;; hareketi bulmus bulunuyoruz. Geriye cevap olarak</span>
<span class="st">    ;; bu hareketi bildirecegiz. </span>
<span class="st">    (return-from eniyi-hareket (list enyuksek-deger eniyim))</span>
<span class="st">    </span>
<span class="st">    ) ;; let sonu</span>
<span class="st">  </span>
<span class="st">  )  ;; defun sonu</span>


<span class="st">;;</span>
<span class="st">;; testler</span>

<span class="st">(oyuna-basla *beyaz*)</span>
<span class="st">(test &quot;degerlendir testi&quot; (tahta-degeri *tahta*) 12)</span>

<span class="st">(oyuna-basla *beyaz*)</span>
<span class="st">(test &quot;altust basit test&quot; (altust-arama *tahta*) &#39;</span>(<span class="dv">12</span> ((<span class="dv">1</span> <span class="dv">5</span>) (<span class="dv">0</span> <span class="dv">4</span>))))

(setq <span class="op">*</span>enust<span class="op">-</span>renk<span class="op">*</span> <span class="st">&quot;b&quot;</span>)
(setf hic<span class="op">-</span>siyah<span class="op">-</span>kalmadi
  <span class="st">&#39;(((nil (&quot;b&quot; nil)  nil (&quot;b&quot; nil)  nil (&quot;b&quot; nil)  nil (&quot;b&quot; nil) )</span>
<span class="st">     ((&quot;b&quot; nil)  nil (&quot;b&quot; nil)  nil (&quot;b&quot; nil)  nil (&quot;b&quot; nil)  nil)</span>
<span class="st">     (nil (&quot;b&quot; nil)  nil (&quot;b&quot; nil)  nil (&quot;b&quot; nil)  nil (&quot;b&quot; nil) )</span>
<span class="st">     (nil nil nil nil nil nil nil nil)(nil nil nil nil nil nil nil nil)</span>
<span class="st">     (nil nil nil nil nil nil nil nil)(nil nil nil nil nil nil nil nil )</span>
<span class="st">     (nil nil nil nil nil nil nil nil)) (12 0)))</span>
<span class="st">(test &quot;basit degerlendir 1&quot; (tahta-degeri hic-siyah-kalmadi) 12)</span>

<span class="st">(setq *enust-renk* &quot;s&quot;)</span>
<span class="st">(setf hic-siyah-kalmadi</span>
<span class="st">  &#39;</span>(((nil (<span class="st">&quot;b&quot;</span> nil)  nil (<span class="st">&quot;b&quot;</span> nil)  nil (<span class="st">&quot;b&quot;</span> nil)  nil (<span class="st">&quot;b&quot;</span> nil) )
     ((<span class="st">&quot;b&quot;</span> nil)  nil (<span class="st">&quot;b&quot;</span> nil)  nil (<span class="st">&quot;b&quot;</span> nil)  nil (<span class="st">&quot;b&quot;</span> nil)  nil)
     (nil (<span class="st">&quot;b&quot;</span> nil)  nil (<span class="st">&quot;b&quot;</span> nil)  nil (<span class="st">&quot;b&quot;</span> nil)  nil (<span class="st">&quot;b&quot;</span> nil) )
     (nil nil nil nil nil nil nil nil)(nil nil nil nil nil nil nil nil)
     (nil nil nil nil nil nil nil nil)(nil nil nil nil nil nil nil nil )
     (nil nil nil nil nil nil nil nil)) (<span class="dv">12</span> <span class="dv">0</span>)))
(test <span class="st">&quot;basit degerlendir 2&quot;</span> (tahta<span class="op">-</span>degeri hic<span class="op">-</span>siyah<span class="op">-</span>kalmadi) <span class="dv">0</span>)

(oyuna<span class="op">-</span>basla <span class="op">*</span>beyaz<span class="op">*</span>)
(setq tahta<span class="op">-</span>kopyasi (copy<span class="op">-</span>tree <span class="op">*</span>tahta<span class="op">*</span>))
(altust<span class="op">-</span>arama <span class="op">*</span>tahta<span class="op">*</span>)
(test <span class="st">&quot;tahta degismemesi gerekir testi&quot;</span> (equal tahta<span class="op">-</span>kopyasi <span class="op">*</span>tahta<span class="op">*</span>) t)

(<span class="bu">print</span> <span class="st">&quot;Tamam. Algoritma Birim Testleri Gecti&quot;</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">(load <span class="st">&quot;dama-alg.lisp&quot;</span>)

<span class="op">;;</span> Bu islev, atak oyun halinde mi, yoksa defans oyun halinde mi
<span class="op">;;</span> oldugumuzu hesaplar. Eger defans agirlikli oynuyorsak, ki program
<span class="op">;;</span> bunu oyunun basinda yapmak uzere yazildi, her tahtanin degeri
<span class="op">;;</span> hesaplanirken agirliklar defansif olculere gore secilir.  Atak
<span class="op">;;</span> oyununda bu agirliklar degisiyor.  Defans<span class="op">/</span>Atak karari su ana kadar
<span class="op">;;</span> kac hamle yapildigina gore veriliyor<span class="op">;</span> Belli bir tetik degerinden
<span class="op">;;</span> sonra, (<span class="dv">7</span> hamle) bilgisayar atak oynamaya basliyor.
(defun atak<span class="op">-</span>oyun? ()
  (cond ((<span class="op">&gt;</span> bilgisayar<span class="op">-</span>hamle<span class="op">-</span>sayisi <span class="dv">7</span>) t)
    (t nil)))

<span class="op">;;</span> Alttaki degerlendirme islevini goruyoruz. Bu islev oyunun
<span class="op">;;</span> akillica secim yapmasina yardim edecek.
(defun tahta<span class="op">-</span>degeri(tahta)   
  (let (
    (y<span class="op">-</span>sayac <span class="dv">0</span>) (x<span class="op">-</span>sayac <span class="dv">0</span>)
    <span class="op">;;</span> sayac degiskenler
    (benim<span class="op">-</span>tas<span class="op">-</span>sayim (caadr tahta))(rakibin<span class="op">-</span>tas<span class="op">-</span>sayisi (cadadr tahta))
    (benim<span class="op">-</span>kral<span class="op">-</span>sayim <span class="dv">0</span>)(rakibin<span class="op">-</span>kral<span class="op">-</span>sayisi <span class="dv">0</span>)
    (mevcut<span class="op">-</span>hamlelerim <span class="dv">0</span>)(rakibin<span class="op">-</span>mevcut<span class="op">-</span>hamleleri <span class="dv">0</span>)
    <span class="op">;;</span> agirliklar
    (kralin<span class="op">-</span>agirligi nil)(mevcut<span class="op">-</span>hamle<span class="op">-</span>agirligi nil)
    (benim<span class="op">-</span>kalan<span class="op">-</span>tas<span class="op">-</span>agirligim nil)(rakibin<span class="op">-</span>kalan<span class="op">-</span>tas<span class="op">-</span>agirligi nil)
    <span class="op">;;</span> sonuc
    (degerlendirme<span class="op">-</span>toplami <span class="dv">0</span>)
    )

    <span class="op">;;</span> Atak<span class="op">/</span>defans halimize gore agirlik degerlerini
    <span class="op">;;</span> degistir
    (cond ((equal (atak<span class="op">-</span>oyun?) nil)
       (progn
         (setq kralin<span class="op">-</span>agirligi <span class="dv">50</span>)
         (setq mevcut<span class="op">-</span>hamle<span class="op">-</span>agirligi <span class="dv">60</span>)
         (setq benim<span class="op">-</span>kalan<span class="op">-</span>tas<span class="op">-</span>agirligim <span class="dv">70</span>)
         (setq rakibin<span class="op">-</span>kalan<span class="op">-</span>tas<span class="op">-</span>agirligi <span class="dv">30</span>)
         ))
      (t
       (progn
         (setq kralin<span class="op">-</span>agirligi <span class="dv">100</span>)
         (setq mevcut<span class="op">-</span>hamle<span class="op">-</span>agirligi <span class="dv">60</span>)
         (setq benim<span class="op">-</span>kalan<span class="op">-</span>tas<span class="op">-</span>agirligim <span class="dv">20</span>)
         (setq rakibin<span class="op">-</span>kalan<span class="op">-</span>tas<span class="op">-</span>agirligi <span class="dv">70</span>)
         )
       ))

    <span class="op">;;</span> butun tahtayi tararken..
    (dotimes (x<span class="op">-</span>sayac <span class="dv">8</span>)
      (dotimes (y<span class="op">-</span>sayac <span class="dv">8</span>) 
    (setq konum<span class="op">-</span>degeri (tas<span class="op">-</span>degeri<span class="op">-</span>ver (<span class="bu">list</span> x<span class="op">-</span>sayac y<span class="op">-</span>sayac) tahta))
    (<span class="cf">if</span> (<span class="kw">not</span> (equal konum<span class="op">-</span>degeri nil))
        (progn
          <span class="op">;;</span> tas degeri ve kral gosterge degerine eris
          (setq renk (car konum<span class="op">-</span>degeri))
          (setq kral<span class="op">-</span>mi (cadr konum<span class="op">-</span>degeri))

          <span class="op">;;</span> saymaya basla
                  
          <span class="op">;;</span> krallari say
          (<span class="cf">if</span> (<span class="kw">and</span> (equal <span class="op">*</span>enust<span class="op">-</span>renk<span class="op">*</span> renk)
               (equal kral<span class="op">-</span>mi t))
          (setq benim<span class="op">-</span>kral<span class="op">-</span>sayim (<span class="op">+</span> <span class="dv">1</span> benim<span class="op">-</span>kral<span class="op">-</span>sayim)))
        
          (<span class="cf">if</span> (<span class="kw">and</span> (equal <span class="op">*</span>enalt<span class="op">-</span>renk<span class="op">*</span> renk)
               (equal kral<span class="op">-</span>mi t))
               (setq rakibin<span class="op">-</span>kral<span class="op">-</span>sayisi (<span class="op">+</span> rakibin<span class="op">-</span>kral<span class="op">-</span>sayisi <span class="dv">1</span>)))

          <span class="op">;;</span> mevcut hareketleri say (hareket sahamiz ne kadar genis?)
          (setq mevcut<span class="op">-</span>hamlelerim
            (length (hareket<span class="op">-</span>listesi<span class="op">-</span>hesapla <span class="op">*</span>enust<span class="op">-</span>renk<span class="op">*</span> tahta)))
          (setq rakibin<span class="op">-</span>mevcut<span class="op">-</span>hamleleri
            (length (hareket<span class="op">-</span>listesi<span class="op">-</span>hesapla <span class="op">*</span>enalt<span class="op">-</span>renk<span class="op">*</span> tahta)))
          ))
    ))

    <span class="op">;;</span> hepsini topla
    (setf degerlendirme<span class="op">-</span>toplami
      (<span class="op">+</span> degerlendirme<span class="op">-</span>toplami
         (<span class="op">*</span> benim<span class="op">-</span>tas<span class="op">-</span>sayim benim<span class="op">-</span>kalan<span class="op">-</span>tas<span class="op">-</span>agirligim)))
    (setq degerlendirme<span class="op">-</span>toplami
      (<span class="op">+</span> degerlendirme<span class="op">-</span>toplami
         (<span class="op">*</span> rakibin<span class="op">-</span>tas<span class="op">-</span>sayisi rakibin<span class="op">-</span>kalan<span class="op">-</span>tas<span class="op">-</span>agirligi)))
    (setq degerlendirme<span class="op">-</span>toplami
      (<span class="op">+</span> degerlendirme<span class="op">-</span>toplami
         (<span class="op">*</span> benim<span class="op">-</span>kral<span class="op">-</span>sayim kralin<span class="op">-</span>agirligi)))
    (setq degerlendirme<span class="op">-</span>toplami
      (<span class="op">+</span> degerlendirme<span class="op">-</span>toplami
         (<span class="op">*</span> mevcut<span class="op">-</span>hamlelerim mevcut<span class="op">-</span>hamle<span class="op">-</span>agirligi)))

    <span class="op">;;</span> sonuc degeri geri bildir
    degerlendirme<span class="op">-</span>toplami)
  )

<span class="op">;;</span>
<span class="op">;;</span> testler
(setq bilgisayar<span class="op">-</span>hamle<span class="op">-</span>sayisi <span class="dv">0</span>)
(test <span class="st">&quot;atak mi defans mi? 1&quot;</span> (atak<span class="op">-</span>oyun?) nil)

(setq bilgisayar<span class="op">-</span>hamle<span class="op">-</span>sayisi <span class="dv">10</span>)
(test <span class="st">&quot;atak mi defans mi? 2&quot;</span> (atak<span class="op">-</span>oyun?) t)

(oyuna<span class="op">-</span>basla <span class="op">*</span>beyaz<span class="op">*</span>)
(test <span class="st">&quot;atak mi defans mi? 3&quot;</span> (atak<span class="op">-</span>oyun?) nil)

(oyuna<span class="op">-</span>basla <span class="op">*</span>beyaz<span class="op">*</span>)
(test <span class="st">&quot;tahta degerlendir&quot;</span> (tahta<span class="op">-</span>degeri <span class="op">*</span>tahta<span class="op">*</span>) <span class="dv">1620</span>)

(<span class="bu">print</span> <span class="st">&quot;Tamam. Degerlendirme Birim Testleri Gecti&quot;</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">(load <span class="st">&quot;dama-deger.lisp&quot;</span>)

(oyuna<span class="op">-</span>basla <span class="op">*</span>beyaz<span class="op">*</span>)

(<span class="bu">print</span> <span class="st">&quot;----------------------------------------------------&quot;</span>)
(<span class="bu">print</span> <span class="st">&quot;Hamleleri mesela siyah icin &#39;((0 2)(1 3)) seklinde girmek gerekli&quot;</span>)
(<span class="bu">print</span> <span class="st">&quot;Bu, x=0 y=2&#39;deki tasi x=1, y=3 pozisyonuna getirecektir&quot;</span>)
(<span class="bu">print</span> <span class="st">&quot;----------------------------------------------------&quot;</span>)

(loop
 (goster <span class="op">*</span>tahta<span class="op">*</span>)
 (<span class="bu">print</span> <span class="st">&quot;Hamlenizi giriniz&quot;</span>)
 (setq insan<span class="op">-</span>hamlesi (<span class="bu">eval</span> (read)))
 (cond ((equal (hamle<span class="op">-</span>kurallara<span class="op">-</span>uygunmu insan<span class="op">-</span>hamlesi <span class="op">*</span>tahta<span class="op">*</span> <span class="st">&quot;b&quot;</span>) t)
    (progn
      (tas<span class="op">-</span>oynat insan<span class="op">-</span>hamlesi <span class="op">*</span>tahta<span class="op">*</span>)
      (<span class="bu">print</span> <span class="st">&quot;su hareketi yaptiniz&quot;</span>)
      (<span class="bu">print</span> insan<span class="op">-</span>hamlesi)
      (goster <span class="op">*</span>tahta<span class="op">*</span>) 
      (setq bilgisayar<span class="op">-</span>hamlesi (cadr (altust<span class="op">-</span>arama <span class="op">*</span>tahta<span class="op">*</span>)))
      (<span class="bu">print</span> <span class="st">&quot;bilgisayarin hareketi&quot;</span>)
      (<span class="bu">print</span> bilgisayar<span class="op">-</span>hamlesi)
      (tas<span class="op">-</span>oynat bilgisayar<span class="op">-</span>hamlesi <span class="op">*</span>tahta<span class="op">*</span>)
      (setf bilgisayar<span class="op">-</span>hamle<span class="op">-</span>sayisi (<span class="op">+</span> bilgisayar<span class="op">-</span>hamle<span class="op">-</span>sayisi <span class="dv">1</span>))
      ))
    (t (<span class="bu">print</span> <span class="st">&quot;HATALI HAREKET&quot;</span>)))
 )</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">;;</span> Oyun tahtasi liste icinde liste olarak temsil edildi. Her tahta
<span class="op">;;</span> konumu, eger uzerinde bir tas var ise, bir liste nesnesi
<span class="op">;;</span> tasir. Eger bu tas normal bir tas ise, bu liste (<span class="st">&quot;b&quot;</span> nil) gibi
<span class="op">;;</span> olur. Eger bu tas kral tasi ise, (<span class="st">&quot;b&quot;</span> T) olarak temsil
<span class="op">;;</span> edilecektir. Yani, ikinci T ya da NIL degeri krallik
<span class="op">;;</span> gostergesidir. Eger konum uzerinde hic tas yok ise, liste nesnesi
<span class="op">;;</span> yerine NIL bulacaksiniz, dikkat edin (nil nil) degil. Listenin en
<span class="op">;;</span> sonundaki iki rakam, tahta uzerinde o anda her renkten kac tas
<span class="op">;;</span> kaldigini gosterir.  Birinci rakam beyaz, ikincisi siyah icin. Bunu
<span class="op">;;</span> yapmamizin sebebi algoritmayi hizlandirmak icin, boylece ikidebir
<span class="op">;;</span> tahtayi bastan sona taramak gerekmiyor.

(setq <span class="op">*</span>beyaz<span class="op">*</span>                  <span class="st">&quot;b&quot;</span>)
(setq <span class="op">*</span>siyah<span class="op">*</span>                  <span class="st">&quot;s&quot;</span>)
(setq <span class="op">*</span>enust<span class="op">-</span>renk<span class="op">*</span>              nil)
(setq <span class="op">*</span>enalt<span class="op">-</span>renk<span class="op">*</span>              nil)
(setq <span class="op">*</span>tahta<span class="op">*</span>                  nil)

(setq bilgisayar<span class="op">-</span>hamle<span class="op">-</span>sayisi <span class="dv">0</span>)

<span class="op">;;</span>
<span class="op">;;</span> test isleten islev
(defun test (isim deyim sonuc)
  (cond
   ((equal deyim sonuc) t)
   (t (<span class="bu">print</span> isim) (error <span class="st">&quot;HATA! Birim test bir yanlis buldu! &quot;</span>))  
   ))

<span class="op">;;</span>
<span class="op">;;</span> Tahta silbastan baslayinca, enust<span class="op">-</span>renk bilgisayara aittir.
(defun oyuna<span class="op">-</span>basla (renk)
  (setq bilgisayar<span class="op">-</span>hamle<span class="op">-</span>sayisi <span class="dv">0</span>)
  (setq <span class="op">*</span>tahta<span class="op">*</span> (copy<span class="op">-</span>tree (tahtayi<span class="op">-</span>hazirla)))
  (cond
   ((equal renk <span class="op">*</span>beyaz<span class="op">*</span>)
    (progn (setq <span class="op">*</span>enust<span class="op">-</span>renk<span class="op">*</span> <span class="st">&quot;b&quot;</span>)
       (setq <span class="op">*</span>enalt<span class="op">-</span>renk<span class="op">*</span> <span class="st">&quot;s&quot;</span>)))
   (t (progn  (setq <span class="op">*</span>enust<span class="op">-</span>renk<span class="op">*</span> <span class="st">&quot;s&quot;</span>)
          (setq <span class="op">*</span>enalt<span class="op">-</span>renk<span class="op">*</span> <span class="st">&quot;b&quot;</span>)
          )
      )
   )
  )

<span class="op">;;</span>
<span class="op">;;</span> tahtayi sifirla
(defun tahtayi<span class="op">-</span>hazirla ()
  <span class="st">&#39;(((nil (&quot;b&quot; nil)  nil (&quot;b&quot; nil)  nil (&quot;b&quot; nil)  nil (&quot;b&quot; nil) )</span>
<span class="st">     ((&quot;b&quot; nil)  nil (&quot;b&quot; nil)  nil (&quot;b&quot; nil)  nil (&quot;b&quot; nil)  nil)</span>
<span class="st">     (nil (&quot;b&quot; nil)  nil (&quot;b&quot; nil)  nil (&quot;b&quot; nil)  nil (&quot;b&quot; nil) )</span>
<span class="st">     (nil nil nil nil nil nil nil nil)</span>
<span class="st">     (nil nil nil nil nil nil nil nil)</span>
<span class="st">     ((&quot;s&quot; nil)  nil (&quot;s&quot; nil)  nil (&quot;s&quot; nil)  nil (&quot;s&quot; nil)  nil)</span>
<span class="st">     (nil (&quot;s&quot; nil)  nil (&quot;s&quot; nil)  nil (&quot;s&quot; nil)  nil (&quot;s&quot; nil) )</span>
<span class="st">     ((&quot;s&quot; nil)  nil (&quot;s&quot; nil)  nil (&quot;s&quot; nil)  nil (&quot;s&quot; nil)  nil)</span>
<span class="st">     ) (12 12))</span>
<span class="st">  )</span>

<span class="st">;;</span>
<span class="st">;; tahtanin o anki durumunu ekrana metin olarak bas (hata bulmak</span>
<span class="st">;; icin cok yararli oldu)</span>
<span class="st">(defun goster (tahta)</span>
<span class="st">  (terpri)</span>
<span class="st">  (write-line &quot;+=0===1===2===3===4===5===6===7-+&quot;)</span>
<span class="st">  (let ((y-sayici 8))</span>
<span class="st">    (dotimes (y-ozyine 8)</span>
<span class="st">      (princ (- y-sayici 1))</span>
<span class="st">      (let ((x-sayici 7))</span>
<span class="st">    (dolist (kon (nth (- 7 (- y-sayici 1)) (car tahta)))</span>
<span class="st">      (princ &quot; &quot;)</span>
<span class="st">      (cond</span>
<span class="st">       ((equal kon nil) (princ &quot; &quot;))</span>
<span class="st">       ((and (equal (car kon) &quot;b&quot;) (null (cadr kon))) (princ &quot;b&quot;))</span>
<span class="st">       ((and (equal (car kon) &quot;b&quot;) (cadr kon)) (princ &quot;B&quot;))</span>
<span class="st">       ((and (equal (car kon) &quot;s&quot;) (null (cadr kon))) (princ &quot;s&quot;))</span>
<span class="st">       ((and (equal (car kon) &quot;s&quot;) (cadr kon)) (princ &quot;S&quot;))</span>
<span class="st">       )</span>
<span class="st">      (princ &quot; &quot;)</span>
<span class="st">      (if (null (equal x-sayici 0)) (princ &quot;|&quot;))</span>
<span class="st">      (setq x-sayici (- x-sayici 1))</span>
<span class="st">      )</span>
<span class="st">    )</span>
<span class="st">      (write-line &quot;|&quot;)</span>
<span class="st">      (if (null (equal y-sayici 1))</span>
<span class="st">      (write-line &quot;|===============================|&quot;))</span>
<span class="st">      (setq y-sayici (- y-sayici 1))</span>
<span class="st">      )</span>
<span class="st">    )</span>
<span class="st">  (write-line &quot;+=0===1===2===3===4===5===6===7=+&quot;)</span>
<span class="st">  nil</span>
<span class="st">  )</span>

<span class="st">;;</span>
<span class="st">;; her hamle su sekilde temsil edilir, mesela &#39;</span>((<span class="dv">0</span> <span class="dv">2</span>)(<span class="dv">1</span> <span class="dv">2</span>))
<span class="op">;;</span> Yani, hamle  X<span class="op">=</span><span class="dv">1</span>, Y<span class="op">=</span><span class="dv">2</span> konumundan X<span class="op">=</span><span class="dv">1</span>, Y<span class="op">=</span><span class="dv">2</span> konumuna yapilacak.
(defun tas<span class="op">-</span>oynat (hamle tahta)

  (setq gecici<span class="op">-</span>tas1 (tas<span class="op">-</span>degeri<span class="op">-</span>ver (car hamle) tahta))
  (setq gecici<span class="op">-</span>tas2 (tas<span class="op">-</span>degeri<span class="op">-</span>ver (cadr hamle) tahta))

  <span class="op">;;</span> hamle
  (setq tahta 
    (tas<span class="op">-</span>degeri<span class="op">-</span>degis (cadr hamle) 
              (tas<span class="op">-</span>cikart (car hamle) tahta) gecici<span class="op">-</span>tas1))
  (setq atlanan<span class="op">-</span>konum 
    (atlayarak<span class="op">-</span>gidilen<span class="op">-</span>konumlar (car hamle) (cadr hamle))) 

  <span class="op">;;</span> eger gerekiyorsa krala cevir
  (cond
   ((<span class="kw">and</span> (equal (car gecici<span class="op">-</span>tas1) <span class="st">&quot;s&quot;</span>) (equal <span class="dv">7</span> (cadadr hamle))) 
    (setf (cadr gecici<span class="op">-</span>tas1) t))
   ((<span class="kw">and</span> (equal (car gecici<span class="op">-</span>tas1) <span class="st">&quot;b&quot;</span>) (equal <span class="dv">0</span> (cadadr hamle))) 
    (setf (cadr gecici<span class="op">-</span>tas1) t))
   )
    
  (cond
   (atlanan<span class="op">-</span>konum <span class="op">;;</span> hareket atlama ise
    (progn 
      (<span class="cf">if</span> (equal (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver atlanan<span class="op">-</span>konum tahta)) <span class="st">&quot;b&quot;</span>)
      (setf (caadr tahta) (<span class="op">-</span> (caadr tahta) <span class="dv">1</span>))
    (setf (cadadr tahta) (<span class="op">-</span> (cadadr tahta) <span class="dv">1</span>)))
      (setq tahta (tas<span class="op">-</span>cikart atlanan<span class="op">-</span>konum tahta))
      (cond
       ((caddr hamle) <span class="op">;;</span> birkac atlama var ise, ozyineli olarak cagir
    (progn
      (tas<span class="op">-</span>oynat (cdr hamle) tahta)
      )
    )
       (t
    tahta ))
      )
    )
   (t <span class="op">;;</span> atlama degil
    tahta
    )  
   )
  ) 

<span class="op">;;</span>
<span class="op">;;</span> tas degerini geri getir
(defun tas<span class="op">-</span>degeri<span class="op">-</span>ver (kon tahta)
  (nth (car kon) (nth (<span class="op">-</span> <span class="dv">7</span> (cadr kon)) (car tahta)))
  )

<span class="op">;;</span>
<span class="op">;;</span> tasin degerini tahtaya koy
(defun tas<span class="op">-</span>degeri<span class="op">-</span>degis (kon tahta eleman)
  (setf (nth (car kon) (nth (<span class="op">-</span> <span class="dv">7</span> (cadr kon)) (car tahta))) eleman)
  tahta
  )

<span class="op">;;</span>
<span class="op">;;</span> tasi tahtadan al
(defun tas<span class="op">-</span>cikart (kon tahta)
  (setf (nth (car kon) (nth (<span class="op">-</span> <span class="dv">7</span> (cadr kon)) (car tahta))) nil)
  tahta
  )

<span class="op">;;</span>
<span class="op">;;</span> 
(defun atlayarak<span class="op">-</span>gidilen<span class="op">-</span>konumlar (kon_a kon_b)
  (setq x (car kon_a))
  (setq y (cadr kon_a))
  (cond
   ((equal kon_b (<span class="bu">list</span> (<span class="op">+</span> x <span class="dv">1</span>) (<span class="op">+</span> y <span class="dv">1</span>))) nil)
   ((equal kon_b (<span class="bu">list</span> (<span class="op">+</span> x <span class="dv">1</span>) (<span class="op">-</span> y <span class="dv">1</span>))) nil)
   ((equal kon_b (<span class="bu">list</span> (<span class="op">-</span> x <span class="dv">1</span>) (<span class="op">+</span> y <span class="dv">1</span>))) nil)
   ((equal kon_b (<span class="bu">list</span> (<span class="op">-</span> x <span class="dv">1</span>) (<span class="op">-</span> y <span class="dv">1</span>))) nil)
   <span class="op">;;</span> ya da ortada kalan taslarin kordinatlarini getir
   (t 
    (cond
     ((<span class="op">&lt;</span> x (car kon_b)) (setq gecici_x (<span class="op">+</span> <span class="dv">1</span> x)))
     (t (setq gecici_x (<span class="op">-</span> x <span class="dv">1</span>)))
     )
    (cond
     ((<span class="op">&lt;</span> y (cadr kon_b)) (setq gecici_y (<span class="op">+</span> <span class="dv">1</span> y)))
     (t (setq gecici_y (<span class="op">-</span> y <span class="dv">1</span>)))
     )
    (<span class="bu">list</span> gecici_x gecici_y)
    )
   )
  )

(defun hamle<span class="op">-</span>kurallara<span class="op">-</span>uygunmu (hareket tahta renk)
  <span class="op">;;</span> hareket menzilin disinda ise, bu kural disi bir hareket
  (cond
   ((null (menzildemi (cadr hareket)))
    nil
    )
   <span class="op">;;</span> gitmeye ugrastigimiz yerde zaten bir tas var ise,
   <span class="op">;;</span> bu da kural disi bir harekettir
   ((tas<span class="op">-</span>degeri<span class="op">-</span>ver (cadr hareket) tahta) 
    nil
    )
   (t 
    (let (
      (eleman (tas<span class="op">-</span>degeri<span class="op">-</span>ver (car hareket) tahta))
      (baslax (caar hareket))
      (baslay (cadar hareket))
      (bitisx   (caadr hareket))
      (bitisy   (cadadr hareket)))

      (cond 
       <span class="op">;;</span> eger hareket ziplama hareketi ise
       ((equal <span class="dv">2</span> (<span class="bu">abs</span> (<span class="op">-</span> baslax bitisx)))
    (cond
     ((equal eleman (<span class="bu">list</span> <span class="st">&quot;s&quot;</span> nil))
      (<span class="cf">if</span> (<span class="kw">and</span> (equal <span class="dv">2</span> (<span class="op">-</span> bitisy baslay))
           (equal (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver
                (atlayarak<span class="op">-</span>gidilen<span class="op">-</span>konumlar 
                 (car hareket)
                 (cadr hareket)) tahta)) <span class="st">&quot;b&quot;</span>))
          t
        )
      )
     ((equal eleman (<span class="bu">list</span> <span class="st">&quot;b&quot;</span> nil))
      (<span class="cf">if</span> (<span class="kw">and</span> (equal <span class="dv">-2</span> (<span class="op">-</span> bitisy baslay))
           (equal (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver
                (atlayarak<span class="op">-</span>gidilen<span class="op">-</span>konumlar 
                 (car hareket)
                 (cadr hareket)) tahta)) <span class="st">&quot;s&quot;</span>))
          t
        )
      )
     ((equal (cadr eleman) t)
      (<span class="cf">if</span> (<span class="kw">and</span> (equal <span class="dv">2</span> (<span class="bu">abs</span> (<span class="op">-</span> bitisy baslay)))
           (equal (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver
                (atlayarak<span class="op">-</span>gidilen<span class="op">-</span>konumlar 
                 (car hareket)
                 (cadr hareket)) tahta))
              (renk<span class="op">-</span>degistir renk)))
          t
        )
      )
     )
    )
       <span class="op">;;</span> ziplama degil ise
       ((equal <span class="dv">1</span> (<span class="bu">abs</span> (<span class="op">-</span> baslax bitisx)))
    (cond
     ((equal eleman (<span class="bu">list</span> <span class="st">&quot;s&quot;</span> nil))
      (<span class="cf">if</span> (equal <span class="dv">1</span> (<span class="op">-</span> bitisy baslay))
          t
        )
      )
     ((equal eleman (<span class="bu">list</span> <span class="st">&quot;b&quot;</span> nil))
      (<span class="cf">if</span> (equal <span class="dv">-1</span> (<span class="op">-</span> bitisy baslay))
          t
        )
      )
     ((equal (cadr eleman) t)
      (<span class="cf">if</span> (equal <span class="dv">1</span> (<span class="bu">abs</span> (<span class="op">-</span> baslay bitisy))) t)
      )
     )
    )
       )
      )
    )
   )
  )

(defun menzildemi (kon)
  (let ((x (car kon)) (y (cadr kon)))
    (cond 
     ((<span class="kw">and</span> (<span class="op">&lt;</span> x <span class="dv">8</span>) (<span class="op">&lt;</span> y <span class="dv">8</span>) (<span class="op">&gt;</span> x <span class="dv">-1</span>) (<span class="op">&gt;</span> y <span class="dv">-1</span>)) t)
     (t nil)
     )
    )
  )

(defun renk<span class="op">-</span>degistir (color)
  (cond
   ((equal <span class="st">&quot;b&quot;</span> color) <span class="st">&quot;r&quot;</span>)
   (t <span class="st">&quot;b&quot;</span>)
   )
  )

<span class="op">;;</span>
<span class="op">;;</span> girilen renk ve tahtaya gore, oyuncunun yapabilecegi
<span class="op">;;</span> butun hareketleri geri getir
(defun hareket<span class="op">-</span>listesi<span class="op">-</span>hesapla (renk tahta)
  (setq tas<span class="op">-</span>konumlari (tas<span class="op">-</span>yerlerini<span class="op">-</span>ver renk tahta))
  (let ((muhtemel<span class="op">-</span>hareketler nil) (mumkun<span class="op">-</span>atlamalar nil))
    (dolist (kon tas<span class="op">-</span>konumlari)
      (setq mumkun<span class="op">-</span>atlamalar 
        (append mumkun<span class="op">-</span>atlamalar
            (mecburi<span class="op">-</span>hareketleri<span class="op">-</span>ver kon tahta renk)))
      (<span class="cf">if</span> (null mumkun<span class="op">-</span>atlamalar) 
      (progn
        (<span class="cf">if</span> (hamle<span class="op">-</span>kurallara<span class="op">-</span>uygunmu
         (<span class="bu">list</span> kon (<span class="bu">list</span> (<span class="op">-</span> (car kon) <span class="dv">1</span>)
                 (<span class="op">-</span> (cadr kon) <span class="dv">1</span>))) tahta renk)
        (setq muhtemel<span class="op">-</span>hareketler
              (append 
               muhtemel<span class="op">-</span>hareketler
               (<span class="bu">list</span> (<span class="bu">list</span> kon (<span class="bu">list</span> (<span class="op">-</span> (car kon) <span class="dv">1</span>)
                         (<span class="op">-</span> (cadr kon) <span class="dv">1</span>)))))))
        (<span class="cf">if</span> (hamle<span class="op">-</span>kurallara<span class="op">-</span>uygunmu
         (<span class="bu">list</span> kon (<span class="bu">list</span> (<span class="op">-</span> (car kon) <span class="dv">1</span>)
                 (<span class="op">+</span> (cadr kon) <span class="dv">1</span>))) tahta renk)
        (setq muhtemel<span class="op">-</span>hareketler
              (append 
               muhtemel<span class="op">-</span>hareketler
               (<span class="bu">list</span> (<span class="bu">list</span> kon (<span class="bu">list</span> (<span class="op">-</span> (car kon) <span class="dv">1</span>)
                         (<span class="op">+</span> (cadr kon) <span class="dv">1</span>)))))))
        (<span class="cf">if</span> (hamle<span class="op">-</span>kurallara<span class="op">-</span>uygunmu
         (<span class="bu">list</span> kon (<span class="bu">list</span> (<span class="op">+</span> (car kon) <span class="dv">1</span>)
                 (<span class="op">-</span> (cadr kon) <span class="dv">1</span>))) tahta renk)
        (setq muhtemel<span class="op">-</span>hareketler
              (append 
               muhtemel<span class="op">-</span>hareketler
               (<span class="bu">list</span> (<span class="bu">list</span> kon (<span class="bu">list</span> (<span class="op">+</span> (car kon) <span class="dv">1</span>)
                         (<span class="op">-</span> (cadr kon) <span class="dv">1</span>)))))))
        (<span class="cf">if</span> (hamle<span class="op">-</span>kurallara<span class="op">-</span>uygunmu
         (<span class="bu">list</span> kon (<span class="bu">list</span> (<span class="op">+</span> (car kon) <span class="dv">1</span>)
                 (<span class="op">+</span> (cadr kon) <span class="dv">1</span>))) tahta renk)
        (setq muhtemel<span class="op">-</span>hareketler
              (append 
               muhtemel<span class="op">-</span>hareketler
               (<span class="bu">list</span> (<span class="bu">list</span> kon (<span class="bu">list</span> (<span class="op">+</span> (car kon) <span class="dv">1</span>)
                         (<span class="op">+</span> (cadr kon) <span class="dv">1</span>)))))))
        ) <span class="op">;;</span> progn sonu
    ) <span class="op">;;</span> <span class="cf">if</span> sonu
      )
    (<span class="cf">if</span> mumkun<span class="op">-</span>atlamalar mumkun<span class="op">-</span>atlamalar muhtemel<span class="op">-</span>hareketler)
    )
  )

(defun tas<span class="op">-</span>yerlerini<span class="op">-</span>ver (renk tahta)
    (setq konumlar nil)

    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(0 0) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">0</span> <span class="dv">0</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(0 1) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">0</span> <span class="dv">1</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(0 2) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">0</span> <span class="dv">2</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(0 3) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">0</span> <span class="dv">3</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(0 4) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">0</span> <span class="dv">4</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(0 5) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">0</span> <span class="dv">5</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(0 6) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">0</span> <span class="dv">6</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(0 7) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">0</span> <span class="dv">7</span>)))))

    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(1 0) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">1</span> <span class="dv">0</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(1 1) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">1</span> <span class="dv">1</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(1 2) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">1</span> <span class="dv">2</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(1 3) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">1</span> <span class="dv">3</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(1 4) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">1</span> <span class="dv">4</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(1 5) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">1</span> <span class="dv">5</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(1 6) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">1</span> <span class="dv">6</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(1 7) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">1</span> <span class="dv">7</span>)))))

    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(2 0) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">2</span> <span class="dv">0</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(2 1) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">2</span> <span class="dv">1</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(2 2) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">2</span> <span class="dv">2</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(2 3) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">2</span> <span class="dv">3</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(2 4) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">2</span> <span class="dv">4</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(2 5) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">2</span> <span class="dv">5</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(2 6) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">2</span> <span class="dv">6</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(2 7) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">2</span> <span class="dv">7</span>)))))

    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(3 0) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">3</span> <span class="dv">0</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(3 1) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">3</span> <span class="dv">1</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(3 2) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">3</span> <span class="dv">2</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(3 3) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">3</span> <span class="dv">3</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(3 4) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">3</span> <span class="dv">4</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(3 5) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">3</span> <span class="dv">5</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(3 6) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">3</span> <span class="dv">6</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(3 7) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">3</span> <span class="dv">7</span>)))))

    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(4 0) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">4</span> <span class="dv">0</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(4 1) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">4</span> <span class="dv">1</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(4 2) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">4</span> <span class="dv">2</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(4 3) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">4</span> <span class="dv">3</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(4 4) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">4</span> <span class="dv">4</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(4 5) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">4</span> <span class="dv">5</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(4 6) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">4</span> <span class="dv">6</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(4 7) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">4</span> <span class="dv">7</span>)))))

    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(5 0) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">5</span> <span class="dv">0</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(5 1) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">5</span> <span class="dv">1</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(5 2) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">5</span> <span class="dv">2</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(5 3) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">5</span> <span class="dv">3</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(5 4) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">5</span> <span class="dv">4</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(5 5) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">5</span> <span class="dv">5</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(5 6) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">5</span> <span class="dv">6</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(5 7) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">5</span> <span class="dv">7</span>)))))

    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(6 0) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">6</span> <span class="dv">0</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(6 1) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">6</span> <span class="dv">1</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(6 2) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">6</span> <span class="dv">2</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(6 3) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">6</span> <span class="dv">3</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(6 4) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">6</span> <span class="dv">4</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(6 5) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">6</span> <span class="dv">5</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(6 6) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">6</span> <span class="dv">6</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(6 7) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">6</span> <span class="dv">7</span>)))))

    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(7 0) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">7</span> <span class="dv">0</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(7 1) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">7</span> <span class="dv">1</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(7 2) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">7</span> <span class="dv">2</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(7 3) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">7</span> <span class="dv">3</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(7 4) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">7</span> <span class="dv">4</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(7 5) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">7</span> <span class="dv">5</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(7 6) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">7</span> <span class="dv">6</span>)))))
    (<span class="cf">if</span> (equal renk (car (tas<span class="op">-</span>degeri<span class="op">-</span>ver <span class="st">&#39;(7 7) tahta)))</span>
<span class="st">        (setq konumlar (append konumlar &#39;</span>((<span class="dv">7</span> <span class="dv">7</span>)))))

    konumlar
)


(defun mecburi<span class="op">-</span>hareketleri<span class="op">-</span>ver (kon tahta renk)
  (let ((muhtemel<span class="op">-</span>hareketler nil) (eleman (tas<span class="op">-</span>degeri<span class="op">-</span>ver kon tahta)))
    (<span class="cf">if</span> (cadr eleman)
    <span class="op">;;</span>
    <span class="op">;;</span>  KRALLAR
    <span class="op">;;</span>
    (progn
      (setq muhtemel<span class="op">-</span>hareketler
        (atlamalari<span class="op">-</span>bul
         (copy<span class="op">-</span>tree tahta) kon (<span class="op">+</span> (car kon) <span class="dv">2</span>)
         (<span class="op">+</span> (cadr kon) <span class="dv">2</span>) renk muhtemel<span class="op">-</span>hareketler))
      (setq muhtemel<span class="op">-</span>hareketler
        (atlamalari<span class="op">-</span>bul
         (copy<span class="op">-</span>tree tahta) kon (<span class="op">+</span> (car kon) <span class="dv">2</span>)
         (<span class="op">-</span> (cadr kon) <span class="dv">2</span>) renk muhtemel<span class="op">-</span>hareketler))
      (setq muhtemel<span class="op">-</span>hareketler
        (atlamalari<span class="op">-</span>bul
         (copy<span class="op">-</span>tree tahta) kon (<span class="op">-</span> (car kon) <span class="dv">2</span>)
         (<span class="op">+</span> (cadr kon) <span class="dv">2</span>) renk muhtemel<span class="op">-</span>hareketler))
      (setq muhtemel<span class="op">-</span>hareketler
        (atlamalari<span class="op">-</span>bul
         (copy<span class="op">-</span>tree tahta) kon (<span class="op">-</span> (car kon) <span class="dv">2</span>)
         (<span class="op">-</span> (cadr kon) <span class="dv">2</span>) renk muhtemel<span class="op">-</span>hareketler))
      )
      <span class="op">;;</span>
      <span class="op">;;</span>  NORMAL
      <span class="op">;;</span>
      (progn
    (<span class="cf">if</span> (equal renk <span class="st">&quot;b&quot;</span>) 
        (progn
          <span class="op">;;</span>
          <span class="op">;;</span>  BEYAZ  :: Bu demektir ki normal parcalar icin <span class="op">+</span> kullan
          <span class="op">;;</span>
          (setq muhtemel<span class="op">-</span>hareketler
            (atlamalari<span class="op">-</span>bul
             (copy<span class="op">-</span>tree tahta) kon (<span class="op">+</span> (car kon) <span class="dv">2</span>)
             (<span class="op">-</span> (cadr kon) <span class="dv">2</span>) renk muhtemel<span class="op">-</span>hareketler))
          (setq muhtemel<span class="op">-</span>hareketler
            (atlamalari<span class="op">-</span>bul
             (copy<span class="op">-</span>tree tahta) kon (<span class="op">-</span> (car kon) <span class="dv">2</span>)
             (<span class="op">-</span> (cadr kon) <span class="dv">2</span>) renk muhtemel<span class="op">-</span>hareketler))
          )
      (progn
        <span class="op">;;</span>
        <span class="op">;;</span>  SIYAH  :: Buna gore normal parcalar icin <span class="st">&#39;-&#39;</span> kullan
        <span class="op">;;</span>
        (setq muhtemel<span class="op">-</span>hareketler
          (atlamalari<span class="op">-</span>bul
           (copy<span class="op">-</span>tree tahta) kon (<span class="op">+</span> (car kon) <span class="dv">2</span>)
           (<span class="op">+</span> (cadr kon) <span class="dv">2</span>) renk muhtemel<span class="op">-</span>hareketler))
        (setq muhtemel<span class="op">-</span>hareketler
          (atlamalari<span class="op">-</span>bul
           (copy<span class="op">-</span>tree tahta) kon (<span class="op">-</span> (car kon) <span class="dv">2</span>)
           (<span class="op">+</span> (cadr kon) <span class="dv">2</span>) renk muhtemel<span class="op">-</span>hareketler))
        )
      )
    )
      )
    muhtemel<span class="op">-</span>hareketler
    )
  )

<span class="op">;;</span>
<span class="op">;;</span> 
(defun atlamalari<span class="op">-</span>bul (gecici_tahta kon yenix yeniy renk m<span class="op">-</span>hareketler)
  (let ((muhtemel<span class="op">-</span>hareketler nil))
    (<span class="cf">if</span> (hamle<span class="op">-</span>kurallara<span class="op">-</span>uygunmu 
     (<span class="bu">list</span> kon (<span class="bu">list</span> yenix yeniy)) gecici_tahta renk)
    (progn
      (setq gecici_tahta 
        (tas<span class="op">-</span>oynat (<span class="bu">list</span> kon (<span class="bu">list</span> yenix yeniy)) gecici_tahta))
      (setq gecici 
        (mecburi<span class="op">-</span>hareketleri<span class="op">-</span>ver 
         (<span class="bu">list</span> yenix yeniy) gecici_tahta renk))
      (<span class="cf">if</span> gecici 
          (dolist (b gecici)
        (setq a (<span class="bu">list</span> kon (<span class="bu">list</span> yenix yeniy)))
        (<span class="cf">if</span> muhtemel<span class="op">-</span>hareketler
            (setq muhtemel<span class="op">-</span>hareketler
              (append 
               muhtemel<span class="op">-</span>hareketler 
               (<span class="bu">list</span> (append a (cdr b)))))
          (setq muhtemel<span class="op">-</span>hareketler
            (<span class="bu">list</span> (append muhtemel<span class="op">-</span>hareketler a (cdr b))))
          )
        )
        (setq muhtemel<span class="op">-</span>hareketler (<span class="bu">list</span> (<span class="bu">list</span> kon (<span class="bu">list</span> yenix yeniy))))
        )
      ))
    (<span class="cf">if</span> muhtemel<span class="op">-</span>hareketler 
    (append m<span class="op">-</span>hareketler muhtemel<span class="op">-</span>hareketler) m<span class="op">-</span>hareketler)
    )
  )

<span class="op">;;</span> Oyunun bitip bitmedigine karar veren islev budur. Cagirmak icin
<span class="op">;;</span> bir renk ve tahtanin durumu bildirilir, eger renk icin hic bir
<span class="op">;;</span> hareket kalmadi ise, bu oyuncu icin oyun bitmis demektir.
<span class="op">;;</span> Bu oyuncunun belki taslarinin onu kapanmistir, ya da hic
<span class="op">;;</span> tasi kalmamistir. Her iki halde de hareket<span class="op">-</span>listesi<span class="op">-</span>hesapla
<span class="op">;;</span> hic hareket listesi geri getirmez. 
(defun oyun<span class="op">-</span>bitti<span class="op">-</span>mi?(renk tahta)
  (cond
   ((equal (hareket<span class="op">-</span>listesi<span class="op">-</span>hesapla renk tahta) nil) t)
   (t nil))
  )


<span class="op">;;</span> <span class="op">-------------------------------------------------------------</span>
<span class="op">;;</span>
<span class="op">;;</span> testler

(oyuna<span class="op">-</span>basla <span class="op">*</span>beyaz<span class="op">*</span>)
(setf sonuc (tas<span class="op">-</span>oynat <span class="st">&#39;((0 2)(1 2)) *tahta*))</span>
<span class="st">(setf beklenen-sonuc</span>
<span class="st">      &#39;</span>(((nil (<span class="st">&quot;b&quot;</span> nil) nil (<span class="st">&quot;b&quot;</span> nil) nil (<span class="st">&quot;b&quot;</span> nil) nil (<span class="st">&quot;b&quot;</span> nil))
     ((<span class="st">&quot;b&quot;</span> nil) nil (<span class="st">&quot;b&quot;</span> nil) nil (<span class="st">&quot;b&quot;</span> nil) nil (<span class="st">&quot;b&quot;</span> nil) nil)
     (nil (<span class="st">&quot;b&quot;</span> nil) nil (<span class="st">&quot;b&quot;</span> nil) nil (<span class="st">&quot;b&quot;</span> nil) nil (<span class="st">&quot;b&quot;</span> nil))
     (nil nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil nil)
     (nil (<span class="st">&quot;s&quot;</span> nil) (<span class="st">&quot;s&quot;</span> nil) nil (<span class="st">&quot;s&quot;</span> nil) nil (<span class="st">&quot;s&quot;</span> nil) nil)
     (nil nil nil (<span class="st">&quot;s&quot;</span> nil) nil (<span class="st">&quot;s&quot;</span> nil) nil (<span class="st">&quot;s&quot;</span> nil))
     ((<span class="st">&quot;s&quot;</span> nil) nil (<span class="st">&quot;s&quot;</span> nil) nil (<span class="st">&quot;s&quot;</span> nil) nil (<span class="st">&quot;s&quot;</span> nil) nil))
    (<span class="dv">12</span> <span class="dv">11</span>)) )
(test <span class="st">&quot;tek hareket yap&quot;</span> (equal beklenen<span class="op">-</span>sonuc sonuc) t)

(oyuna<span class="op">-</span>basla <span class="op">*</span>beyaz<span class="op">*</span>)
(test <span class="st">&quot;yanlis hareket yap&quot;</span>
      (hamle<span class="op">-</span>kurallara<span class="op">-</span>uygunmu <span class="st">&#39;((0 2)(1 2)) *tahta* *beyaz*) nil)</span>

<span class="st">(oyuna-basla *beyaz*)</span>
<span class="st">(test &quot;dogru hamle yap&quot; </span>
<span class="st">      (hamle-kurallara-uygunmu &#39;</span>((<span class="dv">0</span> <span class="dv">2</span>)(<span class="dv">1</span> <span class="dv">3</span>)) <span class="op">*</span>tahta<span class="op">*</span> <span class="st">&#39;USER::BLACK) T)</span>

<span class="st">(oyuna-basla *beyaz*)</span>
<span class="st">(setf beklenen-hareket-listesi </span>
<span class="st">      &#39;</span>(((<span class="dv">1</span> <span class="dv">5</span>) (<span class="dv">0</span> <span class="dv">4</span>)) ((<span class="dv">1</span> <span class="dv">5</span>) (<span class="dv">2</span> <span class="dv">4</span>)) ((<span class="dv">3</span> <span class="dv">5</span>) (<span class="dv">2</span> <span class="dv">4</span>))
    ((<span class="dv">3</span> <span class="dv">5</span>) (<span class="dv">4</span> <span class="dv">4</span>)) ((<span class="dv">5</span> <span class="dv">5</span>) (<span class="dv">4</span> <span class="dv">4</span>)) ((<span class="dv">5</span> <span class="dv">5</span>) (<span class="dv">6</span> <span class="dv">4</span>)) ((<span class="dv">7</span> <span class="dv">5</span>) (<span class="dv">6</span> <span class="dv">4</span>))))
(setf sonuc (hareket<span class="op">-</span>listesi<span class="op">-</span>hesapla <span class="st">&quot;b&quot;</span> <span class="op">*</span>tahta<span class="op">*</span>))
(test <span class="st">&quot;oyuna uygun hareket&quot;</span> (equal sonuc beklenen<span class="op">-</span>hareket<span class="op">-</span>listesi ) t)

(oyuna<span class="op">-</span>basla <span class="op">*</span>beyaz<span class="op">*</span>)
(setf gecici<span class="op">-</span>sonuc (tas<span class="op">-</span>oynat <span class="st">&#39;((0 2)(2 7)) *tahta*))</span>
<span class="st">(setf beklenen-tahta</span>
<span class="st">      &#39;</span>(((nil (<span class="st">&quot;b&quot;</span> nil) (<span class="st">&quot;s&quot;</span> T) (<span class="st">&quot;b&quot;</span> nil) nil (<span class="st">&quot;b&quot;</span> nil) nil (<span class="st">&quot;b&quot;</span> nil))
     ((<span class="st">&quot;b&quot;</span> nil) nil (<span class="st">&quot;b&quot;</span> nil) nil (<span class="st">&quot;b&quot;</span> nil) nil (<span class="st">&quot;b&quot;</span> nil) nil)
     (nil (<span class="st">&quot;b&quot;</span> nil) nil (<span class="st">&quot;b&quot;</span> nil) nil (<span class="st">&quot;b&quot;</span> nil) nil (<span class="st">&quot;b&quot;</span> nil))
     (nil nil nil nil nil nil nil nil) 
     (nil nil nil nil nil nil nil nil)
     (nil nil (<span class="st">&quot;s&quot;</span> nil) nil (<span class="st">&quot;s&quot;</span> nil) nil (<span class="st">&quot;s&quot;</span> nil) nil)
     (nil (<span class="st">&quot;s&quot;</span> nil) nil (<span class="st">&quot;s&quot;</span> nil) nil (<span class="st">&quot;s&quot;</span> nil) nil (<span class="st">&quot;s&quot;</span> nil))
     ((<span class="st">&quot;s&quot;</span> nil) nil (<span class="st">&quot;s&quot;</span> nil) nil (<span class="st">&quot;s&quot;</span> nil) nil (<span class="st">&quot;s&quot;</span> nil) nil))
    (<span class="dv">12</span> <span class="dv">11</span>)))
(test <span class="st">&quot;kral yap&quot;</span> (equal gecici<span class="op">-</span>sonuc beklenen<span class="op">-</span>tahta) t)

(setf hic<span class="op">-</span>siyah<span class="op">-</span>tassiz<span class="op">-</span>tahta
  <span class="st">&#39;(((nil (&quot;b&quot; nil)  nil (&quot;b&quot; nil)  nil (&quot;b&quot; nil)  nil (&quot;b&quot; nil) )</span>
<span class="st">     ((&quot;b&quot; nil)  nil (&quot;b&quot; nil)  nil (&quot;b&quot; nil)  nil (&quot;b&quot; nil)  nil)</span>
<span class="st">     (nil (&quot;b&quot; nil)  nil (&quot;b&quot; nil)  nil (&quot;b&quot; nil)  nil (&quot;b&quot; nil) )</span>
<span class="st">     (nil nil nil nil nil nil nil nil)(nil nil nil nil nil nil nil nil)</span>
<span class="st">     (nil nil nil nil nil nil nil nil)(nil nil nil nil nil nil nil nil )</span>
<span class="st">     (nil nil nil nil nil nil nil nil)) (12 0)))</span>
<span class="st">(test &quot;siyah icin oyun bitti&quot; </span>
<span class="st">      (oyun-bitti-mi? *siyah* hic-siyah-tassiz-tahta) t)</span>

<span class="st">(print &quot;Tamam. Temel Birim Testler Gecti&quot;)</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">(load <span class="st">&quot;dama-deger.lisp&quot;</span>)

(oyuna<span class="op">-</span>basla <span class="op">*</span>beyaz<span class="op">*</span>)

(goster <span class="op">*</span>tahta<span class="op">*</span>)
(setq insan<span class="op">-</span>hamlesi <span class="st">&#39;((0 2)(1 3)))</span>
<span class="st">(cond ((equal (hamle-kurallara-uygunmu insan-hamlesi *tahta* &quot;b&quot;) t)</span>
<span class="st">       (progn</span>
<span class="st">     (tas-oynat insan-hamlesi *tahta*)</span>
<span class="st">     (print &quot;su hareketi yaptiniz&quot;)</span>
<span class="st">     (print insan-hamlesi)</span>
<span class="st">     (goster *tahta*) </span>
<span class="st">     (setq bilgisayar-hamlesi (cadr (altust-arama *tahta*)))</span>
<span class="st">     (print &quot;bilgisayarin hareketi&quot;)</span>
<span class="st">     (print bilgisayar-hamlesi)</span>
<span class="st">     (tas-oynat bilgisayar-hamlesi *tahta*)</span>
<span class="st">     (setf bilgisayar-hamle-sayisi (+ bilgisayar-hamle-sayisi 1))</span>
<span class="st">     (goster *tahta*) </span>
<span class="st">     ))</span>
<span class="st">      (t (print &quot;HATALI HAREKET&quot;)))</span></code></pre></div>
<p>Tek hamlelik bir oyun oynayalım, ve bilgisayarın karşılığını görelim,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">!</span>clisp dama<span class="op">-</span>test.lisp</code></pre></div>
<pre><code>
&quot;Tamam. Temel Birim Testler Gecti&quot; 
&quot;Tamam. Algoritma Birim Testleri Gecti&quot; 
WARNING: DEFUN/DEFMACRO: redefining function TAHTA-DEGERI in
         /home/burak/Documents/classnotes/app-math-tr/probsolve/dama-deger.lisp,
         was defined in
         /home/burak/Documents/classnotes/app-math-tr/probsolve/dama-alg.lisp
&quot;Tamam. Degerlendirme Birim Testleri Gecti&quot; 
+=0===1===2===3===4===5===6===7-+
7   | b |   | b |   | b |   | b |
|===============================|
6 b |   | b |   | b |   | b |   |
|===============================|
5   | b |   | b |   | b |   | b |
|===============================|
4   |   |   |   |   |   |   |   |
|===============================|
3   |   |   |   |   |   |   |   |
|===============================|
2 s |   | s |   | s |   | s |   |
|===============================|
1   | s |   | s |   | s |   | s |
|===============================|
0 s |   | s |   | s |   | s |   |
+=0===1===2===3===4===5===6===7=+

&quot;su hareketi yaptiniz&quot; 
((0 2) (1 3)) 
+=0===1===2===3===4===5===6===7-+
7   | b |   | b |   | b |   | b |
|===============================|
6 b |   | b |   | b |   | b |   |
|===============================|
5   | b |   | b |   | b |   | b |
|===============================|
4   |   |   |   |   |   |   |   |
|===============================|
3   | s |   |   |   |   |   |   |
|===============================|
2   |   | s |   | s |   | s |   |
|===============================|
1   | s |   | s |   | s |   | s |
|===============================|
0 s |   | s |   | s |   | s |   |
+=0===1===2===3===4===5===6===7=+

&quot;bilgisayarin hareketi&quot; 
((1 5) (0 4)) 
+=0===1===2===3===4===5===6===7-+
7   | b |   | b |   | b |   | b |
|===============================|
6 b |   | b |   | b |   | b |   |
|===============================|
5   |   |   | b |   | b |   | b |
|===============================|
4 b |   |   |   |   |   |   |   |
|===============================|
3   | s |   |   |   |   |   |   |
|===============================|
2   |   | s |   | s |   | s |   |
|===============================|
1   | s |   | s |   | s |   | s |
|===============================|
0 s |   | s |   | s |   | s |   |
+=0===1===2===3===4===5===6===7=+</code></pre>
<p>Biz siyah (s) tarafıyız ve ilk hamleyi <code>0,2</code> kordinatından <code>1,3</code> kordinatına dogru yaptık. Bilgisayar buna karşılık <code>1,5</code>'ten <code>0,4</code>'e doğru bir hamle yapti. %</p>
</body>
</html>
