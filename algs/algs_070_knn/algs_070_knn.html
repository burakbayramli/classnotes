<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>En Yakın k-Komşu (k-Nearest Neighbor), Geometrik Yakınlık Hesabı</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1
id="en-yakın-k-komşu-k-nearest-neighbor-geometrik-yakınlık-hesabı">En
Yakın k-Komşu (k-Nearest Neighbor), Geometrik Yakınlık Hesabı</h1>
<p>Yapay Öğrenim alanında örnek bazlı öğrenen algoritmalardan bilinen
KNN, eğitim verinin kendisini sınıflama (classification) amaçlı olarak
kullanır, yeni bir model ortaya çıkartmaz. Algoritma şöyle işler:
etiketleri bilinen eğitim verisi alınır ve bir kenarda tutulur. Yeni bir
veri noktası görülünce bu veriye geri dönülür ve o noktaya “en yakın’’ k
tane nokta bulunur. Daha sonra bu noktaların etiketlerine bakılır ve
çoğunluğun etiketi ne ise, o etiket yeni noktanın etiketi olarak kabul
edilir. Mesela elde <code>1</code> kategorisi altında
<code>[2 2]</code>, <code>2</code> kategorisi altında <code>[5 5]</code>
var ise, yeni nokta <code>[3, 3]</code> için yakınlık açısından
<code>[2 2]</code> bulunmalı ve etiket olarak <code>1</code> sonucu
döndürülmelidir.</p>
<p>Üstte tarif edilen basit bir ihtiyaç, yöntem gibi görülebilir. Fakat
yapay öğrenim ve yapay zeka çok boyutlarda örüntü tanıma (pattern
recognition) ile uğraşır, ve milyonlarca satırlık veri, onlarca boyut
(üstteki örnekte 2, fakat çoğunlukla çok daha fazla boyut vardır) işler
hakikaten zorlaşabilir. Mesela görüntü tanımada veri <code>M x N</code>
boyutundaki dijital imajlar (düzleştirilince <span
class="math inline">\(M \cdot N\)</span> boyutunda), ve onların içindeki
resimlerin kime ait olduğu etiket bilgisi olabilir. KNN bu tür
multimedya, çok boyutlu veri ortamında başarılı şekilde
çalışabilmektedir. Ayrıca en yakın k komşunun içeriği tarifsel bilgi
çıkarımı (knowledge extraction) amacıyla da kullanılabilir [2].</p>
<p>“En yakın’’ sözü bir kordinat sistemi anlamına geliyor, ve KNN, aynen
GMM ve diğer pek çok kordinatsal öğrenme yöntemi gibi eldeki çok boyutlu
veri noktalarının elemanlarını bir kordinat sistemindeymiş gibi görür.
Kıyasla mesela APriori gibi bir algoritma metin bazlı veriyle olduğu
gibi çalışabilirdi.</p>
<p>Peki arama bağlamında, bir veri öbeği içinden en yakın noktaları
bulmanın en basit yolu nedir? Listeyi baştan sonra taramak (kaba kuvvet
yöntemi -brute force-) listedeki her nokta ile yeni nokta arasındaki
mesafeyi teker teker hesaplayıp en yakın k taneyi içinden seçerdi, bu
bir yöntemdir.. Bu basit algoritmanın yükü <span
class="math inline">\(O(N)\)</span>’dir. Eğer tek bir nokta arıyor
olsaydık, kabul edilebilir olabilirdi. Fakat genellikle bir sınıflayıcı
(classifier) algoritmasının sürekli işlemesi, mesela bir online site
için günde milyonlarca kez bazı kararları alması gerekebilir. Bu durumda
ve <span class="math inline">\(N\)</span>’in çok büyük olduğu şartlarda,
üstteki hız bile yeterli olmayacaktır.</p>
<p>Arama işlemini daha hızlı yapmanın yolları var. Akıllı arama
algoritmaları kullanarak eğitim verilerini bir ağaç yapısı üzerinden
tarayıp erişim hızını <span class="math inline">\(O(\log N)\)</span>’e
indirmek mümkündür.</p>
<p>K-D Ağaçları (k-d tree)</p>
<p>Bilgisayar bilimde K-D ağaçları (k-boyutlu ağaçlar kelimesinin
kısaltılmışı) bir çok boyutlu bölümlere ayırma yaklaşımıdır, eldeki çok
boyutlu veri noktaları bölgelere ayrılarak arama ile bulunmaları
kolaylaştırılmaya uğraşılır. Bu yapı belli bir noktaya en yakın k nokta
bulmaya yardımcı olur.</p>
<p>Yapı şöyledir: K-D ağaçları bir ikisel ağaç olarak kodlanır, ağacın
her düğümü k boyutlu uzayı sadece tek bir kordinat üzerinden ikiye
böler. Eğer 3 boyutta isek mesela 1. kordinat üzerinden bu ikiye bölüm
yapılabilir. Ardından o düğümde seçilen kordinat üzerinden bakılan
öğeden daha küçük olan veri noktaları sol dala büyük olanları sağ dala
verilir. Bu işleyiş ağacın altına doğru benzer şekilde devam eder, her
seviyede farklı bir kordinat seçilir.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># -*- coding: utf-8 -*-</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> __future__ <span class="im">import</span> print_function</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> operator, math</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> wraps</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> bpq <span class="im">import</span> BoundedPriorityQueue</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Node(<span class="bu">object</span>):</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, data<span class="op">=</span><span class="va">None</span>, left<span class="op">=</span><span class="va">None</span>, right<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.data <span class="op">=</span> data</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.left <span class="op">=</span> left</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.right <span class="op">=</span> right</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="at">@property</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> is_leaf(<span class="va">self</span>):</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (<span class="kw">not</span> <span class="va">self</span>.data) <span class="kw">or</span> <span class="op">\</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>               (<span class="bu">all</span>(<span class="kw">not</span> <span class="bu">bool</span>(c) <span class="cf">for</span> c, p <span class="kw">in</span> <span class="va">self</span>.children))</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> preorder(<span class="va">self</span>):</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>:</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">yield</span> <span class="va">self</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.left:</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> x <span class="kw">in</span> <span class="va">self</span>.left.preorder():</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>                <span class="cf">yield</span> x</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.right:</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> x <span class="kw">in</span> <span class="va">self</span>.right.preorder():</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>                <span class="cf">yield</span> x</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> inorder(<span class="va">self</span>):</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>:</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.left:</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> x <span class="kw">in</span> <span class="va">self</span>.left.inorder():</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>                <span class="cf">yield</span> x</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">yield</span> <span class="va">self</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.right:</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> x <span class="kw">in</span> <span class="va">self</span>.right.inorder():</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>                <span class="cf">yield</span> x</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> postorder(<span class="va">self</span>):</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>:</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.left:</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> x <span class="kw">in</span> <span class="va">self</span>.left.postorder():</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>                <span class="cf">yield</span> x</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.right:</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> x <span class="kw">in</span> <span class="va">self</span>.right.postorder():</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>                <span class="cf">yield</span> x</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">yield</span> <span class="va">self</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>    <span class="at">@property</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> children(<span class="va">self</span>):</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.left <span class="kw">and</span> <span class="va">self</span>.left.data <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> <span class="va">self</span>.left, <span class="dv">0</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.right <span class="kw">and</span> <span class="va">self</span>.right.data <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> <span class="va">self</span>.right, <span class="dv">1</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> set_child(<span class="va">self</span>, index, child):</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> index <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.left <span class="op">=</span> child</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.right <span class="op">=</span> child</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> height(<span class="va">self</span>):</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>        min_height <span class="op">=</span> <span class="bu">int</span>(<span class="bu">bool</span>(<span class="va">self</span>))</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">max</span>([min_height] <span class="op">+</span> [c.height()<span class="op">+</span><span class="dv">1</span> <span class="cf">for</span> c, p <span class="kw">in</span> <span class="va">self</span>.children])</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_child_pos(<span class="va">self</span>, child):</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> c, pos <span class="kw">in</span> <span class="va">self</span>.children:</span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> child <span class="op">==</span> c:</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> pos</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&#39;&lt;</span><span class="sc">%(cls)s</span><span class="st"> - </span><span class="sc">%(data)s</span><span class="st">&gt;&#39;</span> <span class="op">%</span> <span class="op">\</span></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>            <span class="bu">dict</span>(cls<span class="op">=</span><span class="va">self</span>.__class__.<span class="va">__name__</span>, data<span class="op">=</span><span class="bu">repr</span>(<span class="va">self</span>.data))</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__nonzero__</span>(<span class="va">self</span>):</span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.data <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>    <span class="fu">__bool__</span> <span class="op">=</span> <span class="fu">__nonzero__</span></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__eq__</span>(<span class="va">self</span>, other):</span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(other, <span class="bu">tuple</span>):</span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>.data <span class="op">==</span> other</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>.data <span class="op">==</span> other.data</span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__hash__</span>(<span class="va">self</span>):</span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">id</span>(<span class="va">self</span>)</span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> require_axis(f):</span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>    <span class="at">@wraps</span>(f)</span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _wrapper(<span class="va">self</span>, <span class="op">*</span>args, <span class="op">**</span>kwargs):</span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">None</span> <span class="kw">in</span> (<span class="va">self</span>.axis, <span class="va">self</span>.sel_axis):</span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">&#39;</span><span class="sc">%(func_name) r</span><span class="st">equires the node </span><span class="sc">%(node)s</span><span class="st"> &#39;</span></span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a>                    <span class="st">&#39;to have an axis and a sel_axis function&#39;</span> <span class="op">%</span></span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">dict</span>(func_name<span class="op">=</span>f.<span class="va">__name__</span>, node<span class="op">=</span><span class="bu">repr</span>(<span class="va">self</span>)))</span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> f(<span class="va">self</span>, <span class="op">*</span>args, <span class="op">**</span>kwargs)</span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> _wrapper</span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> KDNode(Node):</span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, data<span class="op">=</span><span class="va">None</span>, left<span class="op">=</span><span class="va">None</span>, right<span class="op">=</span><span class="va">None</span>, axis<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a>            sel_axis<span class="op">=</span><span class="va">None</span>, dimensions<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>(KDNode, <span class="va">self</span>).<span class="fu">__init__</span>(data, left, right)</span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.axis <span class="op">=</span> axis</span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.sel_axis <span class="op">=</span> sel_axis</span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.dimensions <span class="op">=</span> dimensions</span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a>    <span class="at">@require_axis</span></span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add(<span class="va">self</span>, point):</span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> <span class="va">self</span></span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a>            check_dimensionality([point], dimensions<span class="op">=</span>current.dimensions)</span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> current.data <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a>                current.data <span class="op">=</span> point</span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> current</span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> point[current.axis] <span class="op">&lt;</span> current.data[current.axis]:</span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> current.left <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true" tabindex="-1"></a>                    current.left <span class="op">=</span> current.create_subnode(point)</span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> current.left</span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb1-134"><a href="#cb1-134" aria-hidden="true" tabindex="-1"></a>                    current <span class="op">=</span> current.left</span>
<span id="cb1-135"><a href="#cb1-135" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb1-136"><a href="#cb1-136" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> current.right <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb1-137"><a href="#cb1-137" aria-hidden="true" tabindex="-1"></a>                    current.right <span class="op">=</span> current.create_subnode(point)</span>
<span id="cb1-138"><a href="#cb1-138" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> current.right</span>
<span id="cb1-139"><a href="#cb1-139" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb1-140"><a href="#cb1-140" aria-hidden="true" tabindex="-1"></a>                    current <span class="op">=</span> current.right</span>
<span id="cb1-141"><a href="#cb1-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-142"><a href="#cb1-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-143"><a href="#cb1-143" aria-hidden="true" tabindex="-1"></a>    <span class="at">@require_axis</span></span>
<span id="cb1-144"><a href="#cb1-144" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> create_subnode(<span class="va">self</span>, data):</span>
<span id="cb1-145"><a href="#cb1-145" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.__class__(data,</span>
<span id="cb1-146"><a href="#cb1-146" aria-hidden="true" tabindex="-1"></a>                axis<span class="op">=</span><span class="va">self</span>.sel_axis(<span class="va">self</span>.axis),</span>
<span id="cb1-147"><a href="#cb1-147" aria-hidden="true" tabindex="-1"></a>                sel_axis<span class="op">=</span><span class="va">self</span>.sel_axis,</span>
<span id="cb1-148"><a href="#cb1-148" aria-hidden="true" tabindex="-1"></a>                dimensions<span class="op">=</span><span class="va">self</span>.dimensions)</span>
<span id="cb1-149"><a href="#cb1-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-150"><a href="#cb1-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-151"><a href="#cb1-151" aria-hidden="true" tabindex="-1"></a>    <span class="at">@require_axis</span></span>
<span id="cb1-152"><a href="#cb1-152" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> find_replacement(<span class="va">self</span>):</span>
<span id="cb1-153"><a href="#cb1-153" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.right:</span>
<span id="cb1-154"><a href="#cb1-154" aria-hidden="true" tabindex="-1"></a>            child, parent <span class="op">=</span> <span class="va">self</span>.right.extreme_child(<span class="bu">min</span>, <span class="va">self</span>.axis)</span>
<span id="cb1-155"><a href="#cb1-155" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb1-156"><a href="#cb1-156" aria-hidden="true" tabindex="-1"></a>            child, parent <span class="op">=</span> <span class="va">self</span>.left.extreme_child(<span class="bu">max</span>, <span class="va">self</span>.axis)</span>
<span id="cb1-157"><a href="#cb1-157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-158"><a href="#cb1-158" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (child, parent <span class="cf">if</span> parent <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="cf">else</span> <span class="va">self</span>)</span>
<span id="cb1-159"><a href="#cb1-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-160"><a href="#cb1-160" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> should_remove(<span class="va">self</span>, point, node):</span>
<span id="cb1-161"><a href="#cb1-161" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>.data <span class="op">==</span> point:</span>
<span id="cb1-162"><a href="#cb1-162" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb1-163"><a href="#cb1-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-164"><a href="#cb1-164" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (node <span class="kw">is</span> <span class="va">None</span>) <span class="kw">or</span> (node <span class="kw">is</span> <span class="va">self</span>)</span>
<span id="cb1-165"><a href="#cb1-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-166"><a href="#cb1-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-167"><a href="#cb1-167" aria-hidden="true" tabindex="-1"></a>    <span class="at">@require_axis</span></span>
<span id="cb1-168"><a href="#cb1-168" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> remove(<span class="va">self</span>, point, node<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb1-169"><a href="#cb1-169" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>:</span>
<span id="cb1-170"><a href="#cb1-170" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb1-171"><a href="#cb1-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-172"><a href="#cb1-172" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.should_remove(point, node):</span>
<span id="cb1-173"><a href="#cb1-173" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>._remove(point)</span>
<span id="cb1-174"><a href="#cb1-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-175"><a href="#cb1-175" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.left <span class="kw">and</span> <span class="va">self</span>.left.should_remove(point, node):</span>
<span id="cb1-176"><a href="#cb1-176" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.left <span class="op">=</span> <span class="va">self</span>.left._remove(point)</span>
<span id="cb1-177"><a href="#cb1-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-178"><a href="#cb1-178" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="va">self</span>.right <span class="kw">and</span> <span class="va">self</span>.right.should_remove(point, node):</span>
<span id="cb1-179"><a href="#cb1-179" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.right <span class="op">=</span> <span class="va">self</span>.right._remove(point)</span>
<span id="cb1-180"><a href="#cb1-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-181"><a href="#cb1-181" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> point[<span class="va">self</span>.axis] <span class="op">&lt;=</span> <span class="va">self</span>.data[<span class="va">self</span>.axis]:</span>
<span id="cb1-182"><a href="#cb1-182" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.left:</span>
<span id="cb1-183"><a href="#cb1-183" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.left <span class="op">=</span> <span class="va">self</span>.left.remove(point, node)</span>
<span id="cb1-184"><a href="#cb1-184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-185"><a href="#cb1-185" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> point[<span class="va">self</span>.axis] <span class="op">&gt;=</span> <span class="va">self</span>.data[<span class="va">self</span>.axis]:</span>
<span id="cb1-186"><a href="#cb1-186" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.right:</span>
<span id="cb1-187"><a href="#cb1-187" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.right <span class="op">=</span> <span class="va">self</span>.right.remove(point, node)</span>
<span id="cb1-188"><a href="#cb1-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-189"><a href="#cb1-189" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span></span>
<span id="cb1-190"><a href="#cb1-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-191"><a href="#cb1-191" aria-hidden="true" tabindex="-1"></a>    <span class="at">@require_axis</span></span>
<span id="cb1-192"><a href="#cb1-192" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _remove(<span class="va">self</span>, point):</span>
<span id="cb1-193"><a href="#cb1-193" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.is_leaf:</span>
<span id="cb1-194"><a href="#cb1-194" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.data <span class="op">=</span> <span class="va">None</span></span>
<span id="cb1-195"><a href="#cb1-195" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span></span>
<span id="cb1-196"><a href="#cb1-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-197"><a href="#cb1-197" aria-hidden="true" tabindex="-1"></a>        root, max_p <span class="op">=</span> <span class="va">self</span>.find_replacement()</span>
<span id="cb1-198"><a href="#cb1-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-199"><a href="#cb1-199" aria-hidden="true" tabindex="-1"></a>        tmp_l, tmp_r <span class="op">=</span> <span class="va">self</span>.left, <span class="va">self</span>.right</span>
<span id="cb1-200"><a href="#cb1-200" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.left, <span class="va">self</span>.right <span class="op">=</span> root.left, root.right</span>
<span id="cb1-201"><a href="#cb1-201" aria-hidden="true" tabindex="-1"></a>        root.left, root.right <span class="op">=</span> tmp_l <span class="cf">if</span> tmp_l <span class="kw">is</span> <span class="kw">not</span> root <span class="cf">else</span> <span class="va">self</span>, tmp_r <span class="cf">if</span> tmp_r <span class="kw">is</span> <span class="kw">not</span> root <span class="cf">else</span> <span class="va">self</span></span>
<span id="cb1-202"><a href="#cb1-202" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.axis, root.axis <span class="op">=</span> root.axis, <span class="va">self</span>.axis</span>
<span id="cb1-203"><a href="#cb1-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-204"><a href="#cb1-204" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> max_p <span class="kw">is</span> <span class="kw">not</span> <span class="va">self</span>:</span>
<span id="cb1-205"><a href="#cb1-205" aria-hidden="true" tabindex="-1"></a>            pos <span class="op">=</span> max_p.get_child_pos(root)</span>
<span id="cb1-206"><a href="#cb1-206" aria-hidden="true" tabindex="-1"></a>            max_p.set_child(pos, <span class="va">self</span>)</span>
<span id="cb1-207"><a href="#cb1-207" aria-hidden="true" tabindex="-1"></a>            max_p.remove(point, <span class="va">self</span>)</span>
<span id="cb1-208"><a href="#cb1-208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-209"><a href="#cb1-209" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb1-210"><a href="#cb1-210" aria-hidden="true" tabindex="-1"></a>            root.remove(point, <span class="va">self</span>)</span>
<span id="cb1-211"><a href="#cb1-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-212"><a href="#cb1-212" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> root</span>
<span id="cb1-213"><a href="#cb1-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-214"><a href="#cb1-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-215"><a href="#cb1-215" aria-hidden="true" tabindex="-1"></a>    <span class="at">@property</span></span>
<span id="cb1-216"><a href="#cb1-216" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> is_balanced(<span class="va">self</span>):</span>
<span id="cb1-217"><a href="#cb1-217" aria-hidden="true" tabindex="-1"></a>        left_height <span class="op">=</span> <span class="va">self</span>.left.height() <span class="cf">if</span> <span class="va">self</span>.left <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb1-218"><a href="#cb1-218" aria-hidden="true" tabindex="-1"></a>        right_height <span class="op">=</span> <span class="va">self</span>.right.height() <span class="cf">if</span> <span class="va">self</span>.right <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb1-219"><a href="#cb1-219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-220"><a href="#cb1-220" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">abs</span>(left_height <span class="op">-</span> right_height) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb1-221"><a href="#cb1-221" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb1-222"><a href="#cb1-222" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">all</span>(c.is_balanced <span class="cf">for</span> c, _ <span class="kw">in</span> <span class="va">self</span>.children)</span>
<span id="cb1-223"><a href="#cb1-223" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-224"><a href="#cb1-224" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> rebalance(<span class="va">self</span>):</span>
<span id="cb1-225"><a href="#cb1-225" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> create([x.data <span class="cf">for</span> x <span class="kw">in</span> <span class="va">self</span>.inorder()])</span>
<span id="cb1-226"><a href="#cb1-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-227"><a href="#cb1-227" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> axis_dist(<span class="va">self</span>, point, axis):</span>
<span id="cb1-228"><a href="#cb1-228" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> math.<span class="bu">pow</span>(<span class="va">self</span>.data[axis] <span class="op">-</span> point[axis], <span class="dv">2</span>)</span>
<span id="cb1-229"><a href="#cb1-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-230"><a href="#cb1-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-231"><a href="#cb1-231" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dist(<span class="va">self</span>, point):</span>
<span id="cb1-232"><a href="#cb1-232" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> <span class="bu">range</span>(<span class="va">self</span>.dimensions)</span>
<span id="cb1-233"><a href="#cb1-233" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">sum</span>([<span class="va">self</span>.axis_dist(point, i) <span class="cf">for</span> i <span class="kw">in</span> r])</span>
<span id="cb1-234"><a href="#cb1-234" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-235"><a href="#cb1-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-236"><a href="#cb1-236" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> search_knn(<span class="va">self</span>, point, k, dist<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb1-237"><a href="#cb1-237" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> dist <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb1-238"><a href="#cb1-238" aria-hidden="true" tabindex="-1"></a>            get_dist <span class="op">=</span> <span class="kw">lambda</span> n: n.dist(point)</span>
<span id="cb1-239"><a href="#cb1-239" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb1-240"><a href="#cb1-240" aria-hidden="true" tabindex="-1"></a>            get_dist <span class="op">=</span> <span class="kw">lambda</span> n: dist(n.data, point)</span>
<span id="cb1-241"><a href="#cb1-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-242"><a href="#cb1-242" aria-hidden="true" tabindex="-1"></a>        results <span class="op">=</span> BoundedPriorityQueue(k)</span>
<span id="cb1-243"><a href="#cb1-243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-244"><a href="#cb1-244" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._search_node(point, k, results, get_dist)</span>
<span id="cb1-245"><a href="#cb1-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-246"><a href="#cb1-246" aria-hidden="true" tabindex="-1"></a>        <span class="co"># We sort the final result by the distance in the tuple</span></span>
<span id="cb1-247"><a href="#cb1-247" aria-hidden="true" tabindex="-1"></a>        <span class="co"># (&lt;KdNode&gt;, distance)</span></span>
<span id="cb1-248"><a href="#cb1-248" aria-hidden="true" tabindex="-1"></a>        BY_VALUE <span class="op">=</span> <span class="kw">lambda</span> kv: kv[<span class="dv">1</span>]</span>
<span id="cb1-249"><a href="#cb1-249" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">sorted</span>(results.items(), key<span class="op">=</span>BY_VALUE)</span>
<span id="cb1-250"><a href="#cb1-250" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-251"><a href="#cb1-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-252"><a href="#cb1-252" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _search_node(<span class="va">self</span>, point, k, results, get_dist):</span>
<span id="cb1-253"><a href="#cb1-253" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>:</span>
<span id="cb1-254"><a href="#cb1-254" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb1-255"><a href="#cb1-255" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-256"><a href="#cb1-256" aria-hidden="true" tabindex="-1"></a>        nodeDist <span class="op">=</span> get_dist(<span class="va">self</span>)</span>
<span id="cb1-257"><a href="#cb1-257" aria-hidden="true" tabindex="-1"></a>        results.add((<span class="va">self</span>, nodeDist))</span>
<span id="cb1-258"><a href="#cb1-258" aria-hidden="true" tabindex="-1"></a>        split_plane <span class="op">=</span> <span class="va">self</span>.data[<span class="va">self</span>.axis]</span>
<span id="cb1-259"><a href="#cb1-259" aria-hidden="true" tabindex="-1"></a>        plane_dist <span class="op">=</span> point[<span class="va">self</span>.axis] <span class="op">-</span> split_plane</span>
<span id="cb1-260"><a href="#cb1-260" aria-hidden="true" tabindex="-1"></a>        plane_dist2 <span class="op">=</span> plane_dist <span class="op">*</span> plane_dist</span>
<span id="cb1-261"><a href="#cb1-261" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> point[<span class="va">self</span>.axis] <span class="op">&lt;</span> split_plane:</span>
<span id="cb1-262"><a href="#cb1-262" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.left <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb1-263"><a href="#cb1-263" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.left._search_node(point, k, results, get_dist)</span>
<span id="cb1-264"><a href="#cb1-264" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb1-265"><a href="#cb1-265" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.right <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb1-266"><a href="#cb1-266" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.right._search_node(point, k, results, get_dist)</span>
<span id="cb1-267"><a href="#cb1-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-268"><a href="#cb1-268" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> plane_dist2 <span class="op">&lt;</span> results.<span class="bu">max</span>() <span class="kw">or</span> results.size() <span class="op">&lt;</span> k:</span>
<span id="cb1-269"><a href="#cb1-269" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> point[<span class="va">self</span>.axis] <span class="op">&lt;</span> <span class="va">self</span>.data[<span class="va">self</span>.axis]:</span>
<span id="cb1-270"><a href="#cb1-270" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="va">self</span>.right <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb1-271"><a href="#cb1-271" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.right._search_node(point, k, results, get_dist)</span>
<span id="cb1-272"><a href="#cb1-272" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb1-273"><a href="#cb1-273" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="va">self</span>.left <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb1-274"><a href="#cb1-274" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.left._search_node(point, k, results, get_dist)</span>
<span id="cb1-275"><a href="#cb1-275" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-276"><a href="#cb1-276" aria-hidden="true" tabindex="-1"></a>    <span class="at">@require_axis</span></span>
<span id="cb1-277"><a href="#cb1-277" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> search_nn(<span class="va">self</span>, point, dist<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb1-278"><a href="#cb1-278" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">next</span>(<span class="bu">iter</span>(<span class="va">self</span>.search_knn(point, <span class="dv">1</span>, dist)), <span class="va">None</span>)</span>
<span id="cb1-279"><a href="#cb1-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-280"><a href="#cb1-280" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-281"><a href="#cb1-281" aria-hidden="true" tabindex="-1"></a>    <span class="at">@require_axis</span></span>
<span id="cb1-282"><a href="#cb1-282" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> search_nn_dist(<span class="va">self</span>, point, distance, best<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb1-283"><a href="#cb1-283" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> best <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb1-284"><a href="#cb1-284" aria-hidden="true" tabindex="-1"></a>            best <span class="op">=</span> []</span>
<span id="cb1-285"><a href="#cb1-285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-286"><a href="#cb1-286" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.dist(point) <span class="op">&lt;</span> distance:</span>
<span id="cb1-287"><a href="#cb1-287" aria-hidden="true" tabindex="-1"></a>            best.append(<span class="va">self</span>)</span>
<span id="cb1-288"><a href="#cb1-288" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-289"><a href="#cb1-289" aria-hidden="true" tabindex="-1"></a>        children <span class="op">=</span> <span class="bu">sorted</span>(<span class="va">self</span>.children, key<span class="op">=</span><span class="kw">lambda</span> c_p1: c_p1[<span class="dv">0</span>].dist(point))</span>
<span id="cb1-290"><a href="#cb1-290" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-291"><a href="#cb1-291" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> child, p <span class="kw">in</span> children:</span>
<span id="cb1-292"><a href="#cb1-292" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.axis_dist(point, <span class="va">self</span>.axis) <span class="op">&lt;</span> math.<span class="bu">pow</span>(distance, <span class="dv">2</span>):</span>
<span id="cb1-293"><a href="#cb1-293" aria-hidden="true" tabindex="-1"></a>                child.search_nn_dist(point, distance, best)</span>
<span id="cb1-294"><a href="#cb1-294" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-295"><a href="#cb1-295" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> best</span>
<span id="cb1-296"><a href="#cb1-296" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-297"><a href="#cb1-297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-298"><a href="#cb1-298" aria-hidden="true" tabindex="-1"></a>    <span class="at">@require_axis</span></span>
<span id="cb1-299"><a href="#cb1-299" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> is_valid(<span class="va">self</span>):</span>
<span id="cb1-300"><a href="#cb1-300" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>:</span>
<span id="cb1-301"><a href="#cb1-301" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb1-302"><a href="#cb1-302" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.left <span class="kw">and</span> <span class="va">self</span>.data[<span class="va">self</span>.axis] <span class="op">&lt;</span> <span class="va">self</span>.left.data[<span class="va">self</span>.axis]:</span>
<span id="cb1-303"><a href="#cb1-303" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb1-304"><a href="#cb1-304" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.right <span class="kw">and</span> <span class="va">self</span>.data[<span class="va">self</span>.axis] <span class="op">&gt;</span> <span class="va">self</span>.right.data[<span class="va">self</span>.axis]:</span>
<span id="cb1-305"><a href="#cb1-305" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb1-306"><a href="#cb1-306" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">all</span>(c.is_valid() <span class="cf">for</span> c, _ <span class="kw">in</span> <span class="va">self</span>.children) <span class="kw">or</span> <span class="va">self</span>.is_leaf</span>
<span id="cb1-307"><a href="#cb1-307" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-308"><a href="#cb1-308" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-309"><a href="#cb1-309" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> extreme_child(<span class="va">self</span>, sel_func, axis):</span>
<span id="cb1-310"><a href="#cb1-310" aria-hidden="true" tabindex="-1"></a>        max_key <span class="op">=</span> <span class="kw">lambda</span> child_parent: child_parent[<span class="dv">0</span>].data[axis]</span>
<span id="cb1-311"><a href="#cb1-311" aria-hidden="true" tabindex="-1"></a>        me <span class="op">=</span> [(<span class="va">self</span>, <span class="va">None</span>)] <span class="cf">if</span> <span class="va">self</span> <span class="cf">else</span> []</span>
<span id="cb1-312"><a href="#cb1-312" aria-hidden="true" tabindex="-1"></a>        child_max <span class="op">=</span> [c.extreme_child(sel_func, axis) <span class="cf">for</span> c, _ <span class="kw">in</span> <span class="va">self</span>.children]</span>
<span id="cb1-313"><a href="#cb1-313" aria-hidden="true" tabindex="-1"></a>        child_max <span class="op">=</span> [(c, p <span class="cf">if</span> p <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="cf">else</span> <span class="va">self</span>) <span class="cf">for</span> c, p <span class="kw">in</span> child_max]</span>
<span id="cb1-314"><a href="#cb1-314" aria-hidden="true" tabindex="-1"></a>        candidates <span class="op">=</span>  me <span class="op">+</span> child_max</span>
<span id="cb1-315"><a href="#cb1-315" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> candidates:</span>
<span id="cb1-316"><a href="#cb1-316" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">None</span>, <span class="va">None</span></span>
<span id="cb1-317"><a href="#cb1-317" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-318"><a href="#cb1-318" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> sel_func(candidates, key<span class="op">=</span>max_key)</span>
<span id="cb1-319"><a href="#cb1-319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-320"><a href="#cb1-320" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create(point_list<span class="op">=</span><span class="va">None</span>, dimensions<span class="op">=</span><span class="va">None</span>, axis<span class="op">=</span><span class="dv">0</span>, sel_axis<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb1-321"><a href="#cb1-321" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> point_list <span class="kw">and</span> <span class="kw">not</span> dimensions:</span>
<span id="cb1-322"><a href="#cb1-322" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">&#39;either point_list or dimensions must be provided&#39;</span>)</span>
<span id="cb1-323"><a href="#cb1-323" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> point_list:</span>
<span id="cb1-324"><a href="#cb1-324" aria-hidden="true" tabindex="-1"></a>        dimensions <span class="op">=</span> check_dimensionality(point_list, dimensions)</span>
<span id="cb1-325"><a href="#cb1-325" aria-hidden="true" tabindex="-1"></a>    sel_axis <span class="op">=</span> sel_axis <span class="kw">or</span> (<span class="kw">lambda</span> prev_axis: (prev_axis<span class="op">+</span><span class="dv">1</span>) <span class="op">%</span> dimensions)</span>
<span id="cb1-326"><a href="#cb1-326" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-327"><a href="#cb1-327" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> point_list:</span>
<span id="cb1-328"><a href="#cb1-328" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> KDNode(sel_axis<span class="op">=</span>sel_axis, axis<span class="op">=</span>axis, dimensions<span class="op">=</span>dimensions)</span>
<span id="cb1-329"><a href="#cb1-329" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-330"><a href="#cb1-330" aria-hidden="true" tabindex="-1"></a>    point_list <span class="op">=</span> <span class="bu">list</span>(point_list)</span>
<span id="cb1-331"><a href="#cb1-331" aria-hidden="true" tabindex="-1"></a>    point_list.sort(key<span class="op">=</span><span class="kw">lambda</span> point: point[axis])</span>
<span id="cb1-332"><a href="#cb1-332" aria-hidden="true" tabindex="-1"></a>    median <span class="op">=</span> <span class="bu">len</span>(point_list) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb1-333"><a href="#cb1-333" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-334"><a href="#cb1-334" aria-hidden="true" tabindex="-1"></a>    loc   <span class="op">=</span> point_list[median]</span>
<span id="cb1-335"><a href="#cb1-335" aria-hidden="true" tabindex="-1"></a>    left  <span class="op">=</span> create(point_list[:median], dimensions, sel_axis(axis))</span>
<span id="cb1-336"><a href="#cb1-336" aria-hidden="true" tabindex="-1"></a>    right <span class="op">=</span> create(point_list[median <span class="op">+</span> <span class="dv">1</span>:], dimensions, sel_axis(axis))</span>
<span id="cb1-337"><a href="#cb1-337" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> KDNode(loc, left, right, axis<span class="op">=</span>axis, sel_axis<span class="op">=</span>sel_axis, dimensions<span class="op">=</span>dimensions)</span>
<span id="cb1-338"><a href="#cb1-338" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-339"><a href="#cb1-339" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-340"><a href="#cb1-340" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> check_dimensionality(point_list, dimensions<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb1-341"><a href="#cb1-341" aria-hidden="true" tabindex="-1"></a>    dimensions <span class="op">=</span> dimensions <span class="kw">or</span> <span class="bu">len</span>(point_list[<span class="dv">0</span>])</span>
<span id="cb1-342"><a href="#cb1-342" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> p <span class="kw">in</span> point_list:</span>
<span id="cb1-343"><a href="#cb1-343" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(p) <span class="op">!=</span> dimensions:</span>
<span id="cb1-344"><a href="#cb1-344" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">&#39;All Points in the point_list must have the same dimensionality&#39;</span>)</span>
<span id="cb1-345"><a href="#cb1-345" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dimensions</span>
<span id="cb1-346"><a href="#cb1-346" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-347"><a href="#cb1-347" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-348"><a href="#cb1-348" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> level_order(tree, include_all<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb1-349"><a href="#cb1-349" aria-hidden="true" tabindex="-1"></a>    q <span class="op">=</span> deque()</span>
<span id="cb1-350"><a href="#cb1-350" aria-hidden="true" tabindex="-1"></a>    q.append(tree)</span>
<span id="cb1-351"><a href="#cb1-351" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> q:</span>
<span id="cb1-352"><a href="#cb1-352" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> q.popleft()</span>
<span id="cb1-353"><a href="#cb1-353" aria-hidden="true" tabindex="-1"></a>        <span class="cf">yield</span> node</span>
<span id="cb1-354"><a href="#cb1-354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-355"><a href="#cb1-355" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> include_all <span class="kw">or</span> node.left:</span>
<span id="cb1-356"><a href="#cb1-356" aria-hidden="true" tabindex="-1"></a>            q.append(node.left <span class="kw">or</span> node.__class__())</span>
<span id="cb1-357"><a href="#cb1-357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-358"><a href="#cb1-358" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> include_all <span class="kw">or</span> node.right:</span>
<span id="cb1-359"><a href="#cb1-359" aria-hidden="true" tabindex="-1"></a>            q.append(node.right <span class="kw">or</span> node.__class__())</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> bpq, kdtree</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>tree <span class="op">=</span> kdtree.create([[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>], [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>], [<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">2</span>]])</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (tree.search_nn( (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>) ))</span></code></pre></div>
<pre class="text"><code>(&lt;KDNode - [2, 3, 4]&gt;, 3.0)</code></pre>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.random.random((<span class="dv">1000</span>,<span class="dv">2</span>)) <span class="op">*</span> <span class="fl">100.</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>kx <span class="op">=</span> [<span class="bu">list</span>(xxx) <span class="cf">for</span> xxx <span class="kw">in</span> x]</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>tree <span class="op">=</span> kdtree.create(kx)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>kres <span class="op">=</span> tree.search_knn( [<span class="dv">39</span>, <span class="dv">39</span>], k<span class="op">=</span><span class="dv">7</span> )</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> kx <span class="kw">in</span> kres: <span class="bu">print</span> (kx)</span></code></pre></div>
<pre class="text"><code>(&lt;KDNode - [np.float64(39.364728144553865), np.float64(39.05146120930619)]&gt;, 0.13567487549296073)
(&lt;KDNode - [np.float64(40.26032144132441), np.float64(37.867345065620206)]&gt;, 2.8713173358369266)
(&lt;KDNode - [np.float64(41.027532514928566), np.float64(39.98338309762837)]&gt;, 5.077930415793724)
(&lt;KDNode - [np.float64(41.19458364933335), np.float64(37.654723299101256)]&gt;, 6.625966795902305)
(&lt;KDNode - [np.float64(36.46902062671158), np.float64(41.335617219637236)]&gt;, 11.8609643846774)
(&lt;KDNode - [np.float64(40.23345261800878), np.float64(35.58095468251084)]&gt;, 13.211276243917254)
(&lt;KDNode - [np.float64(38.09174668525085), np.float64(42.90978409879636)]&gt;, 16.111335782953674)</code></pre>
<p>Küre Agaçları (Ball Tree, BT)</p>
<p>Bir noktanın diğer noktalara yakın olup olmadığının hesabında
yapılması gereken en pahalı işlem nedir? Mesafe hesabıdır. BT
algoritmasının püf noktası bu hesabı yapmadan, noktalara değil,
noktaları kapsayan “kürelere” bakarak hız kazandırmasıdır. Noktaların
her biri yerine o noktaları temsil eden kürenin pivot noktasına (bu
nokta küre içindeki noktaların ortalamasal olarak merkezi de olabilir,
herhangi bir başka nokta da) bakılır, ve oraya olan mesafeye göre bir
küre altındaki noktalara olabilecek en az ve en fazla uzaklık hemen
anlaşılmış olur.</p>
<p>Not: Küre kavramı üç boyutta anlamlı tabii ki, iki boyutta bir
çemberden bahsetmek lazım, daha yüksek boyutlarda ise merkezi ve çapı
olan bir “hiper yüzeyden’’ bahsetmek lazım. Tarifi kolaylaştırdığı için
çember ve küre tanımlarını kullanıyoruz.</p>
<p>Mesela elimizde alttaki gibi noktalar var ve küreyi oluşturduk.</p>
<p><img src="knn0.png" /></p>
<p>Bu küreyi kullanarak küre dışındaki herhangi bir nokta <span
class="math inline">\(q\)</span>’nun küredeki “diğer tüm noktalar <span
class="math inline">\(x\)</span>’e” olabileceği en az mesafenin ne
olacağını üçgensel eşitsizlik ile anlayabiliriz.</p>
<p>Üçgensel eşitsizlik</p>
<p><span class="math display">\[ |x-y| \le |x-z| + |z-y| \]</span></p>
<p>Operatör <span class="math inline">\(| |\)</span> norm anlamına gelir
ve uzaklık hesabının genelleştirilmiş halidir. Konu hakkında daha fazla
detay {} ders notlarında. Kısaca söylenmek istenen iki nokta arasında
direk gitmek yerine yolu uzatırsak, mesafenin artacağıdır. Tabii
uzaklık, yol, nokta gibi kavramlar tamamen soyut matematiksel ortamda da
işleyecek şekilde ayarlanmıştır. Mesela mesafe (norm) kavramını
değiştirebiliriz, Öklitsel yerine Manhattan mesafesi kullanırız (blok
mesafesi, binalar etrafından dolaşılıyor, direk gidiş yok), fakat bu
kavram bir norm olduğu ve belirttiğimiz uzayda geçerli olduğu için
üçgensel eşitsizlik üzerine kurulmuş tüm diğer kurallar geçerli
olur.</p>
<p><img src="tri1.jpg" /></p>
<p>Şimdi diyelim ki dışarıdaki bir <span
class="math inline">\(q\)</span> noktasından bir küre içindeki diğer tüm
<span class="math inline">\(x\)</span> noktalarına olan mesafe hakkında
bir şeyler söylemek istiyoruz. Üstteki şekilden bir üçgensel eşitsizlik
çıkartabiliriz,</p>
<p><span class="math display">\[ |x-c| + |x-q| \ge |q-c|  \]</span></p>
<p>Bunun doğru bir ifade olduğunu biliyoruz. Peki şimdi yarıçapı bu işe
dahil edelim, çünkü yarıçap hesabı bir kere yapılıp küre seviyesinde
depolanacak ve bir daha hesaplanması gerekmeyecek, yani algoritmayı
hızlandıracak bir şey olabilir bu, o zaman eğer <span
class="math inline">\(|x-c|\)</span> yerine yarıçapı (radius)
kullanırsak, eşitsizlik hala geçerli olur, sol taraf zaten büyüktü,
şimdi daha da büyük olacak,</p>
<p><span class="math display">\[ radius + |x-q| \ge |q-c|  \]</span></p>
<p>Bunu nasıl böyle kesin bilebiliyoruz? Çünkü BT algoritması radius’u
<span class="math inline">\(|x-c|\)</span>’ten kesinlikle daha büyük
olacak şekilde seçer). Şimdi yarıçapı sağa geçirelim,</p>
<p><span class="math display">\[ |x-q| \ge |q-c| - radius \]</span></p>
<p>Böylece güzel bir tanım elde ettik. Yeni noktanın küredeki herhangi
bir nokta <span class="math inline">\(x\)</span>’e olan uzaklığı, yeni
noktanın pivota olan uzaklığının yarıçapı çıkartılmış halinden
<em>muhakkak</em> fazladır. Yani bu çıkartma işleminden ele geçen rakam
yeni noktanın <span class="math inline">\(x\)</span>’e uzaklığına bir
“alt sınır (lower bound)” olarak kabul edilebilir. Diğer tüm mesafeler
bu rakamdan daha büyük olacaktır. Ne elde ettik? Sadece bir yeni nokta,
pivot ve yarıçap kullanarak küredeki “diğer tüm noktalar hakkında” bir
irdeleme yapmamız mümkün olacak. Bu noktalara teker teker bakmamız
gerekmeyecek. Bunun nasıl ise yaradığını algoritma detaylarında
göreceğiz.</p>
<p>Benzer şekilde</p>
<p><img src="tri2.jpg" /></p>
<p>Bu ne diyor?</p>
<p><span class="math display">\[ |q-c| + |x-c| \ge |q-x| \]</span></p>
<p><span class="math inline">\(|x-c|\)</span> yerine yarıçap
kullanırsak, sol taraf büyüyeceği için büyüklük hala büyüklük olarak
kalır,</p>
<p><span class="math display">\[ |q-c| + radius \ge |q-x| \]</span></p>
<p>Ve yine daha genel ve hızlı hesaplanan bir kural elde ettik (önceki
ifadeye benzemesi için yer düzenlemesi yapalım)</p>
<p><span class="math display">\[ |q-x| \le |q-c| + radius \]</span></p>
<p>Bu ifade ne diyor? Yeni noktanın pivota olan uzaklığına yarıçap
“eklenirse’’ bu uzaklıktan, büyüklükten daha büyük bir yeni nokta / küre
mesafesi olamaz, küredeki hangi nokta olursa olsun. Bu eşitsizlik te
bize bir üst sınır (upper bound) vermiş oldu.</p>
<p>Algoritma <code>ball_knn</code><span
class="math inline">\(\left(PS^{in},node\right)\)</span></p>
<ul>
<li><p>Eğer alttaki şart geçerli ise node içindeki bir noktanın daha
önce keşfedilmiş <span class="math inline">\(k\)</span> en yakın
komşudan daha yakın olması imkansızdır</p></li>
<li><p><code>if</code> <span class="math inline">\(D^{node}_{minp} \ge
D_{sofar}\)</span> <code>return</code> <span
class="math inline">\(PS_{in}\)</span> değişmemiş halde;</p></li>
<li><p><code>else if</code> <span class="math inline">\(node\)</span>
bir çocuk noktası ise</p>
<ul>
<li><p><span class="math inline">\(PS_{out} = PS_{in}\)</span></p></li>
<li><p>Her <span class="math inline">\(\forall x \in
points(node)\)</span> için</p>
<ul>
<li><code>if</code> <span class="math inline">\(\left( |x-q| &lt;
D_{sofar} \right)\)</span>, basit lineer arama yap</li>
<li><span class="math inline">\(x\)</span>’i <span
class="math inline">\(PS_{out}\)</span>’a ekle</li>
<li><code>if</code> <span class="math inline">\(|PS^{out}| ==
k+1\)</span> o zaman en uzak olan komşuyu <span
class="math inline">\(PS^{out}\)</span>’tan çıkart ve <span
class="math inline">\(D_{sofar}\)</span>’i güncelle</li>
</ul></li>
</ul></li>
<li><p>Eğer uç nokta değil ise iki çocuk düğümden daha yakın olanını
incele, sonra daha uzakta olanına bak. büyük bir ihtimalle arama devam
ettirilirse bu arama kendiliğinden kesilecektir.</p>
<ul>
<li><p><code>else</code></p>
<ul>
<li><span class="math inline">\(node_1 = node\)</span>’un <span
class="math inline">\(q\)</span>’ya en yakın çocuğu;</li>
<li><span class="math inline">\(node_2 = node\)</span>’un <span
class="math inline">\(q\)</span>’dan en uzak çocuğu;</li>
<li><span class="math inline">\(PS^{temp}\)</span> =
<code>ball_knn</code>(<span
class="math inline">\(PS^{in},node_1)\)</span>;</li>
<li><span class="math inline">\(PS^{out}\)</span> =
<code>ball_knn</code>(<span
class="math inline">\(PS^{temp},node_2);\)</span></li>
</ul></li>
</ul></li>
</ul>
<p>Küre Ağaçları (BT) metotu önce küreleri, ağaçları oluşturmalıdır. Bu
küreler hiyerarşik şekilde planlanır, tüm noktaların içinde olduğu bir
“en üst küre” vardır her kürenin iki tane çocuk küresi olabilir. Belli
bir (dışarıdan tanımlanan) minimum <span
class="math inline">\(r_{min}\)</span> veri noktasına gelinceye kadar
sadece noktaları geometrik olarak kapsamakla görevli küreler
oluşturulur, küreler noktaları sahiplenmezler. Fakat bu <span
class="math inline">\(r_{min}\)</span> sayısına erişince (artık oldukça
alttaki) kürelerin üzerine noktalar konacaktır.</p>
<p>Önce tek kürenin oluşturuluşuna bakalım. Bir küre oluşumu için eldeki
veri içinden herhangi bir tanesi pivot olarak kabul edilebilir. Daha
sonra bu pivot’tan diğer tüm noktalara olan uzaklık ölçülür, ve en
fazla, en büyük olan uzaklık yarıçap olarak kabul edilir (her şeyi
kapsayabilmesi için).</p>
<p>Not: Bu arada “tüm diğer noktalara bakılması” dedik, bundan kaçınmaya
çalışmıyor muyduk? Fakat dikkat, “küre oluşturulması” evresindeyiz, k
tane yakın nokta arama evresinde değiliz. Yapmaya çalıştığımız aramaları
hızlandırmak - eğitim / küre oluşturması bir kez yapılacak ve bu
eğitilmiş küreler bir kenarda tutulacak ve sürekli aramalar için ardı
ardına kullanılacaklar.</p>
<p>Küreyi oluşturmanın algoritması şöyledir: verilen noktalar içinde
herhangi birisi pivot olarak seçilir. Sonra bu noktadan en uzakta olan
nokta <span class="math inline">\(f_1\)</span>, sonra <span
class="math inline">\(f_1\)</span>’den en uzakta olan nokta <span
class="math inline">\(f_2\)</span> seçilir. Sonra tüm noktalara teker
teker bakılır ve <span class="math inline">\(f_1\)</span>’e yakın
olanlar bir gruba, <span class="math inline">\(f_2\)</span>’ye yakın
olanlar bir gruba ayrılır.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> balltree, pprint</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> np.array([[<span class="fl">3.</span>,<span class="fl">3.</span>],[<span class="fl">2.</span>,<span class="fl">2.</span>]])</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> [<span class="fl">1.</span>,<span class="fl">1.</span>]</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;diff&#39;</span>, points<span class="op">-</span>q)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;dist&#39;</span>, balltree.dist(points,q))</span></code></pre></div>
<pre class="text"><code>diff [[2. 2.]
 [1. 1.]]
dist [2.82842712 1.41421356]</code></pre>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># k-nearest neighbor Ball Tree algorithm in Python</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> itertools, numpy <span class="im">as</span> np</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>__rmin__ <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dist(vect,x):</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.fromiter(itertools.imap</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>                       (np.linalg.norm, vect<span class="op">-</span>x),dtype<span class="op">=</span>np.<span class="bu">float</span>)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> norm(x,y): <span class="cf">return</span> np.linalg.norm(x<span class="op">-</span>y)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co"># node: [pivot, radius, points, [child1,child2]]</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> new_node():</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>  [<span class="va">None</span>,<span class="va">None</span>,<span class="va">None</span>,[<span class="va">None</span>,<span class="va">None</span>]]</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> zero_if_neg(x):</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> x <span class="op">&lt;</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>: <span class="cf">return</span> x</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> form_tree(points,node,all_points,plot_tree<span class="op">=</span><span class="va">False</span>):    </span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    pivot <span class="op">=</span> points[<span class="dv">0</span>]</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    radius <span class="op">=</span> np.<span class="bu">max</span>(dist(points,pivot))</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> plot_tree: plot_circles(pivot, radius, points, all_points)</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    node[<span class="dv">0</span>] <span class="op">=</span> pivot</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    node[<span class="dv">1</span>] <span class="op">=</span> radius</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(points) <span class="op">&lt;=</span> __rmin__:</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>        node[<span class="dv">2</span>] <span class="op">=</span> points</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>    idx <span class="op">=</span> np.argmax(dist(points,pivot))</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>    furthest <span class="op">=</span> points[idx,:]</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>    idx <span class="op">=</span> np.argmax(dist(points,furthest))</span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>    furthest2 <span class="op">=</span> points[idx,:]</span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>    dist1<span class="op">=</span>dist(points,furthest)</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>    dist2<span class="op">=</span>dist(points,furthest2)</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>    diffs <span class="op">=</span> dist1<span class="op">-</span>dist2</span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>    p1 <span class="op">=</span> points[diffs <span class="op">&lt;=</span> <span class="dv">0</span>]</span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>    p2 <span class="op">=</span> points[diffs <span class="op">&gt;</span> <span class="dv">0</span>]</span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>    node[<span class="dv">3</span>][<span class="dv">0</span>] <span class="op">=</span> new_node() <span class="co"># left child</span></span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a>    node[<span class="dv">3</span>][<span class="dv">1</span>] <span class="op">=</span> new_node() <span class="co"># right child</span></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>    form_tree(p1,node[<span class="dv">3</span>][<span class="dv">0</span>],all_points)</span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>    form_tree(p2,node[<span class="dv">3</span>][<span class="dv">1</span>],all_points)</span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a><span class="co"># knn: [min_so_far, [points]]</span></span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> search_tree(new_point, knn_matches, node, k):</span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a>    pivot <span class="op">=</span> node[<span class="dv">0</span>]</span>
<span id="cb8-47"><a href="#cb8-47" aria-hidden="true" tabindex="-1"></a>    radius <span class="op">=</span> node[<span class="dv">1</span>]</span>
<span id="cb8-48"><a href="#cb8-48" aria-hidden="true" tabindex="-1"></a>    node_points <span class="op">=</span> node[<span class="dv">2</span>]</span>
<span id="cb8-49"><a href="#cb8-49" aria-hidden="true" tabindex="-1"></a>    children <span class="op">=</span> node[<span class="dv">3</span>]</span>
<span id="cb8-50"><a href="#cb8-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-51"><a href="#cb8-51" aria-hidden="true" tabindex="-1"></a>    <span class="co"># calculate min distance between new point and pivot</span></span>
<span id="cb8-52"><a href="#cb8-52" aria-hidden="true" tabindex="-1"></a>    <span class="co"># it is direct distance minus the radius</span></span>
<span id="cb8-53"><a href="#cb8-53" aria-hidden="true" tabindex="-1"></a>    min_dist_new_pt_node <span class="op">=</span> norm(pivot,new_point) <span class="op">-</span> radius</span>
<span id="cb8-54"><a href="#cb8-54" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-55"><a href="#cb8-55" aria-hidden="true" tabindex="-1"></a>    <span class="co"># if the new pt is inside the circle, its potential minimum</span></span>
<span id="cb8-56"><a href="#cb8-56" aria-hidden="true" tabindex="-1"></a>    <span class="co"># distance to a random point inside is zero (hence</span></span>
<span id="cb8-57"><a href="#cb8-57" aria-hidden="true" tabindex="-1"></a>    <span class="co"># zero_if_neg). we can only say so much without looking at all</span></span>
<span id="cb8-58"><a href="#cb8-58" aria-hidden="true" tabindex="-1"></a>    <span class="co"># points (and if we did, that would defeat the purpose of this</span></span>
<span id="cb8-59"><a href="#cb8-59" aria-hidden="true" tabindex="-1"></a>    <span class="co"># algorithm)</span></span>
<span id="cb8-60"><a href="#cb8-60" aria-hidden="true" tabindex="-1"></a>    min_dist_new_pt_node <span class="op">=</span> zero_if_neg(min_dist_new_pt_node)</span>
<span id="cb8-61"><a href="#cb8-61" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-62"><a href="#cb8-62" aria-hidden="true" tabindex="-1"></a>    knn_matches_out <span class="op">=</span> <span class="va">None</span></span>
<span id="cb8-63"><a href="#cb8-63" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-64"><a href="#cb8-64" aria-hidden="true" tabindex="-1"></a>    <span class="co"># min is greater than so far</span></span>
<span id="cb8-65"><a href="#cb8-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> min_dist_new_pt_node <span class="op">&gt;=</span> knn_matches[<span class="dv">0</span>]:</span>
<span id="cb8-66"><a href="#cb8-66" aria-hidden="true" tabindex="-1"></a>        <span class="co"># nothing to do</span></span>
<span id="cb8-67"><a href="#cb8-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> knn_matches</span>
<span id="cb8-68"><a href="#cb8-68" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> node_points <span class="op">!=</span> <span class="va">None</span>: <span class="co"># if node is a leaf</span></span>
<span id="cb8-69"><a href="#cb8-69" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span> (knn_matches_out)</span>
<span id="cb8-70"><a href="#cb8-70" aria-hidden="true" tabindex="-1"></a>        knn_matches_out <span class="op">=</span> knn_matches[:] <span class="co"># copy it</span></span>
<span id="cb8-71"><a href="#cb8-71" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> p <span class="kw">in</span> node_points: <span class="co"># linear scan</span></span>
<span id="cb8-72"><a href="#cb8-72" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> norm(new_point,p) <span class="op">&lt;</span> radius:</span>
<span id="cb8-73"><a href="#cb8-73" aria-hidden="true" tabindex="-1"></a>                knn_matches_out[<span class="dv">1</span>].append([<span class="bu">list</span>(p)])</span>
<span id="cb8-74"><a href="#cb8-74" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="bu">len</span>(knn_matches_out[<span class="dv">1</span>]) <span class="op">==</span> k<span class="op">+</span><span class="dv">1</span>:</span>
<span id="cb8-75"><a href="#cb8-75" aria-hidden="true" tabindex="-1"></a>                    tmp <span class="op">=</span> [norm(new_point,x) <span class="op">\</span></span>
<span id="cb8-76"><a href="#cb8-76" aria-hidden="true" tabindex="-1"></a>                               <span class="cf">for</span> x <span class="kw">in</span> knn_matches_out[<span class="dv">1</span>]]</span>
<span id="cb8-77"><a href="#cb8-77" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">del</span> knn_matches_out[<span class="dv">1</span>][np.argmax(tmp)]</span>
<span id="cb8-78"><a href="#cb8-78" aria-hidden="true" tabindex="-1"></a>                    knn_matches_out[<span class="dv">0</span>] <span class="op">=</span> np.<span class="bu">min</span>(tmp)</span>
<span id="cb8-79"><a href="#cb8-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-80"><a href="#cb8-80" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb8-81"><a href="#cb8-81" aria-hidden="true" tabindex="-1"></a>        dist_child_1 <span class="op">=</span> norm(children[<span class="dv">0</span>][<span class="dv">0</span>],new_point)</span>
<span id="cb8-82"><a href="#cb8-82" aria-hidden="true" tabindex="-1"></a>        dist_child_2 <span class="op">=</span> norm(children[<span class="dv">1</span>][<span class="dv">0</span>],new_point)</span>
<span id="cb8-83"><a href="#cb8-83" aria-hidden="true" tabindex="-1"></a>        node1 <span class="op">=</span> <span class="va">None</span><span class="op">;</span> node2 <span class="op">=</span> <span class="va">None</span></span>
<span id="cb8-84"><a href="#cb8-84" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> dist_child_1 <span class="op">&lt;</span> dist_child_2:</span>
<span id="cb8-85"><a href="#cb8-85" aria-hidden="true" tabindex="-1"></a>            node1 <span class="op">=</span> children[<span class="dv">0</span>]</span>
<span id="cb8-86"><a href="#cb8-86" aria-hidden="true" tabindex="-1"></a>            node2 <span class="op">=</span> children[<span class="dv">1</span>]</span>
<span id="cb8-87"><a href="#cb8-87" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb8-88"><a href="#cb8-88" aria-hidden="true" tabindex="-1"></a>            node1 <span class="op">=</span> children[<span class="dv">1</span>]</span>
<span id="cb8-89"><a href="#cb8-89" aria-hidden="true" tabindex="-1"></a>            node2 <span class="op">=</span> children[<span class="dv">0</span>]</span>
<span id="cb8-90"><a href="#cb8-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-91"><a href="#cb8-91" aria-hidden="true" tabindex="-1"></a>        knn_tmp <span class="op">=</span> search_tree(new_point, knn_matches, node1, k)</span>
<span id="cb8-92"><a href="#cb8-92" aria-hidden="true" tabindex="-1"></a>        knn_matches_out <span class="op">=</span> search_tree(new_point, knn_tmp, node2, k)</span>
<span id="cb8-93"><a href="#cb8-93" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb8-94"><a href="#cb8-94" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> knn_matches_out</span>
<span id="cb8-95"><a href="#cb8-95" aria-hidden="true" tabindex="-1"></a>                   </span></code></pre></div>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> np.array([[<span class="fl">3.</span>,<span class="fl">4.</span>],[<span class="fl">5.</span>,<span class="fl">5.</span>],[<span class="fl">9.</span>,<span class="fl">2.</span>],[<span class="fl">3.2</span>,<span class="fl">5.</span>],[<span class="fl">7.</span>,<span class="fl">5.</span>],</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>                 [<span class="fl">8.</span>,<span class="fl">9.</span>],[<span class="fl">7.</span>,<span class="fl">6.</span>],[<span class="dv">8</span>,<span class="dv">4</span>],[<span class="dv">6</span>,<span class="dv">2</span>]])</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>tree <span class="op">=</span> balltree.new_node()</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>balltree.form_tree(points,tree,all_points<span class="op">=</span>points)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>pp <span class="op">=</span> pprint.PrettyPrinter(indent<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&quot;tree&quot;</span>)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>pp.pprint(tree)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>newp <span class="op">=</span> np.array([<span class="fl">7.</span>,<span class="fl">7.</span>])</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>dummyp <span class="op">=</span> [np.inf,np.inf] <span class="co"># it should be removed immediately</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> balltree.search_tree(newp,[np.inf, [dummyp]], tree, k<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&quot;done&quot;</span>, res)</span></code></pre></div>
<p>Bu iki grup, o anda işlemekte olduğumuz ağaç düğümün (node) iki
çocukları olacaktır. Çocuk noktaları kararlaştırıldıktan sonra artık
sonraki aşamaya geçilir, fonksiyon <code>form_tree</code> bu çocuk
noktaları alarak, ayrı ayrı, her çocuk grubu için özyineli (recursive)
olarak kendi kendini çağırır. Kendi kendini çağıran
<code>form_tree</code>, tekrar başladığında kendini yeni (bir) nokta
grubu ve yeni bir düğüm objesi ile başbaşa bulur, ve hiçbir şeyden
habersiz olarak işleme koyulur. Tabii her özyineli çağrı yeni düğüm
objesini yaratırken bir referansı üstteki ebeveyn düğüme koymayı
unutmamıştır, böylece özyineli fonksiyon dünyadan habersiz olsa bile,
ağacın en üstünden en altına kesintisiz bir bağlantı zinciri hep
elimizde olur.</p>
<p>Not: <code>form_tree</code> içinde bir numara yaptık, tüm noktaların
<span class="math inline">\(f_1\)</span>’e olan uzaklığı
<code>dist1</code>, <span class="math inline">\(f_2\)</span>’e olan
uzaklığı ise <code>dist2</code>. Sonra <code>diffs = dist1-dist2</code>
ile bu iki uzaklığı birbirinden çıkartıyoruz ve mesela
<code>points[diffs &lt;= 0]</code> ile <span
class="math inline">\(f_1\)</span>’e yakın olanları buluyoruz, çünkü bir
tarafta <span class="math inline">\(f_1\)</span>’e yakınlık 4 diğer
tarafta <span class="math inline">\(f_2\)</span>’ye yakınlık 6 ise,
4-6=-2 ie o nokta <span class="math inline">\(f_1\)</span>’e yakın
demektir. Ufak bir numara ile numpy dilimleme (slicing) tekniğini
kullanabilmiş olduk ve bu önemli çünkü böylece <code>for</code> döngüsü
yazmıyoruz, numpy’in arka planda C ile yazılmış hızlı rutinlerini
kullanıyoruz.</p>
<p>Tekrar hatırlatalım: kürelerin sınırları kesişebilir.</p>
<p>Arama</p>
<p>Üstte sözde program (pseudocode) <code>ball_knn</code> olarak
gösterilen ve bizim kodda <code>search_tree</code> olarak anılan
fonksiyon arama fonksiyonu. Aranan <code>new_point</code>’e olan k en
yakın diğer veri noktalar. Dışarıdan verilen değişken
<code>knn_matches</code> üzerinde fonksiyon özyineli bir şekilde arama
yaparken “o ana kadar bulunmuş en yakın k nokta” ve o noktaların
<code>new_point</code>’e olan en yakın mesafesi saklanır, arama işleyişi
sırasında <code>knn_matches</code>, <code>knn_matches_out</code> sürekli
verilip geri döndürülen değişkenlerdir, sözde programdaki <span
class="math inline">\(P^{in},P^{out}\)</span>’un karşılığıdırlar.</p>
<p>Arama algoritması şöyle işler: şimdi önceden oluşturulmuş küre
hiyerarşisini üstten alta doğru gezmeye başlarız. Her basamakta yeni
nokta ile o kürenin pivot’unu, yarıçapını kullanarak bir “alt sınır
mesafe hesabı” yaparız, bu mesafe hesabının arkasında yatan düşünceyi
yazının başında anlatmıştık. Bu mesafe küre içindeki tüm noktalara olan
bir en az mesafe idi, ve eğer eldeki <code>knn_matches</code> üzerindeki
şimdiye kadar bulunmuş mesafelerin en azından daha az ise, o zaman bu
küre “bakmaya değer” bir küredir, ve arama algoritması bu küreden işleme
devam eder. Şimdiye kadar bulunmuş mesafelerin en azı
<code>knn_matches</code> veri yapısı içine <code>min_so_far</code>
olarak saklanıyor, sözde programdaki <span
class="math inline">\(D_{sofar}\)</span>.</p>
<p>Bu irdeleme sonrası (yani vs küresinden yola devam kararı arkasından)
işleme iki şekilde devam edilebilir, çünkü bir küre iki türden olabilir;
ya nihai en alt kürelerden biridir ve üzerinde gerçek noktalar
depolanmıştır, ya da ara kürelerden biridir (sona gelmedik ama doğru
yoldayız, daha alta inmeye devam), o zaman fonksiyon yine özyineli bir
şekilde bu kürenin çocuklarına bakacaktır - her çocuk için kendi kendini
çağıracaktır. İkinci durumda, kürede noktalar depolanmıştır, artık basit
lineer bir şekilde o tüm noktalara teker teker bakılır, eldekilerden
daha yakın olanı alınır, eldeki liste şişmeye başlamışsa (k’den daha
fazla ise) en büyük noktalardan biri atılır, vs.</p>
<p>Not: Silme işlemi örnek kodumuzda Python <code>del</code> ile
gerçekleştirildi. Eğer bu işlem de hızlandırılmak istenirse, en alt küre
seviyesindeki veriler bir öncelik kuyruğu (priority queue) üzerinde
tutulabilir, ve silme işlemi hep en sondaki elemanı siler, ekleme işlemi
ise yeni elemanı (hep sıralı olan) listede doğru yere koyar.</p>
<p>Daha alta inmemiz gereken birinci durumda yapılan iki çağrının bir
özelliğine dikkat çekmek isterim. Yeni noktanın bu çocuklara olan
uzaklığı da ölçülüyor, ve en önce, en yakın olan çocuğa doğru bir
özyineleme yapılıyor. Bu nokta çok önemli: niye böyle yapıldı? Çünkü
içinde muhtemelen daha yakın noktaların olabileceği kürelere doğru
gidersek, özyineli çağrıların teker teker bitip yukarı doğru çıkmaya
başlaması ve kaldıkları yerden bu sefer ikinci çocuk çağrılarını yapmaya
başlaması ardından, elimizdeki <code>knn_matches</code> üzerinde en
yakın noktaları büyük bir ihtimalle zaten bulmuş olacağız. Bu durumda
ikinci çağrı yapılsa bile tek bir alt sınır hesabı o kürede dikkate
değer hiçbir nokta olamayacağını ortaya çıkaracak (çünkü en iyiler zaten
elimizde), ve ikinci çocuğa olan çağrılar hiç alta inmeden pat diye geri
dönecektir, hiç aşağı inilmeyecektir.</p>
<p>Bu müthiş bir kazanımdır: zaten bu stratejiye litetürde “budamak
(pruning)” adı veriliyor, bu da çok uygun bir kelime aslında, çünkü
ağaçlarla uğraşıyoruz ve bir düğüm (küre) ve onun altındaki hiçbir alt
küreye uğramaktan kurtularak o dalların tamamını bir nevi “budamış”
oluyoruz. Bir sürü gereksiz işlemden de kurtuluyoruz, ve aramayı
hızlandırıyoruz.</p>
<p>Model</p>
<p>KNN’in model kullanmayan, model yerine verinin kendisini kullanan bir
algoritma olarak tanıttık. Peki “eğitim’’ evresi sonrası ele geçen
küreler ve ağaç yapısı bir nevi model olarak görülebilir mi?</p>
<p>Bu önemli bir soru, ve bir bakıma, evet ağaç yapısı sanki bir
modelmiş gibi duruyor. Fakat, mesela istatistiksel, grafiksel, yapay
sınır ağları (neural net) bağlamında bakılırsa bu yapıya tam bir model
denemez. Model bazlı metotlarda model kurulunca veri atılır, ona bir
daha bakılmaz. Fakat KNN, küre ve ağaç yapısını hala eldeki veriye
erişmek için kullanmaktadır. Yani bir bakıma veriyi “indeksliyoruz’’,
ona erişimi kolaylaştırıp hızlandırıyoruz, ama ondan model
çıkartmıyoruz.</p>
<p>Not: Verilen Python kodu ve algoritma yakın noktaları hesaplıyor
sadece, onların etiketlerinden hareketle yeni noktanın etiketini tahmin
etme aşamasını gerçekleştirmiyor. Fakat bu son aşama işin en basit
tarafı, eğitim veri yapısına eklenecek bir etiket bilgisi ve sınıflama
sonrası k noktanın ağırlıklı etiketinin hesabı ile basit şekilde
gerçekleştirilebilir.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>python plot_circles.py</span></code></pre></div>
<p>Ağaç oluşumu sırasındaki kürelerin grafiği alttadır.</p>
<p><img src="knn0.png" /> <img src="knn1.png" /> <img src="knn2.png" />
<img src="knn3.png" /> <img src="knn4.png" /> <img src="knn5.png" />
<img src="knn6.png" /> <img src="knn7.png" /> <img src="knn8.png" />
<img src="knn9.png" /></p>
<p>Kaynaklar</p>
<p>[1] Liu, Moore, Gray, {}</p>
<p>[2] Alpaydın, <em>Introduction to Machine Learning</em></p>
<p>[3] <em>A simple kd-tree in Python</em>, <a
href="https://github.com/stefankoegl/kdtree">https://github.com/stefankoegl/kdtree</a></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
