<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Felzenswalb Gruplaması (Felzenswalb Clustering)</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="felzenswalb-gruplaması-felzenswalb-clustering">Felzenswalb
Gruplaması (Felzenswalb Clustering)</h1>
<p>Minimum Kapsayan Ağaç (Minimum Spanning Tree -MST-) kavramını
kullanan Felzenswalb kümelemesini göreceğiz. MST’yi daha önce işledik.
Literatürde Felzenswalb metotunun imaj gruplaması için kullanıldığı
görülebilir, biz imaj gruplaması yapan algoritma içinden veri kümelemesi
yapan kısmı çıkarttık ve ayrı bir şekilde paylaşıyoruz. Bu gruplama
algoritmasının daha önce paylaştığımız Kruskal’ın MST koduna yapılacak
birkaç ekleme sayesinde elde edilebilmesi hakikaten ilginç. Normal MST
çizitin ayrı bölgelerinde ayrı ağaçlar yaratır ve bunları yavaş yavaş
büyütür, gerektiği noktalarda onları birleştirir. Felzenswalb sadece bu
birleştirme mantığını biraz değiştirip, ayrı ağaçları bir grup olarak
kabul eder, ve bu grupların kendi içinde benzerliği maksimal,
gruplararası benzerliği minimal olacak hale getirir. Bu şekilde bildik
Kruskal işletilince çok hızlı işleyen hızlı bir gruplama algoritması
elde edilmiş olur!</p>
<p>Felzenswalb veri olarak, MST gibi, bir çizit alır ve bu çizit veri
noktalarının arasındaki yakınlık bilgisini içeren bir matris olarak
verilebilir. Mesela 5 veri noktası var ise, 0. nokta ile 1. nokta
arasındaki ‘10’ büyüklüğündeki bir mesafe <span
class="math inline">\(A(0,1) = 10\)</span> olarak kaydedilebilir.
Kümeler birbirine yakın öğeler arasından seçilir.</p>
<p>Algoritmanın önemli avantajlarından biri küme sayısının (GMM’de
olduğu gibi) önceden tanımlanmasına gerek olmamasıdır. Belli eşik
değerleri tanımlanınca küme sayısı kendiliğinden bulunur. Tabii
“dışarıdan verilen bir parametreyi başka biriyle değiştirmiş mi olduk?’’
sorusu akla gelebilir, Felzenswalb’ın aldığı hiperparametreler kabaca
ayarlanabilen ve veri kaynağı bağlamında akla uygun şeyler, ve belli
değerler etrafında stabilite ortaya çıkabiliyor. Kıyasla”küme sayısı’’
ciddi bir rakam ve değişmesi mümkün değil.</p>
<p>Felzenswalb’ın matematiğinde önce imaj bölgelerinin (ya da veri
kümeleri olarak düşünebiliriz) arasında ikili karşılaştırma için bir
ölçüt gerekir. Bu bölümde bir beyan <span
class="math inline">\(D\)</span>’yi ortaya koyacağız, ki bu beyan,
imajdaki iki bileşen (ki imaj gruplamasının doğru olarak bulmaya
çalışacağı bileşenler) arasında bir sınır olup olmadığına dair kanıtın
ölçüsü olacak. Beyanın temeli şudur: iki bileşen arasındaki sınırın
boyunda yer alan her iki tarafın öğelerinin farklılığına bak, ve onu her
bileşenin kendi içindeki farklılığa göre oranla. Yani bu beyan, bir
bileşenin iç farklılığını dış farklılığına kıyaslar, ve bu sebeple
verinin yerel karakteristikleri gözetmiş olur. Kıyaslama mesela, global,
verinin her yerinde aynen geçerli olacak bir sabit eşik değerine
vs. bağlı değildir.</p>
<p>Tanım</p>
<p>Bir bileşen <span class="math inline">\(C \subseteq V\)</span>, ki
<span class="math inline">\(C\)</span> bir bileşendir (component) ve
<span class="math inline">\(V\)</span> çizitin tüm noktalarıdır, <em>iç
farklılığını</em>, o <span class="math inline">\(C\)</span>’nin minimum
kapsayan ağacının, yani <span
class="math inline">\(MST(C)\)</span>’sinin en büyük kenar ağırlığı
olarak alıyoruz. Bu iç farklılığı <span
class="math inline">\(Int(C)\)</span> olarak belirtirsek,</p>
<p><span class="math display">\[ Int(C) = \max_{e \in MST(C,E)} w(e)
\]</span></p>
<p>ki <span class="math inline">\(w((v_i , v_j))\)</span> bir çizit
<span class="math inline">\(G = (V,E)\)</span>’yi oluşturan bir kenar
<span class="math inline">\((v_i,v_j) \in E\)</span> ağırlığı olarak
belirtilir.</p>
<p>Tanım</p>
<p>İki bileşen <span class="math inline">\(C_1,C_2 \subseteq V\)</span>
arasındaki farkı o iki bileşeni birleştiren kenarlardan en ufağı olarak
alıyoruz. İki bileşenin arasında birden fazla bağlantı olması mümkündür,
tüm bunlara bakıyoruz, ve en ufağını alıyoruz.</p>
<p><span class="math display">\[ Dif(C_1,C_2) = \min_{v_i \in C_1, v_j
\in C_2, (v_i,v_j) \in E} w((v_i,v_j))\]</span></p>
<p>Eğer <span class="math inline">\(C_1,C_2\)</span> arasında bir kenar
yok ise <span class="math inline">\(Dif(C_1,C_2) = \infty\)</span> kabul
ediliyor.</p>
<p>Prensip olarak iki bileşen arasındaki en minimal bağlantının problem
çıkartabileceği düşünülebilirdi, niye en az, niye ortalama vs değil?
Pratikte bu ölçütün çok iyi işlediği görülmüştür. Hatta iyi olmaktan
öte, bu ölçüt minimal yerine medyan, ya da diğer yüzdelik dilim
(quantile) ölçütle değiştirildiği zaman (ki bunu yaparak genel
algoritmanın aykırı değerlere -outlier- karşı daha dayanıklı olması
istenmişti), algoritma çetrefilliği NP-Zor haline geliyor. Yani gruplama
kriterinde ufacık bir değişiklik problemin çözüm zorluluğunda müthiş bir
değişim ortaya çıkartıyor.</p>
<p>Şimdi iki bileşenin karşılaştırma beyanı <span
class="math inline">\(D\)</span>’nin tanımına geldik. <span
class="math inline">\(D\)</span> ölçütü, <span
class="math inline">\(Dif(C_1,C_2)\)</span>’nin <span
class="math inline">\(Int(C_1)\)</span> ya da <span
class="math inline">\(Int(C_2)\)</span>’den herhangi birinden daha büyük
olup olmadığına bakar. Ayrıca bu karşılaştırmayı bir eşik değeri
üzerinden pay ekleyerek yapar, eğer irdeleme olumlu ise, iki bileşen
arasında sınır vardır, yoksa yoktur.</p>
<p><span class="math display">\[
D(C_1,C_2) =
\left\{ \begin{array}{ll}
\textrm{Doğru} &amp; \textrm{ Eğer } Dif(C_1,C_2) &gt; MInt(C_1,C_2)
\textrm{ ise } \\
\textrm{Yanlış} &amp; \textrm{ Diğer durumda }
\end{array} \right.
\]</span></p>
<p>Minimum iç fark <span class="math inline">\(MInt\)</span> ise şöyle
tanımlıdır,</p>
<p><span class="math display">\[
MInt(C_1,C_2) = \min (Int(C_1)+\tau(C_1), Int(C_2)+\tau(C_2))
\]</span></p>
<p>Eşik fonksiyonu <span class="math inline">\(\tau\)</span> üstteki
irdelediğimiz fark hesaplarının belli derecelerde dışarıdan etkilemek
için koyulmuştur. Eğer bu kullanılmasaydı sadece <span
class="math inline">\(Int\)</span> fonksiyonu kullanılması gerekecekti,
fakat bu ölçüt tek başına ufak bir bileşenin yerel karakteristiklerini
göstermesi açısından yeterli değildir. Aşırı durumda mesela <span
class="math inline">\(|C| = 1,Int(C)=0\)</span>, yani en küçük <span
class="math inline">\(C\)</span> durumudur bu (<span
class="math inline">\(|C|\)</span> bileşenin içindeki öğe sayısı),
içinde tek öğe vardır, ve hiçbir kenar yoktur, <span
class="math inline">\(Int(C) = 0\)</span>.</p>
<p>Bu sebeple iyi bir <span class="math inline">\(\tau\)</span>
bileşenin büyüklüğünü hesaba katarak, ona ters oranlı bir rakam
oluşturursa iyi olur, mesela bir sabit <span
class="math inline">\(k\)</span> üzerinden,</p>
<p><span class="math display">\[ \tau(C) = \frac{k}{|C|} \]</span></p>
<p>Bu demektir ki ufak bileşenler için daha kuvvetli bir ispat arıyoruz,
çünkü küçük <span class="math inline">\(|C|\)</span>, <span
class="math inline">\(\tau\)</span>’yu büyütecektir, ve <span
class="math inline">\(Dif\)</span>’in ondan büyük olması daha
zorlaşacaktır. Tabii dikkat edelim, <span
class="math inline">\(k\)</span> bir “bileşen sayısı’’ değildir, yani
fonksiyona dikkatli bakarsak, eğer bileşenler arasında yeterince büyük
bir fark var ise ufak bileşenlere hala izin verilmiştir.</p>
<p>Algoritma şöyledir, girdi olarak <span
class="math inline">\(G=(V,E)\)</span> alır, ve <span
class="math inline">\(V\)</span>’yi <span
class="math inline">\(S\)</span> bileşenlerine ayırır ki her <span
class="math inline">\(S\)</span> içinde ona ait olan kenarlar vardır,
yani <span class="math inline">\(S=(C_1,..,C_r)\)</span></p>
<p><code>felzenswalb</code><span
class="math inline">\(\left(G\right)\)</span></p>
<ul>
<li><p><span class="math inline">\(E\)</span> kenarlarını <span
class="math inline">\(\pi = (o_1,..,o_m)\)</span> şeklinde küçükten
büyüğe doğru sırala.</p></li>
<li><p>İlk başta <span class="math inline">\(S^0\)</span> gruplamasını
al. Bu durumda her kenar <span class="math inline">\(v_i\)</span> kendi
bileşeni içindedir.</p></li>
<li><p>Her <span class="math inline">\(q = 1,..,m\)</span> icin</p></li>
<li><p><span class="math inline">\(S^{q-1}\)</span> gruplamasını baz
alıp <span class="math inline">\(S^q\)</span> gruplamasını şöyle yarat;
<span class="math inline">\(q\)</span>’inci sıradaki kenarın
birleştirdiği noktaların <span class="math inline">\(v_i,v_j\)</span>
olduğunu farz edelim, yani <span class="math inline">\(o_q =
(v_i,v_j)\)</span>.</p></li>
<li><p>Eğer <span class="math inline">\(v_i,v_j\)</span> <span
class="math inline">\(S^{q-1}\)</span> gruplaması içinde farklı iki
bileşen içindeyseler, ve <span class="math inline">\(w(o_q)\)</span> her
iki bileşenin içsel farkına kıyasla çok küçük ise, bu iki bileşeni
birleştir, yoksa hiçbir şey yapma.</p></li>
<li><p><code>return</code> <span
class="math inline">\(S^m\)</span></p></li>
</ul>
<p>Üstteki döngü içindeki en son irdelemede içsel farktan bahsediliyor,
bu tabii ki <span class="math inline">\(MInt(C_1,C_2)\)</span>. Daha
formel şekilde <span
class="math inline">\(MInt(C_1^{q-1},C_2^{q-1})\)</span> çünkü
bileşenlerin içerikleri hangi adımda olduğumuza göre değişebilir, <span
class="math inline">\(q\)</span> adımında bir önceki <span
class="math inline">\(q-1\)</span>’den bize “miras kalan’’ gruplamalar
ve bileşenler üzerinden iş yapıyoruz. Bir sonraki adıma ya birleşmiş, ya
da birleşmemiş (aynı) gruplamaları aktarıyoruz.</p>
<p>Aynı algoritmanın biraz daha fazla formül içeren hali [3]</p>
<p><code>felzenswalb</code><span
class="math inline">\(\left(G\right)\)</span></p>
<ul>
<li><p>Bütün kenarları küçükten büyüğe doğru sırala.</p></li>
<li><p>İlk başta kenar <span class="math inline">\(v_i\)</span> kendi
bileşeni içinde olsun, buna <span class="math inline">\(S^0\)</span>
gruplaması diyelim.</p></li>
<li><p>Her tüm kenarlar <span class="math inline">\(e_i = (v_1,v_2) \in
E\)</span> için</p>
<ul>
<li><span class="math inline">\(v_1 \in C_1\)</span> ve <span
class="math inline">\(v_2 \in C_2\)</span>’nin birbirinden ayrı, ayrı
bileşenler içinde ama aynı kenarı içeren noktalar olduğunu
düşünelim,</li>
<li><code>if</code> <span class="math inline">\(w(e_i) \le
MInt(C_1,C_2)\)</span> ise, o zaman</li>
<li><span class="math inline">\(C_1\)</span> ve <span
class="math inline">\(C_2\)</span>’yi birleştir</li>
<li><code>else</code></li>
<li><span class="math inline">\(S^i = S^{i-1}\)</span></li>
</ul></li>
</ul>
<p><code>return</code></p>
<p>Felzenswalb gruplamasının Python ile yazılmış örneği alttadır, daha
hızlı işleyen C++ bazlı kodu şurada [2] bulunabilir.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.sparse <span class="im">as</span> sps</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.io <span class="im">as</span> io</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> itertools, numpy <span class="im">as</span> np</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> threshold(size, c): <span class="cf">return</span> c <span class="op">/</span> size </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> {}</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find(C, u):</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> C[u] <span class="op">!=</span> u:</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        C[u] <span class="op">=</span> find(C, C[u])                    <span class="co"># Path compression</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> C[u]</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> union(C, R, u, v, S):</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    u, v <span class="op">=</span> find(C, u), find(C, v)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> R[u] <span class="op">&gt;</span> R[v]:                             <span class="co"># Union by rank</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        C[v] <span class="op">=</span> u</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        S[v] <span class="op">=</span> S[u] <span class="op">=</span> S[u] <span class="op">+</span> S[v]</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        C[u] <span class="op">=</span> v</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        S[v] <span class="op">=</span> S[u] <span class="op">=</span> S[u] <span class="op">+</span> S[v]</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> R[u] <span class="op">==</span> R[v]:                            <span class="co"># A tie: Move v up a level</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        R[v] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Felzenswalb:</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, min_size, c):</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.min_size_ <span class="op">=</span> min_size</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.c_ <span class="op">=</span> c</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fit(<span class="va">self</span>, X):</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span> X.shape</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>        G <span class="op">=</span> {}</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(X.shape[<span class="dv">0</span>]): G[i] <span class="op">=</span> {}</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> u,v,w <span class="kw">in</span> itertools.izip(X.row, X.col, X.data): G[u][v] <span class="op">=</span> w</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>        E <span class="op">=</span> [(G[u][v],u,v) <span class="cf">for</span> u <span class="kw">in</span> G <span class="cf">for</span> v <span class="kw">in</span> G[u]]</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>        E <span class="op">=</span> <span class="bu">sorted</span>(E)        </span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>        T <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>        C, R <span class="op">=</span> {u:u <span class="cf">for</span> u <span class="kw">in</span> G}, {u:<span class="dv">0</span> <span class="cf">for</span> u <span class="kw">in</span> G}   <span class="co"># Comp. reps and ranks</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        S <span class="op">=</span> {u:<span class="dv">1</span> <span class="cf">for</span> u <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(G))}</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>        ts <span class="op">=</span> {x:threshold(<span class="dv">1</span>,<span class="va">self</span>.c_) <span class="cf">for</span> x <span class="kw">in</span> C}</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> w, u, v <span class="kw">in</span> E:</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> find(C, u) <span class="op">!=</span> find(C, v):</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> w <span class="op">&lt;=</span> ts[u] <span class="kw">and</span> w <span class="op">&lt;=</span> ts[v]:</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>                    T.add((u, v))</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>                    union(C, R, u, v, S)</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>                    ts[u] <span class="op">=</span> w <span class="op">+</span> threshold(S[u],<span class="va">self</span>.c_)</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> _, u, v <span class="kw">in</span> E:</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> find(C, u) <span class="op">!=</span> find(C, v):</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> S[C[u]] <span class="op">&lt;</span> <span class="va">self</span>.min_size_ <span class="kw">or</span> S[C[v]] <span class="op">&lt;</span> <span class="va">self</span>.min_size_:</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>                    union(C, R, u, v, S)</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>         </span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.labels_ <span class="op">=</span> [np.nan <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(C))]</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(C)): <span class="va">self</span>.labels_[i] <span class="op">=</span> <span class="bu">int</span>(C[i])</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.T_ <span class="op">=</span> T</span></code></pre></div>
<p>Basit bir örnek</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.sparse <span class="im">as</span> sps, felz</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.io <span class="im">as</span> io</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> io.mmread(<span class="st">&#39;simple.mtx&#39;</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>clf <span class="op">=</span> felz.Felzenswalb(min_size<span class="op">=</span><span class="dv">1</span>,c<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>clf.fit(X)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> clf.labels_    </span></code></pre></div>
<pre><code>(5, 5)
[1, 1, 3, 3, 1]</code></pre>
<p>Biraz daha çetrefil bir örnek</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.sparse <span class="im">as</span> sps</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.io <span class="im">as</span> io, random</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd, os, sys</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>syn <span class="op">=</span> pd.read_csv(<span class="st">&quot;../kmeans/synthetic.txt&quot;</span>,comment<span class="op">=</span><span class="st">&#39;#&#39;</span>,names<span class="op">=</span>[<span class="st">&#39;a&#39;</span>,<span class="st">&#39;b&#39;</span>],sep<span class="op">=</span><span class="st">&quot;   &quot;</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.array(syn)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics.pairwise <span class="im">import</span> euclidean_distances</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> euclidean_distances(data, data)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>X2 <span class="op">=</span> X.copy()</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co"># filter out large values / distances so matrix can be sparse</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>X2[X <span class="op">&gt;</span> <span class="dv">2000</span>] <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>X3 <span class="op">=</span> sps.lil_matrix(X2)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>X4 <span class="op">=</span> sps.triu(X3)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> <span class="st">&#39;non-zero items&#39;</span>, <span class="bu">len</span>(X4.nonzero()[<span class="dv">0</span>])</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> X4.shape</span></code></pre></div>
<pre><code>non-zero items 87010
(3000, 3000)</code></pre>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> felz</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>clf <span class="op">=</span> felz.Felzenswalb(min_size<span class="op">=</span><span class="dv">20</span>,c<span class="op">=</span><span class="dv">800</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>clf.fit(X4)</span></code></pre></div>
<pre><code>(3000, 3000)</code></pre>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>syn[<span class="st">&#39;cluster&#39;</span>] <span class="op">=</span> clf.labels_</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> <span class="bu">len</span>(syn[<span class="st">&#39;cluster&#39;</span>].unique()), <span class="st">&#39;clusters found&#39;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> syn[:<span class="dv">5</span>]</span></code></pre></div>
<pre><code>19 clusters found
       a      b  cluster
0  54620  43523      120
1  52694  42750      120
2  53253  43024      120
3  54925  42624      120
4  54973  43980      120</code></pre>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> clust <span class="kw">in</span> syn[<span class="st">&#39;cluster&#39;</span>].unique():</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    tmp <span class="op">=</span> np.array(syn[syn[<span class="st">&#39;cluster&#39;</span>] <span class="op">==</span> clust][[<span class="st">&#39;a&#39;</span>,<span class="st">&#39;b&#39;</span>]])</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    plt.scatter(tmp[:,<span class="dv">0</span>], tmp[:,<span class="dv">1</span>], c<span class="op">=</span>np.random.rand(<span class="dv">3</span>,<span class="dv">1</span>))</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;mstseg_01.png&#39;</span>)</span></code></pre></div>
<p><img src="mstseg_01.png" /></p>
<p>Şimdi [4] yazısında gördüğümüz kelime gruplaması örneğini Felzenswalb
ile gruplayalım.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.linalg <span class="im">as</span> lin</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.sparse <span class="im">as</span> sps</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> itertools, sys</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>sys.path.append(<span class="st">&#39;../svdcluster/&#39;</span>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> leven</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>words <span class="op">=</span> np.array(</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    [<span class="st">&#39;the&#39;</span>, <span class="st">&#39;be&#39;</span>, <span class="st">&#39;to&#39;</span>, <span class="st">&#39;of&#39;</span>, <span class="st">&#39;and&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;in&#39;</span>, <span class="st">&#39;that&#39;</span>, <span class="st">&#39;have&#39;</span>,</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>     <span class="st">&#39;I&#39;</span>, <span class="st">&#39;it&#39;</span>, <span class="st">&#39;for&#39;</span>, <span class="st">&#39;not&#39;</span>, <span class="st">&#39;on&#39;</span>, <span class="st">&#39;with&#39;</span>, <span class="st">&#39;he&#39;</span>, <span class="st">&#39;as&#39;</span>, <span class="st">&#39;you&#39;</span>,</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>     <span class="st">&#39;do&#39;</span>, <span class="st">&#39;at&#39;</span>, <span class="st">&#39;this&#39;</span>, <span class="st">&#39;but&#39;</span>, <span class="st">&#39;his&#39;</span>, <span class="st">&#39;by&#39;</span>, <span class="st">&#39;from&#39;</span>, <span class="st">&#39;they&#39;</span>, <span class="st">&#39;we&#39;</span>,</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>     <span class="st">&#39;say&#39;</span>, <span class="st">&#39;her&#39;</span>, <span class="st">&#39;she&#39;</span>, <span class="st">&#39;or&#39;</span>, <span class="st">&#39;an&#39;</span>, <span class="st">&#39;will&#39;</span>, <span class="st">&#39;my&#39;</span>, <span class="st">&#39;one&#39;</span>, <span class="st">&#39;all&#39;</span>,</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>     <span class="st">&#39;would&#39;</span>, <span class="st">&#39;there&#39;</span>, <span class="st">&#39;their&#39;</span>, <span class="st">&#39;what&#39;</span>, <span class="st">&#39;so&#39;</span>, <span class="st">&#39;up&#39;</span>, <span class="st">&#39;out&#39;</span>, <span class="st">&#39;if&#39;</span>,</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>     <span class="st">&#39;about&#39;</span>, <span class="st">&#39;who&#39;</span>, <span class="st">&#39;get&#39;</span>, <span class="st">&#39;which&#39;</span>, <span class="st">&#39;go&#39;</span>, <span class="st">&#39;me&#39;</span>, <span class="st">&#39;when&#39;</span>, <span class="st">&#39;make&#39;</span>,</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>     <span class="st">&#39;can&#39;</span>, <span class="st">&#39;like&#39;</span>, <span class="st">&#39;time&#39;</span>, <span class="st">&#39;no&#39;</span>, <span class="st">&#39;just&#39;</span>, <span class="st">&#39;him&#39;</span>, <span class="st">&#39;know&#39;</span>, <span class="st">&#39;take&#39;</span>,</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>     <span class="st">&#39;people&#39;</span>, <span class="st">&#39;into&#39;</span>, <span class="st">&#39;year&#39;</span>, <span class="st">&#39;your&#39;</span>, <span class="st">&#39;good&#39;</span>, <span class="st">&#39;some&#39;</span>, <span class="st">&#39;could&#39;</span>,</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>     <span class="st">&#39;them&#39;</span>, <span class="st">&#39;see&#39;</span>, <span class="st">&#39;other&#39;</span>, <span class="st">&#39;than&#39;</span>, <span class="st">&#39;then&#39;</span>, <span class="st">&#39;now&#39;</span>, <span class="st">&#39;look&#39;</span>,</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>     <span class="st">&#39;only&#39;</span>, <span class="st">&#39;come&#39;</span>, <span class="st">&#39;its&#39;</span>, <span class="st">&#39;over&#39;</span>, <span class="st">&#39;think&#39;</span>, <span class="st">&#39;also&#39;</span>, <span class="st">&#39;back&#39;</span>,</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>     <span class="st">&#39;after&#39;</span>, <span class="st">&#39;use&#39;</span>, <span class="st">&#39;two&#39;</span>, <span class="st">&#39;how&#39;</span>, <span class="st">&#39;our&#39;</span>, <span class="st">&#39;work&#39;</span>, <span class="st">&#39;first&#39;</span>, <span class="st">&#39;well&#39;</span>,</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>     <span class="st">&#39;way&#39;</span>, <span class="st">&#39;even&#39;</span>, <span class="st">&#39;new&#39;</span>, <span class="st">&#39;want&#39;</span>, <span class="st">&#39;because&#39;</span>, <span class="st">&#39;any&#39;</span>, <span class="st">&#39;these&#39;</span>,</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>     <span class="st">&#39;give&#39;</span>, <span class="st">&#39;day&#39;</span>, <span class="st">&#39;most&#39;</span>, <span class="st">&#39;us&#39;</span>])</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>(dim,) <span class="op">=</span> words.shape</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="kw">lambda</span> (x,y): leven.levenshtein(x,y)</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>res<span class="op">=</span>np.fromiter(itertools.imap(f, itertools.product(words, words)),dtype<span class="op">=</span>np.uint8)</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> sps.coo_matrix(np.reshape(res,(dim,dim)))</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> A.shape</span></code></pre></div>
<pre><code>(100, 100)</code></pre>
<p>Kümelemeyi yapalım, <code>min_size=2</code> seçtik çünkü ufak kümeler
de mümkün.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> felz</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>clf <span class="op">=</span> felz.Felzenswalb(min_size<span class="op">=</span><span class="fl">1.5</span>,c<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>clf.fit(A)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>labels <span class="op">=</span> np.array(clf.labels_)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> <span class="bu">len</span>(np.unique(labels))</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> c, <span class="st">&#39;clusters found&#39;</span></span></code></pre></div>
<pre><code>(100, 100)
16 clusters found</code></pre>
<div class="sourceCode" id="cb15"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> c <span class="kw">in</span> np.unique(labels):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span> <span class="st">&#39;cluster&#39;</span>, c</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span> words[labels<span class="op">==</span>c]</span></code></pre></div>
<pre><code>cluster 9
[&#39;a&#39; &#39;I&#39; &#39;as&#39; &#39;at&#39; &#39;up&#39; &#39;also&#39; &#39;use&#39; &#39;because&#39; &#39;us&#39;]
cluster 10
[&#39;in&#39; &#39;it&#39; &#39;with&#39; &#39;which&#39; &#39;its&#39; &#39;first&#39;]
cluster 13
[&#39;of&#39; &#39;for&#39; &#39;on&#39; &#39;from&#39; &#39;or&#39; &#39;one&#39; &#39;if&#39; &#39;people&#39; &#39;only&#39; &#39;after&#39; &#39;our&#39;
 &#39;work&#39;]
cluster 15
[&#39;the&#39; &#39;be&#39; &#39;have&#39; &#39;he&#39; &#39;by&#39; &#39;they&#39; &#39;we&#39; &#39;her&#39; &#39;she&#39; &#39;my&#39; &#39;their&#39; &#39;who&#39;
 &#39;get&#39; &#39;me&#39; &#39;when&#39; &#39;time&#39; &#39;year&#39; &#39;them&#39; &#39;see&#39; &#39;other&#39; &#39;then&#39; &#39;over&#39; &#39;back&#39;
 &#39;even&#39; &#39;give&#39;]
cluster 18
[&#39;to&#39; &#39;not&#39; &#39;do&#39; &#39;so&#39; &#39;go&#39; &#39;no&#39; &#39;know&#39; &#39;into&#39; &#39;good&#39; &#39;now&#39; &#39;look&#39; &#39;two&#39;
 &#39;how&#39; &#39;new&#39; &#39;most&#39;]
cluster 22
[&#39;this&#39; &#39;his&#39; &#39;him&#39; &#39;think&#39;]
cluster 31
[&#39;and&#39; &#39;an&#39; &#39;all&#39; &#39;can&#39; &#39;want&#39; &#39;any&#39;]
cluster 39
[&#39;that&#39; &#39;what&#39; &#39;than&#39;]
cluster 42
[&#39;but&#39; &#39;out&#39; &#39;about&#39; &#39;just&#39;]
cluster 59
[&#39;make&#39; &#39;like&#39; &#39;take&#39;]
cluster 63
[&#39;you&#39; &#39;your&#39;]
cluster 66
[&#39;would&#39; &#39;could&#39;]
cluster 75
[&#39;some&#39; &#39;come&#39;]
cluster 88
[&#39;will&#39; &#39;well&#39;]
cluster 89
[&#39;say&#39; &#39;way&#39; &#39;day&#39;]
cluster 95
[&#39;there&#39; &#39;these&#39;]</code></pre>
<p>Kaynaklar</p>
<p>[1] Pedro F. Felzenszwalb and Daniel P. Huttenlocher, {}, <a
href="http://cs.brown.edu/~pff/segment/">http://cs.brown.edu/~pff/segment/</a></p>
<p>[2] Github, <a
href="https://github.com/burakbayramli/kod/felzenszwalb">https://github.com/burakbayramli/kod/felzenszwalb</a></p>
<p>[3] Mihai-Cotizo Sima, {}, 2012</p>
<p>[4] Bayramlı, Lineer Cebir, <em>SVD ile Kümeleme</em></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
