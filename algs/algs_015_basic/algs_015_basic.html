<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Temel Algoritmalar, Veri Yapıları</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="temel-algoritmalar-veri-yapıları">Temel Algoritmalar, Veri
Yapıları</h1>
<p>Bilgisayar Bilimdeki (Computer Science) pek çok algoritmanın
kullandığı bazı temel yapılar var. Bu yapıları görelim.</p>
<p>Sözlükler, Böleç Anahtarları (Hash Keys)</p>
<p>Elde anahtarlar ve değerlerden oluşan bir liste var, bize bir anahtar
verilince o anahtara tekabül eden değeri geri getirmek istiyoruz. Bu
anahtarları ve değerleri bildik düz listeye koyabiliriz, ama düz
listeler indis bazlı erişim sağlarlar, bu durumda arama yapmak gerekince
listeyi sürekli baştan sona kadar taramak gerekecektir. Hesapsal
karmaşıklık <span class="math inline">\(O(n)\)</span>.</p>
<p>Daha iyi bir yöntem anahtardan dizin indisi üretmek, boylece dizin
indisi ile direk aradığımız elemana gidebiliriz. Eğer anahtarlar,
mesela, meyve isimleri ise “portakal’’ anahtarını bir sayı indisine
nasıl çeviririz?</p>
<p>Tüm harflerin sayısal karşılığını kullanabiliriz, ve bu sayıları bir
şekilde daha büyük bir sayıya çevirerek her anahtar değerinden bir
sayısal indis üretebiliriz. Bu indis değeri bir dizine direk erişim
sağlayacaktır. Not: Sayı değeri bazen dizinin nihai kapasitesinden daha
büyük bir değer döndürebilir, o zaman matematiksel modülo kullanarak
(yani bölümden arta kalan) indisin sürekli belli bir aralıkta kalmasını
sağlayabiliriz.</p>
<p>Tabii bu durumda farklı anahtarlar aynı indisi değerine gidebilir
(çarpışma -collision- durumu, problemler bitmiyor (!)), o zaman çarpışma
olan yere bir alt liste ekleriz, arama o noktadan sonra kaba kuvvet ile
devam eder.</p>
<p>Programlama dillerinin çoğunda böleç kabiliyeti vardır;</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="bu">hash</span>(<span class="st">&#39;portakal&#39;</span>))</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="bu">hash</span>(<span class="st">&#39;armut&#39;</span>))</span></code></pre></div>
<pre class="text"><code>1625896577505283192
7027255142208074575</code></pre>
<p>Modülo uygulayalım,</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="bu">hash</span>(<span class="st">&#39;portakal&#39;</span>) <span class="op">%</span> <span class="dv">15</span>) <span class="co"># dizin 15 buyuklugunde </span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="bu">hash</span>(<span class="st">&#39;armut&#39;</span>) <span class="op">%</span> <span class="dv">15</span>)</span></code></pre></div>
<pre class="text"><code>7
10</code></pre>
<p>Yığıt (Stacks)</p>
<p>Bu yapı bir listedir, fakat özel bir tür listedir. Ona eklenen öğe en
tepeye / sona eklenir, yani “yığılmış’’ olur, bir saman yığını gibi,
eklenen her şey en tepeye eklenir. Öğe alınması gerektiğinde de en son
eklenen öğe alınır, yani en tepedeki / sondaki öğe. Bu yaklaşıma
ilk-giren-son-çıkar (first-in-last-out, FILO) ismi de veriliyor. Python
ile düz listeler direk yığıt olarak kullanılabiliyor, ve üzerinde ekleme
icin <code>extend</code>, çıkarma için <code>pop</code> çağrıları
yapılabiliyor.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>a  <span class="op">=</span> []</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>a.extend([<span class="st">&quot;ddd&quot;</span>])</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>a.extend([<span class="st">&quot;eddd&quot;</span>])</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (a)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (a.pop())</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (a)</span></code></pre></div>
<pre class="text"><code>[&#39;ddd&#39;, &#39;eddd&#39;]
eddd
[&#39;ddd&#39;]</code></pre>
<p>Kuyruk (Queue)</p>
<p>Bu yapı da yine liste gibi, dizili öğeler var, ama eklenen öğe başa
eklenir, alınan öğe sondan alınır. Kuyruklara ilk-eklenen-ilk-çıkar
(first-in-first-out, FIFO) ismi veriliyor.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Queue(deque):</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    pull <span class="op">=</span> deque.popleft</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    push <span class="op">=</span> deque.append</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> Queue([<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">4</span>])</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (q.pull())</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>q.push(<span class="dv">44</span>)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (q.pull())</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (q)</span></code></pre></div>
<pre class="text"><code>3
4
Queue([5, 4, 44])</code></pre>
<p><img src="basic_01.png" /></p>
<p>Hem yığıt hem de kuyrukların farklı kodlama şekilleri görülebiliyor.
Üstteki örnekte basitlik amaçlı olarak liste bazlı bir kodlama
gösterdik, fakat bağlanmış liste (linked list) kullanan çok hızlı
işleyen, etkili kodlar da vardır. Bağlanmış listeler bilindiği gibi
hafızada öğeler arası göstergeç (pointer) kullanarak öğede öğeye çok
hızlı şekilde atlayabilirler, iki öğe arasına yeni öğe sokmak çok
kolaydır, vs. Bağlantılı öğe kullanınca, ayrıca, dizinlerde olduğu gibi
illa önceden belli bir büyüklükteki yeri ayırmak gerekmiyor.</p>
<p>Bağlanmış Listeler</p>
<p>Eğer bir listede başa, sona ya da araya öğe sokmak hızlı olsun
istiyorsak bağlantılı liste kullanabiliriz. Listede öğeler (node)
vardır, ve her öge kendinden sonra gelecek diğer öğeye bir referans
tutmakla yükümlüdür. Referans derken bir objeye olan referanstan
bahsediyoruz; Python gibi yorumlanan, dinamik, temiz diller arka planda
neler olduğunu biraz saklıyorlar aslında, fakat C, C++ gibi diller ile
uğraşanlar bilirler, bir referans, ya da göstergeç (pointer) bir hafıza
adresidir. O adresin gösterdiği bir başka obje vardır. Göstergecin hangi
objeye işaret ettiği rahatlıkla değiştirilebilir.</p>
<p>Alttaki kodda düğüm (node) sınıfını görüyoruz, ve bağlantılı liste bu
düğümleri tutan (daha doğrusu sadece en baştakini tutan) bir objeden
ibaret. Başa yeni bir eleman eklemek demek başlangıç referansı
<code>head</code>‘i bu yeni düğüme doğru “göstertmek’’ ile olur, aynı
şekilde yeni elemanın sonraki obje referansı <code>next</code> daha
önceki baş elemana doğru yönlendirilir.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Node(<span class="bu">object</span>):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, value, <span class="bu">next</span><span class="op">=</span><span class="va">None</span>):</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.value <span class="op">=</span> value</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.<span class="bu">next</span> <span class="op">=</span> <span class="bu">next</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>): <span class="cf">return</span> <span class="bu">str</span>(<span class="va">self</span>.value)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> LinkedList(<span class="bu">object</span>):</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.head <span class="op">=</span> <span class="va">None</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _add(<span class="va">self</span>, value):</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.head <span class="op">=</span> Node(value, <span class="va">self</span>.head)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _printList(<span class="va">self</span>):</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> <span class="va">self</span>.head</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> node:</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span> (node.value,)</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> node.<span class="bu">next</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span> </span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _find(<span class="va">self</span>, index):</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>        prev <span class="op">=</span> <span class="va">None</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> <span class="va">self</span>.head</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> node <span class="kw">and</span> i <span class="op">&lt;</span> index:</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>            prev <span class="op">=</span> node</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> node.<span class="bu">next</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> node, prev, i</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _insert_middle(<span class="va">self</span>, index, value):</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>        node, prev, i <span class="op">=</span> <span class="va">self</span>._find(index)</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>        tmp <span class="op">=</span> Node(value, node)</span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>        prev.<span class="bu">next</span> <span class="op">=</span> tmp</span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _delete(<span class="va">self</span>, prev, node):</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> prev:</span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.head <span class="op">=</span> node.<span class="bu">next</span></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a>            prev.<span class="bu">next</span> <span class="op">=</span> node.<span class="bu">next</span></span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> deleteNode(<span class="va">self</span>, index):</span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a>        node, prev, i <span class="op">=</span> <span class="va">self</span>._find(index)</span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> index <span class="op">==</span> i:</span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._delete(prev, node)</span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">&#39;Node with index </span><span class="sc">{}</span><span class="st"> not found&#39;</span>.<span class="bu">format</span>(index))</span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a>ll <span class="op">=</span> LinkedList()</span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true" tabindex="-1"></a>ll._add(<span class="dv">37</span>)</span>
<span id="cb9-51"><a href="#cb9-51" aria-hidden="true" tabindex="-1"></a>ll._add(<span class="dv">99</span>)</span>
<span id="cb9-52"><a href="#cb9-52" aria-hidden="true" tabindex="-1"></a>ll._add(<span class="dv">12</span>)</span>
<span id="cb9-53"><a href="#cb9-53" aria-hidden="true" tabindex="-1"></a>ll._printList()</span>
<span id="cb9-54"><a href="#cb9-54" aria-hidden="true" tabindex="-1"></a>node, prev, i <span class="op">=</span> ll._find(<span class="dv">1</span>)</span>
<span id="cb9-55"><a href="#cb9-55" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="bu">str</span>(node), <span class="st">&#39;bulundu&#39;</span>)</span></code></pre></div>
<pre class="text"><code>12
99
37
99 bulundu</code></pre>
<p><img src="basic_02.png" /></p>
<p>Şimdi yeni bir örnekte araya bir öğe sokmayı görelim. Ortalarda bir
yerde öğe sokmak için önce indis değerine göre eski eleman bulunur, bu
öğeden sonra eleman sokulacak, ve daha önce <code>head</code> ile
yapılan ekleme örneğinde olduğu gibi, bu eski elemanın göstergeci yeni
objeye, yeni objenin göstergeci eski objenin gösterdiği objeye
yönlendirilecek.</p>
<p><img src="basic_03.png" /></p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>ll <span class="op">=</span> LinkedList()</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>ll._add(<span class="dv">99</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>ll._add(<span class="dv">12</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>ll._insert_middle(<span class="dv">1</span>,<span class="dv">37</span>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>ll._printList()</span></code></pre></div>
<pre class="text"><code>12
37
99</code></pre>
<p>Aradan bir öğe silelim. Silmek için yine göstergeç cambazlığı;
silinecek öğeye işaret eden göstergeç silinecek öğenin gösterdiği objeye
işaret ettiriliyor, böylece silinecek objeye kimse işaret etmez hale
geliyor. Erişilemez hale gelen obje silinmiş demektir.</p>
<p>Not: Bellek idaresi açısından hiç işaret edilmeyen objelere ne olur?
Bu objeler dinamik programlama dillerinde etrafta hala bir süre daha
kalmaya devam edebilirler, ne zaman dilin çöp toplayıcısı devreye
girerse o zaman silinirler. Yani bellekten gerçekten çıkartıldıkları an
çöp toplama işlemi sonrasıdır. C gibi dillerde bellekten silme işlemi
programcı tarafından tetiklenir, çöp toplayıcı yoktur.</p>
<p><img src="basic_04.png" /></p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>ll <span class="op">=</span> LinkedList()</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>ll._add(<span class="dv">37</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>ll._add(<span class="dv">99</span>)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>ll._add(<span class="dv">12</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>ll._printList()</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>node, prev, i <span class="op">=</span> ll._find(<span class="dv">1</span>)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>ll._delete(prev, node)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>ll._printList()</span></code></pre></div>
<pre class="text"><code>12
99
37
12
37</code></pre>
<p>Bağlantılı listelerin yığıt, kuyruk gibi yapıların kodlaması için ne
kadar faydalı olabileceği sürpriz değil; yığıt ya da kuyruk için hem baş
hem sondaki düğümlere referans tutulur, sona, başa ekleme, oradan obje
alma gibi işlemler biraz göstergeç cambazlığı ile çok hızlı bir şekilde
kodlanabilir.</p>
<p>İki Yönlü Bağlantılı Liste</p>
<p>Üstteki örnek tek yönlü bağlantılı listeydi, iki yönlü referans
tutmak ta mümkün.</p>
<p><img src="basic_05.png" /></p>
<p>Önce Genişliğine (Breadth-First) ve Önce Derinliğine (Depth-First)
Arama</p>
<p>Elimizde alttaki gibi bir çizit olsun,</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> {<span class="st">&#39;A&#39;</span>: <span class="bu">set</span>([<span class="st">&#39;B&#39;</span>, <span class="st">&#39;C&#39;</span>]),</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>         <span class="st">&#39;B&#39;</span>: <span class="bu">set</span>([<span class="st">&#39;A&#39;</span>, <span class="st">&#39;D&#39;</span>, <span class="st">&#39;E&#39;</span>]),</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>         <span class="st">&#39;C&#39;</span>: <span class="bu">set</span>([<span class="st">&#39;A&#39;</span>, <span class="st">&#39;F&#39;</span>]),</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>         <span class="st">&#39;D&#39;</span>: <span class="bu">set</span>([<span class="st">&#39;B&#39;</span>]),</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>         <span class="st">&#39;E&#39;</span>: <span class="bu">set</span>([<span class="st">&#39;B&#39;</span>, <span class="st">&#39;F&#39;</span>]),</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>         <span class="st">&#39;F&#39;</span>: <span class="bu">set</span>([<span class="st">&#39;C&#39;</span>, <span class="st">&#39;E&#39;</span>])}</span></code></pre></div>
<p><img src="graph.png" /></p>
<p>Arama için bir başlangıç düğümünü alıyoruz, onun komşularını,
komşuların komşularını ziyaret ede ede tüm çiziti ziyaret etmiş
oluyoruz. Ama bu ziyaret hangi sırada olmalı?</p>
<p>Bu sırayı belirlemek için bir yığıt kullanabiliriz. Yığıt kullanınca
aslında önce derinliğe türden bir arama kodlamış oluyoruz. Her ziyaret
öncesi bir düğümün komşularını alıp, onları yığıta koyuyoruz, sonra
yığıtın en üstündeki düğümü alıp onu ziyaret ediyoruz. Bu işlem aynı
seviyedeki tüm komşuları ziyaret etmeden sürekli komşunun komşusu,
vs. aldığı için bu bir derinliğe iniş kodlar.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> collections</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs(graph, start):</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    visited, stack <span class="op">=</span> collections.OrderedDict(), [start]</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> stack: <span class="co"># yigit bos ise bu ifade false olur</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>        vertex <span class="op">=</span> stack.pop()</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># bu kontrol hizli olsun diye OrderedDict kullandik</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># boylece hem ziyaret sirasi hatirlanacak, hem de</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># dugum ziyaret edilip edilmedigi sorusu cok hizli cevaplanacak</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> vertex <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>            visited[vertex] <span class="op">=</span> <span class="st">&#39;&#39;</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>            stack.extend(graph[vertex])</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> visited</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (dfs(graph, <span class="st">&#39;A&#39;</span>))</span></code></pre></div>
<pre class="text"><code>OrderedDict({&#39;A&#39;: &#39;&#39;, &#39;B&#39;: &#39;&#39;, &#39;E&#39;: &#39;&#39;, &#39;F&#39;: &#39;&#39;, &#39;C&#39;: &#39;&#39;, &#39;D&#39;: &#39;&#39;})</code></pre>
<p>Özyineli formda da yazabiliriz, eğer her komşu için teker teker
<code>dfs</code>’in kendisini çağırırsak derinleme dalış yapmış oluruz,
çünkü komşu listesinde ilk elemanda özyineli çağrı yapınca o geri gelene
kadar o çağrı içindeyiz, o çağrı da bir komşu listesi alıp öğelerde
özyineli çağrı yapacak, böyle derinleme devam edecek… Tabii bu durumda
gidilen yolu hatırlamak için onu bir liste olarak sürekli bir sonraki
özyineli çağrıya geçeriz ve her çağrıdan da geriye döndürürüz.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> collections</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs(graph,curr,path <span class="op">=</span> collections.OrderedDict()):</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    path[curr] <span class="op">=</span> <span class="st">&#39;&#39;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> edge <span class="kw">in</span> graph[curr]:</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> edge <span class="kw">not</span> <span class="kw">in</span> path:</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>            path <span class="op">=</span> dfs(graph,edge,path)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> path</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (dfs(graph,<span class="st">&#39;A&#39;</span>))</span></code></pre></div>
<pre class="text"><code>OrderedDict({&#39;A&#39;: &#39;&#39;, &#39;C&#39;: &#39;&#39;, &#39;F&#39;: &#39;&#39;, &#39;E&#39;: &#39;&#39;, &#39;B&#39;: &#39;&#39;, &#39;D&#39;: &#39;&#39;})</code></pre>
<p>Şimdi diğer arama şekline, önce genişliğine aramaya gelelim. Bunu
yapmak için yığıt veri yapısı yerine kuyruk kullanmak yeterli. Bu
durumda komşuları kuyruğa koyduğumuz zaman o komşuların işlenmesi
bitmeden sonraki düğümlere geçilmeyecektir, çünkü kuyruğa ilk konan ilk
önce işlenir, yani komşuların kendisinin işlenmesi bitmeden onların alt
çocuklarına sıra gelmeyecektir. Bu, ziyareti seviye seviye işlem yapmaya
zorlar.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bfs(graph, start):</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    visited, queue <span class="op">=</span> collections.OrderedDict(), Queue([start])</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> queue:</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>        vertex <span class="op">=</span> queue.pull()</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> vertex <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>            visited[vertex] <span class="op">=</span> <span class="st">&#39;&#39;</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> x <span class="kw">in</span> graph[vertex]: queue.push(x)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> visited</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (bfs(graph, <span class="st">&#39;A&#39;</span>))</span></code></pre></div>
<pre class="text"><code>OrderedDict({&#39;A&#39;: &#39;&#39;, &#39;C&#39;: &#39;&#39;, &#39;B&#39;: &#39;&#39;, &#39;F&#39;: &#39;&#39;, &#39;D&#39;: &#39;&#39;, &#39;E&#39;: &#39;&#39;})</code></pre>
<p>İkisel Arama Ağaçları (Binary Search Trees -BST-)</p>
<p>Bir BST şu özelliklere sahiptir: bir düğümün sadece iki tane alt
düğümü vardır, bu alt düğümlerden solda olanı üst düğümden her zaman
küçük, sağda olanı her zaman büyüktür. Ağaçta tekrarlanan öğe yoktur.
Ağaç eğer dengeli ise (yani birkaç düğümün altı sürekli dallanarak
gittiği ama ötekilerin aynı seviyede kaldığı durum yok ise) o zaman ağaç
derinliği <span class="math inline">\(n\)</span> öğe için <span
class="math inline">\(\log n\)</span> olacaktır.</p>
<p><img src="basic_06.png" /></p>
<p>Böyle bir yapının pek çok farklı şekildeki aramalar için ne kadar
elverişli olduğunu görmek zor olmaz; mesela “belli bir aralıktaki tüm
düğümleri getir’’ algoritması hızlı işler [3, sf. 403]. Üst düğümden
başlarız, baktığımız düğümün eldeki değerden küçük ya da büyük olduğuna
göre sola ya da sağa gideriz, vs. Bir özellik daha; mesela alttaki gibi
bir ağaca bakalım (harfler arasında da küçüktür / büyüktür irdelemesi
yapılabiliyor tabii ki),</p>
<p><img src="basic_07.png" /></p>
<p>Şimdi bu ağacı üstten alta doğru “yassılaştırdığımızı’’ düşünelim, bu
bize anahtarları sıralanmış bir düz yapı vermez mi? Evet. Yani bir ağaç
yapısının doğal bir sonucu olarak her zaman bize çok hızlı bir şekilde
sıralanmış bir liste verebilir. Üstelik ağaca ekleme, silme işlemleri de
hızlı olduğu için bu sıralanmışlık kalıcı olacaktır. Altta
<code>_printInorder</code> bu özelliği gösteriyor.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Node:</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, val):</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.l <span class="op">=</span> <span class="va">None</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.r <span class="op">=</span> <span class="va">None</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.v <span class="op">=</span> val</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BST:</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.root <span class="op">=</span> <span class="va">None</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add(<span class="va">self</span>, val):</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(<span class="va">self</span>.root <span class="op">==</span> <span class="va">None</span>):</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.root <span class="op">=</span> Node(val)</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._add(val, <span class="va">self</span>.root)</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _add(<span class="va">self</span>, val, node):</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(val <span class="op">&lt;</span> node.v):</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span>(node.l <span class="op">!=</span> <span class="va">None</span>):</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>._add(val, node.l)</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>                node.l <span class="op">=</span> Node(val)</span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span>(node.r <span class="op">!=</span> <span class="va">None</span>):</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>._add(val, node.r)</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>                node.r <span class="op">=</span> Node(val)</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> find(<span class="va">self</span>, val):</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(<span class="va">self</span>.root <span class="op">!=</span> <span class="va">None</span>):</span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>._find(val, <span class="va">self</span>.root)</span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _find(<span class="va">self</span>, val, node):</span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(val <span class="op">==</span> node.v):</span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> node</span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span>(val <span class="op">&lt;</span> node.v <span class="kw">and</span> node.l <span class="op">!=</span> <span class="va">None</span>):</span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>._find(val, node.l)</span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span>(val <span class="op">&gt;</span> node.v <span class="kw">and</span> node.r <span class="op">!=</span> <span class="va">None</span>):</span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>._find(val, node.r)</span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> printInOrder(<span class="va">self</span>):</span>
<span id="cb22-44"><a href="#cb22-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(<span class="va">self</span>.root <span class="op">!=</span> <span class="va">None</span>):</span>
<span id="cb22-45"><a href="#cb22-45" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._printInOrder(<span class="va">self</span>.root)</span>
<span id="cb22-46"><a href="#cb22-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-47"><a href="#cb22-47" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _printInOrder(<span class="va">self</span>, node):</span>
<span id="cb22-48"><a href="#cb22-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(node <span class="op">!=</span> <span class="va">None</span>):</span>
<span id="cb22-49"><a href="#cb22-49" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._printInOrder(node.l)</span>
<span id="cb22-50"><a href="#cb22-50" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span> (<span class="bu">str</span>(node.v) <span class="op">+</span> <span class="st">&#39; &#39;</span>)</span>
<span id="cb22-51"><a href="#cb22-51" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._printInOrder(node.r)</span>
<span id="cb22-52"><a href="#cb22-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-53"><a href="#cb22-53" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> printPreOrder(<span class="va">self</span>):</span>
<span id="cb22-54"><a href="#cb22-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(<span class="va">self</span>.root <span class="op">!=</span> <span class="va">None</span>):</span>
<span id="cb22-55"><a href="#cb22-55" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._printPreOrder(<span class="va">self</span>.root)</span>
<span id="cb22-56"><a href="#cb22-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-57"><a href="#cb22-57" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _printPreOrder(<span class="va">self</span>, node):</span>
<span id="cb22-58"><a href="#cb22-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(node <span class="op">!=</span> <span class="va">None</span>):</span>
<span id="cb22-59"><a href="#cb22-59" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span> (<span class="bu">str</span>(node.v) <span class="op">+</span> <span class="st">&#39; &#39;</span>)</span>
<span id="cb22-60"><a href="#cb22-60" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._printPreOrder(node.l)</span>
<span id="cb22-61"><a href="#cb22-61" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._printPreOrder(node.r)            </span>
<span id="cb22-62"><a href="#cb22-62" aria-hidden="true" tabindex="-1"></a>                        </span>
<span id="cb22-63"><a href="#cb22-63" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> printPostOrder(<span class="va">self</span>):</span>
<span id="cb22-64"><a href="#cb22-64" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(<span class="va">self</span>.root <span class="op">!=</span> <span class="va">None</span>):</span>
<span id="cb22-65"><a href="#cb22-65" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._printPostOrder(<span class="va">self</span>.root)</span>
<span id="cb22-66"><a href="#cb22-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-67"><a href="#cb22-67" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _printPostOrder(<span class="va">self</span>, node):</span>
<span id="cb22-68"><a href="#cb22-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(node <span class="op">!=</span> <span class="va">None</span>):</span>
<span id="cb22-69"><a href="#cb22-69" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span> (<span class="bu">str</span>(node.v) <span class="op">+</span> <span class="st">&#39; &#39;</span>)</span>
<span id="cb22-70"><a href="#cb22-70" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._printPostOrder(node.l)</span>
<span id="cb22-71"><a href="#cb22-71" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._printPostOrder(node.r)</span>
<span id="cb22-72"><a href="#cb22-72" aria-hidden="true" tabindex="-1"></a>                        </span>
<span id="cb22-73"><a href="#cb22-73" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> closest(<span class="va">self</span>, target):</span>
<span id="cb22-74"><a href="#cb22-74" aria-hidden="true" tabindex="-1"></a>        gap <span class="op">=</span> <span class="bu">float</span>(<span class="st">&quot;inf&quot;</span>)</span>
<span id="cb22-75"><a href="#cb22-75" aria-hidden="true" tabindex="-1"></a>        closest <span class="op">=</span> <span class="bu">float</span>(<span class="st">&quot;inf&quot;</span>)</span>
<span id="cb22-76"><a href="#cb22-76" aria-hidden="true" tabindex="-1"></a>        curr <span class="op">=</span> <span class="va">self</span>.root</span>
<span id="cb22-77"><a href="#cb22-77" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> curr:</span>
<span id="cb22-78"><a href="#cb22-78" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">abs</span>(curr.v <span class="op">-</span> target) <span class="op">&lt;</span> gap:</span>
<span id="cb22-79"><a href="#cb22-79" aria-hidden="true" tabindex="-1"></a>                gap <span class="op">=</span> <span class="bu">abs</span>(curr.v <span class="op">-</span> target)</span>
<span id="cb22-80"><a href="#cb22-80" aria-hidden="true" tabindex="-1"></a>                closest <span class="op">=</span> curr</span>
<span id="cb22-81"><a href="#cb22-81" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> target <span class="op">==</span> curr.v:</span>
<span id="cb22-82"><a href="#cb22-82" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb22-83"><a href="#cb22-83" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> target <span class="op">&lt;</span> curr.v:</span>
<span id="cb22-84"><a href="#cb22-84" aria-hidden="true" tabindex="-1"></a>                curr <span class="op">=</span> curr.l</span>
<span id="cb22-85"><a href="#cb22-85" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb22-86"><a href="#cb22-86" aria-hidden="true" tabindex="-1"></a>                curr <span class="op">=</span> curr.r</span>
<span id="cb22-87"><a href="#cb22-87" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> closest.v</span>
<span id="cb22-88"><a href="#cb22-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-89"><a href="#cb22-89" aria-hidden="true" tabindex="-1"></a>bst <span class="op">=</span> BST()</span>
<span id="cb22-90"><a href="#cb22-90" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&quot;Adding nodes 1 to 10 in the tree...&quot;</span>)</span>
<span id="cb22-91"><a href="#cb22-91" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">11</span>):</span>
<span id="cb22-92"><a href="#cb22-92" aria-hidden="true" tabindex="-1"></a>    bst.add(i)</span>
<span id="cb22-93"><a href="#cb22-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-94"><a href="#cb22-94" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span></span>
<span id="cb22-95"><a href="#cb22-95" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&quot;Searching for nodes 16 and 6&quot;</span>)</span>
<span id="cb22-96"><a href="#cb22-96" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> bst.find(<span class="dv">16</span>)</span>
<span id="cb22-97"><a href="#cb22-97" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> f: <span class="bu">print</span> (f.v)</span>
<span id="cb22-98"><a href="#cb22-98" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> bst.find(<span class="dv">6</span>)</span>
<span id="cb22-99"><a href="#cb22-99" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> f: <span class="bu">print</span> (f.v)</span>
<span id="cb22-100"><a href="#cb22-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-101"><a href="#cb22-101" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span></span>
<span id="cb22-102"><a href="#cb22-102" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&quot;Printing preorder...&quot;</span>)</span>
<span id="cb22-103"><a href="#cb22-103" aria-hidden="true" tabindex="-1"></a>bst.printInOrder()</span></code></pre></div>
<pre class="text"><code>Adding nodes 1 to 10 in the tree...
Searching for nodes 16 and 6
6
Printing preorder...
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 </code></pre>
<p>En yakın öğe arama fonksiyonu <code>closest</code> ilginç; BST’de bir
öğeyi tam eşitlik üzerinden aramak zaten oldukca hızlı. Şimdi düğümler
arasında aynı gezinme tekniğini kullanarak istenen yaklaşık bir değere
olan o gezilen düğümlere “yakınlığı’’ hesaplayıp, en yakın olanı sürekli
akılda tutup iş bittiğinde bu elemanı geri döndürmek bize en yakın öğeyi
verecektir.</p>
<p>Vektörler ve İkisel Arama (Binary Search)</p>
<p>Aslında ağaç üzerinde gördüğümüz sağa ya da sola gitme kavramı
genelleştirilerek bir dizin üzerinde arama yapmak için kullanılabilir.
Elimizde sıralanmış (bu önemli) bir dizin olduğunu düşünelim. Şimdi
eldeki bir test noktasının bu dizinde olup olmadığını merak ediyoruz.
Şöyle bir algoritma kullanabiliriz: dizinin tam ortasındaki öğesine
bakarız, eğer aranan eleman o ise, iş biter. Eğer değil ise ve
elimizdeki öğe bakılan orta noktadan küçük ise o orta noktanın solundaki
hiçbir öğeye artık bakmaya gerek yoktur. Sağ kısma geçeriz, ve aynı
işlemi tekrarlarız.</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> binary_search(alist, item):</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    first <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    last <span class="op">=</span> <span class="bu">len</span>(alist)<span class="op">-</span><span class="dv">1</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    found <span class="op">=</span> <span class="va">False</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> first<span class="op">&lt;=</span>last <span class="kw">and</span> <span class="kw">not</span> found:</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>        midpoint <span class="op">=</span> (first <span class="op">+</span> last)<span class="op">//</span><span class="dv">2</span> <span class="co"># // tamsayi bolumu demek, 5//2=2</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> alist[midpoint] <span class="op">==</span> item:</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>            found <span class="op">=</span> <span class="va">True</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> item <span class="op">&lt;</span> alist[midpoint]:</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>                last <span class="op">=</span> midpoint<span class="op">-</span><span class="dv">1</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>                first <span class="op">=</span> midpoint<span class="op">+</span><span class="dv">1</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> found, midpoint</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>testlist <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">8</span>, <span class="dv">13</span>, <span class="dv">17</span>, <span class="dv">19</span>, <span class="dv">32</span>, <span class="dv">42</span>,]</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(binary_search(testlist, <span class="dv">3</span>))</span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(binary_search(testlist, <span class="dv">13</span>))</span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(binary_search(testlist, <span class="dv">20</span>))</span></code></pre></div>
<pre class="text"><code>(False, 3)
(True, 4)
(False, 7)</code></pre>
<p>Yakın öğe bulmak benzer mantığı kullanır.</p>
<p>Bakılan kısımlar sürekli yarıya bölündüğü için bakılan kısım çok
hızlı bir şekilde küçülecektir, bu işlem hızını arttırır. Karmaşıklık
<span class="math inline">\(O(\log N)\)</span>. Lineer arama yapmaktan
(kaba kuvvet) daha hızlı.</p>
<p>Yarıya bölüp arama hakkında ilginç bir hikaye: bir projede bir
arkadaşımın üzerinde çalıştığı aşağı yukarı 1000 satırlık bir CSS
dosyası vardı (CSS’i web sayfaları ile uğraşanlar bilirler). Her nasılsa
dosya bir şekilde değişime uğramış, ve işleyen dosya artık işlemez hale
gelmiş. Bu dosya üzerinde kaynak kod deposu da kullanılmamış, yani
değişimin ne olduğunu depoya sorma şansı yok. CSS’in bir tarafı bozuk
ama neresi?</p>
<p>Benim fikrim ikiye bölme tekniği ile hatayı bulmaktı; CSS’in bir
yarısını iptal edip diğer kısmını kullan, işliyorsa öteki kısımda devam
et, aynı şekilde onu yarıla, ta ki hata ortadan yokoluncaya kadar. Bu
şekilde birkaç deneme ile hatalı satırı bulduk.</p>
<p>Öncelik Kuyruğu (Priority Queue)</p>
<p>Bu tür kuyruklarda öğe alma işlemi her zaman en küçük öğeyi verir.
Bir öğe eklediğimiz zaman o öğe büyüklüğüne göre kuyruk içindeki yerine
otomatik olarak sokulur. Öncelik kuyrukları arka planda ikisel ağaç
(binary tree) üzerinden kodlanırlar, en küçük öğeyi almak sabit, müthiş
hızlıdır çünkü en küçük öğe her zaman ağacın en tepesindeki düğümdedir.
Ekleme de oldukca iyi çalışır. Yani öncelik kuyrukları dışarıdan
ikidebir “sırala’’ komutu verilmeden sürekli kendilerini sıralı halde
tutan bir yapıdırlar. Bu kuyruklar pek çok bilgisayar bilim
algoritmasının demirbaşıdır.</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> heapq <span class="im">import</span> heappush, heappop</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> random <span class="im">import</span> randrange</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> pqueue():</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>): <span class="va">self</span>.data <span class="op">=</span> []</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> push(<span class="va">self</span>,x): heappush(<span class="va">self</span>.data,x)</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> pull(<span class="va">self</span>): <span class="cf">return</span> heappop(<span class="va">self</span>.data)</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>): <span class="cf">return</span> <span class="st">&#39;&#39;</span>.join(<span class="bu">str</span>(<span class="va">self</span>.data))</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>pq <span class="op">=</span> pqueue()</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a><span class="co"># rasgele degerler</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10</span>): pq.push(randrange(<span class="dv">100</span>))</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (pq)</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (pq.pull())</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>pq.push(<span class="dv">100</span>)</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (pq)</span></code></pre></div>
<pre class="text"><code>[3, 8, 86, 50, 19, 91, 97, 90, 62, 70]
3
[8, 19, 86, 50, 70, 91, 97, 90, 62, 100]</code></pre>
<p>Biraz daha kapsamlı bir kod <code>pqdict</code> paketinde, bu önemsel
kuyruğa anahtar / değerler veriliyor, anahtar değerleri mesela araba
modelleri, önem ise fiyatları olabilir, ve değerler çekildiğinde değeri
en az (önemi en fazla) olan değer çekilecektir. Ayrıca bu kuyruğu bir
döngüyle “gezmek’’ kuyruktan değerlerin çekilmesini de sağlıyor.
Kuyruğun iç kodlamasında kullandığı temel yapı ikisel yığın (binary
heap) adlı bir yapıdır.</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pqdict <span class="im">import</span> pqdict</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>Q <span class="op">=</span> pqdict() </span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>Q[<span class="st">&#39;toyota&#39;</span>] <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>Q[<span class="st">&#39;mercedes&#39;</span>] <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>Q[<span class="st">&#39;bmw&#39;</span>] <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> c <span class="kw">in</span> Q: <span class="bu">print</span> (c)</span></code></pre></div>
<pre class="text"><code>toyota
mercedes
bmw</code></pre>
<p>Bir ilginç özellik daha: bir döngü içinde değilsek <code>[]</code>
operatörü hem öncelik değerine bakılmasını hem de o değerin, anahtar
kuyruktan çekilmeden, değiştirilebilmesini sağlıyor.</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>Q[<span class="st">&#39;toyota&#39;</span>] <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>Q[<span class="st">&#39;mercedes&#39;</span>] <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>Q[<span class="st">&#39;bmw&#39;</span>] <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="bu">len</span>(Q))</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>Q[<span class="st">&#39;bmw&#39;</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;hala&#39;</span>, <span class="bu">len</span>(Q))</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> c <span class="kw">in</span> Q: <span class="bu">print</span> (c)</span></code></pre></div>
<pre class="text"><code>3
hala 3
bmw
mercedes
toyota</code></pre>
<p>Silmeden bakabilmek ve güncelleyebilmek önemli bir özellik (Java
karşılığı <code>PG.java</code> dosyasında).</p>
<p>Bellek Kullanımı</p>
<p>Bitirmeden önce bellek kullanımı hakkında birkaç paragraf yazalım.
Algoritmalarımız için veri yapısı seçerken o veri yapısının belleği
nasıl idare ettiğini bilmek iyi olur. Mesela sayı indisli bir dizin /
liste kullanıyoruz, dizinlere indis bazlı erişim çok hızlıdır, burası
güzel. Fakat dizinin sürekli büyümesi gerekiyorsa bu büyüme arka planda
nasıl idare ediliyor? Bazı kodlamalar vardır ki dizinleri parça parça
büyütür, yani 10’dan 20’ye büyümek gerekiyorsa 20 öğelik yeni yer
ayrılır, ve 10 öğe yeni listeye kopyalanır. O zaman parçalar küçük ise
bu kopyalama işleminde sırasında zaman kaybı olabilir. Eğer başa, sona
sürekli ekleme yapıldığı dinamik bir durum var ise belki bağlantılı
liste kullanmak daha iyidir.</p>
<p>Kaynaklar</p>
<p>[1] Heatland, <em>Python Algorithms</em></p>
<p>[2] Wahl, <em>Algorithms in Python</em></p>
<p>[3] Sedgewick, <em>Algorihms, 4th Edition</em></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
