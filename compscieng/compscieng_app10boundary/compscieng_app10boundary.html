<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>İki Nokta Sınır Değerli Problemler (Two-Point Boundary Value Problems -TPBVP-)</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1
id="iki-nokta-sınır-değerli-problemler-two-point-boundary-value-problems--tpbvp-">İki
Nokta Sınır Değerli Problemler (Two-Point Boundary Value Problems
-TPBVP-)</h1>
<p>BVP problemleri şu genel formda olan problemlerdir [1, sf. 287],</p>
<p><span class="math display">\[
x&#39;&#39;(t) = f(t, x(t), x&#39;(t)))
\]</span></p>
<p><span class="math display">\[x(t_0) = x_0, \quad x(t_f) =
x_f\]</span></p>
<p>İkinci satır sınır şartlarını belirtiyor, zaman için <span
class="math inline">\(t_0,t_1,...t_f\)</span> indisleri kullanılır, yani
sistemin konumu <span class="math inline">\(x(t)\)</span>’in başlangıçta
<span class="math inline">\(x_0\)</span> bitişte <span
class="math inline">\(x_f\)</span> noktasında olması isteniyor (bunlar
gerçek tek sayı değerleri olacak). Bilinmeyen bir başlangıç şartı var,
bu <span class="math inline">\(x&#39;(0)\)</span> şartı, diyelim <span
class="math inline">\(x&#39;(0) = z\)</span>. Bilinmeyen <span
class="math inline">\(z\)</span>’yi nasıl bulacağız? Genel yaklaşım
olarak bilinen az sayıda değişkeni ileri doğru entegre ederek sonda
gelinen noktaya bakılır, eldeki kısmı son nokta verisiyle
karşılaştırılarak bir hata üzerinden başlangıç düzeltilmeye uğraşılır,
bu özyineli şekilde devam eder. Çözüm yöntemi olarak ateş etme yöntemi
(the shooting method) vardır, farklı paketler farklı yaklaşımlar
kullanabilir.</p>
<p>Paket İle</p>
<p><span class="math display">\[
\frac{\mathrm{d} y}{\mathrm{d} x} = f(x, y, p) + \frac{S y}{x-a}
\]</span></p>
<p><span class="math display">\[
a \le x \le b, \quad bc(y(a), y(b), p) = 0
\]</span></p>
<p>ki <span class="math inline">\(x\)</span> tek boyutlu bağımsız
değişken, <span class="math inline">\(y(x)\)</span> n-boyutlu vektör
değerli fonksiyon, <span class="math inline">\(p\)</span> <span
class="math inline">\(k\)</span> boyutlu bilinmeyen parametrelerin
vektörü, ki onu <span class="math inline">\(y(x)\)</span>’yi bulurken
aynı anda bulmak gerekiyor. <span class="math inline">\(bc\)</span> ile
sınır şartları tanımlanıyor.</p>
<p>Bratu Problemi</p>
<p>Paket çözümleri de kullanılabilir [2, sf. 396]. Mesela
<code>scipy</code>. Bratu problemi</p>
<p><span class="math display">\[
y&#39;&#39; + k + \exp(y) = 0
\]</span></p>
<p><span class="math display">\[
y(0) = y(1) = 0
\]</span></p>
<p>Bu sistemi 1. derece bir denklemler sistemine değiştirelim,</p>
<p><span class="math display">\[
y_1&#39; = y_2
\]</span></p>
<p><span class="math display">\[
y_2&#39; = -\exp(y_1)
\]</span></p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fun(x, y):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># k=1 farz edildi</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.vstack((y[<span class="dv">1</span>], <span class="op">-</span>np.exp(y[<span class="dv">0</span>])))</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bc(ya, yb):</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array([ya[<span class="dv">0</span>], yb[<span class="dv">0</span>]])</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">5</span>)</span></code></pre></div>
<p>Çağrı <code>bc</code> içinde sınır şartlarının artığı, hatası
döndürülüyor. Daha doğrusu <code>bc</code>’ye verilen iki parametre
içinde başta ve sonda olmak üzere <span class="math inline">\(y =
[y_1,y_2]\)</span> formatında artık değerler var. Bu artıklardan
hangisinin belirlediğimiz sınır şartına ait olanı biz seçiyoruz. Mesela
<code>ya[0]</code> ve <code>yb[0]</code> ile içinde <span
class="math inline">\(y_1\)</span>’in başta ve sondaki değerini seçmiş
oluyoruz, ki zaten problemin sınır şartları onlar üzerinden
tanımlanmıştı. Eğer <span class="math inline">\(y_1&#39;\)</span>, yani
<span class="math inline">\(y_2\)</span> üzerinde bir son şart olsaydı o
zaman <code>yb</code> 1. indisteki değeri döndürürdük. Ayrıca artıkler
hep sıfıra eşitlik üzerinden tanımlanır, eğer <span
class="math inline">\(y_1(0)=k\)</span> gibi bir sınır değeri var ise,
<span class="math inline">\(ya[0]-k\)</span> döndürmemiz gerekir.</p>
<p>Bu problemin iki farklı çözümü var. Her iki çözümü de elde etmek için
<span class="math inline">\(y\)</span> için farklı başlangıç noktaları
deneyeceğiz, bu seçenekleri <span class="math inline">\(1\)</span> ve
<span class="math inline">\(2\)</span> olarak işaretleyelim,</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>y_1 <span class="op">=</span> np.zeros((<span class="dv">2</span>, x.size))</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>y_2 <span class="op">=</span> np.zeros((<span class="dv">2</span>, x.size))</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>y_2[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.integrate <span class="im">import</span> solve_bvp</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>res_1 <span class="op">=</span> solve_bvp(fun, bc, x, y_1)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>res_2 <span class="op">=</span> solve_bvp(fun, bc, x, y_2)</span></code></pre></div>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>x_plot <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">100</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>y_plot_1 <span class="op">=</span> res_1.sol(x_plot)[<span class="dv">0</span>]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>y_plot_2 <span class="op">=</span> res_2.sol(x_plot)[<span class="dv">0</span>]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>plt.plot(x_plot, y_plot_1, label<span class="op">=</span><span class="st">&#39;y_a&#39;</span>)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>plt.plot(x_plot, y_plot_2, label<span class="op">=</span><span class="st">&#39;y_b&#39;</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&quot;x&quot;</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&quot;y&quot;</span>)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app10boundary_03.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_app10boundary_03.png" /></p>
<p>Top Atışı Metotu (Shooting Method)</p>
<p>Bir diğer çözüm yöntemi top atışı (silah anlamında) problemidir,
güllenin nereden atıldığı bilinir, düşmesi istenen bir yer vardır, ama
hangi açıyla (burada <span class="math inline">\(x&#39;(0))\)</span>
yukarı doğru tutulacağı bilinmez.</p>
<p><img src="compscieng_app10boundary_02.png" /></p>
<p>Bilinmeyen başlangıç şartlarından birini bulmak için bir yöntem tüm
bilinenleri kullanıp, bilinmeyen için bir tahmin yerine koymak, ve bu
sistemi entegre ederek sonuca gelmek. Sonuca gelindiğinde <span
class="math inline">\(x_f\)</span>’e ne kadar yakın olunduğuna göre bir
hata gradyanı oluşturup bu gradyanı <span
class="math inline">\(x&#39;(0)\)</span>’te düzeltme yapmak için
kullanmak, ve süreci tekrarlamak. Bu işlem ardı ardına yapılır ve
istenen bitiş değerine gelince durulur. Bu yönteme ilham aldığı temel
örnekten hareketle atış metotu (the shooting method) adı veriliyor.</p>
<p>Gradyanı hesaplamak ve düzeltmede kullanmak için Sekant Yöntemini
kullanabiliriz [10]. Hata fonksiyonu <span
class="math inline">\(z\)</span>’nin fonksiyonudur,</p>
<p><span class="math display">\[ e(z) = x(t_f) - x_f \]</span></p>
<p>İstediğimiz <span class="math inline">\(e(z)\)</span>’nin minimal
olması, yani sıfıra eşit olması, <span class="math inline">\(e(z) =
0\)</span>. Bu durumda bir kök bulma problemi ortaya çıkıyor,</p>
<p><span class="math display">\[ z_{n+1} = z_n - \frac{ \quad e(z_n)
\quad }{\frac{\mathrm{d} e(z_n) }{\mathrm{d} z_n} }\]</span></p>
<p>Sekant yöntemi için</p>
<p><span class="math display">\[ z_{n+1} = z_n -
\frac{ e(z_n)  }{\quad \dfrac{e(z_n) - e(z_{n-1})}{z_n - z_{n-1}} \quad
}
\]</span></p>
<p>Örnek</p>
<p><span class="math display">\[ x&#39;&#39;(t) = 2x^2(t) + 4t x(t)
x&#39;(t)\]</span></p>
<p><span class="math display">\[ x(0) = \frac{1}{4}, \quad x(1) =
\frac{1}{3}\]</span></p>
<p>Bu problemin analitik çözümü aslında biliniyor,</p>
<p><span class="math display">\[x(t) = \frac{1}{4 - t^2}, \quad
x&#39;(t) = \frac{2t}{(4-t^2)^2} = 2t x^2(t)\]</span></p>
<p>Ama bilmeseydik nasıl çözerdik? Alttaki gibi. Önce <span
class="math inline">\(x_1&#39;(t)\)</span> için yeni bir değişken
tanımlayalım, <span class="math inline">\(x_1&#39;(t) = x_2(t)\)</span>
olsun, o zaman <span class="math inline">\(x_2&#39;(t)\)</span> ana ODE
denklemimiz olabilir, çok boyutlu olarak</p>
<p><span class="math display">\[
\left[\begin{array}{c}
x_1&#39;(t) \\ x_2&#39;(t)
\end{array}\right]
=
\left[\begin{array}{c}
x_2(t) \\
2x_1^2(t) + 4t \cdot x_1(t)x_2(t)
\end{array}\right]
\]</span></p>
<p>Sınır şartları</p>
<p><span class="math display">\[
\left[\begin{array}{c}
x_1(0) \\ x_2(0)
\end{array}\right]
=
\left[\begin{array}{c}
x_0 = 1/4 \\ x_f = 1/3
\end{array}\right]
\]</span></p>
<p>Kod,</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy <span class="im">as</span> sp</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy.linalg <span class="im">as</span> lin</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.integrate <span class="im">import</span> odeint</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rhs(u,t):</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    x1, x2,  <span class="op">=</span> u</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [x2, (<span class="dv">2</span><span class="op">*</span>x1 <span class="op">+</span> <span class="dv">4</span><span class="op">*</span>t<span class="op">*</span>x2)<span class="op">*</span>x1]</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bvp_shoot(t0,tf,x0,xf,N,tol,kmax):</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    dx0 <span class="op">=</span> np.zeros(kmax)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    e <span class="op">=</span> np.zeros(kmax)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    dx0[<span class="dv">0</span>]<span class="op">=</span> (xf<span class="op">-</span>x0)<span class="op">/</span>(tf<span class="op">-</span>t0)<span class="op">;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    t<span class="op">=</span>np.linspace(t0,tf,<span class="dv">100</span>)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,kmax<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        x<span class="op">=</span>odeint(rhs,[x0, dx0[k]], t)        </span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        e[k]<span class="op">=</span>x[<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>]<span class="op">-</span>xf</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        ddx<span class="op">=</span> dx0[k]<span class="op">-</span>dx0[k<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> np.<span class="bu">abs</span>(e[k])<span class="op">&lt;</span>tol <span class="kw">or</span> np.<span class="bu">abs</span>(ddx)<span class="op">&lt;</span>tol: <span class="cf">break</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        deddx<span class="op">=</span> (e[k]<span class="op">-</span>e[k<span class="op">-</span><span class="dv">1</span>])<span class="op">/</span>ddx<span class="op">;</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        dx0[k<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> dx0[k]<span class="op">-</span>e[k]<span class="op">/</span>deddx<span class="op">;</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> t, x</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>t0 <span class="op">=</span> <span class="fl">0.</span><span class="op">;</span> tf <span class="op">=</span> <span class="fl">1.</span><span class="op">;</span> x0 <span class="op">=</span> <span class="dv">1</span><span class="op">/</span><span class="fl">4.</span><span class="op">;</span> xf <span class="op">=</span> <span class="dv">1</span><span class="op">/</span><span class="fl">3.</span><span class="op">;</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="fl">100.</span><span class="op">;</span> tol <span class="op">=</span> <span class="fl">1e-8</span><span class="op">;</span> kmax <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>t,x <span class="op">=</span> bvp_shoot(t0,tf,x0,xf,N,tol,kmax)</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>xo <span class="op">=</span> <span class="fl">1.0</span> <span class="op">/</span>(<span class="fl">4.0</span> <span class="op">-</span> t<span class="op">**</span><span class="dv">2</span>)<span class="op">;</span> err <span class="op">=</span> lin.norm(x[:,<span class="dv">0</span>] <span class="op">-</span> xo)<span class="op">/</span>(N <span class="op">+</span> <span class="fl">1.0</span>)</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>plt.plot(t,x[:,<span class="dv">0</span>],<span class="st">&#39;g&#39;</span>) <span class="co"># bizim hesap</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>plt.plot(t,xo,<span class="st">&#39;--r&#39;</span>) <span class="co"># analitik bilinen</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app10boundary_01.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_app10boundary_01.png" /></p>
<p>Grafikte görüldüğü gibi iki çözüm birbirinin tıpkı aynısı.</p>
<p>Sturm-Liouville</p>
<p>Yine paket ile devam edelim. Sturm-Liouville adlı bir problemi
çözelim,</p>
<p><span class="math display">\[
y&#39;&#39; + k^y = 0
\]</span></p>
<p><span class="math display">\[
y(0) = y(1) = 0
\]</span></p>
<p>Bu problemin <span class="math inline">\(n\)</span> bir tam sayı
olmak üzere <span class="math inline">\(k = n \pi\)</span> için bariz /
önemsiz olmayan bir çözümünün <span
class="math inline">\(y=A\sin(kx)\)</span> olduğu biliniyor. <span
class="math inline">\(A=1\)</span> ile normalizasyon sağlamak için bir
sınır şart daha ekliyoruz,</p>
<p><span class="math display">\[
y&#39;(0) = k
\]</span></p>
<p>Çünkü <span class="math inline">\(y=A\sin(kx) \to y&#39; = A k
\cos(kx)\)</span>, ve <span class="math inline">\(y&#39;(0)\)</span>
dersek <span class="math inline">\(y&#39;(0) = A k \cos(0)) = A
k\)</span> olacaktır, o zaman <span class="math inline">\(y&#39;(0) =
k\)</span> şartını koyarsak <span class="math inline">\(A=1\)</span>’i
zorlamış oluruz.</p>
<ol type="1">
<li>derece sisteme çevirirsek,</li>
</ol>
<p><span class="math display">\[
y_1&#39; = y_2
\]</span></p>
<p><span class="math display">\[
y_2&#39; = -k^2 y_1
\]</span></p>
<p>Ayrıca <span class="math inline">\(k\pi\)</span> için bir çözüm
aradığımız için <span class="math inline">\(y\)</span> değerlerinin
aşağı yukarı <span class="math inline">\(\sin(2\pi x)\)</span>’yi takip
etmesini sağlıyoruz,</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.integrate <span class="im">import</span> solve_bvp</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fun(x, y, p):</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> p[<span class="dv">0</span>]</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.vstack((y[<span class="dv">1</span>], <span class="op">-</span>k<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> y[<span class="dv">0</span>]))</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bc(ya, yb, p):</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> p[<span class="dv">0</span>]</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array([ya[<span class="dv">0</span>], yb[<span class="dv">0</span>], ya[<span class="dv">1</span>] <span class="op">-</span> k])</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">5</span>)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.zeros((<span class="dv">2</span>, x.size))</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>y[<span class="dv">0</span>, <span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>y[<span class="dv">0</span>, <span class="dv">3</span>] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>sol <span class="op">=</span> solve_bvp(fun, bc, x, y, p<span class="op">=</span>[<span class="dv">6</span>])</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (sol.p)</span></code></pre></div>
<pre class="text"><code>[6.2832946]</code></pre>
<p><span class="math inline">\(k\)</span>’nin aşağı yukarı doğru değerde
olduğunu görüyoruz. Tüm çözümü grafikleyince beklenen sinüs eğrisini de
göreceğiz,</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>x_plot <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">100</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>y_plot <span class="op">=</span> sol.sol(x_plot)[<span class="dv">0</span>]</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>plt.plot(x_plot, y_plot)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&quot;x&quot;</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&quot;y&quot;</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app10boundary_04.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_app10boundary_04.png" /></p>
<p>Bilinmeyen Sabit Durumları</p>
<p>Her TPBVP problemi üstte görülen yazılımlara direk, olduğu gibi
aktarılacak durumda olmayabilir. Ama bu problemleri de bazı numaralar
kullanarak çözüm yazılımının beklediği hale çevirebiliriz.</p>
<p>Mesela çoğu sınır değeri problemi bilinmeyen sabitler içerirler, ki
çözüm içi bu sabitlerin bilinmesi gereklidir. Bu tür problemler üstteki
yöntemlerle direk çözülemez. Ama bilinmeyen sabitleri de birer değişken
olarak kabul edersek, bu engelin etrafından dolaşabiliriz. Bu
“değişkenin’’ ilk türevi tabii ki sıfır olacaktır, ve bu türevin sıfıra
eşit olma hali üzerinden sabiti diferansiyel denklem sistemimize dahil
edebiliriz.</p>
<p><em>Elastiklik</em> (elastica) problemi mekanik alanında standart bir
problem [3, sf. 221, 4, pg. 87]. İki ucundan kuvvet uygulanan bir esnek
çubuğun nasıl büküldüğünü modelliyor. Sabiti dahil etmeden ana sistem
şöyle,</p>
<p><span class="math display">\[
x&#39; = \cos (\phi)
\]</span></p>
<p><span class="math display">\[
y&#39; = \sin (\phi)
\]</span></p>
<p><span class="math display">\[
\phi&#39; = \kappa
\]</span></p>
<p><span class="math display">\[
\kappa&#39; = F \cos (\phi)
\]</span></p>
<p>Bilinmeyen sabit <span class="math inline">\(F\)</span>. Sınır
değerleri,</p>
<p><span class="math display">\[
x(0) = 0
\]</span></p>
<p><span class="math display">\[
y(0) = 0
\]</span></p>
<p><span class="math display">\[
\kappa(0) = 0
\]</span></p>
<p><span class="math display">\[
y(0.5) = 0
\]</span></p>
<p><span class="math display">\[
\phi(0.5) = -\pi/2
\]</span></p>
<p>Görülen beş tane sınır değişkeniyle aslında problemi tamamen
tanımlanmış oluyor. Entegrasyondan ortaya çıkan dört tane sabit olacak,
üstte beş tane değer var. Hatta <span
class="math inline">\(F\)</span>’yi de bir sınır değeri olarak dahil
edince hala çözüm için yeterli öğe elimizde oluyor. Yeni sınır
değeri</p>
<p><span class="math display">\[
F&#39; = 0
\]</span></p>
<p>Dikkat, yani <span class="math inline">\(F\)</span>’nin türevi her
yerde sıfır olmalı (çünkü sabit).</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># x,y,\phi,\kappa, F</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.integrate <span class="im">import</span> solve_bvp</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fun(x, y):</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.vstack(( np.cos(y[<span class="dv">2</span>]),</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>                       np.sin(y[<span class="dv">2</span>]),</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>                       y[<span class="dv">3</span>],</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>                       y[<span class="dv">4</span>]<span class="op">*</span>np.cos(y[<span class="dv">2</span>]),</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>                       np.zeros(x.shape[<span class="dv">0</span>]) ))</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bc(ya, yb):</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array([ ya[<span class="dv">0</span>],</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>                      ya[<span class="dv">1</span>],</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>                      ya[<span class="dv">3</span>],</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>                      yb[<span class="dv">1</span>],</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>                      yb[<span class="dv">2</span>]<span class="op">+</span>(np.pi<span class="op">/</span><span class="dv">2</span>) ])</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="fl">0.5</span>, <span class="dv">400</span>)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.zeros((<span class="dv">5</span>, x.size))</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>sol <span class="op">=</span> solve_bvp(fun, bc, x, y)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (sol.y[<span class="dv">4</span>,<span class="dv">0</span>])</span></code></pre></div>
<pre class="text"><code>-21.54910449259776</code></pre>
<p><span class="math inline">\(F\)</span> sabitinin degeri ustte
goruluyor.</p>
<p>Dikkat edilirse <code>fun</code> içinde <span
class="math inline">\(F\)</span>’ye sıfır değeri vermek için
<code>np.zeros(x.shape[0])</code> değeri tanımlandı, yani bir sıfır
vektörü tanımlandı.</p>
<p>Çözüm sonucu elde edilen <span class="math inline">\(y\)</span>
değerlerini grafikleyelim,</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>plt.plot(x,sol.y[<span class="dv">1</span>])</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&#39;y&#39;</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app10boundary_05.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_app10boundary_05.png" /></p>
<p>Kızamık (Measles) Problemi</p>
<p>Problem [3, sf. 223, 5, 6, 7, sf. 13]’de görülebilir, nüfusta bir
salgının yayılması modellenmiştir. Nüfus dört farklı grup altında
incelenir, bu gruplar bağışıklı olanlar (immunes), <span
class="math inline">\(I\)</span>, bağışıksızlar (susceptible) <span
class="math inline">\(S\)</span>, bulaştırmayan hasta (latents) <span
class="math inline">\(L\)</span>, ve bulaştıran hasta (infectives),
<span class="math inline">\(I\)</span>. Toplam nufus sabit <span
class="math inline">\(N\)</span> olsun, o zaman</p>
<p><span class="math display">\[
S(t) + I(t) + L(t) + M(t) = N, \quad t \in [0,1]
\]</span></p>
<p>Model her grubun izafi oranını bağışıksızlar <span
class="math inline">\(y_1 = S/N\)</span>, bulaştırmayan hasta <span
class="math inline">\(y_2 = L/N\)</span>, ve hasta olanlar <span
class="math inline">\(y_3 = I / N\)</span> olarak tanımlar. Hastalığın
yayılma dinamiği şöyle tanımlanabilir,</p>
<p><span class="math display">\[
y_1&#39; = \mu - \beta y_1y_3
\]</span></p>
<p><span class="math display">\[
y_2&#39; = \beta y_1y_3 -y_2 / \lambda
\]</span></p>
<p><span class="math display">\[
y_3&#39; = y_2\lambda - y_3 / \eta
\]</span></p>
<p><span class="math inline">\(\beta\)</span> bulaştırma oranı (sabiti).
Bulaştırma oranını sezona bağlı olabileceği için onu bir kosinüs
fonksiyonu ile tanımlarız,</p>
<p><span class="math display">\[
\beta = \beta_0 (1 + \cos(2 \pi t))
\]</span></p>
<p>ki <span class="math inline">\(\beta_0 = 1575\)</span>, diğer
sabitler ise <span class="math inline">\(\mu = 0.02\)</span>, <span
class="math inline">\(\lambda = 0.0279\)</span>, <span
class="math inline">\(\eta = 0.01\)</span>. Sinir sartlari</p>
<p><span class="math display">\[
y(1) = y(0)
\]</span></p>
<p>Tabii <span class="math inline">\(y\)</span> bir vektör, <span
class="math inline">\(y = [y_1,y_2,y_3]\)</span>. Bu sınır şartının
tanımlanmasının sebebi periyodik bir çözüm arıyor olmamız. Bu tür sınır
şartı biraz garip olabilir, ve her sayısal paket bu tür şartın
tanımlanmasına izin vermeyebilir, fakat <code>scipy</code> izin veriyor.
Verilmiyorsa [3] kaynağında anlatılan ekstra değişkenler ve sabit
tanımlama numarasını kullanmak gerekiyor.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.integrate <span class="im">import</span> solve_bvp</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> <span class="fl">0.02</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>l <span class="op">=</span> <span class="fl">0.0279</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>eta <span class="op">=</span> <span class="fl">0.01</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fun_measles(x, y):</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    beta <span class="op">=</span> <span class="dv">1575</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">+</span> np.cos(<span class="dv">2</span> <span class="op">*</span> np.pi <span class="op">*</span> x))</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.vstack((</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        mu <span class="op">-</span> beta <span class="op">*</span> y[<span class="dv">0</span>] <span class="op">*</span> y[<span class="dv">2</span>],</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        beta <span class="op">*</span> y[<span class="dv">0</span>] <span class="op">*</span> y[<span class="dv">2</span>] <span class="op">-</span> y[<span class="dv">1</span>] <span class="op">/</span> l,</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        y[<span class="dv">1</span>] <span class="op">/</span> l <span class="op">-</span> y[<span class="dv">2</span>] <span class="op">/</span> eta</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    ))</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bc_measles(ya, yb):</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ya <span class="op">-</span> yb</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>x_measles <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">5</span>)</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>y_measles <span class="op">=</span> np.full((<span class="dv">3</span>, x_measles.shape[<span class="dv">0</span>]), <span class="fl">0.01</span>)</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>res_measles <span class="op">=</span> solve_bvp(fun_measles, bc_measles, x_measles, y_measles)</span></code></pre></div>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">14</span>, <span class="dv">5</span>))</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>x_measles_plot <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">100</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>y_measles_plot <span class="op">=</span> res_measles.sol(x_measles_plot)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">131</span>)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>plt.plot(x_measles_plot, y_measles_plot[<span class="dv">0</span>], label<span class="op">=</span><span class="st">&#39;$y_1$&#39;</span>)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">132</span>)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>plt.plot(x_measles_plot, y_measles_plot[<span class="dv">1</span>], label<span class="op">=</span><span class="st">&#39;$y_2$&#39;</span>)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">133</span>)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>plt.plot(x_measles_plot, y_measles_plot[<span class="dv">2</span>], label<span class="op">=</span><span class="st">&#39;$y_3$&#39;</span>)</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app10boundary_06.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_app10boundary_06.png" /></p>
<p>Sinir Sistemi Tepkisi (Nerve Impulse)</p>
<p>Tekrar eden sınır şart durumunu bilinmeyen entegral limiti durumu ile
birleştiren bir problemi göreceğiz şimdi [8, sf. 27, 3, sf. 225, 6, 5,
sf. 173]. Bilinmeyen sınır şartı için bir numara yapabiliriz; Yeni bir
değişken <span class="math inline">\(\tau\)</span> tanımlıyoruz, ve bu
değişken sadece <span class="math inline">\([0,1]\)</span> aralığına
kısıtlanıyor. Bağımsız değişken <span class="math inline">\(x\)</span>.
Şimdi <span class="math inline">\(\tau = t/b\)</span>, ki <span
class="math inline">\(b\)</span> bilinmeyen entegral sınırı,</p>
<p><span class="math display">\[
\frac{\mathrm{d} y}{\mathrm{d} x} = f(t,y)
\]</span></p>
<p>yerine</p>
<p><span class="math display">\[
\frac{\mathrm{d} y}{\mathrm{d} \tau} = b f(t,y)
\]</span></p>
<p><span class="math display">\[
\frac{\mathrm{d} b}{\mathrm{d} \tau} = 0
\]</span></p>
<p>Bu nasıl oldu?</p>
<p><span class="math inline">\(t = \tau b\)</span> ise <span
class="math inline">\(\mathrm{d} x / \mathrm{d} \tau = b\)</span>.</p>
<p><span class="math display">\[
\frac{\mathrm{d} y}{\mathrm{d} \tau} = \frac{\mathrm{d} y}{\mathrm{d} t}
\frac{\mathrm{d} t}{\mathrm{d} \tau} =
b f(x,y)
\]</span></p>
<p>Problem sorusuna gelelim. Diyelim ki hücre zar potansiyeli <span
class="math inline">\(y_1\)</span>, geçirgenlik <span
class="math inline">\(y_2\)</span>, ve</p>
<p><span class="math display">\[
y_1&#39; = 3 (y_1 + y_2 - 1/3 y_1^3 - 1.3)
\]</span></p>
<p><span class="math display">\[
y_2&#39; = -(y_1 - 0.7 + 0.8 y_2) / 3
\]</span></p>
<p>Bu problem <span class="math inline">\([0,T]\)</span> zaman diliminde
tanımlanmıştır. Fakat bir problem şu, <span
class="math inline">\(T\)</span>’nin ne olduğunu bilmiiyoruz, ve aynı
<span class="math inline">\(T\)</span> bilinmeyeni sınır şartlarının
tanımlanmasında kullanılmış.</p>
<p><span class="math display">\[
y_1(0) = y_1(T), \quad y_2(0) = y_2(T)
\]</span></p>
<p>Ana denklem,</p>
<p><span class="math display">\[
y_1&#39; = 3 T (y_1 + y_2 - 1/3 y_1^3 - 1.3)
\]</span></p>
<p><span class="math display">\[
y_2&#39; = -T (y_1 - 0.7 + 0.8 y_2) / 3
\]</span></p>
<p>Böylece problem <span class="math inline">\([0,1]\)</span> arasında
tanımlanmış oldu. Sınır şartları böylece <span
class="math inline">\(t=0,1\)</span> üzerinden tanımlanabilir. Fakat
üçüncü bir sınır şartı daha lazım. Farklı bir açıdan eğer çözüm
parçalarından birine bir değer atamak, mesela <span
class="math inline">\(y_1(0) = 0\)</span>. O zaman <span
class="math inline">\(y_1(0) = y_1(T)\)</span> yerine <span
class="math inline">\(y_1(T)=0\)</span> da kullanabiliriz. Böylece sınır
şartları,</p>
<p><span class="math display">\[
y_1(0) = 0, \quad y_1(1) = 0, \quad y_2(0) = y_2(1)
\]</span></p>
<p>haline geldi. Bu problemi ekstra parametre seçeneğini kullanarak,
bölmeden (non-seperated) halde çözebiliriz [9, sf. 173].</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.integrate <span class="im">import</span> solve_bvp</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fun(x, y, p):</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> p[<span class="dv">0</span>]</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.vstack((</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        <span class="fl">3.0</span> <span class="op">*</span> T <span class="op">*</span>  (y[<span class="dv">0</span>] <span class="op">+</span> y[<span class="dv">1</span>] <span class="op">-</span> (y[<span class="dv">0</span>]<span class="op">**</span><span class="dv">3</span>)<span class="op">/</span><span class="fl">3.0</span> <span class="op">-</span> <span class="fl">1.3</span>),</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">-</span>T <span class="op">/</span> <span class="fl">3.0</span> <span class="op">*</span> (y[<span class="dv">0</span>] <span class="op">-</span> <span class="fl">0.7</span> <span class="op">+</span> <span class="fl">0.8</span><span class="op">*</span>y[<span class="dv">1</span>]) </span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    ))</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bc(ya, yb, p):</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array( [ ya[<span class="dv">0</span>], yb[<span class="dv">0</span>], ya[<span class="dv">1</span>]<span class="op">-</span>yb[<span class="dv">1</span>] ]   )</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>                     </span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">5</span>)</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.zeros((<span class="dv">2</span>, x.size))</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>y[<span class="dv">0</span>] <span class="op">=</span> np.sin(<span class="dv">2</span> <span class="op">*</span> np.pi <span class="op">*</span> x)</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>y[<span class="dv">1</span>] <span class="op">=</span> np.cos(<span class="dv">2</span> <span class="op">*</span> np.pi <span class="op">*</span> x)</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>sol <span class="op">=</span> solve_bvp(fun, bc, x, y, p<span class="op">=</span>[<span class="dv">2</span><span class="op">*</span>np.pi])</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (sol.p)</span></code></pre></div>
<pre class="text"><code>[10.71071556]</code></pre>
<p>Üstteki <span class="math inline">\(T\)</span> değeri [9]’da bulunan
ile aynı.</p>
<p>Kaynaklar</p>
<p>[1] Yang, <em>Applied Numerical Methods using Matlab</em></p>
<p>[2] Scipy, <em>Scipy Reference, 0.18.1</em></p>
<p>[3] Cash, <em>Solving Differential Equations in R</em></p>
<p>[4] Greenhill, <em>The applications of elliptic functions</em></p>
<p>[5] Shampine, <em>A BVP Solver Based on Residual Control and the
Matlab PSE</em>, <a
href="http://www.orcca.on.ca/TechReports/TechReports/2001/TR-01-02.pdf">http://www.orcca.on.ca/TechReports/TechReports/2001/TR-01-02.pdf</a></p>
<p>[6] Mayorov, <em>Github</em>, <a
href="https://gist.github.com/nmayorov/f8af5ca956c6a7f75ecdb578a2655894">https://gist.github.com/nmayorov/f8af5ca956c6a7f75ecdb578a2655894</a></p>
<p>[7] Ascher, <em>Numerical Solution of BVPs for ODEs</em></p>
<p>[8] Seydel, <em>From equilibrium to chaos</em></p>
<p>[9] Shampine, <em>Solving ODEs in Matlab</em></p>
<p>[10] Bayramlı, Diferansiyel Denklemler, <em>Kök Bulmak</em></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
