\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Ýki Nokta Sýnýr Deðerli Problemler (Two-Point Boundary Value Problems -TPBVP-)

BVP problemleri þu genel formda olan problemlerdir [1, sf. 287],

$$ 
x''(t) = f(t, x(t), x'(t)))
$$

$$x(t_0) = x_0, \quad x(t_f) = x_f$$ 

Ýkinci satýr sýnýr þartlarýný belirtiyor, zaman için $t_0,t_1,...t_f$
indisleri kullanýlýr, yani sistemin konumu $x(t)$'in baþlangýçta $x_0$
bitiþte $x_f$ noktasýnda olmasý isteniyor (bunlar gerçek tek sayý deðerleri
olacak). Bilinmeyen bir baþlangýç þartý var, bu $x'(0)$ þartý, diyelim
$x'(0) = z$. Bilinmeyen $z$'yi nasýl bulacaðýz? Genel yaklaþým olarak
bilinen az sayýda deðiþkeni ileri doðru entegre ederek sonda gelinen
noktaya bakýlýr, eldeki kýsmý son nokta verisiyle karþýlaþtýrýlarak bir
hata üzerinden baþlangýç düzeltilmeye uðraþýlýr, bu özyineli þekilde devam
eder. Çözüm yöntemi olarak ateþ etme yöntemi (the shooting method) vardýr,
farklý paketler farklý yaklaþýmlar kullanabilir. 

Paket Ýle

$$
\frac{\ud y}{\ud x} = f(x, y, p) + \frac{S y}{x-a}
$$

$$
a \le x \le b, \quad bc(y(a), y(b), p) = 0
$$

ki $x$ tek boyutlu baðýmsýz deðiþken, $y(x)$ n-boyutlu vektör deðerli
fonksiyon, $p$ $k$ boyutlu bilinmeyen parametrelerin vektörü, ki onu
$y(x)$'yi bulurken ayný anda bulmak gerekiyor. $bc$ ile sýnýr þartlarý
tanýmlanýyor.


Bratu Problemi

Paket çözümleri de kullanýlabilir [2, sf. 396]. Mesela \verb!scipy!. Bratu
problemi

$$
y'' + k + \exp(y) = 0
$$

$$
y(0) = y(1) = 0
$$

Bu sistemi 1. derece bir denklemler sistemine deðiþtirelim,

$$
y_1' = y_2
$$

$$
y_2' = -\exp(y_1)
$$

\begin{minted}[fontsize=\footnotesize]{python}
def fun(x, y):
    # k=1 farz edildi
    return np.vstack((y[1], -np.exp(y[0])))

def bc(ya, yb):
    return np.array([ya[0], yb[0]])

x = np.linspace(0, 1, 5)
\end{minted}

Çaðrý \verb!bc! içinde sýnýr þartlarýnýn artýðý, hatasý döndürülüyor. Daha
doðrusu \verb!bc!'ye verilen iki parametre içinde baþta ve sonda olmak
üzere $y = [y_1,y_2]$ formatýnda artýk deðerler var. Bu artýklardan
hangisinin belirlediðimiz sýnýr þartýna ait olaný biz seçiyoruz. Mesela
\verb!ya[0]! ve \verb!yb[0]! ile içinde $y_1$'in baþta ve sondaki deðerini
seçmiþ oluyoruz, ki zaten problemin sýnýr þartlarý onlar üzerinden
tanýmlanmýþtý. Eðer $y_1'$, yani $y_2$ üzerinde bir son þart olsaydý o
zaman \verb!yb! 1. indisteki deðeri döndürürdük. Ayrýca artýkler hep sýfýra
eþitlik üzerinden tanýmlanýr, eðer $y_1(0)=k$ gibi bir sýnýr deðeri var
ise, $ya[0]-k$ döndürmemiz gerekir.

Bu problemin iki farklý çözümü var. Her iki çözümü de elde etmek için
$y$ için farklý baþlangýç noktalarý deneyeceðiz, bu seçenekleri $1$ ve
$2$ olarak iþaretleyelim,

\begin{minted}[fontsize=\footnotesize]{python}
y_1 = np.zeros((2, x.size))
y_2 = np.zeros((2, x.size))
y_2[0] = 3

from scipy.integrate import solve_bvp
res_1 = solve_bvp(fun, bc, x, y_1)
res_2 = solve_bvp(fun, bc, x, y_2)
\end{minted}

\begin{minted}[fontsize=\footnotesize]{python}
x_plot = np.linspace(0, 1, 100)
y_plot_1 = res_1.sol(x_plot)[0]
y_plot_2 = res_2.sol(x_plot)[0]

plt.plot(x_plot, y_plot_1, label='y_a')
plt.plot(x_plot, y_plot_2, label='y_b')
plt.legend()
plt.xlabel("x")
plt.ylabel("y")
plt.savefig('compscieng_app10boundary_03.png')
\end{minted}


\includegraphics[width=20em]{compscieng_app10boundary_03.png}


Top Atýþý Metotu (Shooting Method)

Bir diðer çözüm yöntemi top atýþý (silah anlamýnda) problemidir, güllenin
nereden atýldýðý bilinir, düþmesi istenen bir yer vardýr, ama hangi açýyla
(burada $x'(0))$ yukarý doðru tutulacaðý bilinmez.

\includegraphics[width=20em]{compscieng_app10boundary_02.png}

Bilinmeyen baþlangýç þartlarýndan birini bulmak için bir yöntem tüm
bilinenleri kullanýp, bilinmeyen için bir tahmin yerine koymak, ve bu
sistemi entegre ederek sonuca gelmek. Sonuca gelindiðinde $x_f$'e ne kadar
yakýn olunduðuna göre bir hata gradyaný oluþturup bu gradyaný $x'(0)$'te
düzeltme yapmak için kullanmak, ve süreci tekrarlamak. Bu iþlem ardý ardýna
yapýlýr ve istenen bitiþ deðerine gelince durulur. Bu yönteme ilham aldýðý
temel örnekten hareketle atýþ metotu (the shooting method) adý veriliyor.

Gradyaný hesaplamak ve düzeltmede kullanmak için Sekant Yöntemini
kullanabiliriz [10]. Hata fonksiyonu $z$'nin fonksiyonudur,

$$ e(z) = x(t_f) - x_f $$

Ýstediðimiz $e(z)$'nin minimal olmasý, yani sýfýra eþit olmasý, $e(z) =
0$. Bu durumda bir kök bulma problemi ortaya çýkýyor,

$$ z_{n+1} = z_n - \frac{ \quad e(z_n) \quad }{\frac{\ud e(z_n) }{\ud z_n} }$$

Sekant yöntemi için

$$ z_{n+1} = z_n - 
\frac{ e(z_n)  }{\quad \dfrac{e(z_n) - e(z_{n-1})}{z_n - z_{n-1}} \quad }
$$

Örnek 

$$ x''(t) = 2x^2(t) + 4t x(t) x'(t)$$

$$ x(0) = \frac{1}{4}, \quad x(1) = \frac{1}{3}$$

Bu problemin analitik çözümü aslýnda biliniyor, 

$$x(t) = \frac{1}{4 - t^2}, \quad x'(t) = \frac{2t}{(4-t^2)^2} = 2t x^2(t)$$

Ama bilmeseydik nasýl çözerdik? Alttaki gibi. Önce $x_1'(t)$ için yeni bir
deðiþken tanýmlayalým, $x_1'(t) = x_2(t)$ olsun, o zaman $x_2'(t)$ ana ODE
denklemimiz olabilir, çok boyutlu olarak

$$ 
\left[\begin{array}{c}
x_1'(t) \\ x_2'(t) 
\end{array}\right] 
=
\left[\begin{array}{c}
x_2(t) \\
2x_1^2(t) + 4t \cdot x_1(t)x_2(t)
\end{array}\right] 
$$

Sýnýr þartlarý

$$ 
\left[\begin{array}{c}
x_1(0) \\ x_2(0)
\end{array}\right]
=
\left[\begin{array}{c}
x_0 = 1/4 \\ x_f = 1/3
\end{array}\right]
$$

Kod, 

\begin{minted}[fontsize=\footnotesize]{python}
import scipy as sp import numpy.linalg as lin from
scipy.integrate.odepack import odeint

def rhs(u,t):
    x1, x2,  = u
    return [x2, (2*x1 + 4*t*x2)*x1]

def bvp_shoot(t0,tf,x0,xf,N,tol,kmax):
    dx0 = np.zeros(kmax)
    e = np.zeros(kmax)
    dx0[0]= (xf-x0)/(tf-t0);
    t=np.linspace(t0,tf,100.0)
    for k in range(1,kmax-1):
        x=odeint(rhs,[x0, dx0[k]], t)        
        e[k]=x[-1,0]-xf
        ddx= dx0[k]-dx0[k-1]
        if np.abs(e[k])<tol or np.abs(ddx)<tol: break
        deddx= (e[k]-e[k-1])/ddx;
        dx0[k+1] = dx0[k]-e[k]/deddx;
    return t, x

t0 = 0.; tf = 1.; x0 = 1/4.; xf = 1/3.;
N = 100.; tol = 1e-8; kmax = 10;

t,x = bvp_shoot(t0,tf,x0,xf,N,tol,kmax)
xo = 1.0 /(4.0 - t**2); err = lin.norm(x[:,0] - xo)/(N + 1.0)

plt.plot(t,x[:,0],'g') # bizim hesap
plt.plot(t,xo,'--r') # analitik bilinen
plt.savefig('compscieng_app10boundary_01.png')
\end{minted}

\includegraphics[width=20em]{compscieng_app10boundary_01.png}

Grafikte görüldüðü gibi iki çözüm birbirinin týpký aynýsý. 

Sturm-Liouville

Yine paket ile devam edelim. Sturm-Liouville adlý bir problemi çözelim, 

$$
y'' + k^y = 0
$$

$$
y(0) = y(1) = 0
$$

Bu problemin $n$ bir tam sayý olmak üzere $k = n \pi$ için bariz / önemsiz
olmayan bir çözümünün $y=A\sin(kx)$ olduðu biliniyor. $A=1$ ile normalizasyon
saðlamak için bir sýnýr þart daha ekliyoruz,

$$
y'(0) = k
$$

Çünkü $y=A\sin(kx) \to y' = A k \cos(kx)$, ve $y'(0)$ dersek
$y'(0) = A k \cos(0)) = A k$ olacaktýr, o zaman $y'(0) = k$ þartýný
koyarsak $A=1$'i zorlamýþ oluruz. 

1. derece sisteme çevirirsek,

$$
y_1' = y_2
$$

$$
y_2' = -k^2 y_1
$$

Ayrýca $k\pi$ için bir çözüm aradýðýmýz için $y$ deðerlerinin aþaðý yukarý
$\sin(2\pi x)$'yi takip etmesini saðlýyoruz,

\begin{minted}[fontsize=\footnotesize]{python}
from scipy.integrate import solve_bvp

def fun(x, y, p):
    k = p[0]
    return np.vstack((y[1], -k**2 * y[0]))

def bc(ya, yb, p):
    k = p[0]
    return np.array([ya[0], yb[0], ya[1] - k])

x = np.linspace(0, 1, 5)
y = np.zeros((2, x.size))
y[0, 1] = 1
y[0, 3] = -1

sol = solve_bvp(fun, bc, x, y, p=[6])
print (sol.p)
\end{minted}

\begin{verbatim}
[6.2832946]
\end{verbatim}

$k$'nin aþaðý yukarý doðru deðerde olduðunu görüyoruz. Tüm çözümü
grafikleyince beklenen sinüs eðrisini de göreceðiz, 

\begin{minted}[fontsize=\footnotesize]{python}
x_plot = np.linspace(0, 1, 100)
y_plot = sol.sol(x_plot)[0]
plt.plot(x_plot, y_plot)
plt.xlabel("x")
plt.ylabel("y")
plt.savefig('compscieng_app10boundary_04.png')
\end{minted}

\includegraphics[width=20em]{compscieng_app10boundary_04.png}

Bilinmeyen Sabit Durumlarý

Her TPBVP problemi üstte görülen yazýlýmlara direk, olduðu gibi aktarýlacak
durumda olmayabilir. Ama bu problemleri de bazý numaralar kullanarak
çözüm yazýlýmýnýn beklediði hale çevirebiliriz. 

Mesela çoðu sýnýr deðeri problemi bilinmeyen sabitler içerirler, ki çözüm
içi bu sabitlerin bilinmesi gereklidir. Bu tür problemler üstteki
yöntemlerle direk çözülemez. Ama bilinmeyen sabitleri de birer deðiþken
olarak kabul edersek, bu engelin etrafýndan dolaþabiliriz. Bu
``deðiþkenin'' ilk türevi tabii ki sýfýr olacaktýr, ve bu türevin sýfýra
eþit olma hali üzerinden sabiti diferansiyel denklem sistemimize dahil
edebiliriz. 

{\em Elastiklik} (elastica) problemi mekanik alanýnda standart bir problem
[3, sf. 221, 4, pg. 87]. Ýki ucundan kuvvet uygulanan bir esnek çubuðun
nasýl büküldüðünü modelliyor. Sabiti dahil etmeden ana sistem þöyle,

$$
x' = \cos (\phi) 
$$

$$
y' = \sin (\phi) 
$$

$$
\phi' = \kappa
$$

$$
\kappa' = F \cos (\phi)
$$

Bilinmeyen sabit $F$. Sýnýr deðerleri,

$$
x(0) = 0
$$

$$
y(0) = 0
$$

$$
\kappa(0) = 0
$$

$$
y(0.5) = 0
$$

$$
\phi(0.5) = -\pi/2
$$

Görülen beþ tane sýnýr deðiþkeniyle aslýnda problemi tamamen tanýmlanmýþ
oluyor. Entegrasyondan ortaya çýkan dört tane sabit olacak, üstte beþ tane
deðer var. Hatta $F$'yi de bir sýnýr deðeri olarak dahil edince hala çözüm
için yeterli öðe elimizde oluyor. Yeni sýnýr deðeri

$$
F' = 0
$$

Dikkat, yani $F$'nin türevi her yerde sýfýr olmalý (çünkü sabit).

\begin{minted}[fontsize=\footnotesize]{python}
# x,y,\phi,\kappa, F
from scipy.integrate import solve_bvp

def fun(x, y):
    return np.vstack(( np.cos(y[2]),
                       np.sin(y[2]),
                       y[3],
                       y[4]*np.cos(y[2]),
                       np.zeros(x.shape[0]) ))

def bc(ya, yb):
    return np.array([ ya[0],
                      ya[1],
                      ya[3],
                      yb[1],
                      yb[2]+(np.pi/2) ])

x = np.linspace(0, 0.5, 400)
y = np.zeros((5, x.size))
sol = solve_bvp(fun, bc, x, y)
print (sol.y[4,0])
\end{minted}

\begin{verbatim}
-21.54910449259776
\end{verbatim}

$F$ sabitinin degeri ustte goruluyor. 

Dikkat edilirse \verb!fun! içinde $F$'ye sýfýr deðeri vermek için
\verb!np.zeros(x.shape[0])! deðeri tanýmlandý, yani bir sýfýr vektörü
tanýmlandý.

Çözüm sonucu elde edilen $y$ deðerlerini grafikleyelim,

\begin{minted}[fontsize=\footnotesize]{python}
plt.plot(x,sol.y[1])
plt.title('y')
plt.savefig('compscieng_app10boundary_05.png')
\end{minted}

\includegraphics[width=20em]{compscieng_app10boundary_05.png}

Kýzamýk (Measles) Problemi

Problem [3, sf. 223, 5, 6, 7, sf. 13]'de görülebilir, nüfusta bir salgýnýn
yayýlmasý modellenmiþtir. Nüfus dört farklý grup altýnda incelenir, bu
gruplar baðýþýklý olanlar (immunes), $I$, baðýþýksýzlar (susceptible) $S$,
bulaþtýrmayan hasta (latents) $L$, ve bulaþtýran hasta (infectives),
$I$. Toplam nufus sabit $N$ olsun, o zaman 

$$
S(t) + I(t) + L(t) + M(t) = N, \quad t \in [0,1]
$$

Model her grubun izafi oranýný baðýþýksýzlar $y_1 = S/N$, bulaþtýrmayan
hasta $y_2 = L/N$, ve hasta olanlar $y_3 = I / N$ olarak
tanýmlar. Hastalýðýn yayýlma dinamiði þöyle tanýmlanabilir, 

$$
y_1' = \mu - \beta y_1y_3
$$

$$
y_2' = \beta y_1y_3 -y_2 / \lambda
$$

$$
y_3' = y_2\lambda - y_3 / \eta
$$

$\beta$ bulaþtýrma oraný (sabiti). Bulaþtýrma oranýný sezona baðlý
olabileceði için onu bir kosinüs fonksiyonu ile tanýmlarýz, 

$$
\beta = \beta_0 (1 + \cos(2 \pi t))
$$

ki $\beta_0 = 1575$, diðer sabitler ise $\mu = 0.02$, $\lambda = 0.0279$,
$\eta = 0.01$. Sinir sartlari 

$$
y(1) = y(0)
$$

Tabii $y$ bir vektör, $y = [y_1,y_2,y_3]$. Bu sýnýr þartýnýn
tanýmlanmasýnýn sebebi periyodik bir çözüm arýyor olmamýz. Bu tür sýnýr
þartý biraz garip olabilir, ve her sayýsal paket bu tür þartýn
tanýmlanmasýna izin vermeyebilir, fakat \verb!scipy! izin
veriyor. Verilmiyorsa [3] kaynaðýnda anlatýlan ekstra deðiþkenler ve sabit
tanýmlama numarasýný kullanmak gerekiyor.

\begin{minted}[fontsize=\footnotesize]{python}
from scipy.integrate import solve_bvp

mu = 0.02
l = 0.0279
eta = 0.01
def fun_measles(x, y):
    beta = 1575 * (1 + np.cos(2 * np.pi * x))
    return np.vstack((
        mu - beta * y[0] * y[2],
        beta * y[0] * y[2] - y[1] / l,
        y[1] / l - y[2] / eta
    ))


def bc_measles(ya, yb):
    return ya - yb

x_measles = np.linspace(0, 1, 5)
y_measles = np.full((3, x_measles.shape[0]), 0.01)

res_measles = solve_bvp(fun_measles, bc_measles, x_measles, y_measles)
\end{minted}

\begin{minted}[fontsize=\footnotesize]{python}
plt.figure(figsize=(14, 5))
x_measles_plot = np.linspace(0, 1, 100)
y_measles_plot = res_measles.sol(x_measles_plot)
plt.subplot(131)
plt.plot(x_measles_plot, y_measles_plot[0], label='$y_1$')
plt.subplot(132)
plt.plot(x_measles_plot, y_measles_plot[1], label='$y_2$')
plt.subplot(133)
plt.plot(x_measles_plot, y_measles_plot[2], label='$y_3$')
plt.savefig('compscieng_app10boundary_06.png')
\end{minted}

\includegraphics[width=35em]{compscieng_app10boundary_06.png}

Sinir Sistemi Tepkisi (Nerve Impulse)

Tekrar eden sýnýr þart durumunu bilinmeyen entegral limiti durumu ile
birleþtiren bir problemi göreceðiz þimdi [8, sf. 27, 3, sf. 225, 6, 5,
sf. 173]. Bilinmeyen sýnýr þartý için bir numara yapabiliriz; Yeni bir
deðiþken $\tau$ tanýmlýyoruz, ve bu deðiþken sadece $[0,1]$ aralýðýna
kýsýtlanýyor. Baðýmsýz deðiþken $x$.  Þimdi $\tau = t/b$, ki $b$
bilinmeyen entegral sýnýrý,

$$
\frac{\ud y}{\ud x} = f(t,y)
$$

yerine 

$$
\frac{\ud y}{\ud \tau} = b f(t,y)
$$

$$
\frac{\ud b}{\ud \tau} = 0
$$

Bu nasýl oldu? 

$t = \tau b$ ise $\ud x / \ud \tau = b$. 

$$
\frac{\ud y}{\ud \tau} = \frac{\ud y}{\ud t} \frac{\ud t}{\ud \tau} = 
b f(x,y)
$$

Problem sorusuna gelelim. Diyelim ki hücre zar potansiyeli $y_1$,
geçirgenlik $y_2$, ve

$$
y_1' = 3 (y_1 + y_2 - 1/3 y_1^3 - 1.3)
$$

$$
y_2' = -(y_1 - 0.7 + 0.8 y_2) / 3
$$

Bu problem $[0,T]$ zaman diliminde tanýmlanmýþtýr. Fakat bir problem
þu, $T$'nin ne olduðunu bilmiiyoruz, ve ayný $T$ bilinmeyeni sýnýr
þartlarýnýn tanýmlanmasýnda kullanýlmýþ.  

$$
y_1(0) = y_1(T), \quad y_2(0) = y_2(T)
$$

Ana denklem,

$$
y_1' = 3 T (y_1 + y_2 - 1/3 y_1^3 - 1.3)
$$

$$
y_2' = -T (y_1 - 0.7 + 0.8 y_2) / 3
$$
 
Böylece problem $[0,1]$ arasýnda tanýmlanmýþ oldu.  Sýnýr þartlarý böylece
$t=0,1$ üzerinden tanýmlanabilir. Fakat üçüncü bir sýnýr þartý daha
lazým. Farklý bir açýdan eðer çözüm parçalarýndan birine bir deðer atamak,
mesela $y_1(0) = 0$. O zaman $y_1(0) = y_1(T)$ yerine $y_1(T)=0$ da
kullanabiliriz. Böylece sýnýr þartlarý,

$$
y_1(0) = 0, \quad y_1(1) = 0, \quad y_2(0) = y_2(1)
$$

haline geldi. Bu problemi ekstra parametre seçeneðini kullanarak, bölmeden
(non-seperated) halde çözebiliriz [9, sf. 173]. 

\begin{minted}[fontsize=\footnotesize]{python}
from scipy.integrate import solve_bvp

def fun(x, y, p):
    T = p[0]
    return np.vstack((
        3.0 * T *  (y[0] + y[1] - (y[0]**3)/3.0 - 1.3),
        -T / 3.0 * (y[0] - 0.7 + 0.8*y[1]) 
    ))

def bc(ya, yb, p):
    return np.array( [ ya[0], yb[0], ya[1]-yb[1] ]   )
                     
x = np.linspace(0, 1, 5)
y = np.zeros((2, x.size))
y[0] = np.sin(2 * np.pi * x)
y[1] = np.cos(2 * np.pi * x)
sol = solve_bvp(fun, bc, x, y, p=[2*np.pi])
print (sol.p)
\end{minted}

\begin{verbatim}
[10.71071556]
\end{verbatim}

Üstteki $T$ deðeri [9]'da bulunan ile ayný. 

Kaynaklar

[1] Yang, {\em Applied Numerical Methods using Matlab}

[2] Scipy, {\em Scipy Reference, 0.18.1}

[3] Cash, {\em Solving Differential Equations in R}

[4] Greenhill, {\em The applications of elliptic functions}

[5] Shampine, {\em A BVP Solver Based on Residual Control and the Matlab PSE}, 
    \url{http://www.orcca.on.ca/TechReports/TechReports/2001/TR-01-02.pdf}

[6] Mayorov, {\em Github}, \url{https://gist.github.com/nmayorov/f8af5ca956c6a7f75ecdb578a2655894}

[7] Ascher, {\em Numerical Solution of BVPs for ODEs}

[8] Seydel, {\em From equilibrium to chaos}

[9] Shampine, {\em Solving ODEs in Matlab}

[10] Bayramli, Diferansiyel Denklemler, {\em Kök Bulmak}
    
\end{document}
