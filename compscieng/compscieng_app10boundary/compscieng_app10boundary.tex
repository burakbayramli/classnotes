\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Ýki Nokta Sýnýr Deðerli Problemler (Two-Point Boundary Value Problems -BVP-)

BVP problemleri þu genel formda olan problemlerdir [1, sf. 287],

$$ 
x''(t) = f(t, x(t), x'(t)))
$$

$$x(t_0) = x_0, \quad x(t_f) = x_f$$ 

Ýkinci satýr sýnýr þartlarýný belirtiyor, zaman için $t_0,t_1,...t_f$
indisleri kullanýlýr, yani sistemýn konumu $x(t)$'in baþlangýçta $x_0$
bitiþte $x_f$ noktasýnda olmasý isteniyor (bunlar gerçek tek sayý deðerleri
olacak). Bilinmeyen bir baþlangýç þartý var, bu $x'(0)$ þartý, diyelim
$x'(0) = z$. Bilinmeyen $z$'yi nasýl bulacaðýz? Genel yaklaþým olarak
bilinen az sayýda deðiþkeni ileri doðru entegre ederek sonda gelinen
noktaya bakýlýr, eldeki kýsmý son nokta verisiyle karþýlaþtýrýlarak bir
hata üzerinden baþlangýç düzeltilmeye uðraþýlýr, bu özyineli þekilde devam
eder. Çözüm yöntemi olarak ateþ etme yöntemi (the shooting method) vardýr,
farklý paketler farklý yaklaþýmlar kullanabilir. 

Paket Ýle

$$
\frac{\ud y}{\ud x} = f(x, y, p) + \frac{S y}{x-a}
$$

$$
a \le x \le b, \quad bc(y(a), y(b), p) = 0
$$

ki $x$ tek boyutlu baðýmsýz deðiþken, $y(x)$ n-boyutlu vektör deðerli
fonksiyon, $p$ $k$ boyutlu bilinmeyen parametrelerin vektörü, ki onu
$y(x)$'yi bulurken ayný anda bulmak gerekiyor. $bc$ ile sýnýr þartlarý
tanýmlanýyor.


Bratu Problemi

Paket çözümleri de kullanýlabilir [2, sf. 396]. Mesela \verb!scipy!. Bratu
problemi

$$
y'' + k + \exp(y) = 0
$$

$$
y(0) = y(1) = 0
$$

Bu sistemi 1. derece bir denklemler sistemine deðiþtirelim,

$$
y_1' = y_2
$$

$$
y_2' = -\exp(y_1)
$$

\begin{minted}[fontsize=\footnotesize]{python}
def fun(x, y):
    # k=1 farz edildi
    return np.vstack((y[1], -np.exp(y[0])))

def bc(ya, yb):
    return np.array([ya[0], yb[0]])

x = np.linspace(0, 1, 5)
\end{minted}

Cagri \verb!bc! icinde sinir sartlarinin artigi, hatasi donduruluyor. 

[TBD]

Bu problemin iki farklý çözümü var. Her iki çözümü de elde etmek için
$y$ için farklý baþlangýç noktalarý deneyeceðiz, bu seçenekleri $1$ ve
$2$ olarak iþaretleyelim,

\begin{minted}[fontsize=\footnotesize]{python}
y_1 = np.zeros((2, x.size))
y_2 = np.zeros((2, x.size))
y_2[0] = 3

from scipy.integrate import solve_bvp
res_1 = solve_bvp(fun, bc, x, y_1)
res_2 = solve_bvp(fun, bc, x, y_2)
\end{minted}

\begin{verbatim}
[0. 0.] [0. 0.]
-----------
[0. 0.] [0. 0.]
-----------
[1.49011612e-08 0.00000000e+00] [0. 0.]
-----------
[0.00000000e+00 1.49011612e-08] [0. 0.]
-----------
[0. 0.] [1.49011612e-08 0.00000000e+00]
-----------
[0. 0.] [0.00000000e+00 1.49011612e-08]
-----------
[0.         0.54629898] [ 0.         -0.54629898]
-----------
[0.         0.54930588] [ 0.         -0.54930588]
-----------
[0.         0.54934927] [ 0.         -0.54934927]
-----------
[3. 0.] [3. 0.]
-----------
[3. 0.] [3. 0.]
-----------
[3.00000006 0.        ] [3. 0.]
-----------
[3.00000000e+00 1.49011612e-08] [3. 0.]
-----------
[3. 0.] [3.00000006 0.        ]
-----------
[3. 0.] [3.00000000e+00 1.49011612e-08]
-----------
[8.88178420e-16 1.14187789e+01] [ 1.33226763e-15 -1.14187789e+01]
-----------
[1.5        5.70938946] [ 1.5        -5.70938946]
-----------
[1.50000004 5.70938946] [ 1.5        -5.70938946]
-----------
[1.5        5.70938956] [ 1.5        -5.70938946]
-----------
[1.5        5.70938946] [ 1.50000004 -5.70938946]
-----------
[1.5        5.70938946] [ 1.5        -5.70938936]
-----------
[6.66133815e-16 1.04769120e+01] [ 2.22044605e-16 -1.04769120e+01]
-----------
[1.33409645e-16 1.09994244e+01] [ 6.22273541e-17 -1.09994244e+01]
-----------
[2.28603108e-19 1.09602076e+01] [ 2.29588507e-18 -1.09602076e+01]
-----------
[6.44793865e-19 1.09616046e+01] [-2.01259469e-19 -1.09616046e+01]
-----------
[-3.15161156e-20  1.09611270e+01] [ 6.8359097e-21 -1.0961127e+01]
-----------
[-1.52586641e-20  1.09611047e+01] [ 1.00874000e-20 -1.09611047e+01]
-----------
[-1.52586641e-20  1.09611047e+01] [  0.         -10.96110471]
-----------
[1.49011612e-08 1.09611047e+01] [  0.         -10.96110471]
-----------
[-1.52586641e-20  1.09611049e+01] [  0.         -10.96110471]
-----------
[-1.52586641e-20  1.09611047e+01] [ 1.49011612e-08 -1.09611047e+01]
-----------
[-1.52586641e-20  1.09611047e+01] [  0.         -10.96110453]
-----------
[ 0.         10.85198079] [  0.         -10.85198079]
-----------
[ 0.         10.85182204] [  0.         -10.85182204]
-----------
[ 0.         10.85182204] [  0.         -10.85182204]
-----------
[1.49011612e-08 1.08518220e+01] [  0.         -10.85182204]
-----------
[ 0.         10.85182221] [  0.         -10.85182204]
-----------
[ 0.         10.85182204] [ 1.49011612e-08 -1.08518220e+01]
-----------
[ 0.         10.85182204] [  0.         -10.85182186]
-----------
[ 0.         10.84721572] [  0.         -10.84721572]
-----------
[ 0.         10.84721572] [  0.         -10.84721572]
-----------
[1.49011612e-08 1.08472157e+01] [  0.         -10.84721572]
-----------
[ 0.        10.8472159] [  0.         -10.84721572]
-----------
[ 0.         10.84721572] [ 1.49011612e-08 -1.08472157e+01]
-----------
[ 0.         10.84721572] [  0.         -10.84721555]
-----------
[ 0.         10.84697602] [  0.         -10.84697602]
-----------
\end{verbatim}\begin{minted}[fontsize=\footnotesize]{python}
x_plot = np.linspace(0, 1, 100)
y_plot_1 = res_1.sol(x_plot)[0]
y_plot_2 = res_2.sol(x_plot)[0]
import matplotlib.pyplot as plt
plt.plot(x_plot, y_plot_1, label='y_a')

plt.plot(x_plot, y_plot_2, label='y_b')
plt.legend()
plt.xlabel("x")
plt.ylabel("y")
plt.savefig('compscieng_app10boundary_03.png')
\end{minted}


\includegraphics[width=20em]{compscieng_app10boundary_03.png}


Top Atýþý Metotu (Shooting Method)

Bir diðer çözüm yöntemi top atýþý (silah anlamýnda) problemidir, güllenin
nereden atýldýðý bilinir, düþmesi istenen bir yer vardýr, ama hangi aciyla
(burada $x'(0))$ yukarý doðru tutulacaðý bilinmez.

\includegraphics[width=20em]{compscieng_app10boundary_02.png}

Bilinmeyen baþlangýç þartlarýndan birini bulmak için bir yöntem tüm
bilinenleri kullanýp, bilinmeyen için bir tahmin yerine koymak, ve bu
sistemi entegre ederek sonuca gelmek. Sonuca gelindiðinde $x_f$'e ne kadar
yakýn olunduðuna göre bir hata gradyaný oluþturup bu gradyaný $x'(0)$'te
düzeltme yapmak için kullanmak, ve süreci tekrarlamak. Bu iþlem ardý ardýna
yapýlýr ve istenen bitiþ deðerine gelince durulur. Bu yönteme ilham aldýðý
temel örnekten hareketle atýþ metotu (the shooting method) adý veriliyor.

Gradyaný hesaplamak ve düzeltmede kullanmak için Sekant Yöntemini
kullanabiliriz (bkz {\em Diferansiyel Denklemler, Kök Bulmak} yazýsý). Hata
fonksiyonu $z$'nin fonksiyonudur,

$$ e(z) = x(t_f) - x_f $$

Ýstediðimiz $e(z)$'nin minimal olmasý, yani sýfýra eþit olmasý, $e(z) =
0$. Bu durumda bir kök bulma problemi ortaya çýkýyor,

$$ z_{n+1} = z_n - \frac{ \quad e(z_n) \quad }{\frac{\ud e(z_n) }{\ud z_n} }$$

Sekant yöntemi için

$$ z_{n+1} = z_n - 
\frac{ e(z_n)  }{\quad \dfrac{e(z_n) - e(z_{n-1})}{z_n - z_{n-1}} \quad }
$$

Örnek 

$$ x''(t) = 2x^2(t) + 4t x(t) x'(t)$$

$$ x(0) = \frac{1}{4}, \quad x(1) = \frac{1}{3}$$

Bu problemin analitik çözümü aslýnda biliniyor, 

$$x(t) = \frac{1}{4 - t^2}, \quad x'(t) = \frac{2t}{(4-t^2)^2} = 2t x^2(t)$$

Ama bilmeseydi nasýl çözerdik? Alttaki gibi. Önce $x_1'(t)$ için yeni bir
deðiþken tanýmlayalým, $x_1'(t) = x_2(t)$ olsun, o zaman $x_2'(t)$ ana ODE
denklemimiz olabilir, çok boyutlu olarak

$$ 
\left[\begin{array}{c}
x_1'(t) \\ x_2'(t) 
\end{array}\right] 
=
\left[\begin{array}{c}
x_2(t) \\
2x_1^2(t) + 4t \cdot x_1(t)x_2(t)
\end{array}\right] 
$$

Sýnýr þartlarý

$$ 
\left[\begin{array}{c}
x_1(0) \\ x_2(0)
\end{array}\right]
=
\left[\begin{array}{c}
x_0 = 1/4 \\ x_f = 1/3
\end{array}\right]
$$

Kod, 

\begin{minted}[fontsize=\footnotesize]{python}
import scipy as sp import numpy.linalg as lin from
scipy.integrate.odepack import odeint

def rhs(u,t):
    x1, x2,  = u
    return [x2, (2*x1 + 4*t*x2)*x1]

def bvp_shoot(t0,tf,x0,xf,N,tol,kmax):
    dx0 = np.zeros(kmax)
    e = np.zeros(kmax)
    dx0[0]= (xf-x0)/(tf-t0);
    t=np.linspace(t0,tf,100.0)
    for k in range(1,kmax-1):
        x=odeint(rhs,[x0, dx0[k]], t)        
        e[k]=x[-1,0]-xf
        ddx= dx0[k]-dx0[k-1]
        if np.abs(e[k])<tol or np.abs(ddx)<tol: break
        deddx= (e[k]-e[k-1])/ddx;
        dx0[k+1] = dx0[k]-e[k]/deddx;
    return t, x

t0 = 0.; tf = 1.; x0 = 1/4.; xf = 1/3.;
N = 100.; tol = 1e-8; kmax = 10;

t,x = bvp_shoot(t0,tf,x0,xf,N,tol,kmax)
xo = 1.0 /(4.0 - t**2); err = lin.norm(x[:,0] - xo)/(N + 1.0)

plt.plot(t,x[:,0],'g') # bizim hesap
plt.plot(t,xo,'--r') # analitik bilinen
plt.savefig('compscieng_app10boundary_01.png')
\end{minted}

\includegraphics[width=20em]{compscieng_app10boundary_01.png}

Grafikte görüldüðü gibi iki çözüm birbirinin týpký aynýsý. 


Kaynaklar

[1] Yang, {\em Applied Numerical Methods using Matlab}

[2] Scipy, {\em Scipy Reference, 0.18.1}

\end{document}

