<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>

  <title>Ders 1.5</title>
  <style type="text/css">code{white-space: pre;}</style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  
  
  
  
</head>
<body>
<h1 id="ders-1.5">Ders 1.5</h1>
<p>Önceki derste <span class="math inline">\(-u&#39;&#39; = \delta(x-a)\)</span> denklemini çözmüştük. Ayrıksal olarak bu denklem sol tarafta matris <span class="math inline">\(-K\)</span>, sağ tarafta ise noktasal ağırlığı tek hücre içinde 1 olan bir vektöre tekabül edecektir. K bağlamında 1 -2 1 formu, -1 2 -1 haline gelir, <span class="math inline">\(u\)</span> vektörü önceki gibi, sağ tarafta ise ayrıksal delta fonksiyonu. Ağırlığın 2. hücrede olduğu örnek alttadır.</p>
<p><span class="math display">\[  
\left[\begin{array}{rrrr}
2 &amp; -1 &amp; 0 &amp; 0 \\
-1 &amp; 2 &amp; -1 &amp; 0 \\
0 &amp; -1 &amp; 2 &amp; -1 \\
0 &amp; 0 &amp; -1 &amp; 2 
\end{array}\right]
\left[\begin{array}{c}
u_1 \\
u_2 \\
u_3 \\
u_4
\end{array}\right]
=
\left[\begin{array}{c}
0 \\
1 \\
0 \\
0
\end{array}\right]
\]</span></p>
<p>Ortaya ilginç bir durum çıktı: sağ taraftaki matrise bakarsak, ağırlık 2. hücrede ve orası 1. Eğer 3. olsaydı 3. hücre 1 olurdu, vs. Tüm bu vektörleri yanyana koysak, birim matrisini elde etmez miyiz? Evet. O zaman bir kolaylık ortaya çıktı. Ağırlık <span class="math inline">\(j\)</span> üzerinde ise o vektörü <span class="math inline">\(\delta_j\)</span> ile temsil edersek,</p>
<p><span class="math display">\[ Ku = \delta_j \]</span></p>
<p><span class="math inline">\(\delta_j\)</span> yerine <span class="math inline">\(I\)</span> kullanırsak, ve <span class="math inline">\(u\)</span> vektörü yerine <span class="math inline">\(U\)</span> kullanırsak,</p>
<p><span class="math display">\[ KK^{-1}U = I \cdot K^{-1}\]</span></p>
<p><span class="math display">\[ U = K^{-1} \]</span></p>
<p>olacaktır. <span class="math inline">\(U\)</span> içinde her türlü <span class="math inline">\(j\)</span> olasılığı için bir çözüm içeriyor. Eğer <span class="math inline">\(j=2\)</span> olasılığının çözümünü görmek istiyorsak o zaman <span class="math inline">\(K^{-1}\)</span> matrisinin yani <span class="math inline">\(U\)</span>'nun 2. kolonuna bakmak yeterli.</p>
<p>Peki, eğer yük tek bir nokta yerine &quot;tüm'' noktalarda olsaydı ne yapardık? Tüm noktalardaki yük eşitliğin sağ tarafının tamamen 1 olması demektir. O zaman bir başka numara yaparak, tamamen 1 içeren bu vektörü ayrı ayrı <span class="math inline">\(\delta_j\)</span>'ler &quot;toplamı'' olarak görebiliriz, mesela</p>
<p><span class="math display">\[ 
\left[\begin{array}{c} 1 \\ 0 \\ 0 \\ 0  \end{array} \right] +
\left[\begin{array}{c} 0 \\ 1 \\ 0 \\ 0  \end{array} \right] +
\left[\begin{array}{c} 0 \\ 0 \\ 1 \\ 0  \end{array} \right] +
\left[\begin{array}{c} 0 \\ 0 \\ 0 \\ 1  \end{array} \right] = 
\left[\begin{array}{c} 1 \\ 1 \\ 1 \\ 1  \end{array} \right] 
 \]</span></p>
<p>Bu ne demektir? Eşitliğin sağ tarafının &quot;girdi'' olarak görülebildiğini de biliyoruz. Lineer bir sistemde girdiler toplanırsa, mümkün tüm çıktılar da toplanır. Üstteki <span class="math inline">\(K^{-1}\)</span>'in kolonları da bu mümkün tüm çıktıları zaten verdiğine göre tek yapmamız gereken bu kolonları birbiriyle toplamaktır.</p>
<p>Green'in Fonksiyonu</p>
<p><span class="math inline">\(-u&#39;&#39;\)</span>'ya eşit olarak bir noktasal ağırlık (point load) yani delta fonksiyonu varsa çıkan sonuç Green'in fonksiyonu olarak bilinir ve bu fonksiyon <span class="math inline">\(G(x,a)\)</span> olarak ta gösterilebilir, çünkü Green'in fonksiyonu hem <span class="math inline">\(x\)</span>'e hem <span class="math inline">\(a\)</span>'ya bağlıdır. Ayrıksal, sürekli (continuous) bağlamında ise Green'in fonksiyonu üstte gösterilen matris tersi işleminin sürekli hali olarak düşünülebilir.</p>
<p>Özdeğerler ve Özvektörler (Eigenvalues and Eigenvectors)</p>
<p>Özdeğerler <span class="math inline">\(Ay = \lambda y\)</span> formunda ortaya çıkarlar. Eğer bir problemde bu formu bulabilirsek, çözüm için müthiş kolaylık sağlayan bir kavramdırlar. Özdeğerler <span class="math inline">\(\lambda\)</span> içinde, özvektörler <span class="math inline">\(y\)</span> içinde bulunur.</p>
<p>Bu kavram hakkında anlayış geliştirelim. Mesela elimizde bir <span class="math inline">\(v\)</span> vektörü var, ve <span class="math inline">\(A\)</span> matrisi ile çarpılıyor. Sonuç yine bir vektör olacak, bu vektör <span class="math inline">\(Av\)</span> vektörü.</p>
<div class="figure">
<img src="5_2.png" />

</div>
<p>Eğer o vektör yukarıdaki gibiyse, <span class="math inline">\(v\)</span> bir özvektör <em>değil</em> demektir. Niye? Çünkü özvektörler özel vektörlerdir (her <span class="math inline">\(A\)</span> için) , öyle değerlere sahiptirler ki <span class="math inline">\(A\)</span> ile çarpılınca, çizgisel <em>yönleri</em> değişmez (ama boyları değişebilir). Diyelim ki elimizde bir <span class="math inline">\(y\)</span> var,</p>
<div class="figure">
<img src="5_3.png" />

</div>
<p><span class="math inline">\(Ay\)</span> alttaki gibi olabilir</p>
<div class="figure">
<img src="5_4.png" />

</div>
<p><span class="math inline">\(2y\)</span> olabilir, ters yönde büyüyebilir, sıfır haline de gelebilir, vs. Fakat muhakkak aynı çizgi üzerinde kalır, <span class="math inline">\(\lambda\)</span> değeri de 2, sıfır, vs gibi büyümenin, küçülmenin ne kadar olduğunu belirten değer olacaktır. Fakat, tekrarlamak gerekirse, özvektörler nadirdirler zaten tarif edildiği şekilde davranan bir vektörün az rastlanan bir şey olması normal olmalıdır.</p>
<p>Bunun faydası, değeri nedir? Özvektör bize öyle bir yön sağlar ki o yönde <span class="math inline">\(A\)</span> bir sayı gibi davranır. <span class="math inline">\(A\)</span>, <span class="math inline">\(y\)</span> vektörünü &quot;değiştiren'', onu transform eden bir fonksiyondur bir bakıma, ve bu fonksiyon ne kadar çetrefil olursa olsun belli bir &quot;özel'' yönde sadece sayı etkisi yapmaktadır. Mesela</p>
<p><span class="math display">\[ \frac{du}{dt} = Au \]</span></p>
<p>diyelim ki <span class="math inline">\(u\)</span> 1000 boyutunda bir vektör, <span class="math inline">\(A\)</span> 1000 x 1000 boyutunda bir matris. Denklem çok büyük, ama diyelim ki biz bu <span class="math inline">\(A\)</span> için öyle bir özvektör ve özdeğer <span class="math inline">\(u\)</span> biliyoruz ki (eğer bu değerler problem içinde mantıklı değerler de iseler) o zaman şunu da biliyoruz ki çözüm o yönde başlarsa o yönde kalır.</p>
<p>O zaman elimizde bir skalar var demektir (çünkü <span class="math inline">\(A\)</span> yönde tek sayı etkisi yapıyor) yani üstteki diferansiyel denklem <span class="math inline">\(u&#39; = Au\)</span> yerine <span class="math inline">\(u&#39; = \lambda u\)</span> haline gelebilir.</p>
<p>Bu daha basit denklemin direk analitik çözümünü biliyoruz:</p>
<p><span class="math display">\[ u = ce^{\lambda t} \]</span></p>
<p><span class="math inline">\(\lambda\)</span> özdeğer olarak belli bir yöndeki büyüme, küçülmeyi gösteriyorsa, üstteki formül içinde de benzer anlamı taşır: Artı <span class="math inline">\(\lambda\)</span> üstel değer üzerinden ona oranlı bir büyümeyi, eksi olanı o oranda bir küçülmeyi gösterir. Güzel. Kavramlar birbiriyle bağlantılı çıkıyor, demek ki doğru yoldayız.</p>
<p>Diğer kullanımlar? Temel denklemi tekrar yazalım.</p>
<p><span class="math display">\[ Ay = \lambda y \]</span></p>
<p>Soru şu: <span class="math inline">\(A^2\)</span> için öyle bir vektör arıyorum ki <span class="math inline">\(A\)</span> ile iki kez çarpınca yön değiştirmiyor. Cevap, yine özvektör <span class="math inline">\(y\)</span>. Çünkü <span class="math inline">\(y\)</span>'yi <span class="math inline">\(A\)</span> ile çarpınca <span class="math inline">\(\lambda y\)</span> çıkıyor, yön hala değişmedi, o zaman bir daha çarparsak, yön hala aynı kalır, bu sefer sonuç <span class="math inline">\(\lambda^2y\)</span>.</p>
<p><span class="math display">\[ A^2 = \lambda^2 y \]</span></p>
<p>Özvektörler diferansiyel denklemler için, bir matrisin üstel değerlerini hesaplamak için çok faydalıdırlar. Bir matrisin pivotları sabit konum (steady-state) problemini incelerken de elimizdeki önemli sayılardır. Hareket halindeki bir maddeyi incelerken yardımcı olurlar, salınımı (oscillate) olan, büyüyen, küçülen şeyleri incelemekte de faydalıdırlar.</p>
<p>Eğer <span class="math inline">\(\lambda\)</span> kompleks bir sayı olsaydı? O zaman <span class="math inline">\(\lambda\)</span>'nin reel bölümüne bakardık, <span class="math inline">\(&lt; 0\)</span> ise, stabil küçülme (decay), büyük ise stabil olmayan büyüme (growth) olurdu. Eğer <span class="math inline">\(e^{4it}\)</span> gibi bir değer olsaydı, bu pür salınım olacaktı, çünkü açılımı <span class="math inline">\(\cos(4t) + i\sin(4t)\)</span> formülüdür.</p>
<p>Diğer bir soru: <span class="math inline">\(k\)</span> büyürken <span class="math inline">\(A^k \to 0\)</span> ise, yani <span class="math inline">\(A\)</span>'yi sürekli kendisi ile çarparken sonuç hep küçülüyorsa, bu durumu <span class="math inline">\(\lambda\)</span>'ya bakarak nasıl anlayabilirim?</p>
<p><span class="math inline">\(A^ky\)</span> ise <span class="math inline">\(\lambda^ky\)</span> demektir (üstte gördük), o zaman <span class="math inline">\(A^ky\)</span>'nin nasıl davranacağını <span class="math inline">\(\lambda^ky\)</span>'a bakarak anlayabilirim. <span class="math inline">\(\lambda^ky\)</span> ne zaman sıfıra gider? Cevap: <span class="math inline">\(\lambda &lt; 1\)</span> olduğu zaman.</p>
<p>Kompleks <span class="math inline">\(\lambda\)</span>'li Reel Matris</p>
<p>Diyelim ki elimizde bir vektörü 90 derece döndürebilen bir <span class="math inline">\(A\)</span> matrisi var.</p>
<p><span class="math display">\[ 
A = 
\left[
\begin{array}{rr}
0 &amp; -1 \\
1 &amp; 0
\end{array}
\right]
 \]</span></p>
<p>Bu matrisin reel özdeğerleri olamaz, çünkü bu matrisin uygulanıp yönü değişmeyen hiçbir &quot;reel'' vektör olamaz. Gözle görülebilen her vektör 90 derece transform edilir. İşte bu gibi örneklerde özdeğer bulmak için kompleks vektörler gerekir. Şu vektörü deneyelim: <span class="math inline">\(\left[\begin{array}{cc}1&amp;i\end{array}\right]^T\)</span>.</p>
<p><span class="math display">\[ 
\left[\begin{array}{rr}
0 &amp; -1 \\
1 &amp; 0
\end{array}\right]
\left[\begin{array}{c}
1 \\
i
\end{array}\right]
= 
\left[\begin{array}{c}
-i \\
1
\end{array}\right]
= 
-i
\left[\begin{array}{c}
1 \\
i
\end{array}\right]
 \]</span></p>
<p>Vektör ise yaradı. Şimdi ana noktaya gelelim. Özdeğerleri nasıl kullanırız? Ve onlardan kaç tane vardır? &quot;İyi'' bir matris, ki bu tanıma her simetrik matris dahildir, eğer mesela büyüklüğü 1000 ise, o zaman 1000 tane farklı özvektörü olacaktır. Simetrik matrislerde de o özvektörlerin hepsi reel olacaktır. Mesela:</p>
<p><span class="math display">\[ 
\left[\begin{array}{rr}
2 &amp; -1 \\
-1 &amp; 2
\end{array}\right]
 \]</span></p>
<p>2 x 2 boyutunda bu matriste 2 tane özvektör bulmamız lazım. Bu ufak bir matris, özvektörleri tahmin yapa yapa bulmaya uğraşabiliriz. <span class="math inline">\(\left[\begin{array}{cc}1&amp;0\end{array}\right]^T\)</span> bir özvektör mü? Çarpımı yaparsak,</p>
<p><span class="math display">\[ 
\left[\begin{array}{rr}
2 &amp; -1 \\
-1 &amp; 2
\end{array}\right]
\left[\begin{array}{c}
1 \\
0
\end{array}\right]
=
\left[\begin{array}{r}
2 \\
-1
\end{array}\right]
 \]</span></p>
<p>Olmadı. Sağdaki vektör <span class="math inline">\(\left[\begin{array}{cc}1&amp;0\end{array}\right]^T\)</span>'in bir katı değil. Not: Lineer cebirde kafadan işlem yapmanın yollarından biri, <span class="math inline">\(\left[\begin{array}{cc}1&amp;0\end{array}\right]^T\)</span> ile çarparken 1 görünce, soldaki matrisin &quot;1. sol kolonunu olduğu gibi almak''. Peki <span class="math inline">\(\left[\begin{array}{cc}1&amp;1\end{array}\right]^T\)</span> denersem?</p>
<p><span class="math display">\[ \left[\begin{array}{rr} 2 &amp; -1 \\ -1 &amp; 2
\end{array}\right]
\left[\begin{array}{c}
1 \\
1
\end{array}\right]
=
\left[\begin{array}{c}
1 \\
1
\end{array}\right]
 \]</span></p>
<p>Bu oldu. İkinci özvektör ne olabilir? <span class="math inline">\(\left[\begin{array}{cc}1&amp;-1\end{array}\right]^T\)</span> deneyelim.</p>
<p><span class="math display">\[ 
\left[\begin{array}{rr}
2 &amp; -1 \\
-1 &amp; 2
\end{array}\right]
\left[\begin{array}{r}
1 \\
-1
\end{array}\right]
=
\left[\begin{array}{r}
3 \\
-3
\end{array}\right]
 \]</span></p>
<p>Bu da oldu. O zaman <span class="math inline">\(\lambda_1 = 1\)</span>, <span class="math inline">\(\lambda_2 = 3\)</span>, özvektörler <span class="math inline">\(\left[\begin{array}{cc} 1 &amp; 1 \end{array}\right]^T\)</span> ve <span class="math inline">\(\left[\begin{array}{cc}  1 &amp; -1 \end{array}\right]^T\)</span>. Bu özvektörlere bana ne söylüyor? Onlara bakarak ana matris hakkında ne anlayabilirim? Bakalım, <span class="math inline">\(\left[\begin{array}{cc}  1 &amp; 1 \end{array}\right]^T\)</span> ve <span class="math inline">\(\left[\begin{array}{cc} 1 &amp;  -1\end{array}\right]^T\)</span> birbirine dikgen (orthogonal) vektörler.</p>
<div class="figure">
<img src="5_5.png" />

</div>
<p>Cebirsel olarak bu dikliği anlamak için <span class="math inline">\(y_1^Ty_2\)</span>, ya da <span class="math inline">\(y_1 \cdot y_2\)</span> hesabını yapabilirdik, diklik var ise sonuç sıfır çıkardı. Özvektörlerin dikliği başka bir şey daha söyler, simetrik matrislerin özvektörleri birbirine diktir, o zaman sadece özvektörlere bakarak ana matrisin simetrik olduğunu anlayabilirdik.</p>
<p>Söylemeye çalıştığımız özdeğer ve özvektörler matrisleri incelemenin, onların &quot;içine bakmanın'' yollarından bir tanesidir.</p>
<p>Peki üstteki simetrik olmayan matrise dönersek</p>
<p><span class="math display">\[ 
\left[
\begin{array}{rr}
0 &amp; -1 \\
1 &amp; 0
\end{array}
\right]
 \]</span></p>
<p>Bu matrisin özvektörleri kompleks çıkmıştı, ki bu durum simetrik olmayan matrislerin bir özelliğidir. Simetrik matrisleri bu sebeple tercih ederiz, özvektörleri reel, birbirine dik.</p>
<p>Özdeğerler üzerinde güzel iki tane faydalı kontrol mekanizması: <span class="math inline">\(\lambda_1 = 1\)</span>, <span class="math inline">\(\lambda_2 = 3\)</span> bulduğumuz örnekte iki özdeğer toplamı nedir? 4. Ana matrisin çaprazındaki değerleri toplarsak (buna matrisin &quot;izi'' -trace- adı da verilir)</p>
<p><span class="math display">\[ 
\left[\begin{array}{rr}
2 &amp; -1 \\
-1 &amp; 2
\end{array}\right]
 \]</span></p>
<p>Sonuç yine 4. Bu iki toplam her zaman eşit çıkmalıdır. Bir numara: bir tanesi hariç tüm özdeğerleri bulduksak matrisi izini kullanarak sonuncu özdeğeri hızla bulabiliriz, çünkü çapraz toplamından diğer özdeğer toplamını çıkartırız, kalan sonuncu özdeğer olmalıdır.</p>
<p>Bir kontrol daha. Özdeğerleri birbiriyle çarparsam sonuç 3 çıkar. Ana matrisin determinantını alırsam sonuç yine 3 çıkar. Bu iki kontrol tekniğini, ispatını göstermeden, burada vermiş olalım.</p>
<p>Kullanıma gelelim: Diyelim ki elimizde içinde 1000 tane denklem içeren bir lineer denklem sistemi var.</p>
<p><span class="math display">\[ \frac{du}{dt} = Au \]</span></p>
<p>katsayılar sabit, başlangıç noktası <span class="math inline">\(u(0)\)</span>. Özdeğer ve özvektörler burada nasıl yardımcı olabilir? Önce onları bulmamız gerekir, 1000 tane özvektör var, onları buluruz. Her <span class="math inline">\(i\)</span> için</p>
<p><span class="math display">\[ Ay_i = \lambda_i y_i \]</span></p>
<p>yani elimizdeki özvektörler <span class="math inline">\(y_1,..,y_{1000}\)</span>, özdeğerler <span class="math inline">\(\lambda_1,...,\lambda_{1000}\)</span>.</p>
<p>Bu değerleri diferansiyel denklemi çözmek için nasıl kullanırım? 3 tane basamak takip ederim.</p>
<ol style="list-style-type: decimal">
<li><p><span class="math inline">\(u(0)\)</span>'i özvektörlerin bir kombinasyonu olarak temsil et, yani <span class="math inline">\(u(0) = c_1y_1 + ... + c_{1000}y_{1000}\)</span>.</p></li>
<li><p><span class="math inline">\(e^{\lambda_1t}\)</span>'yi <span class="math inline">\(c_1\)</span> ile çarp, yani <span class="math inline">\(c_1\)</span>'i onun büyümesi ile çarp, genel olarak <span class="math inline">\(e^{\lambda_it}\)</span>'yi <span class="math inline">\(c_i\)</span> ile çarp.</p></li>
<li><p>Topla: <span class="math inline">\(c_1e^{\lambda_1t}y_1 + .. + c_{1000}e^{\lambda_{1000}  t}y_{1000}\)</span>.</p></li>
</ol>
<p>Not: Bunun niye işlediğinin ispatı için [3]'e bakılabilir.</p>
<p>Not: Konuyla ilgili bir problem bu notların en altında.</p>
<p>Tabii bunu işlemesi için <span class="math inline">\(u(0)\)</span>'in özvektörlere, özdeğerlere göre parçalanması gerekir, ayrıca tüm özvektörlerin bulunabiliyor olması gerekir. Problemimiz bize simetrik bir matris sağlıyorsa sorun olmaz, ama bazı problemlerde matris &quot;defolu'' olabilir, bazı özvektörler birbirlerinin içine girerler (collapse) ve elde yeteri kadar özvektör olmaz. Yani çözmeye çalıştığımız probleme göre bu tekniği kullanabilir ya da kullanamayabiliriz.</p>
<p>Not: Özvektörlerin birbirine yakın, hatta eşit olma problemi ODE'lerdeki kritik sönümlü (critically damped) koşulda köklerin birbirine eşit çıkmasıyla aynı durum, bkz [2]. Orada yeni bir çözüm &quot;yaratmak'' için <span class="math inline">\(e^{-at}\)</span> ile <span class="math inline">\(t\)</span>'yi çarpmıştık. Burada da özdeğerleri aslında kökler olarak görebiliriz, eğer iki özdeğer eşit ise, elimde sadece bir tane özvektör olma riski de yüksek demektir. O zaman yeni bir çözüm yaratmak için ODE dünyasındakine benzer bir numara kullanırım, <span class="math inline">\(te^{\lambda t}\)</span> hesabını yapabilirim.</p>
<p>Ek Açıklamalar</p>
<p><span class="math inline">\(u(0)\)</span>'i <span class="math inline">\(A\)</span>'nin özvektör lineer kombinasyonu olarak temsil edilirse, sonucun <span class="math inline">\(c_1e^{\lambda_1t}y_1 + .. + c_ne^{\lambda_n t}y_n\)</span> şeklinde olabileceğini nereden biliyoruz? Çünkü <span class="math inline">\(du/dt = Au\)</span> ve <span class="math inline">\(Au = \lambda u\)</span> lineer denklemler. Bir sonraki adım için <span class="math inline">\(u(0)\)</span> değiştirildiğinde, bu lineer bir şekilde, <span class="math inline">\(A\)</span> üzerinden olacak, ve <span class="math inline">\(A\)</span>'ya &quot;girdi'' olarak verilen vektörler eğer özdeğerlerin kombinasyonu ise, bu kombinasyon çıkışa da aynen, verildiği şekilde yansıyacak.</p>
<p>Bölüm 1.5 Örnek 4 (Kitaptan)</p>
<p>Diyelim ki vektörel formdaki bir <span class="math inline">\(u(t)\)</span> denklemi ABD'de Missisipi nehrinin doğusu ve batısında <span class="math inline">\(t\)</span> anındaki nüfusu temsil ediyor. Şöyle:</p>
<p><span class="math display">\[ u(t+1) = Au(t) \]</span></p>
<p>Bu vektörel <span class="math inline">\(u(t)\)</span>'yi bileşenleriyle şöyle açıklayalım</p>
<p><span class="math display">\[ 
\left[\begin{array}{r}
t+1 \textrm{ anında doğuda olanlar } \\
t+1 \textrm{ anında batıda olanlar } 
\end{array}\right]
=
\left[\begin{array}{rr}
.8 &amp; .3 \\
.2 &amp; .7
\end{array}\right]
\left[\begin{array}{r}
t \textrm{ anında doğuda olanlar } \\
t \textrm{ anında batıda olanlar } 
\end{array}\right]
 \]</span></p>
<p>Buradaki <span class="math inline">\(A\)</span> matrisi belli bir gözleme dayanarak modelleyicinin bulduğu bir şey herhalde, problem onu bize veriyor. <span class="math inline">\(A\)</span> bir &quot;geçiş fonksiyonu'', <span class="math inline">\(t\)</span> anından <span class="math inline">\(t+1\)</span>'e geçişi o yapıyor. Diyelim ki doğuda 1 milyon insanla başladık, 1 sene sonra (<span class="math inline">\(A\)</span> ile çarpıyoruz) yeni rakamlar 800,000 ve 200,000 haline gelecektir.</p>
<p><span class="math inline">\(A\)</span> matrisi bir Markov matrisidir, Markov matrislerinin kolonlarının iç toplamları her zaman 1'e eşittir. Özdeğer / özvektör bağlamında Markov matrislerinin ilginç bir yanı özdeğerlerinden birinin her zaman 1 olmasıdır, yani <span class="math inline">\(\lambda = 1\)</span> muhakkak olacaktır. İki boyutlu <span class="math inline">\(A\)</span> matrisi durumunda bu çok ise yarar, çünkü matris izine (trace) bakarak ve ondan 1 çıkartarak ikinci özdeğeri hemen bulabiliriz. <span class="math inline">\(A\)</span>'nin özvektörleri de <span class="math inline">\(\lambda = 1\)</span> için [600,000, 400,000], <span class="math inline">\(\lambda = 0.5\)</span> için [400,000, -400,000] değerleridir.</p>
<p>Şimdi ilginç bir numara: eğer başlangıç değeri [1,000,000 0]'i özvektörlerin bir kombinasyonu olarak gösterirsek,</p>
<p><span class="math display">\[ u = [1,000,000 0] = 
a_1 \cdot [600,000, 400,000] + 
a_2 \cdot [400,000, -400,000] \]</span></p>
<p><span class="math inline">\(a_1\)</span> ve <span class="math inline">\(a_2\)</span> 1 değerine eşit.</p>
<p>Soldan <span class="math inline">\(A\)</span> ile çarpalım</p>
<p><span class="math display">\[ Au = 
A \ a_1 \cdot [600,000, 400,000] + 
A \ a_2 \cdot [400,000, -400,000] \]</span></p>
<p><span class="math display">\[ Au = 
 a_1 \ A \cdot [600,000, 400,000] + 
 a_2 \ A \cdot [400,000, -400,000] \]</span></p>
<p><span class="math display">\[ Au = 
a_1 \ \lambda_1 \cdot [600,000, 400,000] + 
a_2 \ \lambda_2 \cdot [400,000, -400,000] \]</span></p>
<p><span class="math inline">\(\lambda_1\)</span> ve <span class="math inline">\(\lambda_2\)</span> nereden geldi? Özvektörlerin tanımından: <span class="math inline">\(Ax = \lambda x\)</span>. Üstteki kombinasyonda kullandıklarımız özvektör olduğuna göre, onların <span class="math inline">\(A\)</span> ile çarpılmış hali onların tekrar özdeğerle çarpılmış halini verecektir.</p>
<p>Ayrıca <span class="math inline">\(\lambda_1=1\)</span> olduğuna göre, onu denklemde göstermeye gerek bile yoktur (Markov matrisi içeren problemlerin bir güzel yan etkisi oldu bu). <span class="math inline">\(a_1\)</span> ve <span class="math inline">\(a_2\)</span> zaten 1 değerine eşitti, onları da atabiliriz. Yani,</p>
<p><span class="math display">\[ Au = 
[600,000, 400,000] + 
\lambda_2 \cdot [400,000, -400,000] \]</span></p>
<p>Şimdi geçiş işlemini birkaç kere üst üste yapalım:</p>
<p><span class="math display">\[ A^2u = 
[600,000, 400,000] + 
\lambda_2^2 \cdot [400,000, -400,000] \]</span></p>
<p><span class="math display">\[ A^3u = 
[600,000, 400,000] + 
\lambda_2^3 \cdot [400,000, -400,000] \]</span></p>
<p>...</p>
<p>Böyle devam edecek. <span class="math inline">\(\lambda_2=1/2\)</span> olduğuna göre, ve bu değer 1'den küçük olduğu için <span class="math inline">\(n\)</span> büyüdükçe <span class="math inline">\(\lambda_2^n\)</span> çok küçük bir sayı haline gelir, ve sıfıra yaklaşır. Yani üstteki denklemin sabit konum (steady-state) çözümü [600,000, 400,000] değeridir.</p>
<p>Örnek Problem</p>
<p><span class="math display">\[ 
\frac{du}{dt} = Au
 \]</span></p>
<p>problemini çözdüğümüzü farzedelim, ki <span class="math inline">\(u(t)\)</span> şöyle tanımlı</p>
<p><span class="math display">\[ 
u(t) =
\left[\begin{array}{r}
y(t) \\
z(t)
\end{array}\right]
 \]</span></p>
<p>Ayrı ayrı</p>
<p><span class="math display">\[ dy/dt = 2y - z \]</span></p>
<p><span class="math display">\[ dz/dt = -y + 2z \]</span></p>
<p>Matris formunda</p>
<p><span class="math display">\[ 
\frac{d}{dt}
\left[\begin{array}{r}
y \\
z
\end{array}\right]=
\left[\begin{array}{rr}
2 &amp; -1 \\
-1 &amp; 2
\end{array}\right]
\left[\begin{array}{r}
y \\
z
\end{array}\right]
 \]</span></p>
<p>ki yukarıdaki 2x2 matris <span class="math inline">\(A\)</span> matrisi olacak. <em>Lineer Cebir Ders 23</em>'te görüldüğü gibi bu problemin çözümü</p>
<p><span class="math display">\[ u = S e^{\Lambda t} S^{-1} u(0) \]</span></p>
<p>[1, sf. 53]'te bu problemin sadece</p>
<p><span class="math display">\[ u = S e^{\Lambda t} v(0) \]</span></p>
<p>noktasına kadar gelinip bırakıldığı bir bölüm var, bu bölümün sonucunu üstteki <span class="math inline">\(u\)</span> formülüne göre yineden türetelim. <span class="math inline">\(v(0) = \left[\begin{array}{cc} C &amp;  D \end{array}\right]^T\)</span> şeklinde bir vektör tanımlayalım, bunları başlangıç değerlerinin özvektörleri nasıl kombine ettiğini gösteriyor. <span class="math inline">\(A\)</span> matrisinin özdeğerleri <span class="math inline">\(\lambda_1=1\)</span> ve <span class="math inline">\(\lambda_2=3\)</span>, ona tekabül eden özvektörler <span class="math inline">\(\left[\begin{array}{cc} 1 &amp; 1 \end{array}\right]^T\)</span> ve <span class="math inline">\(\left[\begin{array}{cc}  1 &amp; -1 \end{array}\right]^T\)</span>. O zaman</p>
<p><span class="math display">\[ 
u(t) =
\left[\begin{array}{rr}
1 &amp; 1 \\
1 &amp; -1
\end{array}\right]
\left[\begin{array}{rr}
e^{\lambda_1 t} &amp; \\
&amp; e^{\lambda_2 t} 
\end{array}\right]
\left[\begin{array}{r}
C \\
D
\end{array}\right]
= 
\left[\begin{array}{r}
y(t) \\
z(t)
\end{array}\right]
 \]</span></p>
<p>Bu çarpımı ayrı ayrı yapınca çözümün kitapta gösterildiği gibi</p>
<p><span class="math display">\[        
\left[\begin{array}{r}
y(t) \\
z(t)
\end{array}\right]
=
\left[\begin{array}{r}
Ce^t + De^{3t} \\
Ce^t - De^{3t} 
\end{array}\right]
\]</span></p>
<p>olarak çıktığını göreceğiz.</p>
<p>Kaynaklar</p>
<p>[1] Strang, <em>Computational Science</em></p>
<p>[2] Bayramlı, Diferansiyel Denklemler, <em>Ders 9</em></p>
<p>[3] Bayramlı, Lineer Cebir, <em>Ders 23</em></p>
</body>
</html>
