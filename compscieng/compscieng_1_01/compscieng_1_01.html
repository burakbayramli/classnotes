<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Ders 1.1</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="ders-1.1">Ders 1.1</h1>
<p>Bu derste matrislerden bahsedilecek, onların canlanmasını, dile
gelmesini isxtiyoruz. Mesela alttaki gibi bir matris</p>
<p><span class="math display">\[
K =
\left[\begin{array}{rrrr}
2 &amp; -1 &amp; 0 &amp; 0\\
-1 &amp; 2 &amp; -1 &amp; 0\\
0 &amp; -1 &amp; 2 &amp; -1\\
0 &amp; 0 &amp; -1 &amp; 2
\end{array}\right]
\]</span></p>
<p>nedir? Nereden gelir? Bu matris bir şeyi temsil edecek, bilimsel bir
problemi çözmemizi sağlayacak.</p>
<p>Matrisin özelliklerine bakalım. İlk bakışta bunun simetrik bir matris
olduğunu görüyoruz. Yani <span class="math inline">\(K = K^T\)</span>.
Bu tür matrisler özellikle dengedeki sistemler (equilibrium)
problemlerinde çok ortaya çıkıyorlar. Başka özellikler? <span
class="math inline">\(K\)</span>’yi büyütseydik, seyrek (sparse)
olacaktı, yani içinde çok fazla sayıda sıfır olacaktı. Şu haliyle tam
seyrek denemez, ama aynı kalıpla büyütülürsek seyrek olur. Eğer Python
kullanarak sıfır olmayan elemanları saydırmak isteseydik, sonuç ne
gelecekti? 4x4 olan <span class="math inline">\(K\)</span> için alttaki
kod şu sonucu verir,</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> np.array([[<span class="dv">2</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>],[<span class="op">-</span><span class="dv">1</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>],</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">1</span>],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">2</span>]])</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (np.count_nonzero(K))</span></code></pre></div>
<pre><code>10</code></pre>
<p>4x4 = 16 içinden 10 eleman sıfır değildir. Eğer 100x100 olsaydı?
Matris aynı kalıbı takip ederse, yani çaprazı, ve çaprazın bir altı ve
bir üstü dolu kalırsa, çaprazda 100 eleman olur (boyutla aynı), alt ve
üstünde birer az eleman olur, yani 99+99 = 198. Toplayalım, 100 + 198 =
298. Yani 100x100 = 10000 eleman içinden 298 eleman sıfır değildir, geri
kalan bir sürü eleman sıfırdır. Matris seyrektir.</p>
<p>Sayısal hesaplamada yoğun (dense -sıfırı fazla olmayan-) matrisler,
büyük boyutlarda başımızı ağrıtabilir. Seyrek matrisleri daha hızlı
çözmenin yöntemleri vardır, ama 1 milyon x 1 milyon bir yoğun matris
çözmesi imkansız hale gelebilir.</p>
<p>Başka özellikler? Matris üçlü köşegen (tridiagonal) -üçlü köşegenlik,
matris çaprazı, onun bir üstü ve altı haricindeki tüm diğer elemanların
sıfır olduğu bir matristir-. Bu tür matrisler çok önemlidir, Newton
sağolsun, ikinci seviye diferansiyel denklemlerden sürekli ortaya
çıkarlar mesela.</p>
<p>Dahası? Bu bir Toeplitz matrisi, çaprazdaki değerler sabit değerler,
çapraz boyunca hiç değişmiyorlar. Bu matrislere lineer zamana göre
değişmeyen filtreler (linear time invariant filters) ismi de veriliyor,
çünkü her satır birbirinin aynı (ve hesabımızda satırların zamanı temsil
ettiği kabulünden hareketle). Python ile bir Toeplitz yaratmanın yöntemi
şöyle:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.linalg <span class="im">as</span> lin</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> lin.toeplitz([<span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (K)</span></code></pre></div>
<pre><code>[[ 2 -1  0  0]
 [-1  2 -1  0]
 [ 0 -1  2 -1]
 [ 0  0 -1  2]]</code></pre>
<p>100x100 için Toeplitz komutuna verdiğimiz tek satırda daha fazla
sıfır gerekli. İçinde tamamen sıfır olan bir vektör yaratırız, başındaki
birkaç elemanı istediğimiz değerle atarız.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.linalg <span class="im">as</span> lin</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>vec <span class="op">=</span> np.zeros((<span class="dv">1</span>,<span class="dv">100</span>))</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>vec[<span class="dv">0</span>,<span class="dv">0</span>] <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>vec[<span class="dv">0</span>,<span class="dv">1</span>] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (lin.toeplitz(vec))</span></code></pre></div>
<pre><code>[[ 2. -1.  0. ...  0.  0.  0.]
 [-1.  2. -1. ...  0.  0.  0.]
 [ 0. -1.  2. ...  0.  0.  0.]
 ...
 [ 0.  0.  0. ...  2. -1.  0.]
 [ 0.  0.  0. ... -1.  2. -1.]
 [ 0.  0.  0. ...  0. -1.  2.]]</code></pre>
<p>Seyrek matrislerle işlem yaptığımızı Python’a bir şekilde belirtmemiz
lazım, eğer mevcut haliyle bu matrisi çözmeye uğraşırsak, Python
sıfırlara gelene kadar onların sıfır olduğunu bilemeyecektir.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.sparse <span class="im">as</span> sparse</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.linalg <span class="im">as</span> lin</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>vec <span class="op">=</span> np.zeros((<span class="dv">1</span>,<span class="dv">100</span>))</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>vec[<span class="dv">0</span>,<span class="dv">0</span>] <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>vec[<span class="dv">0</span>,<span class="dv">1</span>] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> lin.toeplitz(vec)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> sparse.lil_matrix(K)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (A.shape)</span></code></pre></div>
<pre><code>(100, 100)</code></pre>
<p>Yanlız yukarıda yoğun matrisi önce yarattım, sonra onu değiştirerek
seyrek matris yarattım, daha iyisi baştan bir seyrek matris yaratmaktı.
Neyse, bu yöntemi ileri de göreceğiz.</p>
<p>Daha derine inelim şimdi. <span class="math inline">\(K\)</span>
matrisi tersi alınabilen (invertible) bir matris midir? Evet. Bu ne
demektir? <span class="math inline">\(KK^{-1} = I\)</span>, ve <span
class="math inline">\(I\)</span> matrisi birim (identity) matrisidir,
Python’da <code>np.eye(N)</code> komutuyla yaratılabilir.</p>
<p>Bir matrisin tersinin alınıp alınamayacağını nasıl anlayabiliriz? Bu
çok önemli, temel bir sorudur.</p>
<p>Bazılarının aklına determinantı hesaplamak gelebilir. Fakat benim ilk
seçimim bu değil, tercihim satır indirgemek (row reduce). Önümüzde bir
matris var, ve içinde neler olup bittiğini bilmiyoruz. Satır indirgeme
yapın.</p>
<p>Bu nasıl yapılır? <span class="math inline">\(K\)</span>’in
çaprazının altındaki -1 değerlerini sıfırlamak istiyorum. Orayı
temizlemek istiyorum, çünkü matrislerim eğer üçgensel (triangular) ise,
olan biteni anında görebilirim.</p>
<p>Birinci satırı ikiye bölüp, ikinci satıra eklerim. Terminoloji: 0,0
kordinatı (en üst sol köse) bu işlem sırasında pivot oldu.</p>
<p><span class="math display">\[
\left[\begin{array}{rrrr}
2 &amp; -1  &amp;  0 &amp; 0 \\
0 &amp;  3/2 &amp; -1 &amp;  0 \\
0 &amp; -1 &amp; 2 &amp; -1 \\
0 &amp;  0 &amp; -1 &amp; 2
\end{array}\right]
\]</span></p>
<p>Şimdi pivot 3/2, ve onun altındaki değeri temizlemek istiyoruz.
İkinci satırın 2/3’ünü alta eklersek, oradaki -1 sıfırlanır.</p>
<p><span class="math display">\[
\left[\begin{array}{rrrr}
2 &amp; -1 &amp; 0 &amp; 0 \\
0 &amp; 3/2 &amp; -1 &amp; 0 \\
0 &amp; 0 &amp; 4/3 &amp; -1 \\
0 &amp; 0 &amp; -1 &amp; 2
\end{array}\right]
\]</span></p>
<p>ve sonunda</p>
<p><span class="math display">\[
\left[\begin{array}{rrrr}
2 &amp; -1 &amp; 0 &amp; 0 \\
0 &amp; 3/2 &amp; -1 &amp; 0 \\
0 &amp; 0 &amp; 4/3 &amp; -1 \\
0 &amp; 0 &amp;  0 &amp; 5/4
\end{array}\right]
\]</span></p>
<p>Bu gerçekten hızlı bir işlem oldu. Python da determinantı zaten böyle
bulacaktı. Yoketme (elimination) kullanacaktı, teker teker -1’leri
yokedecekti. Peki determinantın değeri nedir? 5. Niye 5? Çünkü
elimizdeki artık üçgensel bir matris, ve böyle matrislerde çaprazdaki
elemanları birbiriyle çarpmakla determinant hemen hesaplanır. Python
aynen böyle yapacaktı, <span class="math inline">\(2 \cdot 3/2 \cdot 4/3
\cdot 5/4 = 5\)</span>.</p>
<p>Şimdi tersinin olup olmadığı sorusuna geri dönelim: Bir üst üçgensel
(upper triangular) matris ne zaman tersine çevirilebilir haldedir?
Determinant kelimesini kullanmamıza gerek yok, çapraza bakarız, eğer bu
çapraz sıfır değeri olmayan bir çapraz ise bu matris tersine
çevirilebilir demektir. Terminoloji: demek ki elimizde N tane (<span
class="math inline">\(K_4\)</span> için 4) tane sıfır olmayan pivot
var.</p>
<ol type="1">
<li>dersin amaçlarından biri matrislere isim vermek. <span
class="math inline">\(K\)</span> matrisi bunlardan biri, önemli bir
matris, onu ileride tekrar göreceğiz, görünce tanıyacağız.</li>
</ol>
<p><span class="math display">\[
C =
\left[\begin{array}{rrrr}
2 &amp; -1 &amp; 0 &amp; -1\\
-1 &amp; 2 &amp; -1 &amp; 0\\
0 &amp; -1 &amp; 2 &amp; -1\\
-1 &amp; 0 &amp; -1 &amp; 2\\
\end{array}\right]
\]</span></p>
<p>Peki şu matris? Toeplitz formunda ama üst sağ ve alt sol köşelerde
ekstra bir -1 değeri var. Fakat iddia ediyorum ki bu matris tersine
çevirebilir değil ve bunun için determinant, ya da yoketme tekniğine
gerek yok. Terminoloji: Matrise <span class="math inline">\(C\)</span>
denilmesi onun değerlerinin dairesel (circulant) olmasından ileri
geliyor. -1 değerlerine bakın, sanki bir yuvarlak oluşturuyorlar, sıfır
değerleri aynı şekilde.</p>
<p>Devam edelim: Diyelim ki <span class="math inline">\(C\)</span> bir
vektörü çarpıyor (zaten matrislerin tek amacı bu, vektörler ile
çarpılmak), ve ortaya sıfır vektörü çıkıyor. Boş olan vektör ne
olabilir?</p>
<p><span class="math display">\[ C =
\left[\begin{array}{rrrr}
2 &amp; -1 &amp; 0 &amp; -1\\
-1 &amp; 2 &amp; -1 &amp; 0\\
0 &amp; -1 &amp; 2 &amp; -1\\
-1 &amp; 0 &amp; -1 &amp; 2\\
\end{array}\right]
\left[\begin{array}{r}
\\
\\
\\
\\
\end{array}\right]
=
\left[\begin{array}{r}
0\\
0\\
0\\
0
\end{array}\right]
\]</span></p>
<p>Şu olabilir</p>
<p><span class="math display">\[ C =
\left[\begin{array}{rrrr}
2 &amp; -1 &amp; 0 &amp; -1\\
-1 &amp; 2 &amp; -1 &amp; 0\\
0 &amp; -1 &amp; 2 &amp; -1\\
-1 &amp; 0 &amp; -1 &amp; 2\\
\end{array}\right]
\left[\begin{array}{r}
1\\
1\\
1\\
1\\
\end{array}\right]
=
\left[\begin{array}{r}
0\\
0\\
0\\
0
\end{array}\right]
\]</span></p>
<p>İddia ediyorum ki böyle bir vektörün olabilmesi <span
class="math inline">\(C\)</span>’nin tersine çevirilebilir olma
olasılığını yoketti. Nasıl?</p>
<p>Eğer <span class="math inline">\(C\)</span>’nin tersi olabilseydi,
<span class="math inline">\(Cu = 0\)</span> denklemi ne olurdu? İki
tarafı bu “olabilen’’ <span class="math inline">\(C^{-1}\)</span> ile
çarpıp sonuca bakalım:</p>
<p><span class="math display">\[ C^{-1}Cu = C^{-1}0 \]</span></p>
<p><span class="math display">\[ I u = 0 \]</span></p>
<p><span class="math display">\[ u = 0 \]</span></p>
<p>Yani eğer <span class="math inline">\(C\)</span>’nin tersi olsaydı,
<span class="math inline">\(Cu = 0\)</span> denkleminin tek sonucu <span
class="math inline">\(u=0\)</span> olurdu. Fakat bu böyle değildir,
üstte içinde 1 olan vektör bunun kanıtı. O zaman bir uyuşmazlık,
absürtlük elde ettik, demek ki <span
class="math inline">\(C\)</span>’nin tersi olduğu iddiası yanlıştır.</p>
<p>Fiziksel olarak <span class="math inline">\(K\)</span> ve <span
class="math inline">\(C\)</span>’yi kütle ve yay sistemi olarak kabul
edebiliriz. Mesela <span class="math inline">\(K\)</span> şöyle bir
sistemi temsil edebilir:</p>
<p><img src="1_5.png" /></p>
<p>Yuvarlak olan <span class="math inline">\(C\)</span> sistemi şunu
temsil edebilir</p>
<p><img src="1_6.png" /></p>
<p>Resimdeki noktalar kütleler, ve yaylar o kütleleri birbirine
bağlıyorlar.</p>
<p><span class="math inline">\(T\)</span> Matrisi</p>
<p>Bu matris <span class="math inline">\(K\)</span>’ye benzer, fakat en
üst satırda 2 yerine 1 var.</p>
<p><span class="math display">\[
\left[\begin{array}{rrrr}
1 &amp; -1 &amp; 0 &amp; 0\\
-1 &amp; 2 &amp; -1 &amp; 0\\
0 &amp; -1 &amp; 2 &amp; -1\\
0 &amp; 0 &amp; -1 &amp; 2
\end{array}\right]
\]</span></p>
<p>Kütle ve yay sistemine dönersek bu matris bir ucu serbest olan bir
mekanik sistemi gösterebilir.</p>
<p>B Matrisi</p>
<p><span class="math display">\[
\left[\begin{array}{rrrr}
1 &amp; -1 &amp; 0 &amp; 0\\
-1 &amp; 2 &amp; -1 &amp; 0\\
0 &amp; -1 &amp; 2 &amp; -1\\
0 &amp; 0 &amp; -1 &amp; 1
\end{array}\right]
\]</span></p>
<p>Bu sistem de her iki ucu da serbest olan bir sistemdir. Bu sistemi
alıp istediğimiz yere götürebiliriz.</p>
<p>Son iki matrisin ikisi de simetriktir, üçgensel ve köşegen (diagonal)
matrislerdir. Niye üçgensel ve köşegen? Çünkü her kütle sağ ve solunda
tek bir (diğer) kütleye bağlıdır, o yüzden bağlı olmadığı kütlelere olan
matris değeri 0 olarak gösterilir, bu da bir üçgensel köşegen sistem
ortaya çıkarır.</p>
<p>Ama T ve B artık Toeplitz değildir.</p>
<p>Bu noktada sınır şartları (boundary conditions) kavramına vurgu
yapmakta yarar var. Mekanik sistemde üçün ne olduğu matrislere sınır
şartı olarak yansıyor. Ve bu şartlar bir sistemin çözülmesinde son
derece önemli. Hoca kendisine bir problemle gelenlere genelde ilk önce
bu soruyu soruyor o yüzden: “sınır şartların ne?’’.</p>
<p>Tersine çevirilme durumu? T tersine çevirilebilir, B çevirilemez. B
için yine aynı <span class="math inline">\(u = \left[\begin{array}{cccc}
1 &amp; 1 &amp; 1 &amp; 1 \end{array}\right]^T\)</span> ispatını
kullanabiliriz.</p>
<p>K, T, B, C matrislerini aynı anda yaratan bir Python programı şurada.
Kullanım mesela 4x4 boyutları için <code>K, T, B, C = ktbc(4)</code>
şeklinde, bu bize tüm özel matrisleri bir kerede oluşturuyor.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.linalg <span class="im">as</span> lin</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ktbc(n):</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    vec <span class="op">=</span> np.zeros((<span class="dv">1</span>,n))</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    vec[<span class="dv">0</span>,<span class="dv">0</span>] <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    vec[<span class="dv">0</span>,<span class="dv">1</span>] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    K <span class="op">=</span> lin.toeplitz(vec)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> np.copy(K)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    T[<span class="dv">0</span>,<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> np.copy(K)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    B[<span class="dv">0</span>,<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    B[n<span class="op">-</span><span class="dv">1</span>,n<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    C <span class="op">=</span> np.copy(K)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    C[n<span class="op">-</span><span class="dv">1</span>,n<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> K, T, B, C</span></code></pre></div>
<p>Kapatırken şu özellikleri de ekleyelim.</p>
<p>K, T pozitif kesin (positive definite) matrislerdir.</p>
<p>C, B pozitif yarı-kesin (positive semi-definite) matrislerdir.</p>
<p>Eğer simetrik bir matrisim var ise ve pivotların hepsi pozitif ise, o
matris hem tersine çevirelebilir, hem de pozitif kesin demektir. Yani
bir matrise bakarız, yoketme tekniğini uygularız sonra pivotlarına
bakarız.</p>
<p>Pozitif kesinlik çok önemli bir kavramdır, lineer cebirin tamamını
biraraya getirir sanki, özdeğerlere (eigenvalue) bağlıdır, least square
yöntemine bağlıdır, determinantlar. Her yerden çıkar.</p>
<p>Geriye Doğru Farklılık Matrisi</p>
<p>Python <code>toeplitz</code> çağrısının değişik bir şekilde
kullanarak geriye doğru farklılık (backward difference) matrisi de
yaratabiliriz. Bu kullanımda matrisin sol kolonunu, ve üst satırını
tamamen belirtmek gerekiyor.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.linalg <span class="im">as</span> lin</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> lin.toeplitz([<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (D)</span></code></pre></div>
<pre><code>[[ 1  0  0  0]
 [-1  1  0  0]
 [ 0 -1  1  0]
 [ 0  0 -1  1]]</code></pre>
<p>Çözülmüş Soru 1.1 B</p>
<p>Soru: <span class="math inline">\(T\)</span> matrisini <span
class="math inline">\(H\)</span> matrisine çevir bunu <span
class="math inline">\(J\)</span> matrisini kullanarak yap.</p>
<p><span class="math display">\[ H =
\left[\begin{array}{rrr}
2 &amp; -1 &amp;  0\\
-1 &amp; 2 &amp; -1\\
0 &amp; -1 &amp; 1
\end{array}\right]
\]</span></p>
<p><span class="math display">\[ T =
\left[\begin{array}{rrr}
1 &amp; -1 &amp;  0\\
-1 &amp; 2 &amp; -1\\
0 &amp; -1 &amp; 2
\end{array}\right]
\]</span></p>
<p>Kitaptaki bu sorunun çözümündeki <span
class="math inline">\(J\)</span> matrisi birimsel matrisin tersidir, şu
şekildedir:</p>
<p><span class="math display">\[
\left[\begin{array}{rrr}
0 &amp; 0 &amp; 1\\
0 &amp; 1 &amp; 0\\
1 &amp; 0 &amp; 0
\end{array}\right]
\]</span></p>
<p>Yani 1 sayıları sola yatık çaprazda değil sağa yatik çaprazda. Bu
matrisin çarpım işlemi sırasında ilginç etkileri var. Eğer sağdan
çarpılırsa bir matrisin her satırının içindeki sırayı tersine çeviriyor.
Eğer soldan çarpılırsa her kolon içindeki sırayı tersine çeviriyor.
<span class="math inline">\(J*T*J\)</span> çarpımı aradığımız sonuç.
Yani satırları çevirdikten sonra, kolonları çevirince istediğimiz sonuca
erişiyoruz. Python kodları</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.linalg <span class="im">as</span> lin</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> lin.toeplitz([<span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>])</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>T[<span class="dv">0</span>,<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>J <span class="op">=</span> np.fliplr(np.eye(<span class="dv">3</span>))</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (T)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (np.dot(T,J))</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (np.dot(J, np.dot(T,J)))</span></code></pre></div>
<pre><code>[[ 1 -1  0]
 [-1  2 -1]
 [ 0 -1  2]]
[[ 0. -1.  1.]
 [-1.  2. -1.]
 [ 2. -1.  0.]]
[[ 2. -1.  0.]
 [-1.  2. -1.]
 [ 0. -1.  1.]]</code></pre>
<p>Soru 1.1 2</p>
<p><span class="math inline">\(T_3^{-1}\)</span> hesabını üç basamakta
yap ve bunu yaparken daha önce gördüğümüz <span
class="math inline">\(U\)</span> ve <span
class="math inline">\(U^{-1}\)</span> matrislerini kullan.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.linalg <span class="im">as</span> lin</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> lin.toeplitz([<span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>])</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>T[<span class="dv">0</span>,<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>],</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">0</span>, <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>],</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>]])</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (np.dot(U.T,U))</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (np.dot(U,lin.inv(U)))</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (np.dot(lin.inv(U), lin.inv(U).T))</span></code></pre></div>
<pre><code>[[ 1 -1  0]
 [-1  2 -1]
 [ 0 -1  2]]
[[1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]]
[[3. 2. 1.]
 [2. 2. 1.]
 [1. 1. 1.]]</code></pre>
<p>Soru 1.1.5</p>
<p><span class="math inline">\(K_3\)</span> ve <span
class="math inline">\(K_4\)</span>’un tersini al (<span
class="math inline">\(K_2\)</span>’yi de bir zahmet), ve şu kesirler
olsun</p>
<p><span class="math display">\[ \frac{1}{det} = \frac{1}{4}
\frac{1}{5}\]</span>.</p>
<p><span class="math display">\[
K_3^{-1} = \frac{1}{4}
\left[\begin{array}{rrr}
3 &amp; 2 &amp; 1 \\
2 &amp; 4 &amp; 2 \\
1 &amp; 2 &amp; 3
\end{array}\right]
\quad \textrm{ve} \quad
K_4^{-1} = \frac{1}{5}
\left[\begin{array}{rrrr}
4 &amp; 3 &amp; 2 &amp; 1 \\
3 &amp; 6 &amp; 4 &amp; 2 \\
2 &amp; 4 &amp; 6 &amp;  3 \\
1 &amp; 2 &amp; 3 &amp; 4
\end{array}\right]
\]</span></p>
<p>İlk önce <span class="math inline">\(K=K_5\)</span> determinantını
tahmin edin. Sonra <span class="math inline">\(\det(K)\)</span> ve <span
class="math inline">\(inv(K)\)</span>’yi hesaplayın ve <span
class="math inline">\(\det(K) * inv(K)\)</span> hesabını yapın.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.linalg <span class="im">as</span> lin</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>K, T, B, C <span class="op">=</span> ktbc(<span class="dv">3</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (lin.inv(K))</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (lin.det(K))</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (lin.det(K) <span class="op">*</span> lin.inv(K))</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>K, T, B, C <span class="op">=</span> ktbc(<span class="dv">5</span>)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (lin.det(K))</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (lin.inv(K))</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (lin.det(K) <span class="op">*</span> lin.inv(K))</span></code></pre></div>
<pre><code>[[0.75 0.5  0.25]
 [0.5  1.   0.5 ]
 [0.25 0.5  0.75]]
4.0
[[3. 2. 1.]
 [2. 4. 2.]
 [1. 2. 3.]]
6.0
[[0.83333333 0.66666667 0.5        0.33333333 0.16666667]
 [0.66666667 1.33333333 1.         0.66666667 0.33333333]
 [0.5        1.         1.5        1.         0.5       ]
 [0.33333333 0.66666667 1.         1.33333333 0.66666667]
 [0.16666667 0.33333333 0.5        0.66666667 0.83333333]]
[[5. 4. 3. 2. 1.]
 [4. 8. 6. 4. 2.]
 [3. 6. 9. 6. 3.]
 [2. 4. 6. 8. 4.]
 [1. 2. 3. 4. 5.]]</code></pre>
<p>Soru 1.1.22</p>
<p>Çözülmesi istenen denklem <span class="math inline">\(du^2/dx^2 =
1\)</span>, elastik çubuk problemi ve çubuğun iki tarafı
sabitlenmiş.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.sparse <span class="im">as</span> sparse</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.sparse.linalg</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.linalg <span class="im">as</span> lin</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>vec <span class="op">=</span> np.zeros((<span class="dv">1</span>,n))</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>vec[<span class="dv">0</span>,<span class="dv">0</span>] <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> vec[<span class="dv">0</span>,<span class="dv">1</span>] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> lin.toeplitz(vec)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> sparse.csc_matrix(K)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>e <span class="op">=</span> np.ones((n,<span class="dv">1</span>))</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> sparse.linalg.spsolve(A,e)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>plt.plot(u)</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;1-1-22.png&#39;</span>)</span></code></pre></div>
<p><img src="1-1-22.png" /></p>
<p>Sonuç üstteki grafik gibi olmalı. Yani çözümümüz olan <span
class="math inline">\(u\)</span> değerleri bir parabol oluşturuyorlar.
Bu demektir ki çubuğun orta noktaları daha fazla yer değiştiriyor, uç
noktaları daha az yer değiştiriyor.</p>
<p>Elastik Çubuk</p>
<p>Derste çokça kullanılan elastik çubuk kavramından şimdi bahsetmek iyi
olur. Bu çubuk tek boyutlu ve sadece boyuna doğru (yana doğru değil)
uzayıp kısalabilen matematiksel bir kurgu. Bu çubuğu hayalimizde
birbirine zincirler ile bağlı sonsuz sayıda ufak parcaçığın toplamı
olarak düşünebiliriz. <span class="math inline">\(x\)</span> ve <span
class="math inline">\(u(x)\)</span> bağlamında ise çubuğun iki kere
fotoğrafının çekildiğini düşünelim. İlk fotoğrafta <span
class="math inline">\(x\)</span> bu çubuğun üzerindeki bir parcaçık.
<span class="math inline">\(u(x)\)</span> ise tüm ağırlıklar, kuvvetler
etkilerini gösterip uzama, kısalma bitince çekilen <em>ikinci</em>
fotoğrafta ilk resimdeki <span class="math inline">\(x\)</span>
noktasının ne kadar yer değiştirmiş olduğu.</p>
<p><img src="1_7.png" /></p>
<p>“Ucu sabitlemek’’ gibi kavramlar duyacağız, bunlar bazen fiziksel
olarak anlamlı, bazen ise ikinci fotoğrafta esneme sonrası hangi noktaya
gelindiğinin önceden belirlenmesi anlamında. <span
class="math inline">\(du/dx\)</span> gibi bir türevi irdelerken ise
ortada zaman olmadığını dikkate alalım, türev <span
class="math inline">\(x\)</span>’e göre yani ilk resimdeki parcaçıgin
yeri. O zaman <span class="math inline">\(du/dx\)</span> ikinci
resimdeki esnemenin çubuktaki yer arttıkça (aşağı indikçe) ne kadar
değiştiği.</p>
<p>Denklemin sağında yer alan değerler, sisteme dışarıdan verilen güç
olarak görülebiliyor, hakikaten de değişimin ikinci türevi ivmedir.
1.2.22 sorusunu görsel olarak nasıl hayal edebiliriz? Çubuğun iki ucu
sabitlenmiş, o sebeple K matrisi kullanıyoruz zaten, böylece sınır
şartları dahil oluyor.</p>
<p>Python, VPython üzerinden kullanılabilecek KineticsKit adlı paket
sistemi zihinde canlandırmak için yardımcı olabilir. Birbirine eşit
uzaklıkta, aynı kütlede ve arasında yaylar olan 7 tane topu bırakınca ne
olduğunu simüle edebiliriz. Resimdeki sol kısım başlamadan önce, sağ
kısım yerçekimi işini bitirdikten ve toplar durduktan sonrasını
gösteriyor.</p>
<p><img src="elastic_uniform_load.png" /></p>
<p>Alttaki program hem görsel simülasyonu yapacak, hem de topların önce
ve sonra değerlerini hatırlayarak yerçekimi sonrası aradaki farkı
hesaplayacak. Sonuçlara bakınca hakikaten de ortadaki topların daha
fazla hareket ettiğini görebiliyoruz. Grafiksel olarak düşünürsek te
mantıklı, üste yakın toplar üstten bağlı oldukları için fazla
uzaklaşamıyorlar, ortalara yakın toplar, bir üstlerinden de aldıkları ek
mesafe sayesinde daha fazla yer değiştirebiliyor. Ama alt kısıma
yaklaştıkça orada bir birikme oluyor, çünkü alt üç kısım da
sabitlenmiş.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> KineticsKit <span class="im">import</span> <span class="op">*</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> visual <span class="im">import</span> vector</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>system <span class="op">=</span> System(timestep<span class="op">=</span><span class="fl">0.04</span>, gravity<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>mass1 <span class="op">=</span> Mass(m<span class="op">=</span><span class="fl">0.1</span>, pos<span class="op">=</span>(<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>), fixed<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>mass2 <span class="op">=</span> Mass(m<span class="op">=</span><span class="fl">0.1</span>, pos<span class="op">=</span>(<span class="fl">0.0</span>, <span class="fl">0.5</span>, <span class="fl">0.0</span>))</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>mass3 <span class="op">=</span> Mass(m<span class="op">=</span><span class="fl">0.1</span>, pos<span class="op">=</span>(<span class="fl">0.0</span>, <span class="fl">1.0</span>, <span class="fl">0.0</span>))</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>mass4 <span class="op">=</span> Mass(m<span class="op">=</span><span class="fl">0.1</span>, pos<span class="op">=</span>(<span class="fl">0.0</span>, <span class="fl">1.5</span>, <span class="fl">0.0</span>))</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>mass5 <span class="op">=</span> Mass(m<span class="op">=</span><span class="fl">0.1</span>, pos<span class="op">=</span>(<span class="fl">0.0</span>, <span class="fl">2.0</span>, <span class="fl">0.0</span>))</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>mass6 <span class="op">=</span> Mass(m<span class="op">=</span><span class="fl">0.1</span>, pos<span class="op">=</span>(<span class="fl">0.0</span>, <span class="fl">2.5</span>, <span class="fl">0.0</span>))</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>mass7 <span class="op">=</span> Mass(m<span class="op">=</span><span class="fl">0.1</span>, pos<span class="op">=</span>(<span class="fl">0.0</span>, <span class="fl">3.0</span>, <span class="fl">0.0</span>), fixed<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>system.insertMass(mass1)</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>system.insertMass(mass2)</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>system.insertMass(mass3)</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>system.insertMass(mass4)</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>system.insertMass(mass5)</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>system.insertMass(mass6)</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>system.insertMass(mass7)</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>spring1 <span class="op">=</span> SingleHelixSpring(m0<span class="op">=</span>mass1, m1<span class="op">=</span>mass2, k<span class="op">=</span><span class="dv">1</span>, damping<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>system.insertSpring(spring1)</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>spring2 <span class="op">=</span> SingleHelixSpring(m0<span class="op">=</span>mass2, m1<span class="op">=</span>mass3, k<span class="op">=</span><span class="dv">1</span>, damping<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>system.insertSpring(spring2)</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>spring3 <span class="op">=</span> SingleHelixSpring(m0<span class="op">=</span>mass3, m1<span class="op">=</span>mass4, k<span class="op">=</span><span class="dv">1</span>, damping<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>system.insertSpring(spring3)</span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>spring4 <span class="op">=</span> SingleHelixSpring(m0<span class="op">=</span>mass4, m1<span class="op">=</span>mass5, k<span class="op">=</span><span class="dv">1</span>, damping<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a>system.insertSpring(spring4)</span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>spring5 <span class="op">=</span> SingleHelixSpring(m0<span class="op">=</span>mass5, m1<span class="op">=</span>mass6, k<span class="op">=</span><span class="dv">1</span>, damping<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>system.insertSpring(spring5)</span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>spring5 <span class="op">=</span> SingleHelixSpring(m0<span class="op">=</span>mass6, m1<span class="op">=</span>mass7, k<span class="op">=</span><span class="dv">1</span>, damping<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a>system.insertSpring(spring5)</span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a>loc_1 <span class="op">=</span> [mass2.sphere.pos.y, mass3.sphere.pos.y, </span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>         mass4.sphere.pos.y, mass5.sphere.pos.y, </span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a>         mass6.sphere.pos.y]</span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a>count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="dv">1</span>:</span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a>    system.step()</span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a>    count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> count <span class="op">==</span> <span class="dv">100</span>: <span class="cf">break</span></span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true" tabindex="-1"></a>loc_2 <span class="op">=</span> [mass2.sphere.pos.y, mass3.sphere.pos.y, </span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true" tabindex="-1"></a>         mass4.sphere.pos.y, mass5.sphere.pos.y, </span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true" tabindex="-1"></a>         mass6.sphere.pos.y]</span>
<span id="cb19-49"><a href="#cb19-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-50"><a href="#cb19-50" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> izip</span>
<span id="cb19-51"><a href="#cb19-51" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x,y <span class="kw">in</span> izip(loc_1, loc_2):</span>
<span id="cb19-52"><a href="#cb19-52" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span> x<span class="op">-</span>y</span>
<span id="cb19-53"><a href="#cb19-53" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-54"><a href="#cb19-54" aria-hidden="true" tabindex="-1"></a>      </span></code></pre></div>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
