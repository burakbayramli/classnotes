<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>

  <title>Sonlu Öğeler Metotu (Finite Elements Method -FEM-), Sürekli (Continuous) Yaklaşım</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  
  
  
  
</head>
<body>
<h1 id="sonlu-öğeler-metotu-finite-elements-method--fem--sürekli-continuous-yaklaşım">Sonlu Öğeler Metotu (Finite Elements Method -FEM-), Sürekli (Continuous) Yaklaşım</h1>
<p>Mittal</p>
<p>Fonksiyonların İç Çarpımı (Inner Product)</p>
<p>Vektörlerden bildiğimiz çoğu tekniği fonksiyonlara uygulamak mümkündür [3]. Elimizde <span class="math inline">\(f(x), g(x), ...\)</span> reel değerli, <span class="math inline">\(\alpha \le x \le \beta\)</span> aralığında tanımlı fonksiyonları olduğunu düşünelim, bu fonksiyonlar bir reel vektör uzayı oluştururlar. Şimdi <span class="math inline">\((f,g)\)</span> iç çarpımını düşünelim, ki bu çarpım tanımı</p>
<p><span class="math display">\[
(f,g) = \int_{\alpha}^{\beta} f(x) g(x) \mathrm{d} x
\]</span></p>
<p>olsun. Üstteki bizim tanımımız tabii, başkaları ekler yapabilirler, mesela bazıları iç çarpıma bir ağırlıklama fonksiyonu <span class="math inline">\(w\)</span> ekliyorlar, yani üstteki entegralde <span class="math inline">\(f,g\)</span> ve <span class="math inline">\(w\)</span> çarpılıyor. Bizim dersimizin amaçları için biz gördüğümüz tanımla yetineceğiz.</p>
<p>Üstteki entegral lineer. Simetrik olduğu bariz. Ayrıca kesin artı (positive definite) özelliği de var.</p>
<p>Eldeki iç çarpım tanımıyla artık &quot;bir fonksiyonun uzunluğu'' bile hesaplanabiliyor, aynen vektörlerin uzunluğunun hesaplanabildiği gibi.</p>
<p><span class="math display">\[
|| f || = \sqrt{ (f,f) } =
\sqrt{\int_{\alpha}^{\beta} f(x) f(x) \mathrm{d} x } =
\sqrt{\int_{\alpha}^{\beta} [f(x)]^2 \mathrm{d} x }
\]</span></p>
<p>Bu sayede birim fonksiyonlar bile yaratabilirim, mesela <span class="math inline">\(f(x)\)</span>'i uzunluğu <span class="math inline">\(||f(x)||\)</span> ile bölersem onu normalize etmiş olurum, yani uzunluğu bire inmiş olur, <span class="math inline">\(g\)</span>, <span class="math inline">\(h\)</span>, vs ile bunu aynı şekilde gerçekleştirebilirim.</p>
<p>Tamlık (Completeness)</p>
<p>Bir <span class="math inline">\(\alpha \le x \le \beta\)</span> aralığında tanımlı fonksiyonlar kümesi <span class="math inline">\(S\)</span> olsun. Ayrıca <span class="math inline">\(y_0,y_1,..\)</span> aynı <span class="math inline">\(S\)</span> kümesinde tanımlı birimdik (orthonormal) fonksiyonlar olsun (yani her <span class="math inline">\(y_i\)</span> fonksiyonun birbiri ile iç çarpımı sıfır sonucu verecek). Bu birimdik fonksiyonlar kümesine tam denir eğer herhangi bir <span class="math inline">\(f \in S\)</span>'i o baz fonksiyonların lineer kombinasyonu olarak yaklaşık şekilde temsil edebiliyorsam. Yaklaşıklık derecesi benim tanımladığım <span class="math inline">\(\epsilon &gt; 0\)</span> ile ölçülecektir, ve kaç tane fonksiyonu kombine ettiğim de yine benim tarafımdan tanımlı olacaktır. Yaklaşıklık</p>
<p><span class="math display">\[
|| f - (k_0 y_0 + k_1 y_1 + k_2 y_2 + ... + k_m y_m)  || &lt; \epsilon
\]</span></p>
<p>ile ölçülebilir.</p>
<p>Not: Birimdiklik tamlık için şart değil, fakat birimdiklik bazı rahat işlemler yapabilmemizi sağlar, o bakımdan tercih edilir.</p>
<p>Örnek</p>
<p><span class="math inline">\(-\pi \le x \le \pi\)</span> arasında tanımlı bir <span class="math inline">\(f(x)\)</span> olsun. O zaman Fourier fonksiyonları <span class="math inline">\(1\)</span>, <span class="math inline">\(\sin x\)</span>, <span class="math inline">\(\cos x\)</span>, <span class="math inline">\(\sin 2x\)</span>, <span class="math inline">\(\cos 2x\)</span>, ... bir tam küme oluştururlar. Çünkü <span class="math inline">\(-\pi \le x \le \pi\)</span> arasında bana verilen herhangi bir fonksiyonu Fourier fonksiyonlarının bir kombinasyonu olarak temsil edebilirim, ya da doğru terminoloji kullanmak gerekirse, onu bir &quot;Fourier Serisi'' olarak temsil edebilirim. Görülen o her birimdik fonksiyonu <span class="math inline">\(a_0\)</span>, <span class="math inline">\(b_0\)</span>, <span class="math inline">\(a_1\)</span>, <span class="math inline">\(b_1\)</span>, .. sabitleriyle çarpıp toplarım ve yaklaşık temsili yaparım, tabii katsayıların ne olduğunu bulmam gerekir, doğru olanlarını bulunca <span class="math inline">\(f\)</span>'yi iyi temsil etmiş olurum. Seriyi uzattıkça, daha fazla Fourier terimi ekledikçe, <span class="math inline">\(f\)</span>'ye daha da yaklaşırım, benden beklenen <span class="math inline">\(\epsilon\)</span> yakınlığını böylece elde edebilirim. Mesela kabaca bir yaklaşıklık için 4-5 tane terim, çok iyi olması için yüzlerce.</p>
<p>Örnek</p>
<p>Herhangi bir küpsel polinomu temsil etmek bağlamında <span class="math inline">\(1,x,x^2,x^3\)</span> bir tam küme oluşturur. Fakat bu küme yegane küme mi? Hayır. Mesela <span class="math inline">\(5\)</span>, <span class="math inline">\(3+x\)</span>, <span class="math inline">\(9 + 2x + 6x^2\)</span>, <span class="math inline">\(5x + 20x^2\)</span> kümesi de tamdır.</p>
<p>Tam küme öğelerinin bir özelliğine dikkat çekmek gerekir, onların birini diğerlerinin lineer kombinasyonu olarak temsil etmek mümkün değildir. Mesela <span class="math inline">\(x^3\)</span>'u <span class="math inline">\(1\)</span>, <span class="math inline">\(x\)</span>, <span class="math inline">\(x^2\)</span>'yi lineer olarak birleştirerek erisemem.</p>
<p>Örnek</p>
<p>Bu örnekte tam olmayan bir kümeye bakalım. Mesela küpsel polinomları temsil etmek için <span class="math inline">\(1,x,x^3\)</span> tam değildir, çünkü <span class="math inline">\(x^2\)</span> eksik. Mesela üstteki <span class="math inline">\(9 + 2x + 6x^2\)</span> fonksiyonu.. onu eldeki bu baz ile temsil edemem çünkü <span class="math inline">\(x^2\)</span> bazı yok. Evet <span class="math inline">\(x^3\)</span> var ama oradan &quot;aşağı inerek'' karesel temsil yapmak mümkün değil, en azından benden istenen <span class="math inline">\(\epsilon\)</span> yakınlığında, ve lineer kombinasyonlar kullanarak bunu yapmak mümkün değil.</p>
<p>Teori</p>
<p><span class="math inline">\(y_0,y_1,y_2,..\)</span> fonksiyonları <span class="math inline">\(S\)</span> kümesi için, <span class="math inline">\(\alpha \le x \le \beta\)</span> aralığında tanımlı, tam, ve birimdik (bu sefer şart) bir küme olsun. O zaman <span class="math inline">\(f \in S\)</span> bir sürekli fonksiyon ise ve her <span class="math inline">\(y_m\)</span>'e dikgen ise bu demektir ki <span class="math inline">\(f\)</span> muhakkak sıfırdır.</p>
<p>Mesela iki boyutta basit bir örnek üzerinde görelim; iki birimdik baz var, <span class="math inline">\(x\)</span> ve <span class="math inline">\(y\)</span> üzerinde kalın çizgi ile gösterdiğim, <span class="math inline">\(i,j\)</span> diyelim, şimdi bir <span class="math inline">\(A\)</span> vektörü düşünelim, bu vektör çizildiği haliyle tabii, birimdik <span class="math inline">\(i,j\)</span> kombinasyonu ile temsil edilebilir. Fakat şimdi düşünelim, eğer <span class="math inline">\(A\)</span> hem <span class="math inline">\(i\)</span>'ye hem <span class="math inline">\(j\)</span>'ye dikgen olsaydı, yani öyle bir vektör olsaydı ki ne <span class="math inline">\(x\)</span> ne <span class="math inline">\(y\)</span> üzerinde hiçbir yansıması olmasaydı, bu <span class="math inline">\(A\)</span> sıfırdan başka bir şey olamazdı, değil mi? Üstteki teorinin söylediği bundan ibaret.</p>
<div class="figure">
<img src="compscieng_app45aerofem1_03.png" />

</div>
<p>Ağırlıklı Artıklar Metotu (Weighted Residual Method -WRM-)</p>
<p>Önceki derste iyi koşullu bir sistemi elde etmeyi gördük, bu kötü koşullu (ill conditioned) olmanın tersi tabii. Bu derste WRM'yi kurmayı göreceğiz [1], ki bu metot aslında kapsayıcı bir tarif, altında farklı hesap yöntemleri de olabiliyor, WRM'nin kendisi hata kontrolünü nasıl yapacağımızı tarif ediyor.</p>
<p>Basit bir problemle başlayalım. Laplace formülü mesela, iki boyutu baz alalım, ama birazdan göreceğimiz fikirler 1D ya da 3D için de geçerli. Problem bölgesi (domain) <span class="math inline">\(\Omega\)</span> olsun onun sınırları <span class="math inline">\(\Gamma\)</span>,</p>
<div class="figure">
<img src="compscieng_app45aerofem1_01.png" />

</div>
<p>İlgilendiğimiz alan (field) <span class="math inline">\(T(x,y)\)</span>, bu reel değerli bir fonksiyon, ve kurduğumuz sistem için bu fonksiyonun şu şartlara tabi olmasını istiyoruz,</p>
<p><span class="math display">\[
\nabla^2 T = 0 \quad \Omega \textrm{ üzerinde } 
\]</span></p>
<p><span class="math display">\[
\Gamma \textrm{ için } T = T_0
\]</span></p>
<p>Bu tür problemlere Drichlet problemleri deniyor.</p>
<p>Üstteki şartları yerine getiren bir <span class="math inline">\(T(x,y)\)</span> çözümü bulmak istiyoruz. O zaman ilk akla gelen nedir? Diferansiyel denklemi alıyorum ve <span class="math inline">\(\Omega\)</span> içindeki tüm noktalar için çözmeye uğraşıyorum. Fakat bu kolay değil. Ayrıca <span class="math inline">\(\Omega\)</span>'daki eşitlik <span class="math inline">\(\Gamma\)</span> sınırında geçerli değil, ikinci şart sebebiyle. Bu arada matematiksel olarak çözüm nedir? <span class="math inline">\(\Omega\)</span>'daki sonsuz tane nokta için geçerli olan şeydir. Buna kesin çözüm (exact solution) deniyor.</p>
<p>Fakat bu çözümü bulmak mümkün değilse, ya da yaklaşık bir çözüm de yeterli oluyorsa o zaman yaklaşık yöntemler kullanabilirim.. <span class="math inline">\(\nabla^2 T = 0\)</span> eşitliği <span class="math inline">\(\Omega\)</span>'daki her nokta için, her <span class="math inline">\(\Gamma\)</span> sınır şartında değil belli seçilmiş noktalarda olsun diyebilirim.</p>
<p>Ama &quot;belli noktalarda'' deyince de iş bitmiyor, o seçilmiş noktalarda kesin çözüm mü yapsam, yoksa o noktalarda da yaklaşık çözüm yapsam? Ya da tüm noktalarda yaklaşık çözüm üzerinden bir hata hesaplayıp, tüm seçilmiş noktalarla hesaplanan ortalama bir hatanın sıfır olması için mi uğraşsam?</p>
<p>Şöyle bir yöntem deneyelim; elimizde / verili belli bir baz fonksiyon &quot;sınıfı'' olsun, bu fonksiyonlar Fourier bazı <span class="math inline">\(\sin\)</span>, <span class="math inline">\(\cos\)</span> olabilir, ya da Chebisev polinomları olabilir. Bu &quot;test'', baz fonksiyonları <span class="math inline">\(T_i(x,y)\)</span> içinde, <span class="math inline">\(i=1,2,...,N\)</span>, ve nihai <span class="math inline">\(T\)</span>'yi</p>
<p><span class="math display">\[
T = T_0 + \sum_{i=1}^{N} c_i T_i(x,y)
\]</span></p>
<p>ile hesaplayayım, <span class="math inline">\(c_i\)</span>'ler başta bilmediğim katsayı değerleri olsun. Bilinen / verili test fonksiyonları üzerinden doğru <span class="math inline">\(c_i\)</span>'leri bulursam bu beni gerçek fonksiyon <span class="math inline">\(T\)</span>'ye yaklaştırır. Üstteki toplamda <span class="math inline">\(T_0\)</span> terimi özellikle o şekilde formüle dahil edildi, <span class="math inline">\(T_i\)</span> toplamının sınırda sıfır olmasını ayarlayabilirsem, <span class="math inline">\(T=T_0\)</span> şartını otomatik olarak tatmin etmiş olurum.</p>
<p><span class="math inline">\(N\)</span> sayısına dikkat, gerçek fonksiyonu aşağı yukarı temsil etmek istesem <span class="math inline">\(N\)</span>'yi az tutardım, birkaç tane temel fonksiyon birleşimi.. Ama <span class="math inline">\(N\)</span>'i arttırarak, hatta sonsuza yaklaştığımızda gerçek fonksiyona tıpatıp eşit olacağımızı bekleyebilirdik, o zaman <span class="math inline">\(N\)</span> sayısı bir anlamda yaklaşıklamanın kalitesini kontrol edecektir. <span class="math inline">\(N\)</span> arttıkça hata azalır, yaklaşıklama gerçeğe yaklaşır. Bir ödünleşim (trade-off) durumu var muhakkak, çok büyük <span class="math inline">\(N\)</span> hesaplaması zor olan bir sistem ortaya çıkartabilir, vs.</p>
<p>Bu bizi hata tanımına getiriyor. Onu gerçek ve yaklaşık değerler arasındaki fark, &quot;artık'' (residual) üzerinden tanımlayacağız, artık <span class="math inline">\(R\)</span>,</p>
<p><span class="math display">\[
R(c_i,x,y) = \nabla^2 T
\]</span></p>
<p>Bu kadar basit. Niye artığı direk <span class="math inline">\(\nabla^2 T\)</span>'e eşitlemek yeterli? Çünkü ana formüle bakarsak <span class="math inline">\(\nabla^2 T\)</span> ideal durumda sıfır olmalı değil mi? Ama yaklaşıklama mükemmel olmadığı için sıfırdan farklı (fakat umuyoruz ki ona yakın) değerler döndürecektir, o zaman bu değeri alıp direk hata / artık değeri olarak kullanabiliriz. O zaman</p>
<p><span class="math display">\[
R(c_i,x,y) = T_0 + \sum_{i=1}^{N} c_i T_i(x,y)
\]</span></p>
<p>diyelim. Üstteki denklem bana her veri noktası, belli bir <span class="math inline">\(x,y\)</span> için olan hatayı verir. Sınır koşulunu denklem doğal olarak karşıladığı için orada zaten hata yok. Yani tanım itibariyle sınırda hata sıfır, ve sınırlar içinde muhtemel olarak sıfır olmayan bir değerde.</p>
<p>Şimdi <span class="math inline">\(c_i\)</span>'lerin bulunmasına gelelim, yaklaşık temsil onlar üzerinden mümkün olacak. <span class="math inline">\(N\)</span> tane <span class="math inline">\(c_i\)</span> bilinmiyor o zaman bir şekilde <span class="math inline">\(N\)</span> tane denklem üretmem lazım, ki onları çözerek bilinmeyenleri elde edeyim. WRM burada devreye giriyor.</p>
<p>Ağırlıklı artıklar dedik, ağırlıklardan da (dikkat <span class="math inline">\(c_i\)</span> katsayılarından, ve test fonksiyonlarından farklı bu) da <span class="math inline">\(N\)</span> tane var, <span class="math inline">\(N\)</span> tane fonksiyon. Onları <span class="math inline">\(j\)</span> ile indisleyebiliriz, <span class="math inline">\(w_j\)</span>, <span class="math inline">\(j=1,...,N\)</span>. Artıkları şöyle ağırlıklıyoruz,</p>
<p><span class="math display">\[
\int_\Omega w_j R \mathrm{d} \Omega
\]</span></p>
<p>Biraz önce söylediğimiz artığın sıfır olma hedefini biraz genişletip ağırlıklanmış artığın sıfır olması haline getiriyoruz. O zaman <span class="math inline">\(N\)</span> tane denklemi şöyle üretiriz,</p>
<p><span class="math display">\[
j=1,\quad
\int_\Omega w_1 (x,y) \left[
  \nabla^2 T_0 + \sum_{i=1}^{N} c_i \nabla^2 T_i(x,y) 
  \right] \mathrm{d} \Omega
\]</span></p>
<p><span class="math display">\[
j=2,\quad
\int_\Omega w_2 (x,y) \left[
  \nabla^2 T_0 + \sum_{i=1}^{N} c_i \nabla^2 T_i(x,y) 
  \right] \mathrm{d} \Omega
\]</span></p>
<p><span class="math display">\[
\vdots
\]</span></p>
<p><span class="math display">\[
j=N,\quad
\int_\Omega w_N (x,y) \left[
  \nabla^2 T_0 + \sum_{i=1}^{N} c_i \nabla^2 T_i(x,y) 
  \right] \mathrm{d} \Omega
\]</span></p>
<p>Böylece <span class="math inline">\(N\)</span> tane bilinmeyen için <span class="math inline">\(N\)</span> tane formül elde ettim, ve bu şekilde çözümü yapabilirim.</p>
<p><span class="math inline">\(w_j\)</span>'ler ne yapıyor? Başta hataların ortalamasından bahsetmiştik hatırlarsak, her <span class="math inline">\(w_j\)</span> bir nevi ortalamadır, ama her <span class="math inline">\(j\)</span> için farklı bir ortalama şekli seçebiliriz, mesela alttaki resimde</p>
<div class="figure">
<img src="compscieng_app45aerofem1_02.png" />

</div>
<p>karalanmış kısma daha fazla ağırlık ver diyebiliriz, vs. Genel anlamda hatırlarsak üç sayı A,B,C ortalaması demek aslında her sayının 1/3 &quot;ağırlığı'' ile çarpılıp, toplanması ve sonucun 3'e bölünmesi demektir. Bu ağırlıkları değiştirebiliriz, o zaman farklı bir ortalama elde ederiz, mesela 1/2, 1/4, 1/4 kullansam A'ya daha fazla ağırlık vermiş olurdum.</p>
<p>Bu açıdan bakınca üstte üretilen her denklem belli bir artık formülünün farklı şekillerde ağırlıklanması sonucu elde edilen denklemlerdir.</p>
<p>Galerkin Metotu</p>
<p>Bu metot FEM'in temelini oluşturur [2], 1915, 1913'te Galerkin, Bubnov tarafından ayrı ayrı keşfedilmiştir. Galerkin metotunun özü şu basit önermeden ibaret, daha önce gördüğümüz ağırlıklı artıklar metotunda Galerkin metotu der ki <span class="math inline">\(w_j = T_j\)</span>, yani ağırlık fonksiyonu test fonksiyonu ile aynı olsun. Ayrıca hatırlarsak <span class="math inline">\(T_j\)</span>'lerin bir tam küme oluşturması gerekiyor, o zaman <span class="math inline">\(w_j\)</span>'lerin de tam küme oluşturması gerekiyor. Bu durumda ağırlıklı artıklar metotu bizi şu noktaya getirir,</p>
<p><span class="math display">\[
(w_j,R) = 0
\]</span></p>
<p>Yani <span class="math inline">\(R\)</span> her <span class="math inline">\(w_j\)</span>'e dikgen, bu daha önceki dikgenlik teorisini hatırlatmalı bize, eğer <span class="math inline">\(R\)</span> her birimdik baz fonksiyonuna dik ise, kendisi sıfırdan başka bir şey olamaz. Bu çok kuvvetli bir sonuç. <span class="math inline">\(R\)</span> hatasının tam kümedeki her fonksiyon ile iç çarpımının sıfır olma şartına bakıyoruz.. bu tür bir ilişkinin bize ileride faydalı olacağını görmek zor değil, dikgenlikten direk <span class="math inline">\(R\)</span>'nin sıfır olmasına atlayabilmiş oluyoruz, bunu lineer cebirsel işlemlerimizde kullanabiliriz.</p>
<p>Alberta Üniversitesi</p>
<p>Galerkin, Ağırlıklı Artıklar Metotu (Weighted Residual Method)</p>
<p>WRS diferansiyel denklemleri yaklaşık (approximate) olarak çözebilen bir metottur, bunu tüm yaklaşık fonksiyonun tanım kümesi üzerinden ağırlıklı hata artıklarını sıfıra eşitleyerek yapar. Bununla ne demek istediğimizi birazdan yakından göreceğiz [4, Ders 3].</p>
<p>Euler-Bernoulli kirişlerini tanımlayan denklemi hatırlayalım,</p>
<p><span class="math display">\[
E I \frac{\mathrm{d}^4 y}{\mathrm{d} X_1^4} = q
\qquad (1)
\]</span></p>
<p>Galerkin ve şekil fonksiyonlarını gördük. Metotun dayandığı ana prensip şudur; eğer çözmeye uğraştığım (1)'deki gibi bir problemde eğer <span class="math inline">\(y\)</span> yerine <span class="math inline">\(y_{approx}\)</span> kullanırsam</p>
<p><span class="math display">\[
\frac{\mathrm{d}^4 y}{\mathrm{d} X_1^4} - q = 0 \qquad
\frac{\mathrm{d}^4 y_{approx}}{\mathrm{d} X_1^4} - q \ne 0
\]</span></p>
<p>tabii ki sıfır olmayan bir sonuç alırdım. Ama <span class="math inline">\(y_{approx}\)</span> eğer <span class="math inline">\(y\)</span>'ye oldukca yakınsa sıfır olmasa bile sıfıra yakın bir sonuç alabilirdim.. belki?</p>
<p>Bu yakınlığı bir artık <span class="math inline">\(R\)</span> ile ölçebiliriz,</p>
<p><span class="math display">\[
R = \frac{\mathrm{d}^4 y_{approx}}{\mathrm{d} X_1^4} - q 
\]</span></p>
<p>Üstteki formül içinde bilinmeyen <span class="math inline">\(a_i\)</span> değerleri var hatırlarsak. O zaman, eğer &quot;iyi'' <span class="math inline">\(a_i\)</span> değerleri seçebilirsem teorik olarak <span class="math inline">\(y_{approx}\)</span> değeri <span class="math inline">\(y\)</span> değerine yaklaşacaktır, ve dolaylı olarak bu <span class="math inline">\(R\)</span>'yi minimize eder. Demek ki <span class="math inline">\(R\)</span>'yi minimize edebilen bir yaklaşım aynı zamanda <span class="math inline">\(y\)</span>'yi yaklaşık olarak çözebilen bir yaklaşım olacaktır.</p>
<p>Daha detaylı olarak ifade etmek gerekirse <span class="math inline">\(D\)</span> tanım alanı üzerinde ifade edilen ağırlıklı artık hataların toplamını sıfıra eşitleyerek bilinmeyen <span class="math inline">\(a\)</span> parametrelerini bulmaya uğraşacağız.</p>
<p>Matematiksel olarak üstteki</p>
<p><span class="math display">\[
\int_D W_i R \mathrm{d} x = 0
\]</span></p>
<p>olarak formülize edilebilir. Fakat hala bir sorumuz var, ağırlıklı dedik, formüldeki <span class="math inline">\(W_i\)</span> onun için, fakat bu <span class="math inline">\(W_i\)</span> nereden geliyor?</p>
<p>Ağırlık için farklı fonksiyonlar seçilebilir, ve her seçilen fonksiyon tipine göre farklı sonuçlar elde edilebilir. Galerkin metotuna göre <span class="math inline">\(W_i\)</span> deneme fonksiyonu <span class="math inline">\(\phi_i\)</span> ile aynı olacak şekilde seçilir. Bu ve ileriki derslerde öğreneceğimiz Galerkin yaklaşımı çünkü çoğu profosyonel FEM paketi bu yaklaşımı kullanır.</p>
<p>Örnek olarak [6]'te gördüğümüz eksenel yükleme (axial loading) modelini kullanalım.</p>
<div class="figure">
<img src="compscieng_bpp45fem1_01.jpg" />

</div>
<p>Eksenel yükleme formülünü üstteki probleme uygulayınca</p>
<p><span class="math display">\[
EA \left( \frac{\mathrm{d}^2 u}{\mathrm{d} X_1^2}  \right) = -c X_1
\]</span></p>
<p>Eşitliğin sağındakileri sola geçirip her şeyi <span class="math inline">\(EA\)</span> ile bölersem, artık (residual) hatasını bulabilirim,</p>
<p><span class="math display">\[
R = \frac{\mathrm{d}^2 u_{approx}}{\mathrm{d} X_1^2} + \frac{c X_1}{EA}
\]</span></p>
<p>Yaklaşıklama fonksiyonumuz ne olacak? Genel formu hatırlayalım,</p>
<p><span class="math display">\[
u_{approx} = a_0 \phi_0(X_1) + a_1 \phi_1(X_1) + a_2 \phi_2(X_1) + a_3 \phi_3(X_1) 
\]</span></p>
<p>3'üncü derece polinom kullanabiliriz, tüm dereceler <span class="math inline">\(X_1\)</span>'in fonksiyonu olsun <span class="math inline">\(\phi_i = a_i X_1^i\)</span>,</p>
<p><span class="math display">\[
u_{approx} = a_0 + a_1 X_1 + a_2 X_1^2 + a_3 X_1^3 
\]</span></p>
<p>Bir gerekli (essential) sınır şartı ekleyebiliriz, ki bu <span class="math inline">\(u_{approx}(0)=0\)</span>, çünkü kiriş sol tarafında sabitlenmiştir, ve bunun polinoma yansıması <span class="math inline">\(a_0=0\)</span> olacaktır, yani bu katsayı çıkartılabilir. Yeni hal,</p>
<p><span class="math display">\[
u_{approx} = a_1 X_1 + a_2 X_1^2 + a_3 X_1^3 
\]</span></p>
<p>Galerkin yöntemi kullandığımız için şimdi ağırlık fonksiyonlarını seçiyoruz, fakat daha önce belirttiğimiz gibi Galerkin yönteminde <span class="math inline">\(\phi_i\)</span> ve ağırlık <span class="math inline">\(W_i\)</span> aynı seçilir, yani</p>
<p><span class="math display">\[
W_1 = \phi_1(X_1) = X_1 \qquad 
W_2 = \phi_2(X_1) = X_1^2 \qquad 
W_3 = \phi_3(X_1) = X_1^3
\]</span></p>
<p>Artık elimizde</p>
<p><span class="math display">\[
\int_D W_i R \mathrm{d} x = 0
\]</span></p>
<p>problemini çözmek için gerekli her şey var. <span class="math inline">\(R\)</span>'nin ne olduğunu biliyoruz çünkü o ana problem tanımından geliyor,</p>
<p><span class="math display">\[
= \int_{0}^{L} W_i
\left(
 \frac{\mathrm{d}^2 u_{approx}}{\mathrm{d} X_1^2} + \frac{c X_1}{EA}
\right) \mathrm{d} X_1 = 0
\]</span></p>
<p>Entegral sınırını 0 ila <span class="math inline">\(L\)</span> arası yaptık çünkü etki alanını biliyoruz artık, hesap tüm kiriş boyunca yapılacak, <span class="math inline">\(L\)</span>.</p>
<p>Şimdi bulmamız gereken bilinmeyenlere bakıyoruz, üç tane var <span class="math inline">\(a_1\)</span>, <span class="math inline">\(a_2\)</span>, <span class="math inline">\(a_3\)</span>. Üç tane bilinmeyeni çözmek için üç tane denklem gerekir, ki tüm sistemi çözünce bilinmeyenler bulunabilsin. Ama üstte bir tane denklem var, nasıl üç tane denklem bulacağız?</p>
<p>Aslında üstteki denklem bir denklem kalıbı, her <span class="math inline">\(i\)</span> için bu kalıp bize ayrı bir ağırlık <span class="math inline">\(W_i\)</span> üzerinden farklı bir denklem verebilir. Ağırlıklar <span class="math inline">\(W_1 = X_1\)</span>, <span class="math inline">\(W_2 = X_1^2\)</span>, <span class="math inline">\(W_3 = X_1^3\)</span> demiştik, o zaman</p>
<p><span class="math display">\[
\int_{0}^{L} X_1 \left( \frac{\mathrm{d}^2 u_{approx}}{\mathrm{d} X_1^2} + \frac{c X_1}{EA}  \right) \mathrm{d} X_1 = 0
\]</span></p>
<p><span class="math display">\[
\int_{0}^{L} X_1^2 \left( \frac{\mathrm{d}^2 u_{approx}}{\mathrm{d} X_1^2} + \frac{c X_1}{EA}  \right) \mathrm{d} X_1 = 0
\]</span></p>
<p><span class="math display">\[
\int_{0}^{L} X_1^3 \left( \frac{\mathrm{d}^2 u_{approx}}{\mathrm{d} X_1^2} + \frac{c X_1}{EA}  \right) \mathrm{d} X_1 = 0
\]</span></p>
<p>formüllerini elde edebiliriz.</p>
<p>Fakat hala bir problem var; bilinmeyen katsayı kadar denklem var, fakat diferansiyel denklem derecesini tatmin edecek kadar sınır şartı yok. <span class="math inline">\(u_{approx}(0)=0\)</span> üzerinden bir şart elde ettik, fakat hala bir tane daha şart gerekli. Bu duruma cevap bulmazsak hala üstteki yaklaşımla bile sonsuz tane sonuç elde edilebilir.</p>
<p>O zaman bir sınır şartı daha lazım, gerekli olmayan (non-essential) sınır şartı burada devreye giriyor. Kirişin sol tarafı sabitlenmiştir dedik, fakat sağ tarafında neler oluyor acaba? O uçta stres sıfır denebilir, çünkü o uç serbest uçtur, ve şimdiye kadar gördüğümüz iç stres tanımı kuvvet uygulanan bir nesne içindeki bir kesitte etki eden hayali bir düzlem farz etmişti. Serbest uçta buna gerek yoktur, o uç açıktır. Orada stres sıfır kabul edilebilir. Tabii stres yokluğu tek eksenel durumda gerilmeye yansır, <span class="math inline">\(X_1=L\)</span>'de stres sıfırsa yer değişimin türevi olan gerilme de sıfırdır,</p>
<p><span class="math display">\[
\epsilon = \frac{\mathrm{d} u}{\mathrm{d} X_1} = \frac{\sigma}{E} = 0
\]</span></p>
<p>O zaman ikinci sınır şartı şöyle gösterilebilir [4, Ders 3, 2:00:00],</p>
<p><span class="math display">\[
\frac{\mathrm{d} u}{\mathrm{d} X_1}(L) = 0 
\]</span></p>
<p>Bu sınır şartına literatürde gerekli olmayan (non-essential) sınır şartı da denebiliyor.</p>
<p>Peki bu ikinci şartı nasıl çözüme uygulayacağız? Parçalı Entegral tekniğini kullanabiliriz.</p>
<p>Ana genel denklemi tekrarlarsak,</p>
<p><span class="math display">\[
= \int_{0}^{L} W_i \left(
  \frac{\mathrm{d}^2 u_{approx}}{\mathrm{d} X_1^2} + \frac{c X_1}{EA}
\right) \mathrm{d} X_1 = 0
\]</span></p>
<p>Parantez içindeki ikinci terimi sağ tarafa taşıyabiliriz,</p>
<p><span class="math display">\[
= \int_{0}^{L} W_i \left( \frac{\mathrm{d}^2 u_{approx}}{\mathrm{d} X_1^2} \right) \mathrm{d} X_1 =
\int_{0}^{L} - W_i  \left( \frac{c X_1}{EA} \right) \mathrm{d} X_1
\qquad (2)
\]</span></p>
<p>Şimdi eşitliğin sol tarafına Parçalı Entegral tekniğini uygulayacağım,</p>
<p><span class="math display">\[
\int_{0}^{L} W_i \left( \frac{\mathrm{d}^2 u_{approx}}{\mathrm{d} X_1^2} \right) \mathrm{d} X_1 =
W_i \left( \frac{\mathrm{d} u_{approx}}{\mathrm{d} X_1} \right) \big\vert_{X_1=0}^{X_1=L} -
\int_{0}^{L} \left( \frac{\mathrm{d} W_i}{\mathrm{d} X_1}  \right) \left( \frac{\mathrm{d} u_{approx}}{\mathrm{d} X_1}\right) \mathrm{d} X_1
\]</span></p>
<p>Oldukça karışık bir sonuç elde ettik, fakat eşitliğin sağındaki birinci terime bakarsak oraya ikinci şartı uygulayabileceğimizi görüyoruz. Entegral hesabında <span class="math inline">\(X_1=L\)</span> ikinci sınır şartı sıfır değerini denkleme sokar, <span class="math inline">\(X_1=0\)</span>'da zaten entegral sınır hesabı sıfır değerinde, o zaman o terim tamamen yok sayılabilir, geriye kalanlar,</p>
<p><span class="math display">\[
= - \int_{0}^{L} \left( \frac{\mathrm{d} W_i}{\mathrm{d} X_1}  \right)
\left( \frac{\mathrm{d} u_{approx}}{\mathrm{d} X_1}\right) \mathrm{d} X_1
\]</span></p>
<p>Bu denklem (2)'nin sağ tarafına eşit tabii ki, hepsi bir arada (eksi işaretler birbirini iptal etti),</p>
<p><span class="math display">\[
\int_{0}^{L} \left( \frac{\mathrm{d} W_i}{\mathrm{d} X_1}  \right)
\left( \frac{\mathrm{d} u_{approx}}{\mathrm{d} X_1}\right) \mathrm{d} X_1 =
\int_{0}^{L} W_i  \left( \frac{c X_1}{EA} \right) \mathrm{d} X_1
\]</span></p>
<p>Bu çok daha temiz bir genel denklem. İkinci derece türev kayboldu, herşey birinci derece türev halinde. Bunu ikinci sınır şartını parçalı entegral üzerinden sisteme dahil ederek elde ettik. Ağırlık fonksiyonu iki yerde mevcut, solda türevi üzerinden, fena değil. Bu genel forma farklı ağırlık fonksiyonlarını sokarak üç tane farklı denklem elde edebileceğiz, ve bu denklemleri nihai çözüme ulaşmak için kullanacağız. Bunu yapalım, sırayla <span class="math inline">\(W_1 = X_1\)</span>, <span class="math inline">\(W_2 = X_1^2\)</span>, <span class="math inline">\(W_3 = X_1^3\)</span> için,</p>
<p><span class="math display">\[
\int_{0}^{L} \left( \frac{\mathrm{d}}{\mathrm{d} X_1} (X_1) \right)
\left( \frac{\mathrm{d} u_{approx}}{\mathrm{d} X_1}\right) \mathrm{d} X_1 =
\int_{0}^{L} X_1  \left( \frac{c X_1}{EA} \right) \mathrm{d} X_1
\implies a_1 L + a_2 L^2 + a_3 L^3 = \frac{c L^3}{3EA}
\]</span></p>
<p><span class="math display">\[
\int_{0}^{L} \left( \frac{\mathrm{d}}{\mathrm{d} X_1} (X_1^2) \right)
\left( \frac{\mathrm{d} u_{approx}}{\mathrm{d} X_1}\right) \mathrm{d} X_1 =
\int_{0}^{L} X_1^2  \left( \frac{c X_1}{EA} \right) \mathrm{d} X_1
\implies a_1 L^2 + \frac{4 a_2 L^3}{3} + \frac{3 a_3 L^4}{2} = \frac{cL^4}{4EA}
\]</span></p>
<p><span class="math display">\[
\int_{0}^{L} \left( \frac{\mathrm{d}}{\mathrm{d} X_1} (X_1^3) \right)
\left( \frac{\mathrm{d} u_{approx}}{\mathrm{d} X_1}\right) \mathrm{d} X_1 =
\int_{0}^{L} X_1^3  \left( \frac{c X_1}{EA} \right) \mathrm{d} X_1
\implies a_1 L^3 + \frac{3 a_2 L^4}{2} + \frac{9 a_3 L^5}{5} = \frac{cL^5}{5EA}
\]</span></p>
<p>Eşitliğin sağındaki üç denklemi bir sistem olarak çözersem,</p>
<p><span class="math display">\[
a_1 = \frac{c L^2}{2EA}, \quad a_2 = 0, \quad a_3 = -\frac{c}{6EA}
\]</span></p>
<p>sonucunu elde ederim. Bu katsayıları <span class="math inline">\(u_{approx}\)</span> içine koyunca,</p>
<p><span class="math display">\[
u_{approx} = \frac{c L^2}{2EA} X_1 -\frac{c}{6EA} X_1^3
\]</span></p>
<p>Önceki örnekler standart eni değişmeyen kiriş yapısını temel aldı. Fakat ya kiriş alttaki gibi olsaydı?</p>
<div class="figure">
<img src="compscieng_bpp45fem2_01.jpg" />

</div>
<p>Bu kirişi temsilen</p>
<p><span class="math display">\[
E I \frac{\mathrm{d}^4 y}{\mathrm{d} X_1^4} = q
\]</span></p>
<p>diferansiyel denklemini hala kullanabilir miyiz? Dikkat edersek en değiştiğine göre <span class="math inline">\(X_1\)</span> ile beraber, ona bağlı olarak, atalet momenti <span class="math inline">\(I\)</span> sabit değil, değişken demektir.. Bazıları düşünebilir &quot;ama o zaman değişken <span class="math inline">\(I\)</span>'yi alırız, üstteki denklemdeki <span class="math inline">\(I\)</span>'ya sokarız olur biter''. Bunu yapamayız çünkü <span class="math inline">\(I\)</span>'nin sabit olması üstteki denklemi türetmek için bir önkabuldu, yani <span class="math inline">\(I\)</span> değişken ise üstteki denklemi kullanmak mümkün değildir [7, Ders 4].</p>
<p>Problem şu ki pek çok gerçek dünya uygulaması üstteki Euler-Bernoulli kiriş formülüne erişirken kullandığımız faraziyelere uymaz, bunları hatırlarsak lineer elastiklik, yok sayılabilecek Poisson etkileri, düzlemlerin düz kalması idi. Fakat mesela beton materyelini ele alalım, bu materyel ucuzdur, basınca, yani içe doğru strese karşı çok dayanıklıdır, ki bu yüzden pek çok yapıda kullanılır, fakat beton dışa doğru stres, yani gerilime karşı dayanıklı değildir. Çok az bir yükü bile beton parçaya dışa doğru uygulasam çatlamaya başlar, çatlamak demek oradaki yüzeyin bozulmaya uğraması demektir, ki dolaylı olarak <span class="math inline">\(I\)</span> değişecektir. Diğer bir problem yüke bağlı olarak betonun <span class="math inline">\(E\)</span> değerinin de değişmesi. Yani gerçek dünyada <span class="math inline">\(I\)</span> neredeyse hiçbir zaman sabit değildir, <span class="math inline">\(E\)</span> benzer şekilde, durumu daha kötü yapan bu değişimlerin çoğunlukla yük <span class="math inline">\(q\)</span> değerine bağlı olması. Bu tüm hesapları arap saçına döndürür.</p>
<p>Problemin çözümü FEM yaklaşımında. Nasıl? Çünkü eğer bir kirişi yeterince ufak parçalara bölebilirsem o parçalarda <span class="math inline">\(I\)</span>, ve <span class="math inline">\(E\)</span> sabit kabul edebilirim ve bu parçalarda daha basit olan denklemleri kullanabilirim. FEM matematiği bana bu parçaları birleştirmem için güzel bir mekanizma sağlıyor zaten.</p>
<div class="figure">
<img src="compscieng_bpp45fem2_02.jpg" />

</div>
<p>Üstteki resimdeki yeşil bölgeyi düşünelim, o bölgenin iki yan yüzeylerini düşünürsek, belki soldan sağa giderken biraz değişim olur ama parça çok ufak olduğu için bu değişim fazla değildir.</p>
<p>FEM maceramıza çubuk/makaskiriş (bar/truss) öğeleri ile devam edeceğiz. Bu yapılar çok basit olmalarına rağmen FEM metadolojisini gösterebilmeleri açısından uygunlar. Onları sadece küçülme, esneme açısından inceleyeceğiz, moment, kaykılma gibi konuları şimdilik yok sayacağız. Fakat işleyeceğimiz pek çok yaklaşım, &quot;direngenlikleri (stiffness)'' hesaplarken kullandığımız adımlar her FEM yaklaşımında faydalı olan kavramlar.</p>
<p>Not düşelim, önceki FEM çözümü Galerkin yaklaşımı ile tüm denkleme analitik bir çözüm buldu. Bu derste ve gerisinde göreceğimiz türden FEM, Galerkin çözümünü her parçaya uygulayıp ayrıksal sonuçları birleştiriyor.</p>
<div class="figure">
<img src="compscieng_bpp45fem2_03.jpg" />

</div>
<p>Makaskiriş üstteki gibi olsun, onu parçalara bölelim, sarı noktalar düğümler (nodes), düğümleri birleştiren öğeler (elements) var. Bu yaklaşımda yer değişimleri tüm nesne için değil, her düğümde hesaplayacağız. Yer değişimleri birbiriyle bağlayan şeyler ögeler, kırmızı ile görülen parçalar. Bu öğe parçaları aslında bir aradeğerlemeyi (interpolation) temsil ediyor olacaklar, eğer iki düğümün yer değişimini biliyorsam onları bağlayan parçanın yer değişimini bunları kullanarak, aradeğerleme yaparak hesaplayabilirim.</p>
<p>Eğer tek bir öğeye bakarsak,</p>
<div class="figure">
<img src="compscieng_bpp45fem2_04.jpg" />

</div>
<p>Yer değişimler her düğüm için demiştik, <span class="math inline">\(u_1,u_2\)</span>, amacımız onları hesaplamak. Eğer bu değişimleri hesaplayabilirsem, daha önce belirttiğimiz gibi, aradaki öğenin yer değişimini yaklaşık olarak, iki uca bağlı olarak hesaplayabilirim. Yani eğer düğümlerin her değişimini biliyorsam her şeyin yer değişimini biliyorum demektir.</p>
<p>Galerkin metotuna başlayalım. Metot uygulanınca bize yer değişimleri için bir direngenlik matrisi ve öğeler için düğümsel kuvvet vektörü vermeli. Her şey düğümlerde hesaplanıyor dedik, peki sisteme dağıtık bir yük uygulanıyorsa ne yapacağız? Bu tür kuvvetlerin düğümler arasında etkili olduğunu biliyoruz, o zaman bu tür kuvvetleri <span class="math inline">\(x,y,z\)</span> bileşenlerine ayırıp onları düğümlere etkili vektörler haline getirebilirim.</p>
<p>Ana denklemle başlarsak,</p>
<p><span class="math display">\[
E A \frac{\mathrm{d}^2 y}{\mathrm{d} X_1^2} = -p
\]</span></p>
<p>Artıksal (residual) hesap şöyle,</p>
<p><span class="math display">\[
R = EA \frac{\mathrm{d}^2 u}{\mathrm{d} X_1^2} + p
\]</span></p>
<p>Bu artığın tanım bölgesi üzerinden ağırlıklı entegralinin sıfır olmasını istiyoruz,</p>
<p><span class="math display">\[
\int_\Omega R N_i \mathrm{d} x = 0 
\]</span></p>
<p>Dikkat, daha önce ağırlık <span class="math inline">\(W_i\)</span> kullanmıştık, şimdi <span class="math inline">\(N_i\)</span> var, bu fonksiyonlar her düğümde tanımlı şekil fonksiyonu (shape function) olacak. O şekillerin ne seçildiği FEM'in ana özelliklerinden, detayları göreceğiz.. Şimdi <span class="math inline">\(R\)</span>'yi açıp düzenleme yaparsak,</p>
<p><span class="math display">\[
\int_{0}^{L} \left( EA \frac{\mathrm{d}^2 u}{\mathrm{d} X_1^2} + p  \right) N_i \mathrm{d} X_1 = 0 
\]</span></p>
<p><span class="math display">\[
\int_{0}^{L} \left( EA \frac{\mathrm{d}^2 u}{\mathrm{d} X_1^2} \right) N_i \mathrm{d} X_1 =
- \int_{0}^{L} p N_i \mathrm{d} X_1
\]</span></p>
<p>Parçalı Entegral tekniğini uygulayalım,</p>
<p><span class="math display">\[
\int_{0}^{L} EA \left( \frac{\mathrm{d}^2 u}{\mathrm{d} X_1^2}  \right) N_i \mathrm{d} X_1 =
\left( EA \frac{\mathrm{d} u}{\mathrm{d} X_1} N_i \right) \bigg\vert_{X_1=0}^{X_1=L} -
\int_{0}^{L} EA
\left( \frac{\mathrm{d} u}{\mathrm{d} X_1} \right)
\left( \frac{\mathrm{d} N_i}{\mathrm{d} X_1} \right) \mathrm{d} X_1 =
- \int_{0}^{L} p N_i \mathrm{d} X_1
\]</span></p>
<p>Ekşi işaretler olmasın diye birkaç yer değişimi yapalım,</p>
<p><span class="math display">\[
\int_{0}^{L} EA
\left( \frac{\mathrm{d} u}{\mathrm{d} X_1} \right)
\left( \frac{\mathrm{d} N_i}{\mathrm{d} X_1} \right) \mathrm{d} X_1
=
\left( EA \frac{\mathrm{d} u}{\mathrm{d} X_1} N_i \right) \bigg\vert_{X_1=0}^{X_1=L} +
\int_{0}^{L} p N_i \mathrm{d} X_1 
\]</span></p>
<p>Eşitliğin sağındaki birinci terime dikkat edelim, orada fiziksel anlamı olan bir ilişki görüyor muyuz? <span class="math inline">\(EA\)</span> çarpı <span class="math inline">\(\mathrm{d} u / \mathrm{d} x\)</span>.. Tanıdık geliyor mu? O ifade aslında bir kuvvet değil mi? Çünkü hatırlarsak <span class="math inline">\(\mathrm{d} u / \mathrm{d} x\)</span> yer değişimin türevi, ki bu gerilme, gerilmeyi Young Genliği <span class="math inline">\(E\)</span> ile çarpınca stres elde ederim. Ek olarak <span class="math inline">\(A\)</span> ile alan çarpımı var, stres kuvvet bölü alan olduğu için stresi alanla çarpınca geriye kuvvet kalır. Demek ki o terimle eksenel kuvvet elde ediyorum, bir düğümde konsantre edilmiş <span class="math inline">\(f = E A \epsilon\)</span> kuvvetini hesaplıyorum.</p>
<p>Bu mantık zinciriyle devam edersem üstteki kuvvet bir düğümdeki kuvveti gösteriyor ve bu kuvvetin dışarıdan uygulandığı hali temsil ediyor. Hem yanındaki düğümde bu kuvveti dengeleyen karşı bir kuvvet olacaktır ve bu kuvvetler birbirini iptal edecektir. O zaman eşitliğin sağındaki ilk terim iptal edilebilir.</p>
<p>O terimi iptal etmeden hesapları yapabilirdik fakat sonuç aynı çıkardı. Fakat ekstra, gereksiz hesapları önceden çıkartmak hesap zamanımızı kısaltacağı için iptali şimdiden yapmak bizim için iyi olacak. Neyse, iptal sonrası geriye kalanlar</p>
<p><span class="math display">\[
\int_{0}^{L} EA
\left( \frac{\mathrm{d} u}{\mathrm{d} X_1} \right)
\left( \frac{\mathrm{d} N_i}{\mathrm{d} X_1} \right) \mathrm{d} X_1
= \int_{0}^{L} p N_i \mathrm{d} X_1 
\]</span></p>
<p>Şimdi <span class="math inline">\(N_i\)</span> fonksiyonlarına gelelim, onlara şekil fonksiyonları demiştik. Bu şekilleri daha önce anlattık.</p>
<p>Şapka fonksiyonlarını ifade etmenin daha genel bir yöntemi [8, sf. 9], ki <span class="math inline">\(h = x_{j+1}-x_j\)</span>, ya da 1 uzunluğundaki bir yatay eksen için <span class="math inline">\(h = 1/N\)</span> ve <span class="math inline">\(j = 1,2,...,N\)</span> olmak üzere,</p>
<p><span class="math display">\[
N_1 = \left\{ \begin{array}{rr}
(x_2 - X_1)/h, &amp; x_1 \le X_1 \le x_2,\\
0, &amp; \textrm{diğer}
\end{array} \right.
\]</span></p>
<p><span class="math display">\[
N_j = \left\{ \begin{array}{rr}
(X_1 - x_{j-1})/h, &amp; x_{j-1} \le X_1 \le x_j,\\
(x_{j+1} - X_1)/h, &amp; x_j \le X_1 \le x_{j+1},\\
0, &amp; \textrm{diğer}
\end{array} \right.
\]</span></p>
<p><span class="math display">\[
N_{N+1} = \left\{ \begin{array}{rr}
(X_1 - x_N)/h, &amp; x_N \le X_1 \le x_{N+1},\\
0, &amp; \textrm{diğer}
\end{array} \right.
\]</span></p>
<div class="figure">
<img src="compscieng_bpp45fem2_09.jpg" />

</div>
<p>Daha önceki örnekte iki parça kullanılmıştı, bu parçaları arttırırsak daha gerçek probleme yaklaşırız, dört parça kullanalım [9], çubuk uzunluğu <span class="math inline">\(L\)</span>, o zaman <span class="math inline">\(h = L/4\)</span> olur, baz / şekil fonksiyonları alttaki noktalarda tanımlı,</p>
<div class="figure">
<img src="compscieng_bpp45fem2_10.jpg" />

</div>
<p><span class="math display">\[
N_1 = \left\{ \begin{array}{rr}
X_1 / h &amp; 0 \le X_1 \le L/4 \\
(L/2 - X_1) / h &amp; L/4 \le X_1 \le L/2
\end{array} \right.
\]</span></p>
<p><span class="math display">\[
N_2 = \left\{ \begin{array}{rr}
(X_1 - L/4)/h &amp; L/4 \le X_1 \le L/2 \\
(3L/4 - X_1)/h &amp; L/2 \le X_1 \le 3L/4
\end{array} \right.
\]</span></p>
<p><span class="math display">\[
N_3 = \left\{ \begin{array}{rr}
(X_1-L/2)/h &amp; L/2 \le X_1 \le 3L/4 \\
(L-X_1)/h &amp; 3L/4 \le X_1 \le L
\end{array} \right.
\]</span></p>
<p><span class="math display">\[
N_4 = (X_1 - 3L/4) / h
\]</span></p>
<p>Böylece alttaki fonksiyonları yaratmış olduk,</p>
<div class="figure">
<img src="compscieng_bpp45fem2_11.jpg" />

</div>
<p>Şekil fonksiyonlarının türevleri oldukca basit,</p>
<p><span class="math display">\[
\frac{\mathrm{d} N_1}{\mathrm{d} X_1} = \left\{ \begin{array}{rr}
4/L   &amp; 0 \le X_1 \le L/4 \\
-4/L  &amp; L/4 \le X_1 \le L/2
\end{array} \right.
\]</span></p>
<p><span class="math display">\[
\frac{\mathrm{d} N_2}{\mathrm{d} X_1} = \left\{ \begin{array}{rr}
4/L  &amp; L/4 \le X_1 \le L/2 \\
-4/L &amp; L/2 \le X_1 \le 3L/4
\end{array} \right.
\]</span></p>
<p><span class="math display">\[
\frac{\mathrm{d} N_3}{\mathrm{d} X_1} = \left\{ \begin{array}{rr}
4/L  &amp; L/2 \le X_1 \le 3L/4 \\
-4/L &amp; 3L/4 \le X_1 \le L
\end{array} \right.
\]</span></p>
<p><span class="math display">\[
\frac{\mathrm{d} N_4}{\mathrm{d} X_1} = 4/L
\]</span></p>
<p>Artık <span class="math inline">\(N_i\)</span>, onun türevleri için bir tanıma sahibiz, hesaplamaya başlayabiliriz. Genel FEM formülasyonunda en son alttaki noktaya gelmiştik,</p>
<p><span class="math display">\[
\int_{0}^{L} EA
\left( \frac{\mathrm{d} N_i}{\mathrm{d} X_1} \right)
\left( \frac{\mathrm{d} u}{\mathrm{d} X_1} \right)  \mathrm{d} X_1
= \int_{0}^{L} p N_i \mathrm{d} X_1
\]</span></p>
<p><span class="math inline">\(p = cX_1\)</span> olarak kabul edelim,</p>
<p><span class="math display">\[
\int_{0}^{L} EA
\left( \frac{\mathrm{d} N_i}{\mathrm{d} X_1} \right) 
\left( \frac{\mathrm{d} u}{\mathrm{d} X_1} \right) \mathrm{d} X_1
= \int_{0}^{L} N_i c X_1 \mathrm{d} X_1
\qquad (1)
\]</span></p>
<p>Üstteki formülü kullanarak 4 tane denklem ortaya çıkartabiliriz.</p>
<ol style="list-style-type: decimal">
<li></li>
</ol>
<p><span class="math inline">\(N_1\)</span> formülü <span class="math inline">\(0 \le X_1 \le L/2\)</span> harici diğer her yerde yokolur, ki o aralıkta <span class="math inline">\(N_3,N_4\)</span> geçerli değildir. O zaman ilk denklemimiz</p>
<p><span class="math display">\[
u = u_1 N_1 + u_2 N_2 
\]</span></p>
<p>Onun türevi</p>
<p><span class="math display">\[
\frac{\mathrm{d} u}{\mathrm{d} X_1} = u_1 \frac{\mathrm{d} N_1}{\mathrm{d} X_1} + u_2 \frac{\mathrm{d} N_2}{\mathrm{d} X_1} 
\]</span></p>
<p>İlk denklem için (1) formülü</p>
<p><span class="math display">\[
\int_{0}^{L} EA
\left( \frac{\mathrm{d} N_1}{\mathrm{d} X_1} \right) 
\left( \frac{\mathrm{d} u}{\mathrm{d} X_1} \right) \mathrm{d} X_1
= \int_{0}^{L} N_1 c X_1 \mathrm{d} X_1
\]</span></p>
<p>Bunun içine iki üstteki formülü koyunca ve entegral sınırlarını ayarladıktan sonra</p>
<p><span class="math display">\[
u_1 \int_{0}^{L/2} EA \frac{\mathrm{d} N_1}{\mathrm{d} X_1} \frac{\mathrm{d} N_1}{\mathrm{d} X_1} \mathrm{d} X_1 +
u_2 \int_{0}^{L/2} EA \frac{\mathrm{d} N_1}{\mathrm{d} X_1} \frac{\mathrm{d} N_2}{\mathrm{d} X_1} \mathrm{d} X_1 =
\int_{0}^{L/2} N_1 c X_1 \mathrm{d} X_1
\]</span></p>
<p>İkinci entegral teriminin alt sınırını daha yukarı çekebiliriz <span class="math inline">\(\frac{\mathrm{d} N_2}{\mathrm{d} X_1}\)</span> hesabının sıfır olduğu yerler var,</p>
<p><span class="math display">\[
u_1 \int_{0}^{L/2} EA \frac{\mathrm{d} N_1}{\mathrm{d} X_1} \frac{\mathrm{d} N_1}{\mathrm{d} X_1} \mathrm{d} X_1 +
u_2 \int_{L/4}^{L/2} EA \frac{\mathrm{d} N_1}{\mathrm{d} X_1} \frac{\mathrm{d} N_2}{\mathrm{d} X_1} \mathrm{d} X_1 =
\int_{0}^{L/2} N_1 c X_1 \mathrm{d} X_1
\]</span></p>
<ol start="2" style="list-style-type: decimal">
<li></li>
</ol>
<p><span class="math inline">\(N_2\)</span> formülü <span class="math inline">\(L/4 \le X_1 \le 3L/4\)</span> harici her yerde yokolur, bu aralıkta ise <span class="math inline">\(N_4\)</span> mevcut değildir, yani</p>
<p><span class="math display">\[
u = u_1 N_1 + u_2 N_2 + u_3 N_3
\]</span></p>
<p><span class="math display">\[
\frac{\mathrm{d} u}{\mathrm{d} X_1} =
u_1 \frac{\mathrm{d} N_1}{\mathrm{d} X_1} + 
u_2 \frac{\mathrm{d} N_2}{\mathrm{d} X_1} + 
u_3 \frac{\mathrm{d} N_3}{\mathrm{d} X_1} 
\]</span></p>
<p>Üstteki sonuçları (1) içine koyarsak,</p>
<p><span class="math display">\[
u_1 \int_{L/4}^{3L/4} EA \frac{\mathrm{d} N_2}{\mathrm{d} X_1} \frac{\mathrm{d} N_1}{\mathrm{d} X_1} \mathrm{d} X_1 +
u_2 \int_{L/4}^{3L/4} EA \frac{\mathrm{d} N_2}{\mathrm{d} X_1} \frac{\mathrm{d} N_2}{\mathrm{d} X_1} \mathrm{d} X_1  +
u_3 \int_{L/4}^{3L/4} EA \frac{\mathrm{d} N_2}{\mathrm{d} X_1} \frac{\mathrm{d} N_3}{\mathrm{d} X_1} \mathrm{d} X_1 =
\int_{L/4}^{3L/4} N_2 c X_1 \mathrm{d} X_1
\]</span></p>
<p>Üçüncü entegral teriminin alt sınırını güncelleyebiliriz,</p>
<p><span class="math display">\[
u_1 \int_{L/4}^{3L/4} EA \frac{\mathrm{d} N_2}{\mathrm{d} X_1} \frac{\mathrm{d} N_1}{\mathrm{d} X_1} \mathrm{d} X_1 +
u_2 \int_{L/4}^{3L/4} EA \frac{\mathrm{d} N_2}{\mathrm{d} X_1} \frac{\mathrm{d} N_2}{\mathrm{d} X_1} \mathrm{d} X_1  +
u_3 \int_{L/2}^{3L/4} EA \frac{\mathrm{d} N_2}{\mathrm{d} X_1} \frac{\mathrm{d} N_3}{\mathrm{d} X_1} \mathrm{d} X_1 =
\int_{L/4}^{3L/4} N_2 c X_1 \mathrm{d} X_1
\]</span></p>
<ol start="3" style="list-style-type: decimal">
<li></li>
</ol>
<p><span class="math inline">\(N_3\)</span> formülü <span class="math inline">\(L/2 \le X_1 \le L\)</span> harici her yerde yokolur, o bölümde <span class="math inline">\(N_1\)</span> sıfırdır.</p>
<p><span class="math display">\[
u = u_2 N_2 + u_3 N_3 + u_4 N_4
\]</span></p>
<p><span class="math display">\[
\frac{\mathrm{d} u}{\mathrm{d} X_1} =
u_2 \frac{\mathrm{d} N_2}{\mathrm{d} X_1} + 
u_3 \frac{\mathrm{d} N_3}{\mathrm{d} X_1} + 
u_4 \frac{\mathrm{d} N_4}{\mathrm{d} X_1} 
\]</span></p>
<p>O zaman üçüncü denklem için (ve sınır güncellemesi sonrası)</p>
<p><span class="math display">\[
u_2 \int_{L/2}^{3L/4} EA \frac{\mathrm{d} N_3}{\mathrm{d} X_1} \frac{\mathrm{d} N_2}{\mathrm{d} X_1} \mathrm{d} X_1  +
u_3 \int_{L/2}^{L} EA \frac{\mathrm{d} N_3}{\mathrm{d} X_1} \frac{\mathrm{d} N_3}{\mathrm{d} X_1} \mathrm{d} X_1  +
u_4 \int_{3L/4}^{L} EA \frac{\mathrm{d} N_3}{\mathrm{d} X_1} \frac{\mathrm{d} N_4}{\mathrm{d} X_1} \mathrm{d} X_1 =
\int_{L/2}^{L} N_3 c X_1 \mathrm{d} X_1
\]</span></p>
<ol start="4" style="list-style-type: decimal">
<li></li>
</ol>
<p><span class="math inline">\(3L/4 \le X_1 \le L\)</span> harici her yerde <span class="math inline">\(N_4\)</span> yokolur, o aralıkta <span class="math inline">\(N_1\)</span> ve <span class="math inline">\(N_2\)</span> yokolur. Son denklem için</p>
<p><span class="math display">\[
u = u_3 N_3 + u_4 N_4
\]</span></p>
<p><span class="math display">\[
\frac{\mathrm{d} u}{\mathrm{d} X_1} =
u_3 \frac{\mathrm{d} N_3}{\mathrm{d} X_1} + 
u_4 \frac{\mathrm{d} N_4}{\mathrm{d} X_1} 
\]</span></p>
<p>Bu denklem için de (yine sınır güncellemesi sonrası)</p>
<p><span class="math display">\[
u_3 \int_{3L/4}^{L} EA \frac{\mathrm{d} N_4}{\mathrm{d} X_1} \frac{\mathrm{d} N_3}{\mathrm{d} X_1} \mathrm{d} X_1  +
u_4 \int_{3L/4}^{L} EA \frac{\mathrm{d} N_4}{\mathrm{d} X_1} \frac{\mathrm{d} N_4}{\mathrm{d} X_1} \mathrm{d} X_1  =
\int_{L/2}^{L} N_4 c X_1 \mathrm{d} X_1
\]</span></p>
<p>Dört tane denklem elde ettikten sonra bunları matris formunda şöyle yazabiliriz,</p>
<p><span class="math display">\[
K = \left[\begin{array}{cccc}
% first row
  \int_{0}^{L/2} EA \frac{\mathrm{d} N_1}{\mathrm{d} X_1} \frac{\mathrm{d} N_1}{\mathrm{d} X_1} \mathrm{d} X_1 &amp;
  \int_{L/4}^{L/2} EA \frac{\mathrm{d} N_1}{\mathrm{d} X_1} \frac{\mathrm{d} N_2}{\mathrm{d} X_1} \mathrm{d} X_1 &amp;
  0 &amp;
  0 \\
% second row
  \int_{L/4}^{3L/4} EA \frac{\mathrm{d} N_2}{\mathrm{d} X_1} \frac{\mathrm{d} N_1}{\mathrm{d} X_1} \mathrm{d} X_1 &amp;
  \int_{L/4}^{3L/4} EA \frac{\mathrm{d} N_2}{\mathrm{d} X_1} \frac{\mathrm{d} N_2}{\mathrm{d} X_1} \mathrm{d} X_1 &amp;
  \int_{L/2}^{3L/4} EA \frac{\mathrm{d} N_2}{\mathrm{d} X_1} \frac{\mathrm{d} N_3}{\mathrm{d} X_1} \mathrm{d} X_1 &amp;
  0 \\
% third row
  0 &amp;
  \int_{L/2}^{3L/4} EA \frac{\mathrm{d} N_3}{\mathrm{d} X_1} \frac{\mathrm{d} N_2}{\mathrm{d} X_1} \mathrm{d} X_1 &amp;
  \int_{L/2}^{L} EA \frac{\mathrm{d} N_3}{\mathrm{d} X_1} \frac{\mathrm{d} N_3}{\mathrm{d} X_1} \mathrm{d} X_1  &amp;
  \int_{3L/4}^{L} EA \frac{\mathrm{d} N_3}{\mathrm{d} X_1} \frac{\mathrm{d} N_4}{\mathrm{d} X_1} \mathrm{d} X_1 \\
% fourth row
  0 &amp;
  0 &amp;
  \int_{3L/4}^{L} EA \frac{\mathrm{d} N_4}{\mathrm{d} X_1} \frac{\mathrm{d} N_3}{\mathrm{d} X_1} \mathrm{d} X_1 &amp;
  \int_{3L/4}^{L} EA \frac{\mathrm{d} N_4}{\mathrm{d} X_1} \frac{\mathrm{d} N_4}{\mathrm{d} X_1} \mathrm{d} X_1
\end{array}\right]
\]</span></p>
<p>Ve çözmek istediğimiz sistem alttaki formda olacaktır,</p>
<p><span class="math display">\[
\left[\begin{array}{c}
K
\end{array}\right]
\left[\begin{array}{c}
u_1 \\ u_2 \\ u_3 \\ u_4 
\end{array}\right] = 
\left[\begin{array}{c}
f_1 \\ f_2 \\ f_3 \\ f_4 
\end{array}\right] 
\]</span></p>
<p>Her <span class="math inline">\(K\)</span> hücresindeki ve eşitliğin sağındaki entegral hesaplarını teker teker yaparsak,</p>
<p><span class="math display">\[
\left[\begin{array}{cccc}
8/L  &amp; -4/L  &amp; 0    &amp; 0    \\
-4/L &amp;  8/L  &amp; -4/L &amp; 0    \\
0    &amp;  -4/L &amp; 8/L  &amp; -4/L \\
0    &amp;  0    &amp; -4/L &amp; 4/L
\end{array}\right]
\left[\begin{array}{c}
u_1 \\ u_2 \\ u_3 \\ u_4 
\end{array}\right] =
\frac{cL^2}{EA}
\left[\begin{array}{c}
1/16 \\ 1/8 \\ 3/16 \\ 11/96
\end{array}\right] 
\]</span></p>
<p>sistemi ortaya çıkıyor. Bu sistem çözülünce <span class="math inline">\(u\)</span> için alttaki değerler bulunur,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> sympy <span class="im">import</span> symbols
<span class="im">from</span> sympy.matrices <span class="im">import</span> Matrix
L, c, E, A <span class="op">=</span> symbols(<span class="st">&quot;L, c, E, A&quot;</span>)
K <span class="op">=</span> Matrix([[<span class="dv">8</span><span class="op">/</span>L, <span class="dv">-4</span><span class="op">/</span>L,   <span class="dv">0</span>,    <span class="dv">0</span>],
            [<span class="op">-</span><span class="dv">4</span><span class="op">/</span>L, <span class="dv">8</span><span class="op">/</span>L, <span class="dv">-4</span><span class="op">/</span>L,   <span class="dv">0</span>],
            [<span class="dv">0</span>,   <span class="dv">-4</span><span class="op">/</span>L,  <span class="dv">8</span><span class="op">/</span>L,<span class="op">-</span><span class="dv">4</span><span class="op">/</span>L],
            [<span class="dv">0</span>,     <span class="dv">0</span>,  <span class="dv">-4</span><span class="op">/</span>L, <span class="dv">4</span><span class="op">/</span>L]])           
b <span class="op">=</span> (c<span class="op">*</span>L<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span>(E<span class="op">*</span>A) <span class="op">*</span> Matrix([<span class="dv">1</span><span class="op">/</span><span class="fl">16.</span>, <span class="dv">1</span><span class="op">/</span><span class="fl">8.</span>, <span class="dv">3</span><span class="op">/</span><span class="fl">16.</span>, <span class="dv">11</span><span class="op">/</span><span class="fl">96.</span>])
u <span class="op">=</span> K.solve(b)
u</code></pre></div>
<pre><code>Out[1]: 
Matrix([
[0.122395833333333*L**3*c/(A*E)],
[0.229166666666667*L**3*c/(A*E)],
[        0.3046875*L**3*c/(A*E)],
[0.333333333333333*L**3*c/(A*E)]])</code></pre>
<p>Ders notları [9] bu çıktıyı</p>
<p><span class="math display">\[
\left[\begin{array}{c}
u_1 \\ u_2 \\ u_3 \\ u_4 
\end{array}\right] =
\frac{cL^3}{EA}
\left[\begin{array}{c}
47/384 \\ 11/48 \\ 39/128 \\ 1/3
\end{array}\right]
\]</span></p>
<p>olarak göstermiştir, ki bu sonuç mesela <span class="math inline">\(u_1\)</span> içinde olan <span class="math inline">\(47/384\)</span>, üstteki 0.12239 sonucu ile aynıdır.</p>
<p>İki boyutta FEM kullanımına gelelim. Diyelim ki alttaki gibi bir problem yarattım [10, Video 5],</p>
<div class="figure">
<img src="compscieng_bpp45fem3_01.jpg" />

</div>
<p>Üçgen şeklinde bir yapı var, onun üzerinde iki noktadan kuvvet uygulanmış, şimdi bu üçgendeki stres ve gerilmeyi bulmak istiyorum. Bu problemi nasıl çözerdik? Euler-Bernoulli kiriş denklemini kullanmak zor, şekil ona uygun değil. Zor bir iş.</p>
<p>Fakat üstteki problemi bir FEM problemine dönüştürürsem işler kolaylaşabilir. Bir ızgara oluşturabilirim mesela,</p>
<div class="figure">
<img src="compscieng_bpp45fem3_02.jpg" />

</div>
<p>Altı tane düğüm noktası ortaya çıktı, düğümsel yer değişimini hesaplayabiliriz, ve dikkat edersek düğümlerin üçü altta sabitlenmiş halde. Ama hesapla devam etmem için o görülen tüm yapının direngenliğini (stiffness) bulmam lazım, bu derste göreceğimiz ilk konu o ızgaradaki her üçgenin ayrı ayrı direngenliğini bulabilmek çünkü düğümler üzerindeki kuvvetleri biliyorsam (ki biliyorum) direngenliği kullanarak çözümde ilerleyebilirim.</p>
<p>Hatırlarsak çubuk ve kirişleri modellerken bir yaklaşıklama fonksiyonu kullanmıştım, bu fonksiyon yukarı ya da yana doğru bir hareketi, yer değişimini yaklaşık olarak temsil ediyordu. İki boyutta benzer bir prosedürü kullanacağız, fakat tek yön yerine iki yönü aynı anda temsil etmemiz gerekecek.</p>
<div class="figure">
<img src="compscieng_bpp45fem3_03.jpg" />

</div>
<p>Demek ki <span class="math inline">\(u_{2D} = [\begin{array}{cc} u &amp; v \end{array}]^T\)</span> vektörünü yaklaşıklamam lazım, genel bir metot şöyle olabilir,</p>
<p><span class="math display">\[
u_{2D} = \left[\begin{array}{c}
a_0 + a_1 X_1 + a_2 X_2 + a_3 X_1 X_2 + ...\\
b_0 + b_1 X_1 + b_2 X_2 + b_3 X_1 X_2 + ...
\end{array}\right]
\]</span></p>
<p>Tek yaptığımız tek yönde yaklaşıklama yerine iki yönde yaklaşık bir temsil kullanmak.</p>
<p>Fakat daha önce baktığımız 1D FEM örneğinden hatırlarsak yer değişim yaklaşık fonksiyonunu düğümsel yer değişiklikleri (<span class="math inline">\(u_i\)</span> ve <span class="math inline">\(v_i\)</span>) ve şekil fonksiyonları (<span class="math inline">\(N_i\)</span> gibi) üzerinden temsil etmek istiyoruz. Üstteki değişim tüm üçgene bakıyor, biz üçgenin düğümlerini temsil etmek istiyoruz.</p>
<div class="figure">
<img src="compscieng_bpp45fem3_04.jpg" />

</div>
<p>O zaman herhangi bir FEM öğesi için yer değişimini, genel olarak, düğümleri üzerinden</p>
<p><span class="math display">\[
u_{2D} = \left[\begin{array}{c}
u_1 N_1 + u_2 N_2 + .. + u_n N_N \\
v_1 N_1 + v_2 N_2 + .. + v_n N_N
\end{array}\right]
\]</span></p>
<p>ile gösterebilirim. Üstteki üçgen öğe örneğinde</p>
<p><span class="math display">\[
u_{2D} = \left[\begin{array}{c}
u_1 N_1 + u_2 N_2 + u_3 N_3 \\
v_1 N_1 + v_2 N_2 + v_3 N_3
\end{array}\right]
\]</span></p>
<p>yeterlidir. <span class="math inline">\(x_{2D}\)</span> vektörünü bir matris vektör çarpımı haline getirebiliriz,</p>
<p><span class="math display">\[
u_{2D} =
\left[\begin{array}{c}
u \\ v
\end{array}\right] = 
\left[\begin{array}{ccccccc}
N_1 &amp; 0 &amp; N_2 &amp; 0 &amp; \dots &amp; N_n &amp; 0 \\
0 &amp; N_1 &amp; 0 &amp; N_2 &amp; 0 &amp; \dots &amp; N_n 
\end{array}\right]
\left[\begin{array}{c}
u_1 \\ v_1 \\ u_2 \\ v_2 \\ \dots \\ u_n \\ v_n
\end{array}\right]
\qquad (1)
\]</span></p>
<p>Daha kısa olarak</p>
<p><span class="math display">\[
\implies u_{2D} = [N] u_e
\]</span></p>
<p>denebilir. Dikkat edersek <span class="math inline">\(N\)</span> fonksiyonları <span class="math inline">\(X_1,X_2\)</span> değişkenlerinin birer fonksiyonu, <span class="math inline">\(u_i,v_i\)</span> değerleri ise sabit.</p>
<p>Bu noktada elimde genel bir yer değişim fonksiyonu var, onu kullanarak bir gerilme (strain) vektörü hesaplayabilirim, [12,13]'te işlendi, iki boyutta <span class="math inline">\(\epsilon\)</span>'un sadece üç tane öğesi var,</p>
<p><span class="math display">\[
\epsilon = \left[\begin{array}{c}
\epsilon_{11} \\ \epsilon_{22} \\ 2 \epsilon_{12} 
\end{array}\right]
= \left[\begin{array}{c}
\dfrac{\partial u}{\partial X_1} \\
\dfrac{\partial v}{\partial X_2} \\
\dfrac{\partial u}{\partial X_2} + \dfrac{\partial v}{\partial X_1} 
\end{array}\right]
\qquad (2)
\]</span></p>
<p>Üstteki degerler nereden geldi? Sonsuz Küçük Gerinim Tensörünü hatırlarsak,</p>
<p><span class="math display">\[
\left[\begin{array}{ccc}
  \frac{\partial u_1}{\partial X_1} &amp;
  \frac{1}{2}(\frac{\partial u_1}{\partial X_2} + \frac{\partial u_2}{\partial X_1} ) &amp; 
  \frac{1}{2}(\frac{\partial u_1}{\partial X_3} + \frac{\partial u_3}{\partial  X_1} )
\\
  \frac{1}{2}(\frac{\partial u_1}{\partial X_2} + \frac{\partial u_2}{\partial X_1} ) &amp;
  \frac{\partial u_2}{\partial X_2} &amp;
  \frac{1}{2}(\frac{\partial u_2}{\partial X_3} + \frac{\partial u_3}{\partial X_2} )
\\
  \frac{1}{2}(\frac{\partial u_1}{\partial X_3} + \frac{\partial u_3}{\partial X_1} ) &amp;
  \frac{1}{2}(\frac{\partial u_2}{\partial X_3} + \frac{\partial u_3}{\partial X_2} ) &amp;
  \frac{\partial u_3}{\partial X_3} 
\end{array}\right]
\]</span></p>
<p>Bu tensörün 1'inci satır 1'inci kolonu <span class="math inline">\(\epsilon_{11}\)</span>, 1'inci satır 2'inci kolonu <span class="math inline">\(\epsilon_{12}\)</span> vs. ayrıca bizim burada <span class="math inline">\(u\)</span> dediğimiz üstteki matriste <span class="math inline">\(u_1\)</span>, <span class="math inline">\(v\)</span> dediğimiz ise üstteki matriste <span class="math inline">\(u_2\)</span> ve iki boyutta olduğumuzu hatırlayalım, o zaman <span class="math inline">\(u_3\)</span> ile ilgilenmiyoruz. Aynı sebepten dolayı <span class="math inline">\(\epsilon_{33}\)</span>, <span class="math inline">\(\epsilon_{31}\)</span> gerekli değil. Üç boyuta sonra geleceğiz ve o zaman garanti ederim çok daha karmaşık sonuçlar göreceğiz.</p>
<p>Notasyonel bir konuya dikkat, [10, Video 5]'te <span class="math inline">\(x_{2D}\)</span> kullanıldı, bu harf daha önceki <span class="math inline">\(x\)</span>, değişim sonrası varılan yer ile karıştırılmasın, hoca çok boyutlu bir yer değişimden bahsediyor daha önce <span class="math inline">\(u\)</span> ile gösterilen. Yani üstteki matriste <span class="math inline">\(u\)</span>'nun <span class="math inline">\(X_1\)</span>'e göre türevi <span class="math inline">\(x_{2D}\)</span> üzerinden, yani <span class="math inline">\(x_{2D} = [N] u_e\)</span> üzerinden alınacak.</p>
<p>Devam edelim, (2) türev işlemlerini (1) üzerinde uygulayalım şimdi. <span class="math inline">\(u_e\)</span> içeriği sabit olacağı için türev <span class="math inline">\([N]\)</span> matrisi üzerinden alınır.</p>
<p><span class="math display">\[
\epsilon =
\left[\begin{array}{ccccccc}
\dfrac{\partial N_1}{\partial X_1} &amp; 0 &amp;
\dfrac{\partial N_2}{\partial X_1} &amp; 0 &amp; \dots &amp;
\dfrac{\partial N_n}{\partial X_1} &amp; 0  \\
0 &amp; \dfrac{\partial N_1}{\partial X_1} &amp;
0 &amp; \dfrac{\partial N_2}{\partial X_1} &amp; \dots &amp;
0 &amp; \dfrac{\partial N_n}{\partial X_1}  \\
\dfrac{\partial N_1}{\partial X_2} &amp; \dfrac{\partial N_1}{\partial X_1} &amp; 
\dfrac{\partial N_2}{\partial X_2} &amp; \dfrac{\partial N_2}{\partial X_1} &amp; \dots &amp;
\dfrac{\partial N_n}{\partial X_2} &amp; \dfrac{\partial N_n}{\partial X_1} 
\end{array}\right]
\left[\begin{array}{c}
u_1 \\ v_1 \\ u_2 \\ v_2 \\ \dots \\ u_n \\ v_n
\end{array}\right]
\]</span></p>
<p>Yukarıdaki formülü <span class="math inline">\(\epsilon = [B] u_e\)</span> olarak ta gösterebiliriz, üstte görülen matris <span class="math inline">\(B\)</span> matrisi olarak biliniyor.</p>
<p>Bir kez gerilme sonuçlarını elde edince stres matrisini hesaplayabiliriz, bu tek boyutta bir katsayı çarpımı ile oluyordu çok boyutta bir katsayı matrisi <span class="math inline">\([C]\)</span> ile çarpacağız,</p>
<p><span class="math display">\[
\sigma = \left[\begin{array}{c}
\sigma_{11} \\ \sigma_{22} \\ \sigma_{12}
\end{array}\right] =
[C] \left[\begin{array}{c}
\epsilon_{11} \\ \epsilon_{22} \\ 2 \epsilon_{12}
\end{array}\right] = [C] \epsilon
\]</span></p>
<p>Kaynaklar</p>
<p>[1] Mittal, <em>FEM for Fluid Dynamics, Lecture 07 Part A, Method of Weighted Residuals, IIT Kanpur</em>, <a href="https://www.youtube.com/channel/UCWheqBdP45xBVp_Eqi1eltQ/videos" class="uri">https://www.youtube.com/channel/UCWheqBdP45xBVp_Eqi1eltQ/videos</a></p>
<p>[2] Mittal, <em>FEM for Fluid Dynamics, Lecture 07 Part B, IIT Kanpur</em>, <a href="https://www.youtube.com/channel/UCWheqBdP45xBVp_Eqi1eltQ/videos" class="uri">https://www.youtube.com/channel/UCWheqBdP45xBVp_Eqi1eltQ/videos</a></p>
<p>[3] Mittal, <em>FEM for Fluid Dynamics, Lecture 05 Part C, Inner Product for functions,Orthogonality,Completeness, IIT Kanpur</em>, <a href="https://www.youtube.com/channel/UCWheqBdP45xBVp_Eqi1eltQ/videos" class="uri">https://www.youtube.com/channel/UCWheqBdP45xBVp_Eqi1eltQ/videos</a></p>
<p>[4] Petitt, <em>Intro to the Finite Element Method</em>, University of Alberta, <a href="https://www.youtube.com/watch?v=2iUnfPRk6Ro&amp;list=PLLSzlda_AXa3yQEJAb5JcmsVDy9i9K_fi" class="uri">https://www.youtube.com/watch?v=2iUnfPRk6Ro&amp;list=PLLSzlda_AXa3yQEJAb5JcmsVDy9i9K_fi</a></p>
<p>[5] Bayramlı, <em>Fizik, Materyel Mekaniği - 2</em></p>
<p>[6] Bayramlı, <em>Fizik, Materyel Mekaniği - 4</em></p>
<p>[7] Petitt, <em>Intro to the Finite Element Method</em>, University of Alberta, <a href="https://www.youtube.com/watch?v=2iUnfPRk6Ro&amp;list=PLLSzlda_AXa3yQEJAb5JcmsVDy9i9K_fi" class="uri">https://www.youtube.com/watch?v=2iUnfPRk6Ro&amp;list=PLLSzlda_AXa3yQEJAb5JcmsVDy9i9K_fi</a></p>
<p>[8] Whiteley, <em>Finite Elements Methods, A Practical Guide</em></p>
<p>[9] Adeeb, <em>Introduction to Solid Mechanics, Online Book</em>, <a href="https://engcourses-uofa.ca/books/introduction-to-solid-mechanics/" class="uri">https://engcourses-uofa.ca/books/introduction-to-solid-mechanics/</a></p>
<p>[10] Petitt, <em>Intro to the Finite Element Method</em>, University of Alberta, <a href="https://www.youtube.com/watch?v=2iUnfPRk6Ro&amp;list=PLLSzlda_AXa3yQEJAb5JcmsVDy9i9K_fi" class="uri">https://www.youtube.com/watch?v=2iUnfPRk6Ro&amp;list=PLLSzlda_AXa3yQEJAb5JcmsVDy9i9K_fi</a></p>
<p>[12] Bayramlı, <em>Fizik, Materyel Mekaniği 2</em></p>
<p>[13] Bayramlı, <em>Fizik, Materyel Mekaniği 1</em></p>
</body>
</html>
