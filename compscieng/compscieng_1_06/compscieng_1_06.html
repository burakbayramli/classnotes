<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Ders 1.6</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="ders-1.6">Ders 1.6</h1>
<p>Özvektör formülüne tekrar bakalım</p>
<p><span class="math display">\[ Ay = \lambda y \]</span></p>
<p>Şimdi tüm özvektörler aynı anda tek bir matris içinde olacak şekilde
üstteki formülün her özvektör için işleyecek “kombine’’ bir halini
yazabiliriz. <span class="math inline">\(y_i\)</span> vektörünün tüm bir
kolonu kaplayacak şekilde matrise yazıldığını düşünüyoruz.</p>
<p><span class="math display">\[
A
\left[\begin{array}{cccc}
\uparrow &amp; \uparrow &amp;  &amp; \uparrow \\
y_1 &amp; y_2 &amp; ... &amp; y_n \\
\downarrow &amp; \downarrow &amp;  &amp; \downarrow
\end{array}\right]
=
\left[\begin{array}{cccc}
&amp;&amp;&amp; \\
Ay_1 &amp; Ay_2 &amp; ... &amp; Ay_n \\
&amp;&amp;&amp;
\end{array}\right]
\]</span></p>
<p>Buna göre üstteki eşitliğin sağındaki çarpım da mantıklıdır.Peki
<span class="math inline">\(Ay_i\)</span> çarpımı tanıdık gelmiyor mu?
Çarpım özvektör, özdeğer formülü. O zaman <span
class="math inline">\(Ay_i = \lambda y_i\)</span>. Demek ki,</p>
<p><span class="math display">\[
\left[\begin{array}{cccc}
&amp;&amp;&amp; \\
Ay_1 &amp; Ay_2 &amp; ... &amp; Ay_n \\
&amp;&amp;&amp;
\end{array}\right]
=
\left[\begin{array}{cccc}
&amp;&amp;&amp; \\
\lambda_1y_1 &amp; \lambda_2y_2 &amp; ... &amp; \lambda_ny_n \\
&amp;&amp;&amp;
\end{array}\right]
\]</span></p>
<p><span class="math inline">\(\lambda\)</span>’ları dışarı
çekebiliriz.</p>
<p><span class="math display">\[
= \left[\begin{array}{cccc}
&amp;&amp;&amp; \\
y_1 &amp; y_2 &amp; ... &amp; y_n \\
&amp;&amp;&amp;
\end{array}\right]
\left[\begin{array}{cccc}
\lambda_1 &amp;&amp;&amp; \\
&amp; .. &amp;&amp; \\
&amp;&amp;&amp; \lambda_n \\
\end{array}\right]
\]</span></p>
<p><span class="math inline">\(\lambda\)</span> matrisinde <span
class="math inline">\(\lambda\)</span> olmayan yerler sıfır değerini
taşıyor. Özvektör matrisini <span class="math inline">\(S\)</span>
olarak, çaprazında özdeğerleri taşıyan matrisi <span
class="math inline">\(\Lambda\)</span> olarak nitelersek</p>
<p><span class="math display">\[ AS = S\Lambda \]</span></p>
<p>Eğer üstteki <span class="math inline">\(S\)</span> (ya da herhangi
bir) matrisinin tüm kolonları birbirinden bağımsız ise <span
class="math inline">\(S\)</span> tersine çevirelebilir (invertible)
demektir. O zaman şunu yapabiliriz:</p>
<p><span class="math display">\[ A = S \Lambda S^{-1} \]</span></p>
<p>Bu forma matrisin köşegenleştirilmesi (diagonalization) deniyor.</p>
<p>Biraz zihin egzersizi: <span class="math inline">\(A^2\)</span> ne
olur?</p>
<p><span class="math display">\[ A^2 = (S \Lambda S^{-1})(S \Lambda
S^{-1}) \]</span></p>
<p><span class="math display">\[ = S \Lambda S^{-1}S \Lambda S^{-1}
\]</span></p>
<p>ortadaki <span class="math inline">\(S\)</span> ve <span
class="math inline">\(S^{-1}\)</span> birbirini iptal eder.</p>
<p><span class="math display">\[ = S \Lambda^2 S^{-1} \]</span></p>
<p>Bu bana ne söylüyor? <span class="math inline">\(A^2\)</span>’nin
özvektörleri <span class="math inline">\(A\)</span> ile aynı, çünkü
formülün <span class="math inline">\(S\)</span> ve <span
class="math inline">\(S^{-1}\)</span> içeren kısmı değişmedi, özdeğerler
ise <span class="math inline">\(A\)</span>’nin özdeğerlerinin karesi. Bu
önceden bulduğumuz <span class="math inline">\(A^2y =
\lambda^2y\)</span> sonucu ile uyuşuyor.</p>
<p>Peki, diyelim tersine çevirilebilir ise, <span
class="math inline">\(A^{-1}\)</span> nedir? Ana formülden
başlayalım</p>
<p><span class="math display">\[ A = S \Lambda S^{-1} \]</span></p>
<p>Tersine çevirme işlemi eşitliğin sağ tarafında parantezin içinin
sırasını değiştirir, sonra tersine çevirir, <span
class="math inline">\(S^{-1}\)</span> ile başlarız, onun tersi <span
class="math inline">\(S\)</span>, vs, ve sonuç</p>
<p><span class="math display">\[ A^{-1} = S \Lambda^{-1}S^{-1}
\]</span></p>
<p>Özvektörler matrislerinin yeri ve içeriği değişmedi. Değişik olan tek
şey <span class="math inline">\(\Lambda^{-1}\)</span> ki bu matris
içinde <span class="math inline">\(1/\lambda_1\)</span>, <span
class="math inline">\(1/\lambda_2\)</span>, .. gibi değerler olacak.
Diğer bir açıdan kontrol edelim:</p>
<p><span class="math display">\[ Ay = \lambda y \]</span></p>
<p><span class="math display">\[ y = \lambda A^{-1} y \]</span></p>
<p><span class="math display">\[ \frac{1}{\lambda}y =  A^{-1} y
\]</span></p>
<p>Bu üstteki sonuç ile aynı şeyi söylüyor. <span
class="math inline">\(A^{-1}\)</span>’in tersi aynı <span
class="math inline">\(y\)</span> özvektör(ler)e sahip, ve solda olan
özdeğer öncekine kıyasla <span class="math inline">\(1/\lambda\)</span>
değerinde.</p>
<p>Tabii tüm bunlara başlamadan önce “<span
class="math inline">\(\lambda\)</span>’nin sıfır olmadığı durumlarda’’
demeliydim, çünkü bu sıfırlık durum bize <span
class="math inline">\(A\)</span>’nin tersine çevirilir olmadığı yönünde
bir işaret olurdu. Terminoloji olarak bir tane bile sıfır özdeğer <span
class="math inline">\(A\)</span> eşsiz (singular) demektir, eğer hiçbiri
sıfır değilse <span class="math inline">\(A\)</span> tersine
çevirilebilir demektir.</p>
<p>Bir simetrik <span class="math inline">\(K\)</span> matrisini ele
alalım, simetrik olduğu için tüm özdeğerleri reel sayılar, ve
özvektörleri birbirine dikgen (orthagonal).</p>
<p>Dik yerine normalize edilmiş de diyebilirdik, sayısal paketler
çoğunlukla birimselleştirilmiş, yani uzunluğu 1 olan vektörler döndürür,
ve özdeğer/vektör ikilisi için zaten yön önemlidir, hem özdeğer hem
özvektörü 2 ile çarpıp aynı şeyi elde edebiliriz mesela.</p>
<p>Uzunluktan bahsederken, onu daha önce <span
class="math inline">\(y_i^T \cdot y_j\)</span> olarak gösterdik, ki
simetrik bir matrisin dik özdeğerleri için bu <span
class="math inline">\(y_i^T \cdot y_j = 0, \ i \ne j\)</span>. Normalize
edilmiş bir özvektörün kendisi ile noktasal çarpımı nedir? <span
class="math inline">\(y_i^T \cdot y_i = 1\)</span> çünkü vektör
birimsel, uzunluğu 1. Tüm özdeğerleri içeren matris üzerinden bu hesabı
yapabilir miyiz? Daha önce yarattığımız şu matris ile başlayalım:</p>
<p><span class="math display">\[
\left[\begin{array}{cccc}
\uparrow &amp; \uparrow &amp;  &amp; \uparrow \\
y_1 &amp; y_2 &amp; ... &amp; y_n \\
\downarrow &amp; \downarrow &amp;  &amp; \downarrow
\end{array}\right]
\]</span></p>
<p>sol tarafına devriğini (transpose) koyalım</p>
<p><span class="math display">\[
\left[\begin{array}{ccc}
\leftarrow &amp; y_1^T &amp; \rightarrow \\
&amp; ... &amp; \\
\leftarrow &amp; y_n^T &amp; \rightarrow
\end{array}\right]
\left[\begin{array}{cccc}
\uparrow &amp; \uparrow &amp;  &amp; \uparrow \\
y_1 &amp; y_2 &amp; ... &amp; y_n \\
\downarrow &amp; \downarrow &amp;  &amp; \downarrow
\end{array}\right]
\]</span></p>
<p>Bu çarpımı yaparsak sonuç ne olacak? Mesela <span
class="math inline">\(y_1^T\)</span> ile <span
class="math inline">\(y_1\)</span> çarpımı 1 değerinde, <span
class="math inline">\(y_1^T\)</span> ile diğer her çarpım sıfır. Böyle
gider. Ve sonuç olarak çaprazında 1 diğer her yerinde 0 içeren birim
(identity) matrisini elde ederiz.</p>
<p>Üzerine basarak söyleyelim, bu simetrik matrisler için, çünkü diğer
<span class="math inline">\(A\)</span> matrisleri için özvektörlerin
hepsinin birbirine dik olmasını bekleyemeyiz.</p>
<p>Devam edelim, o zaman üstteki hesabı kısaca gösterirsek</p>
<p><span class="math display">\[ S^T S = I \]</span></p>
<p>Bu hakikaten çok önemli bir sonuç.</p>
<p>Üsttekinin doğru olduğu durumlarda <span
class="math inline">\(S\)</span> harfini değiştirirsek aslında daha iyi
olur böylece özvektör matrisinin bir simetrik <span
class="math inline">\(K\)</span> matrisinden geldiğini daha iyi görürüz.
Bu durumlarda <span class="math inline">\(Q\)</span> harfini
kullanalım.</p>
<p><span class="math inline">\(Q\)</span>’ye bir “dik matris’’ te
denebilir, çünkü <span class="math inline">\(Q^TQ = I\)</span>. Bu
ifadeye bakarak başka bir şey daha söyleyebiliriz, <span
class="math inline">\(Q\)</span>’yu başka <em>ne</em> soldan çarparsa
sonuç birim matristir? <span class="math inline">\(Q^{-1}\)</span>. O
zaman <span class="math inline">\(Q^T = Q^{-1}\)</span> de
diyebiliriz.</p>
<p>Bir dik matris örneği görelim:</p>
<p><span class="math display">\[
\left[\begin{array}{cc}
\cos \theta &amp; -\sin \theta \\
\sin \theta &amp; \cos \theta \\
\end{array}\right]
\]</span></p>
<p>İlk kolona bakalım, uzunluğu hakikaten 1, çünkü <span
class="math inline">\(\cos \theta ^2 + \sin \theta ^2 = 1\)</span>.
Diğer kolon da ona dik, 1. kolon ile çarpılınca sonuç sıfır olacak.</p>
<p>Not: Üstteki matrise “<span class="math inline">\(\theta\)</span>
kadar döndüren matris’’ ismi de verilir, eldeki bir <span
class="math inline">\(v\)</span> vektörünü <span
class="math inline">\(Q\)</span> ile çarpımı, yani <span
class="math inline">\(Qv\)</span>, o vektörü uzunluğunu değiştirmeden
<span class="math inline">\(\theta\)</span> kadar döndürecektir.</p>
<p>Devam edelim</p>
<p><span class="math display">\[ K = S \Lambda S^{-1} \]</span></p>
<p><span class="math inline">\(S\)</span> yerine <span
class="math inline">\(Q\)</span> kullanmaya karar vermiştik</p>
<p><span class="math display">\[  K = Q \Lambda Q^{-1} \]</span></p>
<p>O zaman, daha önceden gördüğümüz eşitlik üzerinden,</p>
<p><span class="math display">\[  K = Q \Lambda Q^{T} \]</span></p>
<p>Şu güzelliğe bakın. Buna mekanikte asal eksen teoremi (principal axis
theorem), matematikte spektral teoremi (spectral theorem), kuantum
mekanikte köşegenleştirme (diagonalization) ismi verilir, her yerde
ortaya çıkar, pek çok şekilde kullanılır. Ne zaman elde bir simetrik
matris var ise, o zaman üstteki tanım kullanılabilir demektir.</p>
<p><span class="math inline">\(K\)</span> matrisine geri dönelim.</p>
<p><span class="math display">\[
K =
\left[\begin{array}{rrrrr}
2 &amp; -1 &amp;&amp;&amp; \\
-1 &amp; \ddots &amp; \ddots &amp;&amp; \\
&amp; \ddots &amp;&amp;&amp; \\
&amp;&amp;&amp;&amp; \\
&amp;&amp;&amp;&amp;
\end{array}\right]
\]</span></p>
<p>Bu matris ikinci farklılıkları ayrıksal olarak temsil etmek için
kullanılmıştı, esnek çubuğu temsil ettiği zaman sabit / sabit problemini
çözüyordu. <span class="math inline">\(K\)</span> sürekli (continuous)
bağlamda hangi diferansiyel denklemi temsil edecektir? <span
class="math inline">\(-d^2y/dx^2\)</span>. Özdeğer, özvektör olarak
ise</p>
<p><span class="math display">\[ Ky = \lambda y \]</span></p>
<p>Şöyle bir geçiş yapılabilir</p>
<p><span class="math display">\[ -\frac{d^2y}{dx^2} = \lambda y(x)
\]</span></p>
<p>Burada ilginç bir numara var: daha önce sürekli fonksiyondan
başlıyorduk, sonra <span class="math inline">\(K\)</span> matrisi
üzerinden ayrıksal hale geçiriyorduk. Hoca burada özdeğer, özvektör
formundan başladı, ve sürekli forma geçti. Sonra üstteki denklemin
çözümünü bulunca, tekrar geri gidecek, ve ayrıksal olarak özvektörlerin
birbirine dikliğini göreceğiz, ve bunun sürekli bağlamda da hala geçerli
olduğunu anlayacağız.</p>
<p>Çözümü bulmak için tahmin yöntemini kullanalım: hangi fonksiyonun
ikinci türevinin negatifi, o fonksiyonun katını verir? Sin ve cos
fonksiyonları, yani <span class="math inline">\(y\)</span> <span
class="math inline">\(\sin \omega x\)</span>, <span
class="math inline">\(\cos \omega x\)</span> olabilir, ya da onların
birleşimi olarak üstel <span class="math inline">\(e^{-i\omega
x}\)</span>, <span class="math inline">\(e^{i\omega x}\)</span> formunda
olabilir.</p>
<p>Eğer <span class="math inline">\(y\)</span> için <span
class="math inline">\(\sin, \cos\)</span> kullanırsak özdeğer ne olur?
Yerine koyarsak görürüz, <span class="math inline">\(\sin\omega
x\)</span>’in iki kere türevini alırsak <span
class="math inline">\(\omega\)</span> iki kere dışarı çıkar, arada bir
eksi değeri mutlaka ortaya çıkar (çünkü <span
class="math inline">\(\cos&#39;\theta = -\sin\theta)\)</span>, eksi ile
eksi çarpılır, sonuç <span class="math inline">\(\omega^2\)</span>.
Hatta üstteki tüm <span class="math inline">\(y\)</span> seçenekleri
için sonuç aynıdır.</p>
<p>Sınır koşullarını unutmayalım tabii. Problemin tamamı</p>
<p><span class="math display">\[ -\frac{d^2y}{dx^2} = \lambda y(x)
\]</span></p>
<p><span class="math display">\[ y(0) = 0, \ y(1) = 0 \]</span></p>
<p>Sınır koşulları sayesinde tüm <span
class="math inline">\(\sin\)</span>, tüm <span
class="math inline">\(\cos\)</span> fonksiyonları arasından belli
bazılarını seçebileceğiz. En basit eleme <span
class="math inline">\(y(0) = 0\)</span>, bu şart sayesinde cos
fonksiyonlarının tamamı elenir. Değil mi? Çünkü <span
class="math inline">\(\cos(0) = 0\)</span> doğru olamaz. Diğer şarta
bakalım, <span class="math inline">\(y(1)\)</span> üzerinden <span
class="math inline">\(\sin(\omega) = 0\)</span> olur, tersinden
düşünürsek <span class="math inline">\(\sin(\omega)\)</span> ile sıfır
değeri verecek <span class="math inline">\(\omega\)</span> ne olabilir?
<span class="math inline">\(\pi\)</span> olabilir. O zaman bir çözüm
bulduk:</p>
<p><span class="math display">\[ y_1 = \sin \pi x \]</span></p>
<p>Elimizdeki ilk “özfonksiyon (eigenfunction)’’ bu. Özdeğeri nedir?</p>
<p><span class="math display">\[ \lambda_1 = \pi^2 \]</span></p>
<p>çünkü üstte belirttik, <span class="math inline">\(\omega^2\)</span>,
o zaman <span class="math inline">\(\pi^2\)</span>.</p>
<p>İkinci değer ne olur? <span class="math inline">\(2\pi\)</span>.</p>
<p><span class="math display">\[ y_2 = sin2\pi x, \ \lambda_2 = (2\pi)^2
= 4\pi^2 \]</span></p>
<p>Eğer sınır şartlarını değiştirseydim, serbest / serbest, serbest /
sabit gibi, o zaman farklı <span class="math inline">\(y\)</span>
değerleri elde ederdim. Mesela ilk sınır şartı <span
class="math inline">\(y&#39;(0) = 0\)</span> olsaydı, sin fonksiyonları
yerine cos fonksiyonları elde ederdik, sin elenirdi çünkü sin’in türevi
<span class="math inline">\(\cos(0) = 0\)</span> doğru bir ifade
olamazdı.</p>
<p>Ayrıksal olarak temsil edersek, <span class="math inline">\(\sin\pi
h\)</span> ve <span class="math inline">\(h = 1 / n+1\)</span>, <span
class="math inline">\(n = 4\)</span> kullanalım</p>
<p><span class="math display">\[
y_1 =
\left[\begin{array}{c}
\sin \frac{\pi}{5} \\
\sin \frac{2\pi}{5} \\
\sin \frac{3\pi}{5} \\
\sin \frac{4\pi}{5}
\end{array}\right]
\]</span></p>
<p><img src="6_2.png" /></p>
<p>Bu da ikinci özvektör (özfonksiyon).</p>
<p><span class="math display">\[
y_2 =
\left[\begin{array}{c}
sin \frac{2\pi}{5} \\
sin \frac{4\pi}{5} \\
sin \frac{6\pi}{5} \\
sin \frac{8\pi}{5}
\end{array}\right]
\]</span></p>
<p><img src="6_3.png" /></p>
<p>Özvektörler olduğunu söylemekle ikinci bir şey daha söylüyoruz, bu
iki vektör birbirine dik. Buradan hareketle <span
class="math inline">\(\sin(\pi x)\)</span> fonksiyonu (iki üstteki
resim) <span class="math inline">\(\sin(2\pi x)\)</span> fonksiyonuna
(bir üstteki resim) dik diyebilirdik, ki hakikaten öyledir. Hatta bu
matematiksel durum Fourier Serilerinin işlemesini sağlayan önemli bir
etkendir.</p>
<p>Bu bağlantıdan devam edelim: pür vektörler olduğu zaman diklik
kontrolü için <span class="math inline">\(y_1^T \cdot y_2\)</span>
diyordum, ve <span class="math inline">\(y_1\)</span> ve <span
class="math inline">\(y_2\)</span>’nin eşleşen elemanları birbiriyle
çarpılıp, bu sonuçlar teker teker toplanıyordu. Elimde <span
class="math inline">\(y_1\)</span> ve <span
class="math inline">\(y_2\)</span> için birer fonksiyon var ise, bir
tarafta <span class="math inline">\(\sin(\pi x)\)</span> var, her <span
class="math inline">\(x\)</span> için değişik değerler veriyor, diğer
tarafta <span class="math inline">\(\sin(2\pi x)\)</span> var, bunları
çarpıp toplamam lazım. Ama elimde teker teker toplayabileceğim değerler
olmadığı için (<span class="math inline">\(x\)</span> reel bir sayıdır,
belli bir aralıkta bile sonsuz tane değere sahip olabilir), o zaman
toplama yerine entegrasyon kullanmam lazım. O zaman</p>
<p><span class="math display">\[ y_1^T \cdot y_2  = \int_0^1 (\sin \pi
x)(\sin 2\pi x) \mathrm{d} x  \]</span></p>
<p>Sonuç sıfır gelecek, çünkü iki fonksiyon birbirine dik.</p>
<p>Soru 1.5.3</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.linalg <span class="im">as</span> lin</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ktbc(n):</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    vec <span class="op">=</span> np.zeros((<span class="dv">1</span>,n))</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    vec[<span class="dv">0</span>,<span class="dv">0</span>] <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    vec[<span class="dv">0</span>,<span class="dv">1</span>] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    K <span class="op">=</span> lin.toeplitz(vec)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> np.copy(K)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    T[<span class="dv">0</span>,<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> np.copy(K)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    B[<span class="dv">0</span>,<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    B[n<span class="op">-</span><span class="dv">1</span>,n<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    C <span class="op">=</span> np.copy(K)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    C[n<span class="op">-</span><span class="dv">1</span>,n<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> K, T, B, C</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.linalg <span class="im">as</span> lin</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ktbc</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>K,T,B,C <span class="op">=</span>  ktbc.ktbc(<span class="dv">5</span>)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>u,v<span class="op">=</span>lin.eig(K)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> u</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> <span class="dv">2</span><span class="op">-</span>np.sqrt(<span class="dv">3</span>), <span class="dv">2</span><span class="op">-</span><span class="dv">1</span>, <span class="dv">2</span><span class="op">-</span><span class="dv">0</span>, <span class="dv">2</span><span class="op">+</span><span class="dv">1</span>, <span class="dv">2</span><span class="op">+</span>np.sqrt(<span class="dv">3</span>)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> <span class="dv">2</span><span class="op">*</span>np.ones((<span class="dv">5</span>,<span class="dv">1</span>)).T <span class="op">-</span> <span class="dv">2</span><span class="op">*</span>np.cos((np.arange(<span class="dv">5</span>)<span class="op">+</span><span class="dv">1</span>) <span class="op">*</span> np.pi<span class="op">/</span><span class="dv">6</span>)</span></code></pre></div>
<pre><code>[ 3.73205081+0.j  3.00000000+0.j  2.00000000+0.j  0.26794919+0.j
  1.00000000+0.j]
0.267949192431 1 2 3 3.73205080757
[[ 0.26794919  1.          2.          3.          3.73205081]]</code></pre>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
