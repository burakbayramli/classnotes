<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  
  
  
  
</head>
<body>
<h1 id="ders-1.6">Ders 1.6</h1>
<p>Özvektör formülüne tekrar bakalım</p>
<p><span class="math display">\[ Ay = \lambda y \]</span></p>
<p>Şimdi tüm özvektörler aynı anda tek bir matris içinde olacak şekilde üstteki formülün her özvektör için işleyecek &quot;kombine'' bir halini yazabiliriz. <span class="math inline">\(y_i\)</span> vektörünün tüm bir kolonu kaplayacak şekilde matrise yazıldığını düşünüyoruz.</p>
<p><span class="math display">\[ 
A 
\left[\begin{array}{cccc}
\uparrow &amp; \uparrow &amp;  &amp; \uparrow \\
y_1 &amp; y_2 &amp; ... &amp; y_n \\
\downarrow &amp; \downarrow &amp;  &amp; \downarrow 
\end{array}\right]
= 
\left[\begin{array}{cccc}
&amp;&amp;&amp; \\
Ay_1 &amp; Ay_2 &amp; ... &amp; Ay_n \\
&amp;&amp;&amp; 
\end{array}\right]
\]</span></p>
<p>Buna göre üstteki eşitliğin sağındaki çarpım da mantıklıdır.Peki <span class="math inline">\(Ay_i\)</span> çarpımı tanıdık gelmiyor mu? Çarpım özvektör, özdeğer formülü. O zaman <span class="math inline">\(Ay_i = \lambda y_i\)</span>. Demek ki,</p>
<p><span class="math display">\[ 
\left[\begin{array}{cccc}
&amp;&amp;&amp; \\
Ay_1 &amp; Ay_2 &amp; ... &amp; Ay_n \\
&amp;&amp;&amp; 
\end{array}\right]
= 
\left[\begin{array}{cccc}
&amp;&amp;&amp; \\
\lambda_1y_1 &amp; \lambda_2y_2 &amp; ... &amp; \lambda_ny_n \\
&amp;&amp;&amp; 
\end{array}\right]
 \]</span></p>
<p><span class="math inline">\(\lambda\)</span>'ları dışarı çekebiliriz.</p>
<p><span class="math display">\[ 
= \left[\begin{array}{cccc}
&amp;&amp;&amp; \\
y_1 &amp; y_2 &amp; ... &amp; y_n \\
&amp;&amp;&amp; 
\end{array}\right]
\left[\begin{array}{cccc}
\lambda_1 &amp;&amp;&amp; \\
&amp; .. &amp;&amp; \\
&amp;&amp;&amp; \lambda_n \\
\end{array}\right]
 \]</span></p>
<p><span class="math inline">\(\lambda\)</span> matrisinde <span class="math inline">\(\lambda\)</span> olmayan yerler sıfır değerini taşıyor. Özvektör matrisini <span class="math inline">\(S\)</span> olarak, çaprazında özdeğerleri taşıyan matrisi <span class="math inline">\(\Lambda\)</span> olarak nitelersek</p>
<p><span class="math display">\[ AS = S\Lambda \]</span></p>
<p>Eğer üstteki <span class="math inline">\(S\)</span> (ya da herhangi bir) matrisinin tüm kolonları birbirinden bağımsız ise <span class="math inline">\(S\)</span> tersine çevirelebilir (invertible) demektir. O zaman şunu yapabiliriz:</p>
<p><span class="math display">\[ A = S \Lambda S^{-1} \]</span></p>
<p>Bu forma matrisin köşegenleştirilmesi (diagonalization) deniyor.</p>
<p>Biraz zihin egzersizi: <span class="math inline">\(A^2\)</span> ne olur?</p>
<p><span class="math display">\[ A^2 = (S \Lambda S^{-1})(S \Lambda S^{-1}) \]</span></p>
<p><span class="math display">\[ = S \Lambda S^{-1}S \Lambda S^{-1} \]</span></p>
<p>ortadaki <span class="math inline">\(S\)</span> ve <span class="math inline">\(S^{-1}\)</span> birbirini iptal eder.</p>
<p><span class="math display">\[ = S \Lambda^2 S^{-1} \]</span></p>
<p>Bu bana ne söylüyor? <span class="math inline">\(A^2\)</span>'nin özvektörleri <span class="math inline">\(A\)</span> ile aynı, çünkü formülün <span class="math inline">\(S\)</span> ve <span class="math inline">\(S^{-1}\)</span> içeren kısmı değişmedi, özdeğerler ise <span class="math inline">\(A\)</span>'nin özdeğerlerinin karesi. Bu önceden bulduğumuz <span class="math inline">\(A^2y = \lambda^2y\)</span> sonucu ile uyuşuyor.</p>
<p>Peki, diyelim tersine çevirilebilir ise, <span class="math inline">\(A^{-1}\)</span> nedir? Ana formülden başlayalım</p>
<p><span class="math display">\[ A = S \Lambda S^{-1} \]</span></p>
<p>Tersine çevirme işlemi eşitliğin sağ tarafında parantezin içinin sırasını değiştirir, sonra tersine çevirir, <span class="math inline">\(S^{-1}\)</span> ile başlarız, onun tersi <span class="math inline">\(S\)</span>, vs, ve sonuç</p>
<p><span class="math display">\[ A^{-1} = S \Lambda^{-1}S^{-1} \]</span></p>
<p>Özvektörler matrislerinin yeri ve içeriği değişmedi. Değişik olan tek şey <span class="math inline">\(\Lambda^{-1}\)</span> ki bu matris içinde <span class="math inline">\(1/\lambda_1\)</span>, <span class="math inline">\(1/\lambda_2\)</span>, .. gibi değerler olacak. Diğer bir açıdan kontrol edelim:</p>
<p><span class="math display">\[ Ay = \lambda y \]</span></p>
<p><span class="math display">\[ y = \lambda A^{-1} y \]</span></p>
<p><span class="math display">\[ \frac{1}{\lambda}y =  A^{-1} y \]</span></p>
<p>Bu üstteki sonuç ile aynı şeyi söylüyor. <span class="math inline">\(A^{-1}\)</span>'in tersi aynı <span class="math inline">\(y\)</span> özvektör(ler)e sahip, ve solda olan özdeğer öncekine kıyasla <span class="math inline">\(1/\lambda\)</span> değerinde.</p>
<p>Tabii tüm bunlara başlamadan önce &quot;<span class="math inline">\(\lambda\)</span>'nin sıfır olmadığı durumlarda'' demeliydim, çünkü bu sıfırlık durum bize <span class="math inline">\(A\)</span>'nin tersine çevirilir olmadığı yönünde bir işaret olurdu. Terminoloji olarak bir tane bile sıfır özdeğer <span class="math inline">\(A\)</span> eşsiz (singular) demektir, eğer hiçbiri sıfır değilse <span class="math inline">\(A\)</span> tersine çevirilebilir demektir.</p>
<p>Bir simetrik <span class="math inline">\(K\)</span> matrisini ele alalım, simetrik olduğu için tüm özdeğerleri reel sayılar, ve özvektörleri birbirine dikgen (orthagonal).</p>
<p>Dik yerine normalize edilmiş de diyebilirdik, sayısal paketler çoğunlukla birimselleştirilmiş, yani uzunluğu 1 olan vektörler döndürür, ve özdeğer/vektör ikilisi için zaten yön önemlidir, hem özdeğer hem özvektörü 2 ile çarpıp aynı şeyi elde edebiliriz mesela.</p>
<p>Uzunluktan bahsederken, onu daha önce <span class="math inline">\(y_i^T \cdot y_j\)</span> olarak gösterdik, ki simetrik bir matrisin dik özdeğerleri için bu <span class="math inline">\(y_i^T \cdot y_j = 0, \ i \ne j\)</span>. Normalize edilmiş bir özvektörün kendisi ile noktasal çarpımı nedir? <span class="math inline">\(y_i^T \cdot y_i = 1\)</span> çünkü vektör birimsel, uzunluğu 1. Tüm özdeğerleri içeren matris üzerinden bu hesabı yapabilir miyiz? Daha önce yarattığımız şu matris ile başlayalım:</p>
<p><span class="math display">\[ 
\left[\begin{array}{cccc}
\uparrow &amp; \uparrow &amp;  &amp; \uparrow \\
y_1 &amp; y_2 &amp; ... &amp; y_n \\
\downarrow &amp; \downarrow &amp;  &amp; \downarrow 
\end{array}\right]
\]</span></p>
<p>sol tarafına devriğini (transpose) koyalım</p>
<p><span class="math display">\[ 
\left[\begin{array}{ccc}
\leftarrow &amp; y_1^T &amp; \rightarrow \\
 &amp; ... &amp; \\
\leftarrow &amp; y_n^T &amp; \rightarrow 
\end{array}\right]
\left[\begin{array}{cccc}
\uparrow &amp; \uparrow &amp;  &amp; \uparrow \\
y_1 &amp; y_2 &amp; ... &amp; y_n \\
\downarrow &amp; \downarrow &amp;  &amp; \downarrow 
\end{array}\right]
\]</span></p>
<p>Bu çarpımı yaparsak sonuç ne olacak? Mesela <span class="math inline">\(y_1^T\)</span> ile <span class="math inline">\(y_1\)</span> çarpımı 1 değerinde, <span class="math inline">\(y_1^T\)</span> ile diğer her çarpım sıfır. Böyle gider. Ve sonuç olarak çaprazında 1 diğer her yerinde 0 içeren birim (identity) matrisini elde ederiz.</p>
<p>Üzerine basarak söyleyelim, bu simetrik matrisler için, çünkü diğer <span class="math inline">\(A\)</span> matrisleri için özvektörlerin hepsinin birbirine dik olmasını bekleyemeyiz.</p>
<p>Devam edelim, o zaman üstteki hesabı kısaca gösterirsek</p>
<p><span class="math display">\[ S^T S = I \]</span></p>
<p>Bu hakikaten çok önemli bir sonuç.</p>
<p>Üsttekinin doğru olduğu durumlarda <span class="math inline">\(S\)</span> harfini değiştirirsek aslında daha iyi olur böylece özvektör matrisinin bir simetrik <span class="math inline">\(K\)</span> matrisinden geldiğini daha iyi görürüz. Bu durumlarda <span class="math inline">\(Q\)</span> harfini kullanalım.</p>
<p><span class="math inline">\(Q\)</span>'ye bir &quot;dik matris'' te denebilir, çünkü <span class="math inline">\(Q^TQ = I\)</span>. Bu ifadeye bakarak başka bir şey daha söyleyebiliriz, <span class="math inline">\(Q\)</span>'yu başka <em>ne</em> soldan çarparsa sonuç birim matristir? <span class="math inline">\(Q^{-1}\)</span>. O zaman <span class="math inline">\(Q^T = Q^{-1}\)</span> de diyebiliriz.</p>
<p>Bir dik matris örneği görelim:</p>
<p><span class="math display">\[ 
\left[\begin{array}{cc}
\cos \theta &amp; -\sin \theta \\
\sin \theta &amp; \cos \theta \\
\end{array}\right]
 \]</span></p>
<p>İlk kolona bakalım, uzunluğu hakikaten 1, çünkü <span class="math inline">\(\cos \theta ^2 + \sin \theta ^2 = 1\)</span>. Diğer kolon da ona dik, 1. kolon ile çarpılınca sonuç sıfır olacak.</p>
<p>Not: Üstteki matrise &quot;<span class="math inline">\(\theta\)</span> kadar döndüren matris'' ismi de verilir, eldeki bir <span class="math inline">\(v\)</span> vektörünü <span class="math inline">\(Q\)</span> ile çarpımı, yani <span class="math inline">\(Qv\)</span>, o vektörü uzunluğunu değiştirmeden <span class="math inline">\(\theta\)</span> kadar döndürecektir.</p>
<p>Devam edelim</p>
<p><span class="math display">\[ K = S \Lambda S^{-1} \]</span></p>
<p><span class="math inline">\(S\)</span> yerine <span class="math inline">\(Q\)</span> kullanmaya karar vermiştik</p>
<p><span class="math display">\[  K = Q \Lambda Q^{-1} \]</span></p>
<p>O zaman, daha önceden gördüğümüz eşitlik üzerinden,</p>
<p><span class="math display">\[  K = Q \Lambda Q^{T} \]</span></p>
<p>Şu güzelliğe bakın. Buna mekanikte asal eksen teoremi (principal axis theorem), matematikte spektral teoremi (spectral theorem), kuantum mekanikte köşegenleştirme (diagonalization) ismi verilir, her yerde ortaya çıkar, pek çok şekilde kullanılır. Ne zaman elde bir simetrik matris var ise, o zaman üstteki tanım kullanılabilir demektir.</p>
<p><span class="math inline">\(K\)</span> matrisine geri dönelim.</p>
<p><span class="math display">\[ 
K =
\left[\begin{array}{rrrrr}
2 &amp; -1 &amp;&amp;&amp; \\
-1 &amp; \ddots &amp; \ddots &amp;&amp; \\
&amp; \ddots &amp;&amp;&amp; \\
&amp;&amp;&amp;&amp; \\
&amp;&amp;&amp;&amp; 
\end{array}\right]
 \]</span></p>
<p>Bu matris ikinci farklılıkları ayrıksal olarak temsil etmek için kullanılmıştı, esnek çubuğu temsil ettiği zaman sabit / sabit problemini çözüyordu. <span class="math inline">\(K\)</span> sürekli (continuous) bağlamda hangi diferansiyel denklemi temsil edecektir? <span class="math inline">\(-d^2y/dx^2\)</span>. Özdeğer, özvektör olarak ise</p>
<p><span class="math display">\[ Ky = \lambda y \]</span></p>
<p>Şöyle bir geçiş yapılabilir</p>
<p><span class="math display">\[ -\frac{d^2y}{dx^2} = \lambda y(x) \]</span></p>
<p>Burada ilginç bir numara var: daha önce sürekli fonksiyondan başlıyorduk, sonra <span class="math inline">\(K\)</span> matrisi üzerinden ayrıksal hale geçiriyorduk. Hoca burada özdeğer, özvektör formundan başladı, ve sürekli forma geçti. Sonra üstteki denklemin çözümünü bulunca, tekrar geri gidecek, ve ayrıksal olarak özvektörlerin birbirine dikliğini göreceğiz, ve bunun sürekli bağlamda da hala geçerli olduğunu anlayacağız.</p>
<p>Çözümü bulmak için tahmin yöntemini kullanalım: hangi fonksiyonun ikinci türevinin negatifi, o fonksiyonun katını verir? Sin ve cos fonksiyonları, yani <span class="math inline">\(y\)</span> <span class="math inline">\(\sin \omega x\)</span>, <span class="math inline">\(\cos \omega x\)</span> olabilir, ya da onların birleşimi olarak üstel <span class="math inline">\(e^{-i\omega x}\)</span>, <span class="math inline">\(e^{i\omega x}\)</span> formunda olabilir.</p>
<p>Eğer <span class="math inline">\(y\)</span> için <span class="math inline">\(\sin, \cos\)</span> kullanırsak özdeğer ne olur? Yerine koyarsak görürüz, <span class="math inline">\(\sin\omega x\)</span>'in iki kere türevini alırsak <span class="math inline">\(\omega\)</span> iki kere dışarı çıkar, arada bir eksi değeri mutlaka ortaya çıkar (çünkü <span class="math inline">\(\cos&#39;\theta = -\sin\theta)\)</span>, eksi ile eksi çarpılır, sonuç <span class="math inline">\(\omega^2\)</span>. Hatta üstteki tüm <span class="math inline">\(y\)</span> seçenekleri için sonuç aynıdır.</p>
<p>Sınır koşullarını unutmayalım tabii. Problemin tamamı</p>
<p><span class="math display">\[ -\frac{d^2y}{dx^2} = \lambda y(x) \]</span></p>
<p><span class="math display">\[ y(0) = 0, \ y(1) = 0 \]</span></p>
<p>Sınır koşulları sayesinde tüm <span class="math inline">\(\sin\)</span>, tüm <span class="math inline">\(\cos\)</span> fonksiyonları arasından belli bazılarını seçebileceğiz. En basit eleme <span class="math inline">\(y(0) = 0\)</span>, bu şart sayesinde cos fonksiyonlarının tamamı elenir. Değil mi? Çünkü <span class="math inline">\(\cos(0) = 0\)</span> doğru olamaz. Diğer şarta bakalım, <span class="math inline">\(y(1)\)</span> üzerinden <span class="math inline">\(\sin(\omega) = 0\)</span> olur, tersinden düşünürsek <span class="math inline">\(\sin(\omega)\)</span> ile sıfır değeri verecek <span class="math inline">\(\omega\)</span> ne olabilir? <span class="math inline">\(\pi\)</span> olabilir. O zaman bir çözüm bulduk:</p>
<p><span class="math display">\[ y_1 = \sin \pi x \]</span></p>
<p>Elimizdeki ilk &quot;özfonksiyon (eigenfunction)'' bu. Özdeğeri nedir?</p>
<p><span class="math display">\[ \lambda_1 = \pi^2 \]</span></p>
<p>çünkü üstte belirttik, <span class="math inline">\(\omega^2\)</span>, o zaman <span class="math inline">\(\pi^2\)</span>.</p>
<p>İkinci değer ne olur? <span class="math inline">\(2\pi\)</span>.</p>
<p><span class="math display">\[ y_2 = sin2\pi x, \ \lambda_2 = (2\pi)^2 = 4\pi^2 \]</span></p>
<p>Eğer sınır şartlarını değiştirseydim, serbest / serbest, serbest / sabit gibi, o zaman farklı <span class="math inline">\(y\)</span> değerleri elde ederdim. Mesela ilk sınır şartı <span class="math inline">\(y&#39;(0) = 0\)</span> olsaydı, sin fonksiyonları yerine cos fonksiyonları elde ederdik, sin elenirdi çünkü sin'in türevi <span class="math inline">\(\cos(0) = 0\)</span> doğru bir ifade olamazdı.</p>
<p>Ayrıksal olarak temsil edersek, <span class="math inline">\(\sin\pi h\)</span> ve <span class="math inline">\(h = 1 / n+1\)</span>, <span class="math inline">\(n = 4\)</span> kullanalım</p>
<p><span class="math display">\[ 
y_1 = 
\left[\begin{array}{c}
\sin \frac{\pi}{5} \\
\sin \frac{2\pi}{5} \\
\sin \frac{3\pi}{5} \\
\sin \frac{4\pi}{5} 
\end{array}\right]
 \]</span></p>
<div class="figure">
<img src="6_2.png" />

</div>
<p>Bu da ikinci özvektör (özfonksiyon).</p>
<p><span class="math display">\[ 
y_2 = 
\left[\begin{array}{c}
sin \frac{2\pi}{5} \\
sin \frac{4\pi}{5} \\
sin \frac{6\pi}{5} \\
sin \frac{8\pi}{5} 
\end{array}\right]
 \]</span></p>
<div class="figure">
<img src="6_3.png" />

</div>
<p>Özvektörler olduğunu söylemekle ikinci bir şey daha söylüyoruz, bu iki vektör birbirine dik. Buradan hareketle <span class="math inline">\(\sin(\pi x)\)</span> fonksiyonu (iki üstteki resim) <span class="math inline">\(\sin(2\pi x)\)</span> fonksiyonuna (bir üstteki resim) dik diyebilirdik, ki hakikaten öyledir. Hatta bu matematiksel durum Fourier Serilerinin işlemesini sağlayan önemli bir etkendir.</p>
<p>Bu bağlantıdan devam edelim: pür vektörler olduğu zaman diklik kontrolü için <span class="math inline">\(y_1^T \cdot y_2\)</span> diyordum, ve <span class="math inline">\(y_1\)</span> ve <span class="math inline">\(y_2\)</span>'nin eşleşen elemanları birbiriyle çarpılıp, bu sonuçlar teker teker toplanıyordu. Elimde <span class="math inline">\(y_1\)</span> ve <span class="math inline">\(y_2\)</span> için birer fonksiyon var ise, bir tarafta <span class="math inline">\(\sin(\pi x)\)</span> var, her <span class="math inline">\(x\)</span> için değişik değerler veriyor, diğer tarafta <span class="math inline">\(\sin(2\pi x)\)</span> var, bunları çarpıp toplamam lazım. Ama elimde teker teker toplayabileceğim değerler olmadığı için (<span class="math inline">\(x\)</span> reel bir sayıdır, belli bir aralıkta bile sonsuz tane değere sahip olabilir), o zaman toplama yerine entegrasyon kullanmam lazım. O zaman</p>
<p><span class="math display">\[ y_1^T \cdot y_2  = \int_0^1 (\sin \pi x)(\sin 2\pi x) \mathrm{d} x  \]</span></p>
<p>Sonuç sıfır gelecek, çünkü iki fonksiyon birbirine dik.</p>
<p>Soru 1.5.3</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> scipy.linalg <span class="im">as</span> lin

<span class="kw">def</span> ktbc(n):
    vec <span class="op">=</span> np.zeros((<span class="dv">1</span>,n))
    vec[<span class="dv">0</span>,<span class="dv">0</span>] <span class="op">=</span> <span class="dv">2</span>
    vec[<span class="dv">0</span>,<span class="dv">1</span>] <span class="op">=</span> <span class="dv">-1</span>
    K <span class="op">=</span> lin.toeplitz(vec)
    T <span class="op">=</span> np.copy(K)
    T[<span class="dv">0</span>,<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span>
    B <span class="op">=</span> np.copy(K)
    B[<span class="dv">0</span>,<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span>
    B[n<span class="dv">-1</span>,n<span class="dv">-1</span>] <span class="op">=</span> <span class="dv">1</span>
    C <span class="op">=</span> np.copy(K)
    C[n<span class="dv">-1</span>,n<span class="dv">-1</span>] <span class="op">=</span> <span class="dv">1</span>
    
    <span class="cf">return</span> K, T, B, C

<span class="im">import</span> scipy.linalg <span class="im">as</span> lin
<span class="im">import</span> ktbc

K,T,B,C <span class="op">=</span>  ktbc.ktbc(<span class="dv">5</span>)

u,v<span class="op">=</span>lin.eig(K)

<span class="bu">print</span> u

<span class="bu">print</span> <span class="dv">2</span><span class="op">-</span>np.sqrt(<span class="dv">3</span>), <span class="dv">2-1</span>, <span class="dv">2-0</span>, <span class="dv">2</span><span class="op">+</span><span class="dv">1</span>, <span class="dv">2</span><span class="op">+</span>np.sqrt(<span class="dv">3</span>)

<span class="bu">print</span> <span class="dv">2</span><span class="op">*</span>np.ones((<span class="dv">5</span>,<span class="dv">1</span>)).T <span class="op">-</span> <span class="dv">2</span><span class="op">*</span>np.cos((np.arange(<span class="dv">5</span>)<span class="op">+</span><span class="dv">1</span>) <span class="op">*</span> np.pi<span class="op">/</span><span class="dv">6</span>)</code></pre></div>
<pre><code>[ 3.73205081+0.j  3.00000000+0.j  2.00000000+0.j  0.26794919+0.j
  1.00000000+0.j]
0.267949192431 1 2 3 3.73205080757
[[ 0.26794919  1.          2.          3.          3.73205081]]</code></pre>
</body>
</html>
