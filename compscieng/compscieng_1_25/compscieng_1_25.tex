\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Ders 25

[ders notlarý atlandý]

z Transform 

z Transform, Laplace Transformunun ayrýksal dünyadaki karþýlýðýdýr,
transform edilen sürekli fonksiyon $f(t)$ deðil, ayrýksal, bir vektör
olarak görülebilecek $x(n)$'dir. z Transform

$$ Z[x(n)] \leadsto X(z) = \sum_{-\infty}^{\infty} x(n)z^{-n}  $$

ki $z$ bir kompleks sayýdýr. 

Geliþigüzel (casual) sistemlerden gelen verilerde sadece $n>0$ veriye
bakýlabilir, o zaman alt sýnýr sýfýr olur

$$ X(z) = \sum_{0}^{\infty} x(n)z^{-n}  $$

z Transform ne iþe yarar? Laplace Transform diferansiyel denklemlerin
çözülmesine yardým ediyordu. z Transform benzer þekilde farklýlýk
(difference) denklemlerin çözülmesine yardým eder. Farklýlýk denklemi
mesela

$$ y(n) = 0.85 y(n-1) + x(n) 
\mlabel{3}
$$

þeklinde olabilir. Daha genel olarak farklýlýk denklemleri þu þekilde
belirtilebilir,

$$ \sum_{k=0}^N a_k y(n-k) = \sum_{l=0}^M b_l x(n-l) 
\mlabel{1}
$$

Ýki üstteki örnek, bu genel denklemin $N=1,M=0$ olduðu halidir, katsayýlar
$a_1 = 0.85,b_0=1$. Genel formdan $y(n)$'i dýþarý çekebiliriz, o zaman
$k$ sýfýr yerine $k=1$'den baþlar

$$ y(n) + \sum_{k=1}^N a_k y(n-k) = \sum_{l=0}^M b_l x(n-l) $$

Genel çözüm için farklýlýk denkleminin bu formuna z Transform
uygulayabiliriz. 

Ama ondan önce kaydýrma iþlemi, lineerlik gibi bazý temel özellikleri,
iþlemleri görelim. Mesela

$$ X(z) = x(0) + x(1)z^{-1} + x(2) z^{-2} + ... 
\mlabel{2}
$$

ise, bu dizin üzerinde zaman kaydýrma iþlemi yapsak, yani $-1$ indeksi
$0$ haline gelse, onun gibi tüm deðerler bir ileri kaysa, $x(-1)$,
$x(0)$ olur, ve transform

$$ x(-1) + x(0)z^{-1} + x(1) z^{-2} + ...$$

Þimdi $z^{-1}$'i dýþarý çekelim

$$ = x(-1) + z^{-1} \bigg[ x(0) + x(1) z^{-1} + ... \bigg] $$

Köþeli parantez içine bakarsak, oradaki deðerler (2)'deki seriye benzemiyor
mu? O zaman oraya direk $X(z)$ deðerini koyabiliriz

$$ = x(-1) + z^{-1}X(z)$$

Bir daha kaydýrýrsak, 

$$ z^{-2}X(z) + z^{-1}x(-1) + x(-2) $$

elde ederiz. Genel olarak $m$ kadar kaydýrýrsak

$$ z^{-m}X(z^{-1}) + z^{-m+1}x(-1) + z^{-m+2}x(-2) + ... + x(-m) $$

Eðer baþlangýç þartlarý sýfýr ise, üstteki formülde $x(-1),x(-2),..$
tamamen sýfýr kabul edilebilir, ve daha basit þu formülü elde ederiz. 

$$ Z[x(n-m)] \leadsto z^{-m}X(z^{-1})$$

Ayrýca, z Transformun lineerlik özelliði sayesinde 

$$ Z(ax(n)) = aZ(x(n)) \leadsto aX(z) $$

Þimdi bu bilgiyle beraber (1)'in z Transformunu yapalým. 

$$ Y(z) + \sum_{k=1}^Na_kz^{-k}Y(z) = \sum_{l=0}^M b_l z^{-l}X(z)  $$

$$ \to Y(z) \bigg[ 1 + \sum_{k=1}^Na_kz^{-k} \bigg] = \sum_{l=0}^M b_l z^{-l}X(z)  $$

$$ \to Y(z)  = \frac{\sum_{l=0}^M b_l z^{-l}X(z) }{ 1 +
  \sum_{k=1}^Na_kz^{-k}} 
\mlabel{5}
$$

Formülün bölümdeki üst kýsmýný açarsak 

$$ b_0z^0 + b_1z^{-1} + b_2z^{-2} + ... + b_mz^{-M} $$

$b_0z^{-M}$ dýþarý çekilirse

$$ = b_0z^{-M}(z^M + \frac{b_1}{b_0}z^{M-1} +  \frac{b_2}{b_0}z^{M-2} +
.. + 
 \frac{b_M}{b_0})
$$

Bölümün alt kýsmýný açarsak 

$$ 1 + a_1z^{-1} + a_2z^{-2} + ... + a_Nz^{-N} $$

$z^{-N}$ dýþarý çekersek 

$$ = z^{-N} ( z^{N} + z^{N-1} + .. + a_N) $$

Bu yeni formlarý bölümde $Y(z)$ içinde yerine koyalým

$$ Y(z) = 
\frac{b_0z^{-M}(z^M + ..\frac{b_M}{b_0})}{z^{-N} ( z^{N} + .. + a_N)} 
$$

$$ = b_0 z^{N - M} \frac{z^M + ..\frac{b_M}{b_0}}{z^{N} + .. + a_N }$$

Bölüm ve bölene bir daha bakalým þimdi. Burada gösterilenler birer polinom,
ve Cebirin Temel Teorisi'ne (Fundamental Theorem of Algebra) göre $n$
derecesindeki bir $p(x)$ polinomunun mutlaka $n$ tane reel ya da kompleks
kökü vardýr. 

Bir polinomun kökü var ise, bu polinom $p(x)$ þu þekilde de gösterilebilir

$$ p(x) = (x-r_n)(x-r_{n-1})..(x-r_1) $$

Bu mantýðý iki üstteki formüle uygularsak 

$$ = b_0 z^{N - M} 
\frac{\prod_{l=1}^{M}(z-z_l)}{ \prod_{k=1}^{N}(z-p_k) }
$$

Yani $b_0z^{N-M}$ haricindeki ifadeler bir polinomun oluþmasýna sebep olurlar,
ve bu polinomun kökleri bulunabilir, kökler bulununca çözüm olan $z$ deðerleri
bulunmuþ olacaktýr. Bu $z$ deðerlerini alýp z Transformunu oluþturuz, ve ya
tabloya bakarak, ya da baþka þekilde ters transform yaparak farksal denklemin
çözümüne ulaþmaya çalýþýrýz.

Çözmek istediðimiz örnek (3)'e tekrar bakalým. Üstteki formüle bu noktada
gerek yok, (5)'e göre bile bu denklemin z Transformunu bulabiliriz. 

$$ Y(z) = \frac{1}{1-0.85z^{-1}} $$

Eðer yaygýn z Transformlarýn tablosuna bakarsak, $|z|>0.85$ için üstteki
formülün ters z Transformunun 

$$ h(n) = Z^{-1} [Y(z)] = 0.85^nu(n) $$

olduðunu öðreniyoruz, ve $u(n)$ þöyle 

$$
u(n) = 
\left\{ \begin{array}{ll}
1, & \textrm{ eðer } n \ge 0 \\ 
0, & \textrm{ eðer } n < 0
\end{array} \right.
$$

Dikkat edilirse ters z Transform tablosunda $y$ deðil $h$ bazlý sonuçlar
gösteriliyor, $h$ fonksiyonlarý dürtü cevabý (impulse response)
fonksiyonlarýdýr, ve hesaplamalarý evriþim (convolution) üzerinden
olur. Bir $h$, bir lineer sistemi özgün olarak temsil ettiði için $h$'i
alýp $y$ bazlý sonuca gitmek çok kolaydýr, hemen $h$'in tarif ettiði
evriþimi yaparýz.

$$ y(n) = \sum_{k=-\infty}^\infty x(k) h(n-k) = \sum_{k=-\infty}^\infty x(k) 0.85^{n-k} u(n-k). $$ 

Kodlama

Düþünelim ki (3) ile tarif edilen farklýlýk denklemi bir þirketin patent
portföyünü temsil ediyor. 

Bu þirket, her sene portföyü $y(n)$'e, $x(n)$ kadar yeni patent ekliyor,
ama her sene ayný zamanda elindeki patentlerin yüzde 15'i "eskiyor", yani
zamanlarý dolarak portföyünden çýkýyor. Bu eksiltme iþlemini bir önceki
$y(n)$'i 0.85 ile çarparak temsil ediyoruz. 

Böyle bir problemde $x(n)$ bize veri olarak verilecektir, ve toplamsal /
kümülatif (cumulative) $y(n)$'i hesaplamamýz istenecektir. Bu hesap
literatürde ``deðer kaybeden kümülatif toplam (cumulative sum with
deprecitation)'' olarak biliniyor.

O zaman üstteki formüldeki sonucu kodlarsak, ve örnek veriyle

\begin{minted}[fontsize=\footnotesize]{python}
patents = np.array([  4.,   3.,   2.,   8.,   4.,  
                      4.,  10.,   4.,  10.,   7.])

def u(n,k):
    if n-k < 0: return 0
    return 1.

def y(n,data):
    sum = 0
    for k in range(len(data)):
        sum += data[k]*(0.85**(n-k))*u(n,k)
    return sum

for n in range(len(patents)):    
    print  y(n,patents)
\end{minted}

\begin{verbatim}
4.0
6.4
7.44
14.324
16.1754
17.74909
25.0867265
25.323717525
31.5251598962
33.7963859118
\end{verbatim}

Bu sistemi otomatik olarak çözen Python iþlemi \verb!lfilter!
çaðrýsýdýr.

\begin{minted}[fontsize=\footnotesize]{python}
from scipy.signal import *

a = np.array([  4.,   3.,   2.,   8.,   4.,  
                4.,  10.,   4.,  10.,   7.])
d = 0.15 
res = lfilter((1,),(1,d-1),a) 
k = [a[0]] 
for inv in a[1:]: k.append((1-d)*k[-1] + inv) 
print np.array(k) 
\end{minted}

\begin{verbatim}
[  4.           6.4          7.44        14.324       16.1754      17.74909
  25.0867265   25.32371752  31.5251599   33.79638591]
\end{verbatim}

Not: Üstteki hesaplar [1] için kullanýldý.

Frekans Filtremek, IIR Filtreleri

Önceki dersteki FIR filtreleri sinyal üzerinde bir evriþimle kodlandý,
filtre katsayýlarýný geriye dönük ham sinyal üzerinde uygulayarak
filtrelenmiþ sonucu üretiyorduk,

$$ y[n] = a_0 x[n] + a_1 x[n-1] + a_2 x[n-2] +  a_3 x[n-3] + ... $$

Fakat filtre için ham sinyalin kendisi elimizdeki tek girdi seçeneði deðil,
sinyal $x$ ile beraber geriye dönük þekilde $y$'nin kendisini de
kullanabilirdik, bu durumda $y$'yi üretmek için $y$'nin kendisini kullanmýþ
olurduk, bu sebeple bu tür filtrelere özyineli (recursive) filtreler ismi
de veriliyor. Yani

\begin{eqnarray*}
y[n] = a_0 x[n] &+& a_1 x[n-1] + a_2 x[n-2] +  a_3 x[n-3] + ...  \\
 &+& b_1 y[n-1] + b_2 y[n-2] + b_3 y[n-3] + ..
\end{eqnarray*}

Peki FIR yöntemi ile filtre tasarlamayý biliyoruz, niye üstteki gibi bir
yaklaþým kullanalým ki? Cevap özyineli filtrelerin FIR'e göre çok hýzlý
iþlemeleri. IIR yönteminin de bazý negatif taraflarý var, fakat bunlardan
uzak durabilirsek optimal hýzda iþleyen bir filtre elde etmek
mümkündür. Ayrýca elektronik devrelerden, analog temelli pek çok özyineli
filtre biliniyor, bu filtreleri sayýsal ortamda kullanabilmek iyi olur.

IIR'nin genel verimliliði hakkýnda bir örnek verelim: diyelim ki 7 vuruþlu
bir ortalama filtremiz var, ve $n=50$ anýnda $y[50]$ þu deðere sahip,

$$ y[50] = x[47] + x[48] + x[49] + x[50] + x[51] + x[52] + x[53] $$

Sinyalde $n$ merkezli olacak þekilde 3 geri ve 3 ileri gidilerek toplam
alýnýyor, filtrelenmiþ sinyal bu. Þimdi ayný filtrenin bir sonraki zaman
kesitinde, $y[51]$'deki deðerine bakalým,

$$ y[51] = x[48] + x[49] + x[50] + x[51] + x[52] + x[53] + x[54] $$

Bu toplam aþaðý yukarý iki üstteki ile ayný deðil mi? $x[48]$ ve $x[53]$
arasý deðerler ayný þekilde toplanýyor, o zaman eðer elimizde $y[50]$
deðeri var ise, $y[51]$'i hesaplamak için en optimal yöntem

$$ y[51] = y[50] + x[54] - x[47]$$

hesabý olacaktýr, yani $y$'nin bir önceki zaman kesitindeki deðerini
kullanmak. IIR filtreleri iþte bu sebeple daha verimli iþlerler, eðer
tasarýmlarýnda dikkatli olunursa daha az miktarda katsayý ile çok daha
hýzlý hesaplar yapabiliriz [2, sf. 283].

Þimdi daha önceki genel formu hatýrlayalým 

$$ y(n) + \sum_{k=1}^N a_k y(n-k) = \sum_{l=0}^M b_l x(n-l) $$

Bu formül bir farklýlýk denklemi. Bu denklemin transfer fonksiyonu
altta, ki (5)'in literatürde daha çok görülen hali $H$ kullanýr,

$$ 
H(z)  = \frac{\sum_{l=0}^M b_l z^{-l}X(z) }{ 1 + \sum_{k=1}^Na_kz^{-k}} 
$$

Açýlmýþ þekilde  

$$ 
= \frac
{b_0 + b_1 z^{-1} + .. + b_m z^{-l}}
{1 + a_1 z^{-1} + .. + a_n z^{-k}}
$$

Bu formun güzel tarafý farklýlýk denklemleri ile üstteki formun arasýndaki
direk baðlantý. Eðer transfer fonksiyonuna bir þekilde eriþebilirsek oradan
direk farklýlýk denklemine geçilebiliyor, katsayýlar $a_0,..,a_n$ ve
$b_0,..,b_m$ farklýlýk denkleminde aynen kullanýlacak haldeler. Bu kavram
IIR filtresi tasarlarken faydalý olacak.

IIR Tasarýmý

IIR filtre tasarýmý için pek çok yöntem var. Bizim iþleyeceðimiz yöntem
dürtü deðiþmezliði (impulse invariance) yöntemi, bir diðeri mesela
çiftlineer (bilinear) transform yöntemi. DD ile bilinen bir analog
filtrenin analog transfer fonksiyonu $H(s)$'yi alýrýz, sonra ters Laplace
transformu ile dürtü cevap fonksiyonu $h(t)$'yi elde ederiz. Sayýsala
geçmek için bu fonksiyonu belli aralýklarla örnekleriz, yani $h(t)$'yi
$h(nT)$ haline getiririz. Sonra bu örneklenmiþ fonksiyonun z-transformunu
alarak $H(z)$'ye geçiþ yaparýz, bu geçiþ bize özyineli fonksiyonumuzda
kullanabileceðimiz direk katsayýlarý verecektir.

Analog deyip geçmeyelim, alçak geçiren, yüksek geçiren, vs. filtreleme
konusunda burada derin bir literatür var. Sayýsal yöntemler ortaya
çýktýðýndan beri haklý olarak çok ilgi gördüler, fakat unutmamak lazým,
sayýsal yöntemlerden önce analog elektronik devreler filtreleme yapýyordu
(halen de yapýyor), mesela alttaki devre çok basit bir alçak geçiren
filtredir [4]. 

\includegraphics[width=15em]{compscieng_1_25_01.png}

Bu devreye verilen $v_s$ sinyali (yani içinde pek çok frekans içeren
elektrik akýmý) seçilen $R,C$'ye göre $v_o$'da alçak geçiren þekilde
filtrelenmiþ olarak çýkacaktýr. Bu klasik bir filtre devresi ve bir
transfer fonksiyonu var. Aslýnda çok basit,

$$ H(s) = \frac{1}{s + 1}$$

Bir frekans eþik deðeri (cutoff frequency) $\Omega_c$ için [3, sf. 527]
$H(\frac{s}{\Omega_c})$ kullanýlýyor. Diyelim ki $\Omega_c = 20$ rad/s,

$$ 
H \bigg( \frac{s}{\Omega_c} \bigg) = H\bigg( \frac{s}{20} \bigg) 
= \frac{1}{(s/20) + 1} = \frac{20}{s + 20}
$$

Simdi ters Laplace ile $h(t)$ bulunur, 

$$ 
h(t) = \mathcal{L}^{-1} \bigg\{ H\bigg( \frac{s}{20} \bigg)  \bigg\} 
= \mathcal{L}^{-1} \bigg\{ \frac{20}{s + 20}  \bigg\}  
= 20 e^{-20 t}
$$

Sonra $Th(nT)$ ayrýksal fonksiyonunun z-transformunu alýrýz, 

$$
H(z) = 20 T \sum _{n=1}^{\infty} e^{-20 nT}z^{-1} 
= 20 T \sum _{n=0}^{\infty} \big( e^{20 T}z^{-1} \big)^n
= \frac{20T}{1 - e^{-20 T}z^{-1}} 
\mlabel{4}
$$

Son eþitlik nasýl mümkün oldu? Geometrik serilerinin açýlýmý sayesinde,
hatýrlarsak, 

$$ \sum _{n=0}^{\infty} x^n = \frac{1}{1-x} $$

Bu kadar. (4) formülündeki son durum bize $a,b$ katsayýlarýný da
veriyor. $a_0 = 1.0$, $a_1=-e^{-20T}$, $b_0 = 20T$. Bu þekilde seçtik çünkü
\verb!scipy.signal.lfilter! ile uyumlu olmasýný istedik, bu kütüphane,

\begin{eqnarray*}
a[0]y[n] = b[0]x[n] + b[1]x[n-1] + ... + b[M]x[n-M] \\
                    - a[1]y[n-1] - ... - a[N]y[n-N]
\end{eqnarray*}

formülünü kodluyor. 

Þimdi örnek üretelim, 1 rad/s = $1/2\pi$ Hertz olduðuna göre, eþik deðeri
$\Omega_c$

\begin{minted}[fontsize=\footnotesize]{python}
cutoff = 20 * 1/(2*np.pi) 
print cutoff, 'Hz'
\end{minted}

\begin{verbatim}
3.18309886184 Hz
\end{verbatim}

O zaman

\begin{minted}[fontsize=\footnotesize]{python}
fs = 40.0 # orneklem orani
T = 1/fs
L = 5.0 # saniyelik sinyal
n = int(L * fs) 
t = np.linspace(0, L, n, endpoint=False)
data = np.sin(2.0*2*np.pi*t) + np.cos(7*2*np.pi*t) 
plt.plot(t,data)
plt.savefig('compscieng_1_25_02.png')
\end{minted}

\includegraphics[width=20em]{compscieng_1_25_02.png}

Biri 2 diðeri 7 Hz ile üretilmiþ iki sinyali üst üste koyduk. Filtreleme
ile bunu ayrýþtýrmaya uðraþalým,

\begin{minted}[fontsize=\footnotesize]{python}
x = data # formul ile ayni olsun diye
a = [1.0, -np.exp(-20*T)]
b = [20*T]
print b, a
y = np.zeros(len(x))
for n in range(1,len(data)):    
   y[n] = b[0]*x[n] - a[1]*y[n-1]
plt.plot(t,y)
plt.savefig('compscieng_1_25_03.png')
\end{minted}

\begin{verbatim}
[0.5] [1.0, -0.60653065971263342]
\end{verbatim}

\includegraphics[width=20em]{compscieng_1_25_03.png}

Fena deðil. Eðer \verb!scipy.signal.butter! ile katsayýlarý üretsek ve
\verb!lfilter! ile uygulasak (ki üstteki kod \verb!lfilter! ile ayný
çarpýmý yapýyor),

\begin{minted}[fontsize=\footnotesize]{python}
from scipy.signal import butter, lfilter
nyq = 0.5 * fs
low = 2.0 / nyq
b, a = butter(1, low, btype='lowpass')
print b,a
y = lfilter(b, a, x)
plt.plot(t,y)
plt.savefig('compscieng_1_25_04.png')
\end{minted}

\begin{verbatim}
[ 0.13672874  0.13672874] [ 1.         -0.72654253]
\end{verbatim}

\includegraphics[width=20em]{compscieng_1_25_04.png}

Bu biraz daha pürüzsüz oldu, kütüphane çaðrýlarý farklý katsayýlar
gösteriyor bu arada, çünkü farklý bir sayýsala geçiþ yöntemi kullanýyorlar
(çiftlineer transform olmalý). Eðer filtre derecesini yani vuruþ sayýsýný
arttýrýrsak, yani daha fazla katsayý ile

\begin{minted}[fontsize=\footnotesize]{python}
b, a = butter(2, low, btype='lowpass')
print b
print a
y = lfilter(b, a, x)
plt.plot(t,y)
plt.savefig('compscieng_1_25_05.png')
\end{minted}

\begin{verbatim}
[ 0.02008337  0.04016673  0.02008337]
[ 1.         -1.56101808  0.64135154]
\end{verbatim}

\includegraphics[width=20em]{compscieng_1_25_05.png}

Bu daha da iyi oldu. 

Bir mühendislik notu olarak þunu ekleyelim, diyelim ki mobil ortamda
filtreleme yapmak istiyoruz, ve IIR yaklaþýmý kullanacaðýz. Bu durumda
üstteki sayýsal kütüphanelere mobil ortamýnda ihtiyacýmýz yok. Bize tek
gereken $a,b$ katsayýlarý, geliþtirme sýrasýnda dizüstü bilgisayarýmýzda
vuruþ sayýsýný verip filteyi ``tasarlýyoruz'' ve katsayýlarý elde edip
mobile sadece bunlarý taþýyoruz. Artýk bu katsayýlarý alýp sinyal üzerinde
uygulamak basit bir çarpma / toplama iþlemi haline gelecektir. Bütün sihir
katsayýlarda!

Kaynaklar

[1] Bayramlý, M., {\em Patent Strategies and R\&D in Complex Product Industries},
    \url{http://amsdottorato.unibo.it/5151/1/bayramli_meltem_tesi.pdf}

[2] Smith, {\em The Scientist and Engineer's Guide to Digital Signal Processing, 2nd Ed.}

[3] Pularikas, {\em Signals and Systems Primer with Matlab}

[4] Irwin, {\em Basic Engineering Circuit Analysis, 10th Edition}

\end{document}
