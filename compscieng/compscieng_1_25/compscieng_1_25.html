<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  
  
  
  
</head>
<body>
<h1 id="ders-1.25">Ders 1.25</h1>
<p>[ders notları atlandı]</p>
<p>z Transform</p>
<p>z Transform, Laplace Transformunun ayrıksal dünyadaki karşılığıdır, transform edilen sürekli fonksiyon <span class="math inline">\(f(t)\)</span> değil, ayrıksal, bir vektör olarak görülebilecek <span class="math inline">\(x(n)\)</span>'dir. z Transform</p>
<p><span class="math display">\[ Z[x(n)] \leadsto X(z) = \sum_{-\infty}^{\infty} x(n)z^{-n}  \]</span></p>
<p>ki <span class="math inline">\(z\)</span> bir kompleks sayıdır.</p>
<p>Gelişigüzel (casual) sistemlerden gelen verilerde sadece <span class="math inline">\(n&gt;0\)</span> veriye bakılabilir, o zaman alt sınır sıfır olur</p>
<p><span class="math display">\[ X(z) = \sum_{0}^{\infty} x(n)z^{-n}  \]</span></p>
<p>z Transform ne işe yarar? Laplace Transform diferansiyel denklemlerin çözülmesine yardım ediyordu. z Transform benzer şekilde farklılık (difference) denklemlerin çözülmesine yardım eder. Farklılık denklemi mesela</p>
<p><span class="math display">\[ y(n) = 0.85 y(n-1) + x(n) 
\qquad (3)
\]</span></p>
<p>şeklinde olabilir. Daha genel olarak farklılık denklemleri şu şekilde belirtilebilir,</p>
<p><span class="math display">\[ \sum_{k=0}^N a_k y(n-k) = \sum_{l=0}^M b_l x(n-l) 
\qquad (1)
\]</span></p>
<p>İki üstteki örnek, bu genel denklemin <span class="math inline">\(N=1,M=0\)</span> olduğu halidir, katsayılar <span class="math inline">\(a_1 = 0.85,b_0=1\)</span>. Genel formdan <span class="math inline">\(y(n)\)</span>'i dışarı çekebiliriz, o zaman <span class="math inline">\(k\)</span> sıfır yerine <span class="math inline">\(k=1\)</span>'den başlar</p>
<p><span class="math display">\[ y(n) + \sum_{k=1}^N a_k y(n-k) = \sum_{l=0}^M b_l x(n-l) \]</span></p>
<p>Genel çözüm için farklılık denkleminin bu formuna z Transform uygulayabiliriz.</p>
<p>Ama ondan önce kaydırma işlemi, lineerlik gibi bazı temel özellikleri, işlemleri görelim. Mesela</p>
<p><span class="math display">\[ X(z) = x(0) + x(1)z^{-1} + x(2) z^{-2} + ... 
\qquad (2)
\]</span></p>
<p>ise, bu dizin üzerinde zaman kaydırma işlemi yapsak, yani <span class="math inline">\(-1\)</span> indeksi <span class="math inline">\(0\)</span> haline gelse, onun gibi tüm değerler bir ileri kaysa, <span class="math inline">\(x(-1)\)</span>, <span class="math inline">\(x(0)\)</span> olur, ve transform</p>
<p><span class="math display">\[ x(-1) + x(0)z^{-1} + x(1) z^{-2} + ...\]</span></p>
<p>Şimdi <span class="math inline">\(z^{-1}\)</span>'i dışarı çekelim</p>
<p><span class="math display">\[ = x(-1) + z^{-1} \bigg[ x(0) + x(1) z^{-1} + ... \bigg] \]</span></p>
<p>Köşeli parantez içine bakarsak, oradaki değerler (2)'deki seriye benzemiyor mu? O zaman oraya direk <span class="math inline">\(X(z)\)</span> değerini koyabiliriz</p>
<p><span class="math display">\[ = x(-1) + z^{-1}X(z)\]</span></p>
<p>Bir daha kaydırırsak,</p>
<p><span class="math display">\[ z^{-2}X(z) + z^{-1}x(-1) + x(-2) \]</span></p>
<p>elde ederiz. Genel olarak <span class="math inline">\(m\)</span> kadar kaydırırsak</p>
<p><span class="math display">\[ z^{-m}X(z^{-1}) + z^{-m+1}x(-1) + z^{-m+2}x(-2) + ... + x(-m) \]</span></p>
<p>Eğer başlangıç şartları sıfır ise, üstteki formülde <span class="math inline">\(x(-1),x(-2),..\)</span> tamamen sıfır kabul edilebilir, ve daha basit şu formülü elde ederiz.</p>
<p><span class="math display">\[ Z[x(n-m)] \leadsto z^{-m}X(z^{-1})\]</span></p>
<p>Ayrıca, z Transformun lineerlik özelliği sayesinde</p>
<p><span class="math display">\[ Z(ax(n)) = aZ(x(n)) \leadsto aX(z) \]</span></p>
<p>Şimdi bu bilgiyle beraber (1)'in z Transformunu yapalım.</p>
<p><span class="math display">\[ Y(z) + \sum_{k=1}^Na_kz^{-k}Y(z) = \sum_{l=0}^M b_l z^{-l}X(z)  \]</span></p>
<p><span class="math display">\[ \to Y(z) \bigg[ 1 + \sum_{k=1}^Na_kz^{-k} \bigg] = \sum_{l=0}^M b_l z^{-l}X(z)  \]</span></p>
<p><span class="math display">\[ \to Y(z)  = \frac{\sum_{l=0}^M b_l z^{-l}X(z) }{ 1 +
  \sum_{k=1}^Na_kz^{-k}} 
\qquad (5)
\]</span></p>
<p>Formülün bölümdeki üst kısmını açarsak</p>
<p><span class="math display">\[ b_0z^0 + b_1z^{-1} + b_2z^{-2} + ... + b_mz^{-M} \]</span></p>
<p><span class="math inline">\(b_0z^{-M}\)</span> dışarı çekilirse</p>
<p><span class="math display">\[ = b_0z^{-M}(z^M + \frac{b_1}{b_0}z^{M-1} +  \frac{b_2}{b_0}z^{M-2} +
.. + 
 \frac{b_M}{b_0})
\]</span></p>
<p>Bölümün alt kısmını açarsak</p>
<p><span class="math display">\[ 1 + a_1z^{-1} + a_2z^{-2} + ... + a_Nz^{-N} \]</span></p>
<p><span class="math inline">\(z^{-N}\)</span> dışarı çekersek</p>
<p><span class="math display">\[ = z^{-N} ( z^{N} + z^{N-1} + .. + a_N) \]</span></p>
<p>Bu yeni formları bölümde <span class="math inline">\(Y(z)\)</span> içinde yerine koyalım</p>
<p><span class="math display">\[ Y(z) = 
\frac{b_0z^{-M}(z^M + ..\frac{b_M}{b_0})}{z^{-N} ( z^{N} + .. + a_N)} 
\]</span></p>
<p><span class="math display">\[ = b_0 z^{N - M} \frac{z^M + ..\frac{b_M}{b_0}}{z^{N} + .. + a_N }\]</span></p>
<p>Bölüm ve bölene bir daha bakalım şimdi. Burada gösterilenler birer polinom, ve Cebirin Temel Teorisi'ne (Fundamental Theorem of Algebra) göre <span class="math inline">\(n\)</span> derecesindeki bir <span class="math inline">\(p(x)\)</span> polinomunun mutlaka <span class="math inline">\(n\)</span> tane reel ya da kompleks kökü vardır.</p>
<p>Bir polinomun kökü var ise, bu polinom <span class="math inline">\(p(x)\)</span> şu şekilde de gösterilebilir</p>
<p><span class="math display">\[ p(x) = (x-r_n)(x-r_{n-1})..(x-r_1) \]</span></p>
<p>Bu mantığı iki üstteki formüle uygularsak</p>
<p><span class="math display">\[ = b_0 z^{N - M} 
\frac{\prod_{l=1}^{M}(z-z_l)}{ \prod_{k=1}^{N}(z-p_k) }
\]</span></p>
<p>Yani <span class="math inline">\(b_0z^{N-M}\)</span> haricindeki ifadeler bir polinomun oluşmasına sebep olurlar, ve bu polinomun kökleri bulunabilir, kökler bulununca çözüm olan <span class="math inline">\(z\)</span> değerleri bulunmuş olacaktır. Bu <span class="math inline">\(z\)</span> değerlerini alıp z Transformunu oluşturuz, ve ya tabloya bakarak, ya da başka şekilde ters transform yaparak farksal denklemin çözümüne ulaşmaya çalışırız.</p>
<p>Çözmek istediğimiz örnek (3)'e tekrar bakalım. Üstteki formüle bu noktada gerek yok, (5)'e göre bile bu denklemin z Transformunu bulabiliriz.</p>
<p><span class="math display">\[ Y(z) = \frac{1}{1-0.85z^{-1}} \]</span></p>
<p>Eğer yaygın z Transformların tablosuna bakarsak, <span class="math inline">\(|z|&gt;0.85\)</span> için üstteki formülün ters z Transformunun</p>
<p><span class="math display">\[ h(n) = Z^{-1} [Y(z)] = 0.85^nu(n) \]</span></p>
<p>olduğunu öğreniyoruz, ve <span class="math inline">\(u(n)\)</span> şöyle</p>
<p><span class="math display">\[
u(n) = 
\left\{ \begin{array}{ll}
1, &amp; \textrm{ eğer } n \ge 0 \\ 
0, &amp; \textrm{ eğer } n &lt; 0
\end{array} \right.
\]</span></p>
<p>Dikkat edilirse ters z Transform tablosunda <span class="math inline">\(y\)</span> değil <span class="math inline">\(h\)</span> bazlı sonuçlar gösteriliyor, <span class="math inline">\(h\)</span> fonksiyonları dürtü cevabı (impulse response) fonksiyonlarıdır, ve hesaplamaları evrişim (convolution) üzerinden olur. Bir <span class="math inline">\(h\)</span>, bir lineer sistemi özgün olarak temsil ettiği için <span class="math inline">\(h\)</span>'i alıp <span class="math inline">\(y\)</span> bazlı sonuca gitmek çok kolaydır, hemen <span class="math inline">\(h\)</span>'in tarif ettiği evrişimi yaparız.</p>
<p><span class="math display">\[ y(n) = \sum_{k=-\infty}^\infty x(k) h(n-k) = \sum_{k=-\infty}^\infty x(k) 0.85^{n-k} u(n-k). \]</span></p>
<p>Kodlama</p>
<p>Düşünelim ki (3) ile tarif edilen farklılık denklemi bir şirketin patent portföyünü temsil ediyor.</p>
<p>Bu şirket, her sene portföyü <span class="math inline">\(y(n)\)</span>'e, <span class="math inline">\(x(n)\)</span> kadar yeni patent ekliyor, ama her sene aynı zamanda elindeki patentlerin yüzde 15'i &quot;eskiyor&quot;, yani zamanları dolarak portföyünden çıkıyor. Bu eksiltme işlemini bir önceki <span class="math inline">\(y(n)\)</span>'i 0.85 ile çarparak temsil ediyoruz.</p>
<p>Böyle bir problemde <span class="math inline">\(x(n)\)</span> bize veri olarak verilecektir, ve toplamsal / kümülatif (cumulative) <span class="math inline">\(y(n)\)</span>'i hesaplamamız istenecektir. Bu hesap literatürde &quot;değer kaybeden kümülatif toplam (cumulative sum with deprecitation)'' olarak biliniyor.</p>
<p>O zaman üstteki formüldeki sonucu kodlarsak, ve örnek veriyle</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">patents <span class="op">=</span> np.array([  <span class="fl">4.</span>,   <span class="fl">3.</span>,   <span class="fl">2.</span>,   <span class="fl">8.</span>,   <span class="fl">4.</span>,  
                      <span class="fl">4.</span>,  <span class="fl">10.</span>,   <span class="fl">4.</span>,  <span class="fl">10.</span>,   <span class="fl">7.</span>])

<span class="kw">def</span> u(n,k):
    <span class="cf">if</span> n<span class="op">-</span>k <span class="op">&lt;</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="dv">0</span>
    <span class="cf">return</span> <span class="fl">1.</span>

<span class="kw">def</span> y(n,data):
    <span class="bu">sum</span> <span class="op">=</span> <span class="dv">0</span>
    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(data)):
        <span class="bu">sum</span> <span class="op">+=</span> data[k]<span class="op">*</span>(<span class="fl">0.85</span><span class="op">**</span>(n<span class="op">-</span>k))<span class="op">*</span>u(n,k)
    <span class="cf">return</span> <span class="bu">sum</span>

<span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(patents)):    
    <span class="bu">print</span>  y(n,patents)</code></pre></div>
<pre><code>4.0
6.4
7.44
14.324
16.1754
17.74909
25.0867265
25.323717525
31.5251598962
33.7963859118</code></pre>
<p>Bu sistemi otomatik olarak çözen Python işlemi <code>lfilter</code> çağrısıdır.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> scipy.signal <span class="im">import</span> <span class="op">*</span>

a <span class="op">=</span> np.array([  <span class="fl">4.</span>,   <span class="fl">3.</span>,   <span class="fl">2.</span>,   <span class="fl">8.</span>,   <span class="fl">4.</span>,  
                <span class="fl">4.</span>,  <span class="fl">10.</span>,   <span class="fl">4.</span>,  <span class="fl">10.</span>,   <span class="fl">7.</span>])
d <span class="op">=</span> <span class="fl">0.15</span> 
res <span class="op">=</span> lfilter((<span class="dv">1</span>,),(<span class="dv">1</span>,d<span class="dv">-1</span>),a) 
k <span class="op">=</span> [a[<span class="dv">0</span>]] 
<span class="cf">for</span> inv <span class="kw">in</span> a[<span class="dv">1</span>:]: k.append((<span class="dv">1</span><span class="op">-</span>d)<span class="op">*</span>k[<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> inv) 
<span class="bu">print</span> np.array(k) </code></pre></div>
<pre><code>[  4.           6.4          7.44        14.324       16.1754      17.74909
  25.0867265   25.32371752  31.5251599   33.79638591]</code></pre>
<p>Not: Üstteki hesaplar [1] için kullanıldı.</p>
<p>Frekans Filtremek, IIR Filtreleri</p>
<p>Önceki dersteki FIR filtreleri sinyal üzerinde bir evrişimle kodlandı, filtre katsayılarını geriye dönük ham sinyal üzerinde uygulayarak filtrelenmiş sonucu üretiyorduk,</p>
<p><span class="math display">\[ y[n] = a_0 x[n] + a_1 x[n-1] + a_2 x[n-2] +  a_3 x[n-3] + ... \]</span></p>
<p>Fakat filtre için ham sinyalin kendisi elimizdeki tek girdi seçeneği değil, sinyal <span class="math inline">\(x\)</span> ile beraber geriye dönük şekilde <span class="math inline">\(y\)</span>'nin kendisini de kullanabilirdik, bu durumda <span class="math inline">\(y\)</span>'yi üretmek için <span class="math inline">\(y\)</span>'nin kendisini kullanmış olurduk, bu sebeple bu tür filtrelere özyineli (recursive) filtreler ismi de veriliyor. Yani</p>
<span class="math display">\[\begin{eqnarray*}
y[n] = a_0 x[n] &amp;+&amp; a_1 x[n-1] + a_2 x[n-2] +  a_3 x[n-3] + ...  \\
 &amp;+&amp; b_1 y[n-1] + b_2 y[n-2] + b_3 y[n-3] + ..
\end{eqnarray*}\]</span>
<p>Peki FIR yöntemi ile filtre tasarlamayı biliyoruz, niye üstteki gibi bir yaklaşım kullanalım ki? Cevap özyineli filtrelerin FIR'e göre çok hızlı işlemeleri. IIR yönteminin de bazı negatif tarafları var, fakat bunlardan uzak durabilirsek optimal hızda işleyen bir filtre elde etmek mümkündür. Ayrıca elektronik devrelerden, analog temelli pek çok özyineli filtre biliniyor, bu filtreleri sayısal ortamda kullanabilmek iyi olur.</p>
<p>IIR'nin genel verimliliği hakkında bir örnek verelim: diyelim ki 7 vuruşlu bir ortalama filtremiz var, ve <span class="math inline">\(n=50\)</span> anında <span class="math inline">\(y[50]\)</span> şu değere sahip,</p>
<p><span class="math display">\[ y[50] = x[47] + x[48] + x[49] + x[50] + x[51] + x[52] + x[53] \]</span></p>
<p>Sinyalde <span class="math inline">\(n\)</span> merkezli olacak şekilde 3 geri ve 3 ileri gidilerek toplam alınıyor, filtrelenmiş sinyal bu. Şimdi aynı filtrenin bir sonraki zaman kesitinde, <span class="math inline">\(y[51]\)</span>'deki değerine bakalım,</p>
<p><span class="math display">\[ y[51] = x[48] + x[49] + x[50] + x[51] + x[52] + x[53] + x[54] \]</span></p>
<p>Bu toplam aşağı yukarı iki üstteki ile aynı değil mi? <span class="math inline">\(x[48]\)</span> ve <span class="math inline">\(x[53]\)</span> arası değerler aynı şekilde toplanıyor, o zaman eğer elimizde <span class="math inline">\(y[50]\)</span> değeri var ise, <span class="math inline">\(y[51]\)</span>'i hesaplamak için en optimal yöntem</p>
<p><span class="math display">\[ y[51] = y[50] + x[54] - x[47]\]</span></p>
<p>hesabı olacaktır, yani <span class="math inline">\(y\)</span>'nin bir önceki zaman kesitindeki değerini kullanmak. IIR filtreleri işte bu sebeple daha verimli işlerler, eğer tasarımlarında dikkatli olunursa daha az miktarda katsayı ile çok daha hızlı hesaplar yapabiliriz [2, sf. 283].</p>
<p>Şimdi daha önceki genel formu hatırlayalım</p>
<p><span class="math display">\[ y(n) + \sum_{k=1}^N a_k y(n-k) = \sum_{l=0}^M b_l x(n-l) \]</span></p>
<p>Bu formül bir farklılık denklemi. Bu denklemin transfer fonksiyonu altta, ki (5)'in literatürde daha çok görülen hali <span class="math inline">\(H\)</span> kullanır,</p>
<p><span class="math display">\[ 
H(z)  = \frac{\sum_{l=0}^M b_l z^{-l}X(z) }{ 1 + \sum_{k=1}^Na_kz^{-k}} 
\]</span></p>
<p>Açılmış şekilde</p>
<p><span class="math display">\[ 
= \frac
{b_0 + b_1 z^{-1} + .. + b_m z^{-l}}
{1 + a_1 z^{-1} + .. + a_n z^{-k}}
\]</span></p>
<p>Bu formun güzel tarafı farklılık denklemleri ile üstteki formun arasındaki direk bağlantı. Eğer transfer fonksiyonuna bir şekilde erişebilirsek oradan direk farklılık denklemine geçilebiliyor, katsayılar <span class="math inline">\(a_0,..,a_n\)</span> ve <span class="math inline">\(b_0,..,b_m\)</span> farklılık denkleminde aynen kullanılacak haldeler. Bu kavram IIR filtresi tasarlarken faydalı olacak.</p>
<p>IIR Tasarımı</p>
<p>IIR filtre tasarımı için pek çok yöntem var. Bizim işleyeceğimiz yöntem dürtü değişmezliği (impulse invariance) yöntemi, bir diğeri mesela çiftlineer (bilinear) transform yöntemi. DD ile bilinen bir analog filtrenin analog transfer fonksiyonu <span class="math inline">\(H(s)\)</span>'yi alırız, sonra ters Laplace transformu ile dürtü cevap fonksiyonu <span class="math inline">\(h(t)\)</span>'yi elde ederiz. Sayısala geçmek için bu fonksiyonu belli aralıklarla örnekleriz, yani <span class="math inline">\(h(t)\)</span>'yi <span class="math inline">\(h(nT)\)</span> haline getiririz. Sonra bu örneklenmiş fonksiyonun z-transformunu alarak <span class="math inline">\(H(z)\)</span>'ye geçiş yaparız, bu geçiş bize özyineli fonksiyonumuzda kullanabileceğimiz direk katsayıları verecektir.</p>
<p>Analog deyip geçmeyelim, alçak geçiren, yüksek geçiren, vs. filtreleme konusunda burada derin bir literatür var. Sayısal yöntemler ortaya çıktığından beri haklı olarak çok ilgi gördüler, fakat unutmamak lazım, sayısal yöntemlerden önce analog elektronik devreler filtreleme yapıyordu (halen de yapıyor), mesela alttaki devre çok basit bir alçak geçiren filtredir [4].</p>
<div class="figure">
<img src="compscieng_1_25_01.png" />

</div>
<p>Bu devreye verilen <span class="math inline">\(v_s\)</span> sinyali (yani içinde pek çok frekans içeren elektrik akımı) seçilen <span class="math inline">\(R,C\)</span>'ye göre <span class="math inline">\(v_o\)</span>'da alçak geçiren şekilde filtrelenmiş olarak çıkacaktır. Bu klasik bir filtre devresi ve bir transfer fonksiyonu var. Aslında çok basit,</p>
<p><span class="math display">\[ H(s) = \frac{1}{s + 1}\]</span></p>
<p>Bir frekans eşik değeri (cutoff frequency) <span class="math inline">\(\Omega_c\)</span> için [3, sf. 527] <span class="math inline">\(H(\frac{s}{\Omega_c})\)</span> kullanılıyor. Diyelim ki <span class="math inline">\(\Omega_c = 20\)</span> rad/s,</p>
<p><span class="math display">\[ 
H \bigg( \frac{s}{\Omega_c} \bigg) = H\bigg( \frac{s}{20} \bigg) 
= \frac{1}{(s/20) + 1} = \frac{20}{s + 20}
\]</span></p>
<p>Simdi ters Laplace ile <span class="math inline">\(h(t)\)</span> bulunur,</p>
<p><span class="math display">\[ 
h(t) = \mathcal{L}^{-1} \bigg\{ H\bigg( \frac{s}{20} \bigg)  \bigg\} 
= \mathcal{L}^{-1} \bigg\{ \frac{20}{s + 20}  \bigg\}  
= 20 e^{-20 t}
\]</span></p>
<p>Sonra <span class="math inline">\(Th(nT)\)</span> ayrıksal fonksiyonunun z-transformunu alırız,</p>
<p><span class="math display">\[
H(z) = 20 T \sum_{n=1}^{\infty} e^{-20 nT}z^{-1} 
= 20 T \sum_{n=0}^{\infty} \big( e^{20 T}z^{-1} \big)^n
= \frac{20T}{1 - e^{-20 T}z^{-1}} 
\qquad (4)
\]</span></p>
<p>Son eşitlik nasıl mümkün oldu? Geometrik serilerinin açılımı sayesinde, hatırlarsak,</p>
<p><span class="math display">\[ \sum_{n=0}^{\infty} x^n = \frac{1}{1-x} \]</span></p>
<p>Bu kadar. (4) formülündeki son durum bize <span class="math inline">\(a,b\)</span> katsayılarını da veriyor. <span class="math inline">\(a_0 = 1.0\)</span>, <span class="math inline">\(a_1=-e^{-20T}\)</span>, <span class="math inline">\(b_0 = 20T\)</span>. Bu şekilde seçtik çünkü <code>scipy.signal.lfilter</code> ile uyumlu olmasını istedik, bu kütüphane,</p>
<span class="math display">\[\begin{eqnarray*}
a[0]y[n] = b[0]x[n] + b[1]x[n-1] + ... + b[M]x[n-M] \\
                    - a[1]y[n-1] - ... - a[N]y[n-N]
\end{eqnarray*}\]</span>
<p>formülünü kodluyor.</p>
<p>Şimdi örnek üretelim, 1 rad/s = <span class="math inline">\(1/2\pi\)</span> Hertz olduğuna göre, eşik değeri <span class="math inline">\(\Omega_c\)</span></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">cutoff <span class="op">=</span> <span class="dv">20</span> <span class="op">*</span> <span class="dv">1</span><span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>np.pi) 
<span class="bu">print</span> cutoff, <span class="st">&#39;Hz&#39;</span></code></pre></div>
<pre><code>3.18309886184 Hz</code></pre>
<p>O zaman</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">fs <span class="op">=</span> <span class="fl">40.0</span> <span class="co"># orneklem orani</span>
T <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>fs
L <span class="op">=</span> <span class="fl">5.0</span> <span class="co"># saniyelik sinyal</span>
n <span class="op">=</span> <span class="bu">int</span>(L <span class="op">*</span> fs) 
t <span class="op">=</span> np.linspace(<span class="dv">0</span>, L, n, endpoint<span class="op">=</span><span class="va">False</span>)
data <span class="op">=</span> np.sin(<span class="fl">2.0</span><span class="op">*</span><span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>t) <span class="op">+</span> np.cos(<span class="dv">7</span><span class="op">*</span><span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>t) 
plt.plot(t,data)
plt.savefig(<span class="st">&#39;compscieng_1_25_02.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="compscieng_1_25_02.png" />

</div>
<p>Biri 2 diğeri 7 Hz ile üretilmiş iki sinyali üst üste koyduk. Filtreleme ile bunu ayrıştırmaya uğraşalım,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">x <span class="op">=</span> data <span class="co"># formul ile ayni olsun diye</span>
a <span class="op">=</span> [<span class="fl">1.0</span>, <span class="op">-</span>np.exp(<span class="op">-</span><span class="dv">20</span><span class="op">*</span>T)]
b <span class="op">=</span> [<span class="dv">20</span><span class="op">*</span>T]
<span class="bu">print</span> b, a
y <span class="op">=</span> np.zeros(<span class="bu">len</span>(x))
<span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="bu">len</span>(data)):    
   y[n] <span class="op">=</span> b[<span class="dv">0</span>]<span class="op">*</span>x[n] <span class="op">-</span> a[<span class="dv">1</span>]<span class="op">*</span>y[n<span class="dv">-1</span>]
plt.plot(t,y)
plt.savefig(<span class="st">&#39;compscieng_1_25_03.png&#39;</span>)</code></pre></div>
<pre><code>[0.5] [1.0, -0.60653065971263342]</code></pre>
<div class="figure">
<img src="compscieng_1_25_03.png" />

</div>
<p>Fena değil. Eğer <code>scipy.signal.butter</code> ile katsayıları üretsek ve <code>lfilter</code> ile uygulasak (ki üstteki kod <code>lfilter</code> ile aynı çarpımı yapıyor),</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> scipy.signal <span class="im">import</span> butter, lfilter
nyq <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> fs
low <span class="op">=</span> <span class="fl">2.0</span> <span class="op">/</span> nyq
b, a <span class="op">=</span> butter(<span class="dv">1</span>, low, btype<span class="op">=</span><span class="st">&#39;lowpass&#39;</span>)
<span class="bu">print</span> b,a
y <span class="op">=</span> lfilter(b, a, x)
plt.plot(t,y)
plt.savefig(<span class="st">&#39;compscieng_1_25_04.png&#39;</span>)</code></pre></div>
<pre><code>[ 0.13672874  0.13672874] [ 1.         -0.72654253]</code></pre>
<div class="figure">
<img src="compscieng_1_25_04.png" />

</div>
<p>Bu biraz daha pürüzsüz oldu, kütüphane çağrıları farklı katsayılar gösteriyor bu arada, çünkü farklı bir sayısala geçiş yöntemi kullanıyorlar (çiftlineer transform olmalı). Eğer filtre derecesini yani vuruş sayısını arttırırsak, yani daha fazla katsayı ile</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">b, a <span class="op">=</span> butter(<span class="dv">2</span>, low, btype<span class="op">=</span><span class="st">&#39;lowpass&#39;</span>)
<span class="bu">print</span> b
<span class="bu">print</span> a
y <span class="op">=</span> lfilter(b, a, x)
plt.plot(t,y)
plt.savefig(<span class="st">&#39;compscieng_1_25_05.png&#39;</span>)</code></pre></div>
<pre><code>[ 0.02008337  0.04016673  0.02008337]
[ 1.         -1.56101808  0.64135154]</code></pre>
<div class="figure">
<img src="compscieng_1_25_05.png" />

</div>
<p>Bu daha da iyi oldu.</p>
<p>Bir mühendislik notu olarak şunu ekleyelim, diyelim ki mobil ortamda filtreleme yapmak istiyoruz, ve IIR yaklaşımı kullanacağız. Bu durumda üstteki sayısal kütüphanelere mobil ortamında ihtiyacımız yok. Bize tek gereken <span class="math inline">\(a,b\)</span> katsayıları, geliştirme sırasında dizüstü bilgisayarımızda vuruş sayısını verip filteyi &quot;tasarlıyoruz'' ve katsayıları elde edip mobile sadece bunları taşıyoruz. Artık bu katsayıları alıp sinyal üzerinde uygulamak basit bir çarpma / toplama işlemi haline gelecektir. Bütün sihir katsayılarda!</p>
<p>Kaynaklar</p>
<p>[1] Bayramlı, M., <em>Patent Strategies and R&amp;D in Complex Product Industries</em>, <a href="http://amsdottorato.unibo.it/5151/1/bayramli_meltem_tesi.pdf" class="uri">http://amsdottorato.unibo.it/5151/1/bayramli_meltem_tesi.pdf</a></p>
<p>[2] Smith, <em>The Scientist and Engineer's Guide to Digital Signal Processing, 2nd Ed.</em></p>
<p>[3] Pularikas, <em>Signals and Systems Primer with Matlab</em></p>
<p>[4] Irwin, <em>Basic Engineering Circuit Analysis, 10th Edition</em></p>
</body>
</html>
