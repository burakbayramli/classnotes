<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  
  
  
  
</head>
<body>
<h1 id="ders-1-18">Ders 1-18</h1>
<p>Sonlu Öğeler, 2. Bölüm</p>
<p>Üzerinden geçelim, sistem zayıf form ile ise başlar. Önceki dersin sonunda Galerkin fikrini tanıştırdık, sürekli diferansiyel denklem yerine onu ayrıksal temsil etmeye uğraştık. Galerkin bunun için bazı deneme fonsiyonları kullanır onlara <span class="math inline">\(\phi_1,...,\phi_N\)</span> diyelim, ayrıca test fonksiyonları da vardır (fakat çoğunlukla test fonksiyonları ile deneme, yani <span class="math inline">\(\phi\)</span> ve <span class="math inline">\(v\)</span> fonksiyonları aynı seçilir). Bugün işleyeceğimiz bu fonksiyonların nasıl seçildiği ve hazırlık aşamasını gösterdikten sonra elde edilen <span class="math inline">\(KU = F\)</span> denkleminin nasıl çözüldüğü. <span class="math inline">\(K\)</span> nereden geliyor, <span class="math inline">\(F\)</span> nereden geliyor? <span class="math inline">\(F\)</span> bir şekilde alttaki ikinci denklemin (oktan sonra) sağ tarafından geliyor, <span class="math inline">\(K\)</span> ise sol tarafından.. Detayları şimdi göreceğiz.</p>
<p><span class="math display">\[
- \frac{\mathrm{d}}{\mathrm{d} x} \left( c(x) \frac{\mathrm{d} u}{\mathrm{d} x} \right) = f(x) \to
\]</span></p>
<p><span class="math display">\[
\int_{0}^{1} c \frac{\mathrm{d} u}{\mathrm{d} x} \frac{\mathrm{d} v}{\mathrm{d} x} \mathrm{d} x =
\int_{0}^{1} f(x) v(x) \mathrm{d} x
\qquad (1)
\]</span></p>
<p>ki eğer <span class="math inline">\(u(1)=0\)</span> ise <span class="math inline">\(v(1) = 0\)</span> (sınır şartı).</p>
<p>Sonlu öğeler metotunun (FEM) temeli <span class="math inline">\(KU = F\)</span>. Üstteki denklemde okun sol tarafı diferansiyel denklemimiz, sınır şartları vs ile &quot;güçlü formda'', oktan sonrası zayıf form, ki onun da kendi sınır şartları var. Sabit değişkenler güçlü formdan zayıf forma geçiyor, ama serbest değişkenler geçmiyor. <span class="math inline">\(v\)</span>'yi <span class="math inline">\(u\)</span>'dan olan ufak sapmalar olarak gördüğüm için eğer <span class="math inline">\(u\)</span>'yi sabitliyorsam <span class="math inline">\(v\)</span> de sabitleniyor.</p>
<p>Tüm bunları gördük ama hala ayaklarımız yere basmadı; bir çok fikirden bahsettik, ama şimdi daha gerçek dünyaya bağlanacağız. Gerçek dünya demek tabii <span class="math inline">\(\phi\)</span>'lerle alakalı, hangi somut fonksiyonları <span class="math inline">\(\phi\)</span> olarak seçeceğiz?</p>
<p>Acaba örnek bir <span class="math inline">\(\phi\)</span> ne olabilir? Mesela <span class="math inline">\(x=2\)</span> noktasında tepe yapan bir parçalı lineer fonksiyon kullanabilirim,</p>
<div class="figure">
<img src="compscieng_1_18_01.png" />

</div>
<p>Bu fonksiyona <span class="math inline">\(\phi_2(x)\)</span> diyelim, 1 ila 3 arasında 2 üzerinde tepe yapıyor diğer yerlerde ya lineer eğimi var, ya da değeri sıfır. Her <span class="math inline">\(\phi\)</span> maksimum tepe noktası 1 olarak seçilebilir. Onun sağındaki <span class="math inline">\(\phi_3\)</span> olabilir, benzer bir fonksiyon sadece 3 değeri bazlı tanımlı. Buradaki ana amaç sistemı basit ögeler üzerinde inşa etmek. FEM'in ana fikri budur; <span class="math inline">\(\phi\)</span> için basit fonksiyonlar kullan. Bu basitliğin devamı olarak <span class="math inline">\(\phi\)</span> ve <span class="math inline">\(v\)</span> fonksiyonlarını aynı seç.</p>
<p>Peki sınır noktalarında ne olacak? Üstte serbest-sabit problemi çözeceğim, sol üç nokta serbest, sağ üç nokta sabit (sınır tanımlanmış).</p>
<div class="figure">
<img src="compscieng_1_18_02.png" />

</div>
<p>Üstteki resme bakarsak, <span class="math inline">\(x=0\)</span> için bir &quot;yarım şapka'' fonksiyonu tanımladım, <span class="math inline">\(\phi_0\)</span> diyelim, ve eğer diğer üçgen fonksiyonlara tam şapka dersek bu da yarım şapka. O noktada <span class="math inline">\(\phi\)</span> ve <span class="math inline">\(v\)</span>'lerim kısıtlı değiller. Böylece elimde beş tane deneme fonksiyonu oluyor, <span class="math inline">\(\phi_0\)</span>, <span class="math inline">\(\phi_1\)</span>, <span class="math inline">\(\phi_2\)</span>, <span class="math inline">\(\phi_3\)</span>, <span class="math inline">\(\phi_4\)</span>.</p>
<p>Amaç nedir? Yaklaşık FEM çözümüm <span class="math inline">\(U(x)\)</span>'in üstteki basit şapka fonksiyonlarının bir kombinasyonu olmasını istiyorum.</p>
<p><span class="math display">\[
U(x) = U_0 \phi_0(x) + ... + U_4 \phi_4(x)
\qquad (2)
\]</span></p>
<p><span class="math inline">\(U_0,..,U_4\)</span> değerleri skalar, tek sayı.. onlar ilk başta bilinmeyen &quot;ağırlık'' değerleri, <span class="math inline">\(\phi\)</span>'leri belli şekilde çarpacaklar ve bu çarpımların toplamı yaklaşık bir <span class="math inline">\(u\)</span> olacak.</p>
<p>Bu kombinasyonlar neye benzerdi acaba? Şöyle olabilirdi,</p>
<div class="figure">
<img src="compscieng_1_18_03.png" />

</div>
<p>Başlangıçtaki değer niye <span class="math inline">\(u_0\)</span>? Çünkü orada tüm diğer <span class="math inline">\(\phi\)</span> fonksiyonları sıfır seviyesinde, hemen yandaki <span class="math inline">\(\phi_1\)</span> bile orada sıfır ve maksimum <span class="math inline">\(\phi\)</span> değer 1 olduğu için başlangıç değeri <span class="math inline">\(u_0\)</span>.</p>
<p>Bu arada Galerkin, ismini taşıyan yöntemi bulurken, aklında erişmeye uğraştığı belli bir çözüm fonksiyonu vardı, ve şapka fonksiyonlarını oraya varmak için seçmişti fakat modern FEM yaklaşımlarında, yazılımlarında bir temel fonksiyonu ilk baştan seçeriz, problem hakkında bir şey bilmesek bile. Şapka fonksiyonları bu fonksiyonlardan biridir.</p>
<p>Sonlu öğeler temel fonksiyonları düğüm noktalarıyla bağlantılıdır, bu bağlamda sonlu farklılıkler (finite differences) metotuna benzer, öğeler düğüm noktalarına oturtuluyor. FEM ile şapka fonksiyonu özelinde her düğüm noktasındaki <span class="math inline">\(u\)</span> değerinin o noktadaki ağırlık değeri ile aynı olmasını zorlamış oluyoruz; mesela 1 düğümündeki değer nedir? <span class="math inline">\(u_1\)</span>! Çünkü orada diğer tüm şapka fonksiyonları sıfırdır, sadece <span class="math inline">\(\phi_1\)</span> değeri 1, toplanan tüm terimler yokoluyor geriye sadece <span class="math inline">\(u_1 \phi_1 = u_1\)</span> kalıyor.</p>
<div class="figure">
<img src="compscieng_1_18_04.png" />

</div>
<p>FD benzerliği hakkında, <span class="math inline">\(KU=F\)</span>'i oluşturduğumuzda onun bir FD denklemine oldukca benzediğini göreceğiz, arada yapısal farklar var tabii, FD ile ayrıksal denklemleri biz tanımlıyoruz, FEM ile sadece baz öğeleri seçiyoruz denklemin ne olduğunu Galerkin yöntemi bize söylüyor.</p>
<p>Şimdi bize lazım olan üstteki resimdeki her nokta için ayrı bir denklem, yani toplam 5 tane denklem. Bu denklemler nereden gelecek? Kritik bir soru.</p>
<p>Bu denklemler zayıf formdan gelecekler. Şunu yapıyorum, (1)'deki <span class="math inline">\(u\)</span> yerine (2)'deki <span class="math inline">\(U\)</span>'yu sokuyorum. Ayrıca bir <span class="math inline">\(v\)</span> lazım, daha önce <span class="math inline">\(v(1)=0\)</span> şartı takip edilmek suretiyle herhangi bir <span class="math inline">\(v\)</span> olabilir demiştik, ama şimdi ayrıksal forma geçtik, ben de <span class="math inline">\(\phi_i\)</span> fonksiyonlarını <span class="math inline">\(V_i\)</span> fonksiyonlarım için kullanmaya karar veriyorum. Böylece,</p>
<p><span class="math display">\[
\int_{0}^{1} c(x) \frac{\mathrm{d} U}{\mathrm{d} x} \frac{\mathrm{d} V_i}{\mathrm{d} x} \mathrm{d} x =
\int_{0}^{1} f(x) V_i(x) \mathrm{d} x
\qquad (3)
\]</span></p>
<p>ki <span class="math inline">\(i=0,1,2,3,4\)</span>. Böylece 5 tane denklem elde ediyorum, 5 tane <span class="math inline">\(V\)</span> ile ana formülü &quot;test ediyorum''. Yani üstteki denklemi 5 tane <span class="math inline">\(V\)</span> için farklı şekillerle üretmiş oluyorum. İşte 5 x 5 sistemim bu. Neler yaptım şimdiye kadar? Baz fonksiyonlarını seçtik, onları zayıf forma sokuyoruz. <span class="math inline">\(\mathrm{d} U / \mathrm{d} x\)</span> ağırlıklı toplamdan geliyor (dikkat tüm <span class="math inline">\(V\)</span>'leri kullanarak), sonra <span class="math inline">\(\mathrm{d} V_i / \mathrm{d} x\)</span> sokuyoruz, ve entegrali hesaplıyoruz. FD durumunda bu hesap yoktu, entegral hesabı yani, FEM ile var, eşitliğin hem sağında hem de solunda. Eşitliğin sağındaki entegral her <span class="math inline">\(V_i\)</span> için bize bir <span class="math inline">\(F_i\)</span> verecek, yani <span class="math inline">\(F\)</span> vektörünün bir satırını. Tabii <span class="math inline">\(K\)</span> matrisi eşitliğin solundan bir şekilde çıkacak, nasıl birazdan göreceğiz.</p>
<p>Örnek</p>
<p>Sağ tarafa bakalım önce, mesela <span class="math inline">\(i=0\)</span> için, <span class="math inline">\(f(x)=1\)</span> olsun (örneğe göre böyle) bu durumda <span class="math inline">\(\int_{0}^{1} 1 \cdot V_0(x) \mathrm{d} x\)</span> entegrali ne olur? Entegral bir alan hesabıdır hatırlarsak, o zaman</p>
<div class="figure">
<img src="compscieng_1_18_05.png" />

</div>
<p><span class="math inline">\(V_0\)</span> üstteki ilk yarım şapka, o üçgenin alanı, eğer <span class="math inline">\(x\)</span> ekseni eşit aralıklarla bölmüşsek ve her aralık <span class="math inline">\(\Delta x\)</span> ise, <span class="math inline">\((\Delta x \cdot 1) / 2 = \frac{\Delta x}{2}\)</span>.</p>
<p>Dikkat 0 ila 1 arası entegral üstteki resimdeki tüm yatay ekseni kapsar, 0,1,2,.. indisleri kafa karıştırmasın. O indisler <span class="math inline">\(x=0\)</span> ile <span class="math inline">\(x=1\)</span> arasını indisliyor. O zaman 0 ile 1 arası entegral tüm <span class="math inline">\(V\)</span>'lerin olduğu alan üzerinden alınır, fakat biz her seferinde birini seçtiğimiz için onun alanını hesaplamış oluyoruz çünkü mesela <span class="math inline">\(V_0\)</span> tanımlandığı yer sonrasında sıfır değerinde.</p>
<p><span class="math inline">\(i=1\)</span> için ne olur? <span class="math inline">\(\int_{0}^{1} 1 \cdot V_1(x) \mathrm{d} x\)</span>, üçgen tabanı <span class="math inline">\(2 \Delta x\)</span>, çarpı 1, sonuç <span class="math inline">\(\Delta x\)</span>. diğer <span class="math inline">\(V\)</span> değerleri benzer şekilde, o zaman <span class="math inline">\(F\)</span> vektör şu şekilde,</p>
<p><span class="math display">\[
F = \left[\begin{array}{c}
1/2 \\ 1 \\ 1 \\ 1 \\ 1
\end{array}\right]
\]</span></p>
<p><span class="math inline">\(K\)</span> için hazır mıyız? Anahtar bölüm orası.</p>
<ol start="3" style="list-style-type: decimal">
<li>formülünün tüm sol tarafı <span class="math inline">\(KU\)</span>'yu vermeli.. Satır satır gidelim, mesela sıfırıncı denklem hangisi? <span class="math inline">\(i=0\)</span> olduğu zaman, yani <span class="math inline">\(V_0\)</span> kullanılan, zayıf formu <span class="math inline">\(V_0\)</span> ile test ettiğimiz durumdur. Her şeyi açarak yazarsak,</li>
</ol>
<p><span class="math display">\[
\int_{0}^{1} c(x)
\left( U_0 \phi_0&#39; + ... + U_4 \phi_4&#39;  \right)
\frac{\mathrm{d} V_0}{\mathrm{d} x} \mathrm{d} x = F_0 = \Delta x \cdot \frac{1}{2}
\]</span></p>
<p>Şu ana kadar eldekileri matris formunda yazarsak,</p>
<p><span class="math display">\[
\left[\begin{array}{rrrrr}
 &amp; &amp; &amp; &amp; \\
 &amp; &amp; &amp; &amp; \\
 &amp; &amp; &amp; &amp; \\
 &amp; &amp; &amp; &amp; 
\end{array}\right]
\left[\begin{array}{r}
U_0 \\ U_1 \\ U_2 \\ U_3 \\ U_4
\end{array}\right] =
\left[\begin{array}{r}
F_0 \\ F_1 \\ F_2 \\ F_3 \\ F_4
\end{array}\right]
\]</span></p>
<p>Boş matrisin ilk satırını <span class="math inline">\(V_0\)</span>'yi kullanarak yapacağım entegral hesabından elde edeceğim. Daha kolay başlayalım, ilk satırın sol ilk hücresine ne gelir? <span class="math inline">\(K_{00}\)</span> diyelim, oradaki değer <span class="math inline">\(U_0\)</span>'i çarpıyor değil mi ve bir şekilde entegralinin alınması lazım.. Şöyle olabilir mi?</p>
<p><span class="math display">\[
K_{00} = \int_{0}^{1} c(x) \phi_0&#39; V_0&#39; \mathrm{d} x
\]</span></p>
<p><span class="math inline">\(c(x)\)</span> için şimdilik 1 kabul edelim. Fakat eğer 1 olmasaydı daha çetrefil bir fonksiyon olsaydı? İçinde <span class="math inline">\(c(x)\)</span> olan birçok entegrali üstteki gibi hesaplamak lazım, ve bu hesapların kesin olması gerekmeyebilir, yani bu entegralleri yaklaşık olarak hesaplasak ta yeterli olabilir. Sonuçta diğer her şeyi yaklaşık yapıyoruz değil mi? Belli noktalar üzerinden yaklaşık bir temsil yaratıyoruz vs.. Bu çerçevede eğer üstteki türden entegralleri hesabın tümünü bozmayacak seviyeye yetecek kesinlik3te hesaplayabilirsek, işimizi halletmiş oluruz. <span class="math inline">\(c(x)\)</span> 1 olunca tabii ki kesin çözümü bulacağız ama diğer tür durumlar için aklımızda olsun.</p>
<p>Hesabın kendisine gelelim. <span class="math inline">\(\phi_0&#39;\)</span> nedir? Bu arada <span class="math inline">\(\phi\)</span>'leri <span class="math inline">\(V\)</span> ile aynı seçtiğimiz için <span class="math inline">\(\phi_0&#39; = V_0&#39;\)</span> ve her iki türev üstteki resimdeki baştaki yarım üçgenin eğimi. Eğitim dikey artış bolu yatay artış, yatay kısım <span class="math inline">\(\Delta x\)</span>, o zaman 1'inci dugume kadar <span class="math inline">\(- 1 / \Delta x\)</span>, sonrası sıfır.</p>
<p>Bu vurgulanması gereken bir noktaya götürüyor, fonksiyonlarımız yerel / lokal. Bu ne demek? Eğer <span class="math inline">\(\phi_1&#39;\)</span> türevini <span class="math inline">\(V_4&#39;\)</span> türeviyle entegre etseydim (<span class="math inline">\(K\)</span> matrisinde 4'uncu satır ile 1'inci kolon değeri yani) ne olacaktı? Sıfır olacaktı. Niye? Çünkü bu fonksiyonlar yerel, 0'inci ve 4'uncu düğümlerden uzakta değerleri sıfır, sıfır olmadıkları yerler çakışmıyor. Şimdi bu dinamiği tüm matris için düşünürsek ne kadar az çakışma yeri olduğunu görebiliriz. Herhangi bir <span class="math inline">\(\phi\)</span> mesela, tabii ki kendisiyle çakışır ve yanindaki komşularla biraz çakışır. Ama daha ilerisiyle örtüşmesi yoktur. Bu bize <span class="math inline">\(K\)</span> için üçlü köşegen bir matris verecek, üç öğeli köşegen bantında değerler olacak, geri kalan her yer sıfır.</p>
<div class="figure">
<img src="compscieng_1_18_06.png" />

</div>
<p><span class="math inline">\(K_{00}\)</span> hesabına dönelim, <span class="math inline">\(c(x)=1\)</span>, <span class="math inline">\(\phi_0&#39; = -1/\Delta x\)</span>, <span class="math inline">\(V_0&#39;\)</span> aynı değer, ve entegre ettiğimizi unutmayalım, 0 ile 1 arası ama aslında 0 ile <span class="math inline">\(\Delta x\)</span> arası çünkü sadece oraya kadar değerler var, o zaman <span class="math inline">\(K_{00} = 1/\Delta x\)</span> oluyor.</p>
<p>Peki</p>
<p><span class="math display">\[
K_{11} = \int_{0}^{1} c(x) \phi_1&#39; V_1&#39; \mathrm{d} x
\]</span></p>
<p><span class="math inline">\(\phi_1\)</span> eğimi nedir? Bu şapka fonksiyonu tam, <span class="math inline">\(\Delta x\)</span>'e kadar yukarı çıkıyor sonra aşağı ınıyor, o zaman</p>
<p><span class="math display">\[
\phi_1&#39; = V_1&#39; =
\left\{ \begin{array}{rc}
1/\Delta x &amp; 0 &lt; x \le \Delta x \\
-1/\Delta x &amp; \Delta x &lt; x \le 2\Delta x 
\end{array} \right.
\]</span></p>
<p><span class="math inline">\(\phi_1&#39;\)</span> ve <span class="math inline">\(V_1&#39;\)</span> çarpımı her iki bölüm için <span class="math inline">\(1/\Delta x^2\)</span> verir. Peki <span class="math inline">\(K_{11}\)</span> entegral sonucu ne o zaman? <span class="math inline">\(2 \Delta x\)</span> değil mi? Çünkü bu sefer entegral sınırlarına dikkkat, 0 ile <span class="math inline">\(2\Delta x\)</span> arasında.</p>
<p><span class="math display">\[
K_{11} = \int_{0}^{2\Delta x} c(x) \phi_1&#39; V_1&#39; \mathrm{d} x = 2\Delta x
\]</span></p>
<p><span class="math inline">\(K_{22}\)</span>, <span class="math inline">\(K_{33}\)</span>, .. benzer şekilde olacak.</p>
<p>Peki <span class="math inline">\(K_{01}\)</span> ne olur? Yani sıfırıncı satır ve 1'inci kolona bakıyorum. Her iki şapka fonksiyonunu çizersek,</p>
<div class="figure">
<img src="compscieng_1_18_07.png" />

</div>
<p>Görüldüğü gibi biri yarım, diğeri tam, ama çakıştıkları yer hocanın gri kalın şeritle gösterdiği bölümden öncesi. Ondan sonrası <span class="math inline">\(\phi_0\)</span> sıfır değerinde orada entegral almaya gerek yok.</p>
<p>Tabii entegre edilen eğimler, <span class="math inline">\(\phi_0&#39;\)</span> <span class="math inline">\(-1/\Delta x\)</span> olacak, <span class="math inline">\(V_1&#39;\)</span> ise pozitif değerli, <span class="math inline">\(1/\Delta x\)</span>. Çarpımları <span class="math inline">\(-1/\Delta x^2\)</span> entegre sınırı 0 ile <span class="math inline">\(\Delta x\)</span> arası, entegrasyon sonucu <span class="math inline">\(K_{01} = 1-/\Delta x\)</span>. n</p>
<p>Köşegen bir üstü ve bir altı aşağı çapraz inen tüm satırlar için aynı şey geçerli, çünkü hepsi de yanyana olan <span class="math inline">\(\phi\)</span> ve <span class="math inline">\(V\)</span> üzerinden entegral alıyor olacaklar</p>
<div class="figure">
<img src="compscieng_1_18_08.png" />

</div>
<p>Tüm matrisi doldursak görürdük ki <span class="math inline">\(K\)</span> matrisi simetrik, pozitif kesin olacak. Hatta onun ötesinde biraz basitleştirme sonrası üstteki matris bize bu dersten daha da tanıdık gelebilir. Eğer <span class="math inline">\(1/\Delta x\)</span> dışarı çekilirse bizim <span class="math inline">\(T\)</span> matrisi ortaya çıkıyor,</p>
<p><span class="math display">\[
K = \frac{1}{\Delta x}
\left[\begin{array}{rrrrr}
1 &amp; -1   &amp;    &amp; \\
-1  &amp; 2  &amp; -1 &amp;  &amp;   \\
    &amp; -1 &amp;  2 &amp; -1 &amp;   \\
    &amp;    &amp; -1 &amp; 2 &amp; -1  \\
    &amp;    &amp;    &amp; 1  &amp; 2 
\end{array}\right]
\]</span></p>
<p>Hepsini bir araya koyarsak,</p>
<p><span class="math display">\[
KU =
\frac{1}{\Delta x}
\left[\begin{array}{rrrrr}
1 &amp; -1   &amp;    &amp; \\
-1  &amp; 2  &amp; -1 &amp;  &amp;   \\
    &amp; -1 &amp;  2 &amp; -1 &amp;   \\
    &amp;    &amp; -1 &amp; 2 &amp; -1  \\
    &amp;    &amp;    &amp; 1  &amp; 2 
\end{array}\right]
\left[\begin{array}{r}
U_0 \\ U_1 \\ U_2 \\ U_3 \\ U_4
\end{array}\right] =
\Delta x
\left[\begin{array}{r}
1/2 \\ 1 \\ 1 \\ 1 \\ 1
\end{array}\right] = F
\]</span></p>
<p>Basit örneğimiz için FEM sistemi <span class="math inline">\(KU = F\)</span> işte bu.</p>
<p>Gerçi üstteki denklem sonlu farklılıklara (FD) benzer bir sistem ortaya çıkarttı, derse o sebeple 'bu iki yaklaşımın farkı nerede?' sorusuyla başlamıştım. Fakat dikkatli bakarsak bu çok basit problemde bile ufak bir fark var, üstteki vektörde 1/2 var mesela, FD sistemine bu yok. Ama tabii <span class="math inline">\(F\)</span> 1 değilse ya da <span class="math inline">\(c\)</span> 1 değilse daha fazla farklar ortaya çıkacaktır, <span class="math inline">\(c\)</span> 1 değilse bir sürü çetrefil entegral ortaya çıkar, onları yaklaşık şekilde temsil etmeye uğraşırım muhakkak.</p>
<p>Ya <span class="math inline">\(F\)</span> için pür 1 değil mesela nokta yük (point load) <span class="math inline">\(\delta (x-\frac{1}{5})\)</span> olsaydı elimizde? Şimdi entegrallere geri dönmem gerekiyor değil mi? (3) denklemindeki eşitliğin sağ tarafındaki entegralden bahsediyorum. Şimdi o entegralde 1 yerine noktasal yük var</p>
<p><span class="math display">\[
= \int_{0}^{1} \delta (x-1/5) V_i \mathrm{d} x
\]</span></p>
<p>diye gidiyor, yani <span class="math inline">\(\delta (x-1/5)\)</span> fonksiyonunu her şapka fonksiyonuna karşı entegre etmem gerekiyor. Ne elde ederim? Delta fonksiyonu 1/5 noktasındaki değeri çekip çıkartır, çünkü o noktada zıplama yapıyor, orada entegrali, alanı 1, o zaman 1/5 üzerindeki <span class="math inline">\(V_i\)</span> değerini seçecektir. O da <span class="math inline">\(i=1\)</span> olur, demek ki iki üstteki eşitliğin sağ tarafı suna benzer,</p>
<p><span class="math display">\[
= \Delta x
\left[\begin{array}{r}
0 \\ 1 \\ 0 \\ 0 \\ 0
\end{array}\right] = F
\]</span></p>
<p>Gerçi bu da FD'nin üreteceği sonuca biraz benzer.</p>
<p>Ya nokta yükü düğüm üzerinde değil iki düğüm arasına gelecek şekilde seçseydim? Mesela 3/10 noktasında? O zaman entegraller bana</p>
<p><span class="math display">\[
= \Delta x
\left[\begin{array}{r}
0 \\ 1/2 \\ 1/2 \\ 0 \\ 0
\end{array}\right] = F
\]</span></p>
<p>verirdi değil mi? Görüyoruz, FEM nasıl otomatik olarak akılcı olan şeyi yaptı.. Noktasal yükün etkisini iki vektör hücresine yaydı. Otomatik olarak <span class="math inline">\(c(x)\)</span>'i, <span class="math inline">\(f(x)\)</span>'i esnek şekilde probleme dahil ediyor, serbest sınırı idare ediyor.. FD bunu yapamazdı, çünkü FD katı olarak düğümler üzerinde tanımlıdır.</p>
<hr>
<p>Alttaki Eski Bir Ders Video'sundan Alınmıştır</p>
<p>Sonlu Öğeler Metodu (Finite Elements Method)</p>
<p>Bu metot differansiyel, kısmi differansiyel denklemleri (partial differential equations) yaklaşıksal olarak modelleme ve çözmenin yöntemleridir.</p>
<p>Formül: Başlangıç denklemi</p>
<p><span class="math display">\[ \frac{-d}{\mathrm{d} x} \bigg( c(x) \ \frac{\mathrm{d} u}{\mathrm{d} x} \bigg) = f(x) \]</span></p>
<p>İki tarafı da <span class="math inline">\(v(x)\)</span> ile çarpıyoruz ve 0 to 1 sınırlarıyla entegralini alıyoruz.</p>
<p><span class="math display">\[
\int_0^1 \frac{-d}{\mathrm{d} x} \bigg( c(x) \frac{\mathrm{d} u}{\mathrm{d} x} \bigg) v(x)\mathrm{d} x
= \int_0^1 f(x)v(x) \mathrm{d} x
\]</span></p>
<p>Parçalı entegral (integration by parts) formülü şöyledir:</p>
<p><span class="math display">\[ \int y \mathrm{d} z = y  z - \int z \mathrm{d} y \]</span></p>
<p>Ana formülün bölümlerini, parçalı entegrale göre bölüştürürsek:</p>
<p><span class="math display">\[ dz = \frac{-d}{dx} \bigg( c(x) \ \frac{du}{dx} \bigg) dx  \]</span></p>
<p><span class="math display">\[ z = - c(x) \ \frac{du}{dx}  \]</span></p>
<p><span class="math display">\[ y = v(x)  \]</span></p>
<p><span class="math display">\[ dy = \frac{dv}{dx}dx \]</span></p>
<p>Yukarıda <span class="math inline">\(dz\)</span> içinde <span class="math inline">\(dx\)</span> ve <span class="math inline">\(\frac{1}{dx}\)</span> birbirini iptal eder. Parçalı entegral formülünün sağ tarafına göre yerlerine koyarsak:</p>
<p><span class="math display">\[
\int_0^1 v(x)\mathrm{d} x \frac{-d}{\mathrm{d} x} \bigg( c(x) \frac{\mathrm{d} u}{\mathrm{d} x} \bigg)
= - \bigg[ v(x) c(x) \frac{\mathrm{d} u}{\mathrm{d} x} \bigg]_{x=0}^{x=1} \int_0^1 c(x) \frac{\mathrm{d} u}{\mathrm{d} x} \frac{\mathrm{d} v}{\mathrm{d} x} \mathrm{d} x
\]</span></p>
<p>Üstteki parçalı entegral açılımında sol taraf entegrale sınır değerleri aldığında, sağ taraftaki <span class="math inline">\(yz\)</span> sonucunun aynı sınır değerlerine tabi olduğuna dikkat edelim.</p>
<p>Differansiyel denklemde sınır koşulları <span class="math inline">\(x=1\)</span> durumunda <span class="math inline">\(c(1)u&#39;(1)=0\)</span>, ve <span class="math inline">\(x=0\)</span> durumunda <span class="math inline">\(v(0)=0\)</span> olarak biliniyor. O zaman üstteki denklemin sol tarafında <span class="math inline">\(x=0\)</span> ve <span class="math inline">\(x=1\)</span> koşulları için tanımlı bölüm <span class="math inline">\(0 - 0 = 0\)</span> olacaktır ve denklemden atılabilir. Geriye kalanlar</p>
<p><span class="math display">\[
\int_0^1 c(x) \frac{\mathrm{d} u}{\mathrm{d} x} \frac{\mathrm{d} v}{\mathrm{d} x} \mathrm{d} x
= \int_0^1 f(x)v(x) \mathrm{d} x
\]</span></p>
<p>Bu fonksiyonu Galerkin adlı bir matematikçi bulmuş, &quot;zayıf form (weak form)&quot; olarak adlandırılıyor.</p>
<p>Şimdi diyelim ki n tane test fonksiyonu seçtik <span class="math inline">\(\phi_1(x),..,\phi(n)\)</span> ve bu fonksiyonların <span class="math inline">\(U_j\)</span> sayıları ile çarpımının toplamını, yani bir tür kombinasyonunu <span class="math inline">\(u(x)\)</span> yerine kullanmaya karar verdik.</p>
<p><span class="math display">\[ U(x) = U_1 \phi_1+ ... + U_n\phi_n \]</span></p>
<p>O zaman</p>
<p><span class="math display">\[ U&#39;(x) = U_1 \phi_1&#39;+ ... + U_n\phi_n&#39; \]</span></p>
<p><span class="math display">\[ = \sum_1^n U_j \frac{d\phi_j}{dx} \]</span></p>
<p>Şimdi <span class="math inline">\(du / dx\)</span> yerine <span class="math inline">\(U&#39;(x)\)</span> koyarsak</p>
<p><span class="math display">\[
\int_0^1 c(x) \bigg( \sum_1^n U_j \frac{\mathrm{d}\phi_j}{\mathrm{d} x}\bigg)
\frac{\mathrm{d} V_i}{\mathrm{d} x}\mathrm{d} x
= \int_0^1 f(x)V_i(x)\mathrm{d} x
\]</span></p>
<p>Dikkat edelim, <span class="math inline">\(v(x)\)</span> yerine <span class="math inline">\(V_i(x)\)</span> kullandık. Üstteki formül her i için yeni bir formül &quot;üretecek&quot;. Niye <span class="math inline">\(V_i\)</span>? Zayıf formdaki <span class="math inline">\(v(x)\)</span> formülünü de zaten biz uydurmuştuk, yani <span class="math inline">\(v(x)\)</span> biz ne istersek o olur. O zaman bu fonksiyonu n tane formül üretmek için bir numara olarak kullanıyoruz, n tane formül olunca matrisin n x n elemanını doldurabileceğiz ve çözüme erişebileceğiz. Ek not, çoğunlukla <span class="math inline">\(V_i(x)\)</span> için <span class="math inline">\(\phi_i\)</span> sembolü kullanılıyor.</p>
<p>Ayrıca formüldeki <span class="math inline">\(U_j\)</span> kısmını cekip çıkartırsak ve bir vektör içine koyarsak, geri kalanlar bir <span class="math inline">\(K_{ij}\)</span> matrisi içinde tutulabilir.</p>
<p><span class="math display">\[ K_{ij} = \int_0^1 c(x) \frac{\mathrm{d}\phi_j}{\mathrm{d} x} \frac{\mathrm{d} V_i}{\mathrm{d} x} \mathrm{d} x  \]</span></p>
<p>Sağ taraf aynı şekilde i tane formül üretir</p>
<p><span class="math display">\[ F_i = \int_0^1 f(x)V_i(x) \mathrm{d} x \]</span></p>
<p>Final formül matrix formunda basit bir şekilde temsil edilebilecektir.</p>
<p><span class="math display">\[ KU = F \]</span></p>
<p>Örnek</p>
<p>Örnek olarak <span class="math inline">\(-u&#39;&#39; = 1\)</span> denklemini çözelim. Not: Differansiyel denklemlerde sonuç bulmak demek bir &quot;fonksiyon&quot; bulmak demektir. Normal cebirsel denklemlerde sonuç bulmak değişkenlerin &quot;sayısal&quot; değerini bulmak demektir. Birazdan bulacağımız sonuç <span class="math inline">\(u(x)\)</span> &quot;fonksiyonu&quot; olacak.</p>
<p>Eğer denklem <span class="math inline">\(-u&#39;&#39;=1\)</span> ise o zaman bu formülü ana forma uygun hale getirmek için <span class="math inline">\(c(x) = 1\)</span> olarak almamız gerekir. <span class="math inline">\(-u&#39;&#39;=1\)</span> denkleminde eşitliğin sağ tarafı 1 olduğuna göre <span class="math inline">\(f(x) = 1\)</span> demektir.</p>
<p>Artık <span class="math inline">\(\phi\)</span> fonksiyonlarını seçme zamanı geldi. Bu fonksiyonların &quot;toplamı&quot; hedeflediğimiz fonksiyonu yaklaşıksal (approximate) olarak temsil edecek. Örnek olarak seçebileceğimiz bir fonksiyon &quot;şapka fonksiyonu (hat function)&quot; olarak bilinen üçgen fonksiyonlar olabilir. Alttaki figürde bu fonksiyonları görüyoruz.</p>
<div class="figure">
<img src="fem_hat.png" />

</div>
<p>Bu figürde x ekseninin h büyüklüğündeki parçalara bölündüğünü görüyoruz.</p>
<p>Entegralleri hesaplayalım</p>
<p><span class="math display">\[ F_1 = \int_0^1 V_1(x) \mathrm{d} x \]</span></p>
<p>Daha önce <span class="math inline">\(V_1\)</span> ve <span class="math inline">\(\phi_1\)</span>'i aynı kabul ettiğimizi belirtmiştik.</p>
<p>Yukarıdaki entegralin aslında bir alan hesabı yaptığını görüyoruz. Sınırlar <span class="math inline">\(0\)</span> ve <span class="math inline">\(1\)</span> arasında, ama <span class="math inline">\(2h\)</span> ötesinde zaten <span class="math inline">\(\phi_1\)</span> fonksiyonu yok. <span class="math inline">\(\phi_1\)</span>'in alanı nedir? Alan üçgenin alanı: Taban çarpı yükseklik bölü 2: <span class="math inline">\(2h\)</span>, yüksekliği <span class="math inline">\(1\)</span>, o zaman alan <span class="math inline">\((2h \times 1) / 2 = 1/3\)</span></p>
<p>Benzer mantıkla bakarsak, <span class="math inline">\(F_2\)</span> ile <span class="math inline">\(F_1\)</span> aynı, yani <span class="math inline">\(1/3\)</span>. <span class="math inline">\(F_3\)</span> ise onların yarısı, yani <span class="math inline">\(1/6\)</span>.</p>
<p><span class="math inline">\(K_{ij}\)</span> nasıl hesaplanacak? <span class="math inline">\(c(x) = 1\)</span> olduğu için formülden çıkarılabilir ve <span class="math inline">\(V_1\)</span> ve <span class="math inline">\(\phi_1\)</span>'in aynı olduğuna söyledik:</p>
<p><span class="math display">\[ K_{ij} = \int_0^1 c(x) \frac{\mathrm{d}\phi_j}{\mathrm{d} x} \frac{\mathrm{d} V_i}{\mathrm{d} x} \mathrm{d} x \]</span></p>
<p><span class="math display">\[ K_{11} = \int_0^1 \bigg( \frac{\mathrm{d} V_1}{\mathrm{d} x} \bigg) ^2 \mathrm{d} x  \]</span></p>
<p><span class="math inline">\(dV_1/dx\)</span> nedir? Birinci şapka fonksiyonunun türevidir. Bu türeve bakarsak, <span class="math inline">\(0\)</span> ve <span class="math inline">\(h\)</span> arasında artı eğim (slope) <span class="math inline">\(1/h\)</span>, <span class="math inline">\(h\)</span> ve <span class="math inline">\(2h\)</span> arasında eksi eğim <span class="math inline">\(-1/h\)</span> oluyor. Ama kare aldığımız için sonuç aynı, <span class="math inline">\(1/h^2\)</span>. O zaman h = 1/3 olduğuna göre <span class="math inline">\(1/(1/3)^2\)</span>, yani <span class="math inline">\(dV_1/dx = 9\)</span>.</p>
<p><span class="math display">\[ K_{11} = \int_0^{2/3} 9 \mathrm{d} x = 9x \bigg|_0^{2/3} = (9)(2/3) - 0 = 6 \]</span></p>
<p><span class="math inline">\(K_{22}\)</span> şeklen aynı fonksiyon parçasını temel aldığı için aynı değere sahip: 6. <span class="math inline">\(K_{33}\)</span> onların yarısı, eşittir 3.</p>
<p><span class="math inline">\(K_{12}\)</span> farklı eğimlerin çarpımı anlamına gelir, yani <span class="math inline">\(V_1&#39;\)</span> ile <span class="math inline">\(V_2&#39;\)</span> çarpımı olur. Bu iki fonksiyona bakalım, 0 ile h arasında <span class="math inline">\(V_2\)</span> yok, eğim 0. İkisinin de sıfır olmadığı, çarpımda kullanılabilecek bir eğiminin olduğu tek aralık h ve 2h arası. Burada <span class="math inline">\(V_1&#39; = -3, V_2 = 3\)</span>.</p>
<p><span class="math display">\[
K_{12} = \int_{1/3}^{2/3} (3)(-3) \mathrm{d} x
= -9x \bigg|_{1/3}^{2/3} = -6 - (-3) = -3
\]</span></p>
<p>Aynı şekilde <span class="math inline">\(K_{23} = -3\)</span>. Ama <span class="math inline">\(K_{13} = 0\)</span> çünkü hiç çakışma yok.</p>
<p>Matrisi doldurursak,</p>
<p><span class="math display">\[
KU = F
\]</span></p>
<p><span class="math display">\[ 
\left[\begin{array}{ccc}
    6 &amp; -3 &amp; 0 \\
    -3 &amp; 6 &amp; -3 \\
    0 &amp; -3 &amp; 3     
\end{array}\right]
\left[\begin{array}{c}
    U_1 \\
    U_2 \\
    U_3
\end{array}\right]
=
\left[\begin{array}{c}
    1/3 \\
    1/3 \\
    1/6
\end{array}\right]
\]</span></p>
<p>Python kodu</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">K <span class="op">=</span> [[<span class="fl">6.</span>, <span class="fl">-3.</span>, <span class="dv">0</span>],
     [<span class="op">-</span><span class="fl">3.</span>, <span class="fl">6.</span>, <span class="fl">-3.</span>],
     [<span class="fl">0.</span>, <span class="fl">-3.</span>, <span class="fl">3.</span>]]

f <span class="op">=</span> [<span class="fl">1.</span><span class="op">/</span><span class="fl">3.</span>, <span class="fl">1.</span><span class="op">/</span><span class="fl">3.</span>, <span class="fl">1.</span><span class="op">/</span><span class="fl">6.</span>]

<span class="bu">print</span> np.linalg.solve(K,f)</code></pre></div>
<pre><code>[ 0.27777778  0.44444444  0.5       ]</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> <span class="fl">5.</span><span class="op">/</span><span class="fl">18.</span>, <span class="fl">4.</span><span class="op">/</span><span class="fl">9.</span>, <span class="fl">1.</span><span class="op">/</span><span class="fl">2.</span></code></pre></div>
<pre><code>0.277777777778 0.444444444444 0.5</code></pre>
<p>Rapor edilen değerler bu denklemin bilinen çözümü <span class="math inline">\(u(x) = x - \frac{1}{2}x^2\)</span> ile 0, h, 2h noktalarında (mesh points) birebir uyum gösterdiğini görüyoruz. Yani yaklaşıksal olarak differansiyel denklemi çözmeyi başardık.</p>
<p>Kaynaklar</p>
<p>[1] Strang, G., <em>Computational Science and Engineering</em></p>
</body>
</html>
