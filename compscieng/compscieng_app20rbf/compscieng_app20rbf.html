<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Aradeğerleme (Interpolation) - Dairesel Baz Fonksiyonları (Radial Basis Functions -RBF-)</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1
id="aradeğerleme-interpolation---dairesel-baz-fonksiyonları-radial-basis-functions--rbf-">Aradeğerleme
(Interpolation) - Dairesel Baz Fonksiyonları (Radial Basis Functions
-RBF-)</h1>
<p>Ara değerlemek (interpolation), yani elde olan veriyi kullanıp
olmayan hakkında tahmin yapmaya uğraşmak için çok boyutlu ortamda RBF
iyi işleyen bir yaklaşım. Belki de zihinde en rahat canlandırılabilecek
örnek yeryüzünde dağlara ovalara tekabül eden yükseklik (elevation)
verilerini alarak onlara sürekli tepe fonksiyonları “uydurmak’’ böylece
dağların nerede olduğunu sürekli şekilde saptamak. Temsil etmek
istediğimiz (ama bilmediğimiz) fonksiyon <span
class="math inline">\(z=g(x,y)\)</span> olarak gösterilebilecek bir
fonksiyon, bir düzlemde herhangi bir <span
class="math inline">\(x,y\)</span> noktasındaki yükseklik <span
class="math inline">\(z\)</span>. Bu fonksiyondan örneklenerek alınmış
verilerle onu yaklaşık olarak temsil etmek istiyoruz.</p>
<p>Düz verinin kendisini kullanmak bağlamında düşük çözünürlükte
yükseklik verisi ise yaramayabilir, mesela bir örneklem noktası dağın
bir eteğinden diğeri öteki yanındaki eteğinden alınmışsa bu dağ yok
anlamına gelecektir. Peki o zaman niye yükseklik verisinin geldiği
yerden daha yüksek çözünürlüklü veri almıyoruz? Bu hem erişim hem de
tutacağı yer bağlamında pahalı olabilir. 1 derecelik enlem / boylam
içinde, mesela 36-37 ve 32-33 arası diyelim, 100 metrelik çözünürlük
demek 0.001 derece değişimine tekabül eder, ve bu durumda 1 milyon veri
noktası alınması gerekecektir. Halbuki yükseklik verisinden yüzde 3
miktarında bile [2] bir rasgele örneklem alırsak, bu noktalara RBF ile
tepe fonksiyonları uydurarak matematiksel, sürekli olan bir genel
fonksiyon elde ederiz, ve uydurma iyi işlerse artık istediğimiz
çözünürlükte yükseklik verisi elde edebiliriz çünkü elimizdeki sürekli
fonksiyona istediğimiz her nokta için yükseliğin ne olduğunu artık
hesaplattırabiliriz.</p>
<p>Bu örneği 3 boyutta herhangi bir başka veri için de düşünmek mümkün;
ama yükseklik verisinde daha rahat, her örneklem noktasına konulan
tepeler ve onların birleşimi bize pürüzsüz, sürekli bir engebe şekli
verir. RBF baz fonksiyonları <span class="math inline">\(\Phi(x) =
f(||x-c||)\)</span> şeklindedir, <span class="math inline">\(f\)</span>
tepe, ya da farklı bir fonksiyon olabilir, <span
class="math inline">\(||\cdot||\)</span> norm fonksiyonudur, Öklitsel
norm olabilir mesela.</p>
<p>Burada <span class="math inline">\(c\)</span> üstüne baz fonksiyon
konulan nokta, her örneklem veri noktası yani. RBF eğitimi / uydurma
metadolijisine göre herhangi bir veri noktası dışındaki tüm diğer
örneklem verileri o veri noktasının oluşumunu etkiler. Bu anormal bir
faraziye değil, bir dağın başında, ortasında, tepesinden alınmış
örneklemler varsa, mesela en alt ve en tepedeki veri ortadakini etkiler,
yani o bağlantıyı, ilişkiyi farzetmek normaldir. Orta nokta zirveyi
tanımlayan fonksiyona belli bir ağırlıkla bağlı, en alttakine başka bir
şekilde bağlı, vs. Bu ağırlıkların ne olacağını genel çözüm
belirleyecektir. Eğer <span class="math inline">\(f\)</span> için
Gaussian’ımsı bir tepe fonksiyonu seçersek, yeni gözlemin baz
fonksiyonları ile arasındaki ilişki,</p>
<p><span class="math display">\[
h(x) = \sum_{i=1}^N w_n \times exp(-\gamma \|x-m_i\|^2)
\]</span></p>
<p>olarak gösterilebilir, <span class="math inline">\(\gamma\)</span>
her noktanın etkisinin ne olduğunu dışarıdan ayarlamak için genel bir
sabit, ne kadar küçükse konulan tepe o kadar kenarlara yayılır, daha
büyük değerler daha noktasal olur. <span
class="math inline">\(N\)</span> tane baz fonksiyonu olacak, <span
class="math inline">\(N\)</span> tane <span
class="math inline">\(m_i,y_i\)</span>, ya da <span
class="math inline">\(x_i,y_i\)</span> verisine bakarak bu fonksiyonları
bulacağız.</p>
<p>İki üstteki formüldeki <span class="math inline">\(x-c\)</span>
kullanımına dikkat, bu aslında “diğer noktaları’’ temsil etmenin
akıllıca bir yolu, <span class="math inline">\(c\)</span> üzerinde <span
class="math inline">\(x-c\)</span> sıfır değerdedir, bu o noktayı temsil
için diğer noktalar üzerindeki bazların devreye girmesi gerektiğini
modelde söyler.</p>
<p>Her bazın etkisi <span class="math inline">\(w_n\)</span> ağırlığı
üzerinden modele yansıtılır. Bu ağırlıkların ne olduğunu bulmak, nihai
genel fonksiyonu bulmuş olmak anlamına gelir. Farklı indislerle tekrar
belirtmek gerekirse her veri noktası için şu doğru olmalı,</p>
<p>Bu bize <span class="math inline">\(N\)</span> tane veri noktası için
<span class="math inline">\(N\)</span> tane denklem ve <span
class="math inline">\(N\)</span> tane bilinmeyen sağlar. Eldeki <span
class="math inline">\((x_1,y_1),...,(x_N,y_N)\)</span> verileri ile
<span class="math inline">\(w\)</span>’yi bulmamızı sağlayacak
regresyonu matris formunda şöyle gösterebiliriz,</p>
<p><span class="math display">\[
\underbrace{
\left[\begin{array}{rrr}
    \exp(-\gamma \|x_1-m_1\|^2) &amp; \cdots &amp; \exp(-\gamma
\|x_1-m_N\|^2)\\
    \exp(-\gamma \|x_2-m_1\|^2) &amp; \cdots &amp; \exp(-\gamma
\|x_2-m_N\|^2)\\
    \vdots &amp; \ddots &amp; \vdots \\
    \exp(-\gamma \|x_N-m_1\|^2) &amp; \cdots &amp; \exp(-\gamma
\|x_N-m_N\|^2)
\end{array}\right]
}_{\Phi}
\underbrace{
\left[\begin{array}{r}
w_1  \\ w_2  \\ \vdots \\  w_N
\end{array}\right]}_{w}
=
\underbrace{
\left[\begin{array}{rrr} y_1  \\
y_2  \\ \vdots \\  y_N
\end{array}\right]}_{y}
\]</span></p>
<p>Tabii aslında verilerin kendisi RBF merkezleriyle aynı şey olduğu
için şunu da söyleyebilirdik,</p>
<p><span class="math display">\[
\underbrace{
\left[\begin{array}{rrr}
    \exp(-\gamma \|x_1-x_1\|^2) &amp; \cdots &amp; \exp(-\gamma
\|x_1-x_N\|^2)\\
    \exp(-\gamma \|x_2-x_1\|^2) &amp; \cdots &amp; \exp(-\gamma
\|x_2-x_N\|^2)\\
    \vdots &amp; \ddots &amp; \vdots \\
    \exp(-\gamma \|x_N-x_1\|^2) &amp; \cdots &amp; \exp(-\gamma
\|x_N-x_N\|^2)
\end{array}\right]
}_{\Phi}
\underbrace{
\left[\begin{array}{r}
w_1  \\ w_2  \\ \vdots \\  w_N
\end{array}\right]}_{w}
=
\underbrace{
\left[\begin{array}{rrr} y_1  \\
y_2  \\ \vdots \\  y_N
\end{array}\right]}_{y}
\]</span></p>
<p>Bu durumda <span class="math inline">\(w = \Phi^{-1}y\)</span> bize
<span class="math inline">\(w\)</span> ağırlıklarını, yani nihai çözümü
verecektir.</p>
<p>Bir örnek üzerinde görelim,</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpl_toolkits.mplot3d <span class="im">import</span> Axes3D</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> cm</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy.linalg <span class="im">as</span> lin</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.spatial.distance <span class="im">import</span> cdist</span></code></pre></div>
<p>Şimdi direk bilinen iki RBF kullanalım, böylece her şeyin nasıl
biraraya geldiği ileride daha iyi anlaşılır. Bizim tanımladığımız
ağırlıklar, ve iki RBF ile şu şekilde bir grafik oluşturabilirdik,</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>gamma <span class="op">=</span> <span class="fl">2.0</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">36</span>,<span class="dv">37</span>,D)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.linspace(<span class="dv">32</span>,<span class="dv">33</span>,D)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>xx,yy <span class="op">=</span> np.meshgrid(x,y)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>xm <span class="op">=</span> np.array([[<span class="fl">36.06122449</span>],</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>               [<span class="fl">36.71428571</span>]])</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>ym <span class="op">=</span> np.array([[<span class="fl">32.67346939</span>],</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>               [<span class="fl">32.32653061</span>]])</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>           </span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.hstack((xm,ym))</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>Phi <span class="op">=</span> np.exp(<span class="op">-</span>gamma<span class="op">*</span>cdist(X,X,metric<span class="op">=</span><span class="st">&#39;euclid&#39;</span>))</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> np.array([[<span class="fl">0.5</span>],[<span class="fl">0.5</span>]])</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>xxx <span class="op">=</span> xx.reshape(D<span class="op">*</span>D)</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>yyy <span class="op">=</span> yy.reshape(D<span class="op">*</span>D)</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.vstack((xxx,yyy))</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> cdist(X,a.T)</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> np.exp(<span class="op">-</span>gamma <span class="op">*</span> d)</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>dd <span class="op">=</span> np.dot(w.T,d)</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>znew <span class="op">=</span> dd.reshape(D,D)</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>surf <span class="op">=</span> ax.plot_surface(xx, yy, znew, cmap<span class="op">=</span>cm.coolwarm,linewidth<span class="op">=</span><span class="dv">0</span>, antialiased<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;linear_app88rbf_04.png&#39;</span>)</span></code></pre></div>
<p><img src="linear_app88rbf_04.png" /></p>
<p>Bu kod üzerinde oynayarak farklı <span
class="math inline">\(\gamma\)</span>, ağırlıklar <span
class="math inline">\(w\)</span> değerlerinin grafikte değişime yol
açtığı görülebilir.</p>
<p>Burada RBF ile aslında analitik bir fonksiyon yaratmış olduk. Bir kez
ağırlıklarını aldıktan sonra (RBF merkezlerini zaten biliyoruz) herhangi
bir <span class="math inline">\(x,y\)</span> değeri için o noktadaki
birleşik RBF sonucunu hesaplatabiliriz, mesela üstteki fonksiyon
için</p>
<p><span class="math display">\[
x_{m1} = [36.06, 32.67],
x_{m2} = [36.71, 32.32],
x_{test} = [36.16, 32.77]
\]</span></p>
<p><span class="math display">\[
y = 0.5 \exp (-\gamma || x_{test} - x_{m1} ||^2) + 0.5 \exp (-\gamma ||
x_{test} - x_{m2} ||^2 )
\]</span></p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>x_test <span class="op">=</span> [<span class="fl">36.16</span>, <span class="fl">32.77</span>]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>w1 <span class="op">=</span> <span class="fl">0.5</span><span class="op">;</span> w2 <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>d1 <span class="op">=</span> (x_test[<span class="dv">0</span>]<span class="op">-</span>xm[<span class="dv">0</span>])<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> (x_test[<span class="dv">1</span>]<span class="op">-</span>ym[<span class="dv">0</span>])<span class="op">**</span><span class="dv">2</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>d2 <span class="op">=</span> (x_test[<span class="dv">0</span>]<span class="op">-</span>xm[<span class="dv">1</span>])<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> (x_test[<span class="dv">1</span>]<span class="op">-</span>ym[<span class="dv">1</span>])<span class="op">**</span><span class="dv">2</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>y_new <span class="op">=</span> w1<span class="op">*</span>np.exp(<span class="op">-</span>gamma <span class="op">*</span> d1) <span class="op">+</span> w2<span class="op">*</span>np.exp(<span class="op">-</span>gamma <span class="op">*</span> d2) </span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (y_new)</span></code></pre></div>
<pre><code>[0.6637959]</code></pre>
<p>Gerçek dünya şartlarına yaklaşırsak; bu tür durumlarda çok daha fazla
baz fonksiyon, örneklem kullanılır, altta <code>func</code> fonksiyonu
örneklem üretmek için kullanılacak, normal şartlarda bu fonksiyonu
bilmiyoruz, sadece ondan gelen örneklem verilerini biliyoruz. Bir örnek
amaçlı, belli bir şekli zorlamak için bunu yaptık.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">0</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> func(x, y):</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    s1 <span class="op">=</span> <span class="fl">0.2</span><span class="op">;</span> x1 <span class="op">=</span> <span class="fl">36.5</span><span class="op">;</span> y1 <span class="op">=</span> <span class="fl">32.5</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    s2 <span class="op">=</span> <span class="fl">0.4</span><span class="op">;</span> x2 <span class="op">=</span> <span class="fl">36.1</span><span class="op">;</span> y2 <span class="op">=</span> <span class="fl">32.8</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    g1 <span class="op">=</span> np.exp( <span class="op">-</span><span class="dv">4</span> <span class="op">*</span>np.log(<span class="dv">2</span>) <span class="op">*</span> ((x<span class="op">-</span>x1)<span class="op">**</span><span class="dv">2</span><span class="op">+</span>(y<span class="op">-</span>y1)<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> s1<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    g2 <span class="op">=</span> np.exp( <span class="op">-</span><span class="dv">2</span> <span class="op">*</span>np.log(<span class="dv">2</span>) <span class="op">*</span> ((x<span class="op">-</span>x2)<span class="op">**</span><span class="dv">2</span><span class="op">+</span>(y<span class="op">-</span>y2)<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> s2<span class="op">**</span><span class="dv">2</span>)    </span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> g1 <span class="op">+</span> g2 </span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>gamma <span class="op">=</span> <span class="fl">2.0</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">36</span>,<span class="dv">37</span>,D)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.linspace(<span class="dv">32</span>,<span class="dv">33</span>,D)</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>xx,yy <span class="op">=</span> np.meshgrid(x,y)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>zz <span class="op">=</span> func(xx,yy)</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>surf <span class="op">=</span> ax.plot_surface(xx, yy, zz, cmap<span class="op">=</span>cm.coolwarm,linewidth<span class="op">=</span><span class="dv">0</span>, antialiased<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;linear_app88rbf_01.png&#39;</span>)</span></code></pre></div>
<p><img src="linear_app88rbf_01.png" /></p>
<p>İki tane tepe var. Şimdi bu fonksiyondan rasgele örneklem alalım, ve
<span class="math inline">\(\Phi\)</span> üzerinden RBF ağırlıklarını
hesaplayalım,</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>xxx <span class="op">=</span> xx.reshape(D<span class="op">*</span>D)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>yyy <span class="op">=</span> yy.reshape(D<span class="op">*</span>D)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>zzz <span class="op">=</span> zz.reshape(D<span class="op">*</span>D)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>idx <span class="op">=</span> np.random.choice(<span class="bu">range</span>(D<span class="op">*</span>D),S)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>xr <span class="op">=</span> xxx[idx].reshape(S,<span class="dv">1</span>)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>yr <span class="op">=</span> yyy[idx].reshape(S,<span class="dv">1</span>)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>zr <span class="op">=</span> zzz[idx].reshape(S,<span class="dv">1</span>)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.hstack((xr,yr))</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>Phi <span class="op">=</span> np.exp(<span class="op">-</span>gamma<span class="op">*</span>cdist(X,X,metric<span class="op">=</span><span class="st">&#39;euclid&#39;</span>))</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> np.dot(lin.pinv(Phi),zr)</span></code></pre></div>
<p>Ağırlıklarla fonksiyonu tekrar yaratmaya uğraşalım,</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.vstack((xxx,yyy))</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> cdist(X,a.T)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> np.exp(<span class="op">-</span>gamma <span class="op">*</span> d)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>dd <span class="op">=</span> np.dot(w.T,d)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>znew <span class="op">=</span> dd.reshape(D,D)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>surf <span class="op">=</span> ax.plot_surface(xx, yy, znew, cmap<span class="op">=</span>cm.coolwarm,linewidth<span class="op">=</span><span class="dv">0</span>, antialiased<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;linear_app88rbf_02.png&#39;</span>)</span></code></pre></div>
<p><img src="linear_app88rbf_02.png" /></p>
<p>Pek optimizasyon yapmadık, ama orijinale benzidiği söylenebilir.</p>
<p>Not: <code>cdist</code> bir veri matrisindeki her satır ile her diğer
satır arasında (tüm kombinasyonlar) mesafe hesabı yapar.</p>
<p>Yeni tek bir veri noktası için</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>xnew <span class="op">=</span> np.array([[<span class="fl">36.5</span>,<span class="fl">32.5</span>]])</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (np.multiply(w.T,np.exp(<span class="op">-</span>gamma<span class="op">*</span>lin.norm(X<span class="op">-</span>xnew,axis<span class="op">=</span><span class="dv">1</span>))).<span class="bu">sum</span>())</span></code></pre></div>
<pre><code>0.6423871447150892</code></pre>
<p>Bu yaklaşımı tüm dünyanın yeryüzü dağ, tepe veri tabanını oluşturmak
için kullanabiliriz. 1 milyon veri yerine onun yüzden 3’u üzerinden RBF
işlettikten sonra <span class="math inline">\(x,y,w\)</span> değerlerini
tutarız, gerisini atarız. Bu üç değer geniş bir bölgeyi pürüzsüz
fonksiyonlarla yaklaşık temsil etmenin en iyi yolu. Veri tabanı sadece
bu değerleri taşıyacak.</p>
<p>Bizim bu konuya girmemizin sebebi Google Elevation API ile aldığımız
yükseklik verilerini verimli şekilde kullanma ihtiyacı idi.</p>
<p>Simdi <code>scipy</code> ile ayni isleri yapalim,</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">0</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="dv">200</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">36</span>,<span class="dv">37</span>,D)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.linspace(<span class="dv">32</span>,<span class="dv">33</span>,D)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>xx,yy <span class="op">=</span> np.meshgrid(x,y)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>znew <span class="op">=</span> func(xx,yy)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>xx <span class="op">=</span> xx.reshape(D<span class="op">*</span>D)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>yy <span class="op">=</span> yy.reshape(D<span class="op">*</span>D)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>znew <span class="op">=</span> znew.reshape(D<span class="op">*</span>D)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.interpolate <span class="im">import</span> Rbf</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>rbfi <span class="op">=</span> Rbf(xx,yy,znew,function<span class="op">=</span><span class="st">&#39;gaussian&#39;</span>)</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>znew <span class="op">=</span> rbfi(xx,yy)</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>xx <span class="op">=</span> xx.reshape(D,D)</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>yy <span class="op">=</span> yy.reshape(D,D)</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>znew <span class="op">=</span> znew.reshape(D,D)</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>surf <span class="op">=</span> ax.plot_surface(xx, yy, znew, cmap<span class="op">=</span>cm.coolwarm,linewidth<span class="op">=</span><span class="dv">0</span>, antialiased<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;linear_app88rbf_05.png&#39;</span>)</span></code></pre></div>
<p><img src="linear_app88rbf_05.png" /></p>
<p>Not: <code>scipy</code> ile bize döndürülen ve ara değerleme için
direk çağırılabilen objeyi gerekli her türlü bilgiyi içinde taşıyor.
Yani modeli çıkartıp veriyi atıp, sadece bu objeyi (mesela
<code>pickle</code> ile) diskte saklayabiliriz, bu tek başına
yeterlidir.</p>
<p>Modelleme <code>scipy</code> İle, Tekrar Yaratmak Elle Yazılan
Fonksiyon İle</p>
<p>Bir diğer yaklaşım veriyi örneklemek, <code>scipy</code> ile RBF’leri
yaratmak, ama <code>sciy</code> parametrelerini kullanarak modeli
kendimizin tekrar yaratması. Bunun değişik sebepleri olabilir, belki
veriyi modelleyen bir yükseklik fonksiyonu üzerinde otomatik türev almak
istiyoruz, ama <code>scipy</code> içindeki versiyon ile bunu
yapamıyoruz. Ya da motor kapağı altında nelerin olup bittiğini daha iyi
anlamak istiyoruz.</p>
<p>Her neyse, yine iki tepeli ortamı yaratıyoruz,</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpl_toolkits.mplot3d <span class="im">import</span> Axes3D</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> cm</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">0</span>)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> func(x, y):</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    s1 <span class="op">=</span> <span class="fl">0.2</span><span class="op">;</span> x1 <span class="op">=</span> <span class="fl">36.5</span><span class="op">;</span> y1 <span class="op">=</span> <span class="fl">32.5</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    s2 <span class="op">=</span> <span class="fl">0.4</span><span class="op">;</span> x2 <span class="op">=</span> <span class="fl">36.1</span><span class="op">;</span> y2 <span class="op">=</span> <span class="fl">32.8</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    g1 <span class="op">=</span> np.exp( <span class="op">-</span><span class="dv">4</span> <span class="op">*</span>np.log(<span class="dv">2</span>) <span class="op">*</span> ((x<span class="op">-</span>x1)<span class="op">**</span><span class="dv">2</span><span class="op">+</span>(y<span class="op">-</span>y1)<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> s1<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    g2 <span class="op">=</span> np.exp( <span class="op">-</span><span class="dv">2</span> <span class="op">*</span>np.log(<span class="dv">2</span>) <span class="op">*</span> ((x<span class="op">-</span>x2)<span class="op">**</span><span class="dv">2</span><span class="op">+</span>(y<span class="op">-</span>y2)<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> s2<span class="op">**</span><span class="dv">2</span>)    </span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> g1 <span class="op">+</span> g2 </span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">36</span>,<span class="dv">37</span>,D)</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.linspace(<span class="dv">32</span>,<span class="dv">33</span>,D)</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>xx,yy <span class="op">=</span> np.meshgrid(x,y)</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>zz <span class="op">=</span> func(xx,yy)</span></code></pre></div>
<p>Ve grafiklemeyi yapıyoruz,</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>xx <span class="op">=</span> xx.reshape(D,D)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>yy <span class="op">=</span> yy.reshape(D,D)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>zz <span class="op">=</span> func(xx,yy)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>ax.view_init(elev<span class="op">=</span><span class="dv">29</span>, azim<span class="op">=</span><span class="dv">29</span>)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>surf <span class="op">=</span> ax.plot_surface(xx, yy, zz, cmap<span class="op">=</span>cm.coolwarm,linewidth<span class="op">=</span><span class="dv">0</span>, antialiased<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;linear_app88rbf_03.png&#39;</span>)</span></code></pre></div>
<p>Şimdi örneklem alıp RBF yaratalım,</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.interpolate <span class="im">import</span> Rbf</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">0</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>idx <span class="op">=</span> np.random.choice(<span class="bu">range</span>(D<span class="op">*</span>D),S)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>xr <span class="op">=</span> xx.reshape(D<span class="op">*</span>D)[idx].reshape(S,<span class="dv">1</span>)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>yr <span class="op">=</span> yy.reshape(D<span class="op">*</span>D)[idx].reshape(S,<span class="dv">1</span>)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>zr <span class="op">=</span> zz.reshape(D<span class="op">*</span>D)[idx].reshape(S,<span class="dv">1</span>)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>rbfi <span class="op">=</span> Rbf(xr,yr,zr,function<span class="op">=</span><span class="st">&#39;gaussian&#39;</span>,epsilon<span class="op">=</span><span class="fl">0.15</span>)</span></code></pre></div>
<p>Modelleme Gaussian RBF’ler üzerinden yapıldı. Üstteki
<code>rbfi</code> değişkenini elde edince artık herhangi bir <span
class="math inline">\(x\)</span>,<span class="math inline">\(y\)</span>
kordinatı üzerinde <code>rbfi(x,y)</code> ile ara değerleme yaparak
modelin hesapladığı bir <span class="math inline">\(z\)</span> değeri
elde edebiliriz.</p>
<p>Peki arka planda bu hesaplama neye benziyor? Dokümantasyona
bakınca</p>
<p><code>'gaussian': exp(-(r/self.epsilon)**2)</code></p>
<p>ifadesini görüyoruz, burada <code>r</code> yeni nokta ile bir RBF baz
fonksiyonu arasındaki mesafe. Bir test noktası ile üstteki RBF’leri (D*D
tane) arasındaki mesafe şöyle hesaplanabilir,</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dist_matrix(X, Y):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    sx <span class="op">=</span> np.<span class="bu">sum</span>(X<span class="op">**</span><span class="dv">2</span>, <span class="dv">1</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    sy <span class="op">=</span> np.<span class="bu">sum</span>(Y<span class="op">**</span><span class="dv">2</span>, <span class="dv">1</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    D2 <span class="op">=</span>  sx[:, np.newaxis] <span class="op">-</span> <span class="fl">2.0</span><span class="op">*</span>X.dot(Y.T) <span class="op">+</span> sy[np.newaxis, :] </span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    D2[D2 <span class="op">&lt;</span> <span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    D <span class="op">=</span> np.sqrt(D2)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> D</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>test_1 <span class="op">=</span> np.array([[<span class="fl">36.0</span>,<span class="fl">32.0</span>]])</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>test_1_dist <span class="op">=</span> dist_matrix(test_1, rbfi.xi.T)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (test_1_dist.shape)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (test_1_dist[<span class="dv">0</span>][:<span class="dv">10</span>])</span></code></pre></div>
<pre><code>(1, 50)
[0.4229176  1.08927112 0.72276945 0.76827462 0.96299239 1.21064725
 0.85578867 0.94970984 0.80965755 0.76794254]</code></pre>
<p>O mesafeyi alıp eksi karesini hesaplayıp <code>exp</code>’ye vermek
lazım. Tüm RBF’leri de bir şekilde dahil etmek lazım tabii, o da
hesaplanan ağırlıklar ile üstteki sonucu çarpıp hepsini toplamakla olur.
Gerekli parametreler <code>rbfi</code> içinde,</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (rbfi.epsilon)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (rbfi.smooth)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (rbfi.xi.shape)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (rbfi.nodes.shape)</span></code></pre></div>
<pre><code>0.15
0.0
(2, 50)
(50,)</code></pre>
<p>Ağırlıklar <code>nodes</code>, RBF merkezleri <code>xi</code>,
<code>epsilon</code> genel bir pürüz parametresi. İki test noktası
üzerinde görelim, dikkat burada {} RBF’ler gözönüne alınacak,</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>nodes <span class="op">=</span> rbfi.nodes.reshape(<span class="dv">1</span>,<span class="bu">len</span>(rbfi.nodes))</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gaussian(r,eps): <span class="cf">return</span> np.exp(<span class="op">-</span>(r<span class="op">/</span>eps)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f_interp(newp, rbfi):</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    nodes <span class="op">=</span> rbfi.nodes.reshape(<span class="dv">1</span>,<span class="bu">len</span>(rbfi.nodes))</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    newp_dist <span class="op">=</span> dist_matrix(newp, rbfi.xi.T)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.dot(gaussian(newp_dist, rbfi.epsilon), nodes.T)</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>test_2 <span class="op">=</span> np.array([[<span class="fl">36.0</span>,<span class="fl">32.0</span>],[<span class="fl">36.1</span>,<span class="fl">31.9</span>]])</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (f_interp(test_2,rbfi))</span></code></pre></div>
<pre><code>[[-0.00387063]
 [-0.00337065]]</code></pre>
<p>Şimdi iki tepeli fonksiyonu RBF’ler üzerinde yaratalım,</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>test_3 <span class="op">=</span> np.column_stack((xx.ravel(), yy.ravel()))</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>znewnew <span class="op">=</span> f_interp(test_3,rbfi).reshape(xx.shape)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>ax.view_init(elev<span class="op">=</span><span class="dv">29</span>, azim<span class="op">=</span><span class="dv">29</span>)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>surf <span class="op">=</span> ax.plot_surface(xx, yy, znewnew, cmap<span class="op">=</span>cm.coolwarm,linewidth<span class="op">=</span><span class="dv">0</span>, antialiased<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;linear_app88rbf_06.png&#39;</span>)</span></code></pre></div>
<p><img src="linear_app88rbf_06.png" /></p>
<p>RBF Türev ve Hessian Matrisi</p>
<p>Ana formülü hatırlayalım,</p>
<p><span class="math display">\[
f(x) = \sum_{i=1}^{m} \beta_i \phi(|| x-x_i||)
\]</span></p>
<p>ki <span class="math inline">\(\beta_1,...,\beta_m\)</span> öyle
seçiliyor ki</p>
<p><span class="math display">\[
f(x_i) = F(x_i), \quad i=1,2,...,m
\]</span></p>
<p>eşitliği tatmin edilsin. Burada <span
class="math inline">\(F\)</span> modellenen ana fonksiyondur, ve <span
class="math inline">\(\phi\)</span> bizim seçtiğimiz baz fonksiyondur.
RBF’in türevi nedir? Analitik olarak hesaplayabiliriz,</p>
<p><span class="math display">\[
\frac{\partial f(x)}{\partial x} = \beta^T \frac{\partial g}{\partial x}
=
\sum_{i=1}^{m} \beta_i \phi&#39;(r_i) \frac{\partial r_i}{\partial x}
\]</span></p>
<p>öyle ki <span class="math inline">\(\phi&#39;(r) = \mathrm{d} \phi /
\mathrm{d} r\)</span>, ve</p>
<p><span class="math display">\[
r_i(x) = ||x-x_i|| = \sqrt{(x-x_i)^T(x-x_i)}
\qquad (1)
\]</span></p>
<p>Ayrıca</p>
<p><span class="math display">\[
\frac{\partial r_i}{\partial x} = \frac{1}{r_i(x)} (x-x_i)^T
\]</span></p>
<p>Hepsi bir arada [4]</p>
<p><span class="math display">\[
\frac{\partial f(x)}{\partial x} = \sum_{i=1}^{m}
\frac{\beta_i\phi&#39;(r_i)}{r_i(x)}
(x-x_i)^T
\]</span></p>
<p>Hessian’ı alttaki gibi hesaplayabiliriz [3]. [4]’teki formül</p>
<p><span class="math display">\[
\frac{\partial^2 f(x)}{\partial x^2} =
\sum_{i=1}^{m} \bigg\{
\phi&#39;(r_i) I + \bigg[\phi&#39;&#39;(r_i) -
\frac{\phi&#39;(r_i)}{r_i(x)} \bigg]
(x-x_i) \frac{\partial r_i}{\partial x}
\bigg\}
\qquad (2)
\]</span></p>
<p>Türetmek için, radyal vektörler <span class="math inline">\(\,w_k =
(x - x_k)\in{\mathbb R}^n\,\)</span> tanımlanır, dikkat bunların <span
class="math inline">\(\,dw_k = dx\)</span> türevleri aynı. Şimdi
vektörleri tek bir matriste birleştirelim,</p>
<p><span class="math display">\[
\Omega = \big[\,w_1\;w_2\;\ldots\;w_m\big] \in {\mathbb R}^{n\times m}
\]</span></p>
<p><span class="math display">\[
d\Omega = \big[\,dx\;dx\;\ldots\;dx\big] =  dx\,{\tt\large 1}^T
\]</span></p>
<p>Dikkat <span class="math inline">\(\,r_j=\|w_j\|\,\)</span>
öğelerinin kendisi <span class="math inline">\(\,r\in{\mathbb
R}^m\)</span> vektörünün aynı zamanda ögesi. Kartezyen baz vektörleri
<span class="math inline">\(\,e_k\in{\mathbb R}^m\)</span> üsttekini</p>
<p><span class="math display">\[w_k=\Omega\,e_k,\quad
dx=d\Omega\,e_k,\quad r_j=e_j^Tr\]</span></p>
<p>şeklinde yazmamıza izin veriyor. RBF’i öğesel bazda uygulayarak
indisli toplam notasyonundan kurtulmuş oluyoruz. Şimdi türevleri,
diferansiyelleri</p>
<p><span class="math display">\[
g=\phi(r),\quad g&#39;=\phi&#39;(r),\quad
g&#39;&#39;=\phi&#39;&#39;(r)\; \in{\mathbb R}^m
\]</span></p>
<p><span class="math display">\[
dg=g&#39;\odot dr,\quad dg&#39;=g&#39;&#39;\odot dr \; \in{\mathbb R}^m
\]</span></p>
<p>ile yazabiliriz, ki <span class="math inline">\(\odot\)</span> öğesel
bazlı Hadamard çarpımıdır.</p>
<p>Ayrıca vektörler köşegen matrisler arasında geçiş yapabilmek
faydalıdır, ki bu matrisleri büyük harfle belirteceğiz, mesela</p>
<p><span class="math display">\[
R={\rm Diag}(r),\quad G=
{\rm Diag}(g),\quad G&#39;&#39;={\rm Diag}(g&#39;&#39;)\;\in{\mathbb
R}^{m\times m}
\]</span></p>
<p><span class="math display">\[
r = {\rm diag}(R),\quad g = {\rm diag}(G),\quad g&#39;&#39;=\ldots
\]</span></p>
<p><span class="math display">\[
r  = R{\tt\large 1},\quad g = G{\tt\large 1},\quad g&#39;&#39;=\ldots
\]</span></p>
<p><span class="math display">\[
dg = G&#39;dr,\quad dg&#39; = G&#39;&#39;dr
\]</span></p>
<p>ayrıca iş kolaylaştırması için alttaki tanım faydalı,</p>
<p><span class="math display">\[
P=R^{-1}\quad\implies PR=I,\;\;p\odot r = {\tt\large 1}
\]</span></p>
<p>Şimdi ana ilişkiyi yazalım ve türevini alalım,</p>
<p><span class="math display">\[
r\odot r = {\rm diag}(\Omega^T\Omega)
\]</span></p>
<p><span class="math display">\[
2r\odot dr = {\rm diag}(\Omega^Td\Omega+d\Omega^T\Omega)
\;=\; 2{\,\rm {diag}}(\Omega^Td\Omega)
\]</span></p>
<p><span class="math display">\[
R\,dr = {\rm diag}(\Omega^Tdx\,{\tt\large 1}^T) \;=\; \Omega^Tdx
\]</span></p>
<p><span class="math display">\[
dr = P\Omega^Tdx
\]</span></p>
<p><span class="math display">\[
\frac{\partial r}{\partial x} = P\Omega^T
\]</span></p>
<p><span class="math inline">\(i^{th}\)</span> bileşeni kontrol edersek
(1) formülünü ortaya çıkartabileceğimizi görüyoruz, demek ki doğru
yoldayız,</p>
<p><span class="math display">\[
e_i^T\bigg(\frac{\partial r}{\partial x}\bigg) = e_i^TP\Omega^T
\]</span></p>
<p><span class="math display">\[
\frac{\partial r_i}{\partial x}
\;=\; \frac{1}{r_i}\;e_i^T\Omega^T
\;=\; \frac{w_i^T}{\|w_i\|}
\]</span></p>
<p>Model fonksiyonu (<span class="math inline">\(\beta\)</span> <span
class="math inline">\(b\)</span> kullandık daha kısa)</p>
<p><span class="math display">\[f = b^Tg = b:g\]</span></p>
<p>İki nokta üst üste iz (trace) için Frobenius çarpım notasyonudur,
mesela <span class="math inline">\(\;A:B = {\rm Tr}(A^TB)\)</span>.</p>
<p>Şimdi Hessian</p>
<p><span class="math display">\[
dJ = d\Omega\,PG&#39;B{\tt\large 1} + \Omega PdG&#39;B{\tt\large 1} +
\Omega\,dP\,G&#39;B{\tt\large 1}
\]</span></p>
<p><span class="math display">\[
= dx\,{\tt\large 1}^TPG&#39;B{\tt\large 1} + \Omega PB\,dg&#39; - \Omega
(P\,dR\,P)G&#39;B{\tt\large 1}
\]</span></p>
<p><span class="math display">\[
= dx\,({\tt\large 1}^TPG&#39;B{\tt\large 1}) +\Omega PB\,dg&#39; -\Omega
PG&#39;PB\,dr
\]</span></p>
<p><span class="math display">\[
= (G&#39;:PB)\,dx +\Omega PBG&#39;&#39;\,dr -\Omega PG&#39;PB\,dr
\]</span></p>
<p><span class="math display">\[
= \Big((G&#39;:PB)I +\Omega PB(G&#39;&#39; - PG&#39;)P\Omega^T\Big)\,dx
\]</span></p>
<p><span class="math display">\[
H = \frac{\partial J}{\partial x}
= (G&#39;:PB)I + \Omega PB(G&#39;&#39;-PG&#39;)P\Omega^T
\]</span></p>
<p><span class="math display">\[
= \Big((p\odot b):g&#39;\Big)\,I \;+\;
\bigg(\frac{\partial r}{\partial
x}\bigg)^T\Big(BG&#39;&#39;-BPG&#39;\Big)\bigg(\frac{\partial
r}{\partial x}\bigg)
\]</span></p>
<p>Pek öyle durmasa da bu formül (2) formülü ile aynı.</p>
<p>Akılda tutalım <span class="math inline">\((R,G,B)\)</span>
matrisleri köşegen ve birbirleri ile sırabağımsız ilişkileri var, ama
<span class="math inline">\(\,\Omega\,\)</span> matrisi tam matris ve
diğer matrislerle sırabağımsız ilişkiye giremiyor.</p>
<p>Autograd ile Gradyan ve Hessian</p>
<p>Otomatik türev üzerinden de üstteki hesapları yapabiliriz. Daha
önceki kodlarda iki dağlı veriden örneklem alıp RBF yaratmıştık, bu obje
<code>rbfi</code> içinde, oradan devam edersek,</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> autograd.numpy <span class="im">as</span> anp</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> autograd</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dist_matrix(X, Y):</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> X.reshape(<span class="dv">1</span>, X.shape[<span class="dv">0</span>])</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    sx <span class="op">=</span> anp.<span class="bu">sum</span>(X<span class="op">**</span><span class="dv">2</span>, <span class="dv">1</span>)</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    sy <span class="op">=</span> anp.<span class="bu">sum</span>(Y<span class="op">**</span><span class="dv">2</span>, <span class="dv">1</span>)</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    D2 <span class="op">=</span>  sx[:, anp.newaxis] <span class="op">-</span> <span class="fl">2.0</span><span class="op">*</span>anp.dot(X,Y.T) <span class="op">+</span> sy[anp.newaxis, :] </span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    D <span class="op">=</span> anp.sqrt(D2)</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> D</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>nodes <span class="op">=</span> rbfi.nodes.reshape(<span class="dv">1</span>,<span class="bu">len</span>(rbfi.nodes))</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gaussian(r,eps): <span class="cf">return</span> anp.exp(<span class="op">-</span>(r<span class="op">/</span>eps)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f_interp(newp):</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>    nodes <span class="op">=</span> rbfi.nodes.reshape(<span class="dv">1</span>,<span class="bu">len</span>(rbfi.nodes))    </span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>    newp_dist <span class="op">=</span> dist_matrix(newp, rbfi.xi.T)</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> anp.dot(gaussian(newp_dist, rbfi.epsilon), nodes.T)</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>test_1 <span class="op">=</span> anp.array([<span class="fl">36.0</span>,<span class="fl">32.0</span>])</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>test_1_dist <span class="op">=</span> dist_matrix(test_1, rbfi.xi.T)</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;f&#39;</span>,f_interp(test_1))</span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>grbf <span class="op">=</span> autograd.grad(f_interp)</span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>hrbf <span class="op">=</span> autograd.hessian(f_interp)</span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;gradyan&#39;</span>,grbf(test_1))</span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;hessian&#39;</span>,hrbf(test_1))</span></code></pre></div>
<pre><code>f [[-0.00387063]]
gradyan [0.02331737 0.08191414]
hessian [[[[0.6466522  0.74921925]
   [0.74921925 1.92847522]]]]</code></pre>
<p>Rasgele Noktalar Seçmek</p>
<p>Fonksiyonu RBF ile temsil etmek için gereken Rasgele noktaları
Hammersley noktaları adı verilen bir rasgele sayı üretme tekniği ile
seçmek mümkün, bu şekilde son derece çetrefil fonksiyonlar bile az
sayıda örneklem noktaları üzerinden temsil edilebiliyor [5]. Mesela
altta 10 tane bu tür noktayı 2 boyut için seçtik. Sayılar 0 ile 1
arasında ama gereken aralığa ölçeklenerek, toplanarak taşınabilir.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> hammer</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (hammer.hammersley([<span class="dv">2</span>,<span class="dv">3</span>],<span class="dv">10</span>))</span></code></pre></div>
<pre><code>[[0.     0.    ]
 [0.1    0.    ]
 [0.2    0.5   ]
 [0.3    0.25  ]
 [0.4    0.75  ]
 [0.5    0.125 ]
 [0.6    0.625 ]
 [0.7    0.375 ]
 [0.8    0.875 ]
 [0.9    0.0625]]</code></pre>
<p>Mesela</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpl_toolkits.mplot3d <span class="im">import</span> Axes3D</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> peaks(x,y):</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span>  (<span class="dv">3</span><span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>x)<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> np.exp(<span class="op">-</span>(x<span class="op">**</span><span class="dv">2</span>) <span class="op">-</span> (y<span class="op">+</span><span class="dv">1</span>)<span class="op">**</span><span class="dv">2</span>) </span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>          <span class="op">-</span> <span class="dv">10</span><span class="op">*</span>(x<span class="op">/</span><span class="dv">5</span> <span class="op">-</span> x<span class="op">**</span><span class="dv">3</span> <span class="op">-</span> y<span class="op">**</span><span class="dv">5</span>) <span class="op">*</span> np.exp(<span class="op">-</span>x<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> y<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>          <span class="op">-</span> <span class="dv">1</span><span class="op">/</span><span class="dv">3</span> <span class="op">*</span> np.exp(<span class="op">-</span>(x<span class="op">+</span><span class="dv">1</span>)<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> y<span class="op">**</span><span class="dv">2</span>)) </span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>(z)</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="op">-</span><span class="dv">3</span> <span class="op">+</span> <span class="dv">6</span><span class="op">*</span>hammer.hammersley([<span class="dv">2</span>,<span class="dv">3</span>],n)</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> peaks(x[:,<span class="dv">0</span>],x[:,<span class="dv">1</span>])</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>xx, yy <span class="op">=</span> np.mgrid[<span class="op">-</span><span class="dv">3</span>:<span class="dv">3</span>:<span class="ot">150j</span>,<span class="op">-</span><span class="dv">3</span>:<span class="dv">3</span>:<span class="ot">150j</span>]</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>zz <span class="op">=</span> peaks(xx,yy)</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>fig<span class="op">=</span>plt.figure()</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">111</span>,projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>ax.plot_surface(xx,yy,zz,rstride<span class="op">=</span><span class="dv">1</span>,cstride<span class="op">=</span><span class="dv">1</span>,color<span class="op">=</span><span class="st">&#39;c&#39;</span>,alpha<span class="op">=</span><span class="fl">0.3</span>,linewidth<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>ax.scatter(x[:,<span class="dv">0</span>],x[:,<span class="dv">1</span>],z,color<span class="op">=</span><span class="st">&#39;k&#39;</span>,s<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;linear_app88rbf_07.png&#39;</span>)</span></code></pre></div>
<p><img src="linear_app88rbf_07.png" /></p>
<p>Görüldüğü gibi oldukca çetrefil bir fonksiyon bu,</p>
<p><span class="math display">\[
f(x_1,x_2) = 3 (1 - x_1)^2 e^{-x_1^2-(-x_2^2 + 1)^2} -
10 \bigg( \frac{x_1}{5} - x_1^3-x_2^5 \bigg) e^{-x_1^2 -x_2^2} -
\frac{1}{3} e^{-(x_1 + 1)^2 - x_2^2}
\]</span></p>
<p>ama Hammersley tekniği ile kritik noktalarından örneklem
alınabiliyor. [5]’te bu teknik ile üretilen yeni fonsiyonun gerçeğine
çok yakın olacağını görüyoruz, 20 tane nokta ile!</p>
<p>Kaynaklar</p>
<p>[1] Neto, <em>Radial Basis Functions</em>, <a
href="http://www.di.fc.ul.pt/~jpn/r/rbf/rbf.html">http://www.di.fc.ul.pt/~jpn/r/rbf/rbf.html</a></p>
<p>[2] Pouderoux, <em>Adaptive Hierarchical RBF Interpolation for
Creating Smooth Digital Elevation Models</em> <a
href="https://hal.archives-ouvertes.fr/hal-00308008/document">https://hal.archives-ouvertes.fr/hal-00308008/document</a></p>
<p>[3] Math Stackexchange, <em>The Hessian of a Radial Basis
Function</em>, <a
href="https://math.stackexchange.com/questions/3417706/the-hessian-of-a-radial-basis-function">https://math.stackexchange.com/questions/3417706/the-hessian-of-a-radial-basis-function</a></p>
<p>[4] Mcdonald, <em>Global and local optimization using radial basis
function response surface models</em>, <a
href="https://www.sciencedirect.com/science/article/pii/S0307904X06002009">https://www.sciencedirect.com/science/article/pii/S0307904X06002009</a></p>
<p>[5] Kroese, <em>Data Science and Machine Learning: Mathematical and
Statistical Methods</em></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
