<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Aradeğerleme (Interpolation) - Dairesel Baz Fonksiyonları (Radial Basis Functions -RBF-)</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="aradeğerleme-interpolation---dairesel-baz-fonksiyonları-radial-basis-functions--rbf-">Aradeğerleme (Interpolation) - Dairesel Baz Fonksiyonları (Radial Basis Functions -RBF-)</h1>
<p>Ara değerlemek (interpolation), yani elde olan veriyi kullanıp olmayan hakkında tahmin yapmaya uğraşmak için çok boyutlu ortamda RBF iyi işleyen bir yaklaşım. Belki de zihinde en rahat canlandırılabilecek örnek yeryüzünde dağlara ovalara tekabül eden yükseklik (elevation) verilerini alarak onlara sürekli tepe fonksiyonları &quot;uydurmak'' böylece dağların nerede olduğunu sürekli şekilde saptamak. Temsil etmek istediğimiz (ama bilmediğimiz) fonksiyon <span class="math inline">\(z=g(x,y)\)</span> olarak gösterilebilecek bir fonksiyon, bir düzlemde herhangi bir <span class="math inline">\(x,y\)</span> noktasındaki yükseklik <span class="math inline">\(z\)</span>. Bu fonksiyondan örneklenerek alınmış verilerle onu yaklaşık olarak temsil etmek istiyoruz.</p>
<p>Düz verinin kendisini kullanmak bağlamında düşük çözünürlükte yükseklik verisi ise yaramayabilir, mesela bir örneklem noktası dağın bir eteğinden diğeri öteki yanındaki eteğinden alınmışsa bu dağ yok anlamına gelecektir. Peki o zaman niye yükseklik verisinin geldiği yerden daha yüksek çözünürlüklü veri almıyoruz? Bu hem erişim hem de tutacağı yer bağlamında pahalı olabilir. 1 derecelik enlem / boylam içinde, mesela 36-37 ve 32-33 arası diyelim, 100 metrelik çözünürlük demek 0.001 derece değişimine tekabül eder, ve bu durumda 1 milyon veri noktası alınması gerekecektir. Halbuki yükseklik verisinden yüzde 3 miktarında bile [2] bir rasgele örneklem alırsak, bu noktalara RBF ile tepe fonksiyonları uydurarak matematiksel, sürekli olan bir genel fonksiyon elde ederiz, ve uydurma iyi işlerse artık istediğimiz çözünürlükte yükseklik verisi elde edebiliriz çünkü elimizdeki sürekli fonksiyona istediğimiz her nokta için yükseliğin ne olduğunu artık hesaplattırabiliriz.</p>
<p>Bu örneği 3 boyutta herhangi bir başka veri için de düşünmek mümkün; ama yükseklik verisinde daha rahat, her örneklem noktasına konulan tepeler ve onların birleşimi bize pürüzsüz, sürekli bir engebe şekli verir. RBF baz fonksiyonları <span class="math inline">\(\Phi(x) = f(||x-c||)\)</span> şeklindedir, <span class="math inline">\(f\)</span> tepe, ya da farklı bir fonksiyon olabilir, <span class="math inline">\(||\cdot||\)</span> norm fonksiyonudur, Öklitsel norm olabilir mesela.</p>
<p>Burada <span class="math inline">\(c\)</span> üstüne baz fonksiyon konulan nokta, her örneklem veri noktası yani. RBF eğitimi / uydurma metadolijisine göre herhangi bir veri noktası dışındaki tüm diğer örneklem verileri o veri noktasının oluşumunu etkiler. Bu anormal bir faraziye değil, bir dağın başında, ortasında, tepesinden alınmış örneklemler varsa, mesela en alt ve en tepedeki veri ortadakini etkiler, yani o bağlantıyı, ilişkiyi farzetmek normaldir. Orta nokta zirveyi tanımlayan fonksiyona belli bir ağırlıkla bağlı, en alttakine başka bir şekilde bağlı, vs. Bu ağırlıkların ne olacağını genel çözüm belirleyecektir. Eğer <span class="math inline">\(f\)</span> için Gaussian'ımsı bir tepe fonksiyonu seçersek, yeni gözlemin baz fonksiyonları ile arasındaki ilişki,</p>
<p><span class="math display">\[
h(x) = \sum_{i=1}^N w_n \times exp(-\gamma \|x-m_i\|^2)
\]</span></p>
<p>olarak gösterilebilir, <span class="math inline">\(\gamma\)</span> her noktanın etkisinin ne olduğunu dışarıdan ayarlamak için genel bir sabit, ne kadar küçükse konulan tepe o kadar kenarlara yayılır, daha büyük değerler daha noktasal olur. <span class="math inline">\(N\)</span> tane baz fonksiyonu olacak, <span class="math inline">\(N\)</span> tane <span class="math inline">\(m_i,y_i\)</span>, ya da <span class="math inline">\(x_i,y_i\)</span> verisine bakarak bu fonksiyonları bulacağız.</p>
<p>İki üstteki formüldeki <span class="math inline">\(x-c\)</span> kullanımına dikkat, bu aslında &quot;diğer noktaları'' temsil etmenin akıllıca bir yolu, <span class="math inline">\(c\)</span> üzerinde <span class="math inline">\(x-c\)</span> sıfır değerdedir, bu o noktayı temsil için diğer noktalar üzerindeki bazların devreye girmesi gerektiğini modelde söyler.</p>
<p>Her bazın etkisi <span class="math inline">\(w_n\)</span> ağırlığı üzerinden modele yansıtılır. Bu ağırlıkların ne olduğunu bulmak, nihai genel fonksiyonu bulmuş olmak anlamına gelir. Farklı indislerle tekrar belirtmek gerekirse her veri noktası için şu doğru olmalı,</p>
<p>Bu bize <span class="math inline">\(N\)</span> tane veri noktası için <span class="math inline">\(N\)</span> tane denklem ve <span class="math inline">\(N\)</span> tane bilinmeyen sağlar. Eldeki <span class="math inline">\((x_1,y_1),...,(x_N,y_N)\)</span> verileri ile <span class="math inline">\(w\)</span>'yi bulmamızı sağlayacak regresyonu matris formunda şöyle gösterebiliriz,</p>
<p><span class="math display">\[
\underbrace{
\left[\begin{array}{rrr} 
    \exp(-\gamma \|x_1-m_1\|^2) &amp; \cdots &amp; \exp(-\gamma \|x_1-m_N\|^2)\\ 
    \exp(-\gamma \|x_2-m_1\|^2) &amp; \cdots &amp; \exp(-\gamma \|x_2-m_N\|^2)\\ 
    \vdots &amp; \ddots &amp; \vdots \\ 
    \exp(-\gamma \|x_N-m_1\|^2) &amp; \cdots &amp; \exp(-\gamma \|x_N-m_N\|^2)
\end{array}\right]
}_{\Phi}
\underbrace{
\left[\begin{array}{r}
 w_1  \\ w_2  \\ \vdots \\  w_N
\end{array}\right]}_{w}
=
\underbrace{
\left[\begin{array}{rrr} y_1  \\
 y_2  \\ \vdots \\  y_N
\end{array}\right]}_{y}
\]</span></p>
<p>Tabii aslında verilerin kendisi RBF merkezleriyle aynı şey olduğu için şunu da söyleyebilirdik,</p>
<p><span class="math display">\[
\underbrace{
\left[\begin{array}{rrr} 
    \exp(-\gamma \|x_1-x_1\|^2) &amp; \cdots &amp; \exp(-\gamma \|x_1-x_N\|^2)\\ 
    \exp(-\gamma \|x_2-x_1\|^2) &amp; \cdots &amp; \exp(-\gamma \|x_2-x_N\|^2)\\ 
    \vdots &amp; \ddots &amp; \vdots \\ 
    \exp(-\gamma \|x_N-x_1\|^2) &amp; \cdots &amp; \exp(-\gamma \|x_N-x_N\|^2)
\end{array}\right]
}_{\Phi}
\underbrace{
\left[\begin{array}{r}
 w_1  \\ w_2  \\ \vdots \\  w_N
\end{array}\right]}_{w}
=
\underbrace{
\left[\begin{array}{rrr} y_1  \\
 y_2  \\ \vdots \\  y_N
\end{array}\right]}_{y}
\]</span></p>
<p>Bu durumda <span class="math inline">\(w = \Phi^{-1}y\)</span> bize <span class="math inline">\(w\)</span> ağırlıklarını, yani nihai çözümü verecektir.</p>
<p>Bir örnek üzerinde görelim,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> mpl_toolkits.mplot3d <span class="im">import</span> Axes3D
<span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt
<span class="im">from</span> matplotlib <span class="im">import</span> cm
<span class="im">import</span> numpy <span class="im">as</span> np
<span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt
<span class="im">import</span> numpy.linalg <span class="im">as</span> lin
<span class="im">from</span> scipy.spatial.distance <span class="im">import</span> cdist</code></pre></div>
<p>Şimdi direk bilinen iki RBF kullanalım, böylece her şeyin nasıl biraraya geldiği ileride daha iyi anlaşılır. Bizim tanımladığımız ağırlıklar, ve iki RBF ile şu şekilde bir grafik oluşturabilirdik,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">D <span class="op">=</span> <span class="dv">50</span>
gamma <span class="op">=</span> <span class="fl">2.0</span>

x <span class="op">=</span> np.linspace(<span class="dv">36</span>,<span class="dv">37</span>,D)
y <span class="op">=</span> np.linspace(<span class="dv">32</span>,<span class="dv">33</span>,D)

xx,yy <span class="op">=</span> np.meshgrid(x,y)

xm <span class="op">=</span> np.array([[<span class="fl">36.06122449</span>],
               [<span class="fl">36.71428571</span>]])
ym <span class="op">=</span> np.array([[<span class="fl">32.67346939</span>],
               [<span class="fl">32.32653061</span>]])
           
X <span class="op">=</span> np.hstack((xm,ym))

Phi <span class="op">=</span> np.exp(<span class="op">-</span>gamma<span class="op">*</span>cdist(X,X,metric<span class="op">=</span><span class="st">&#39;euclid&#39;</span>))

w <span class="op">=</span> np.array([[<span class="fl">0.5</span>],[<span class="fl">0.5</span>]])

xxx <span class="op">=</span> xx.reshape(D<span class="op">*</span>D)
yyy <span class="op">=</span> yy.reshape(D<span class="op">*</span>D)

a <span class="op">=</span> np.vstack((xxx,yyy))
d <span class="op">=</span> cdist(X,a.T)
d <span class="op">=</span> np.exp(<span class="op">-</span>gamma <span class="op">*</span> d)
dd <span class="op">=</span> np.dot(w.T,d)
znew <span class="op">=</span> dd.reshape(D,D)

fig <span class="op">=</span> plt.figure()
ax <span class="op">=</span> fig.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)
surf <span class="op">=</span> ax.plot_surface(xx, yy, znew, cmap<span class="op">=</span>cm.coolwarm,linewidth<span class="op">=</span><span class="dv">0</span>, antialiased<span class="op">=</span><span class="va">False</span>)
plt.savefig(<span class="st">&#39;linear_app88rbf_04.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="linear_app88rbf_04.png" />

</div>
<p>Bu kod üzerinde oynayarak farklı <span class="math inline">\(\gamma\)</span>, ağırlıklar <span class="math inline">\(w\)</span> değerlerinin grafikte değişime yol açtığı görülebilir.</p>
<p>Burada RBF ile aslında analitik bir fonksiyon yaratmış olduk. Bir kez ağırlıklarını aldıktan sonra (RBF merkezlerini zaten biliyoruz) herhangi bir <span class="math inline">\(x,y\)</span> değeri için o noktadaki birleşik RBF sonucunu hesaplatabiliriz, mesela üstteki fonksiyon için</p>
<p><span class="math display">\[
x_{m1} = [36.06, 32.67],
x_{m2} = [36.71, 32.32], 
x_{test} = [36.16, 32.77]
\]</span></p>
<p><span class="math display">\[
y = 0.5 \exp (-\gamma || x_{test} - x_{m1} ||^2) + 0.5 \exp (-\gamma || x_{test} - x_{m2} ||^2 )
\]</span></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">x_test <span class="op">=</span> [<span class="fl">36.16</span>, <span class="fl">32.77</span>]
w1 <span class="op">=</span> <span class="fl">0.5</span><span class="op">;</span> w2 <span class="op">=</span> <span class="fl">0.5</span>
d1 <span class="op">=</span> (x_test[<span class="dv">0</span>]<span class="op">-</span>xm[<span class="dv">0</span>])<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> (x_test[<span class="dv">1</span>]<span class="op">-</span>ym[<span class="dv">0</span>])<span class="op">**</span><span class="dv">2</span>
d2 <span class="op">=</span> (x_test[<span class="dv">0</span>]<span class="op">-</span>xm[<span class="dv">1</span>])<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> (x_test[<span class="dv">1</span>]<span class="op">-</span>ym[<span class="dv">1</span>])<span class="op">**</span><span class="dv">2</span>
y_new <span class="op">=</span> w1<span class="op">*</span>np.exp(<span class="op">-</span>gamma <span class="op">*</span> d1) <span class="op">+</span> w2<span class="op">*</span>np.exp(<span class="op">-</span>gamma <span class="op">*</span> d2) 
<span class="bu">print</span> (y_new)</code></pre></div>
<pre><code>[0.6637959]</code></pre>
<p>Gerçek dünya şartlarına yaklaşırsak; bu tür durumlarda çok daha fazla baz fonksiyon, örneklem kullanılır, altta <code>func</code> fonksiyonu örneklem üretmek için kullanılacak, normal şartlarda bu fonksiyonu bilmiyoruz, sadece ondan gelen örneklem verilerini biliyoruz. Bir örnek amaçlı, belli bir şekli zorlamak için bunu yaptık.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">np.random.seed(<span class="dv">0</span>)

<span class="kw">def</span> func(x, y):
    s1 <span class="op">=</span> <span class="fl">0.2</span><span class="op">;</span> x1 <span class="op">=</span> <span class="fl">36.5</span><span class="op">;</span> y1 <span class="op">=</span> <span class="fl">32.5</span>
    s2 <span class="op">=</span> <span class="fl">0.4</span><span class="op">;</span> x2 <span class="op">=</span> <span class="fl">36.1</span><span class="op">;</span> y2 <span class="op">=</span> <span class="fl">32.8</span>
    g1 <span class="op">=</span> np.exp( <span class="dv">-4</span> <span class="op">*</span>np.log(<span class="dv">2</span>) <span class="op">*</span> ((x<span class="op">-</span>x1)<span class="op">**</span><span class="dv">2</span><span class="op">+</span>(y<span class="op">-</span>y1)<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> s1<span class="op">**</span><span class="dv">2</span>)
    g2 <span class="op">=</span> np.exp( <span class="dv">-2</span> <span class="op">*</span>np.log(<span class="dv">2</span>) <span class="op">*</span> ((x<span class="op">-</span>x2)<span class="op">**</span><span class="dv">2</span><span class="op">+</span>(y<span class="op">-</span>y2)<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> s2<span class="op">**</span><span class="dv">2</span>)    
    <span class="cf">return</span> g1 <span class="op">+</span> g2 

D <span class="op">=</span> <span class="dv">50</span>
S <span class="op">=</span> <span class="dv">100</span>
gamma <span class="op">=</span> <span class="fl">2.0</span>

x <span class="op">=</span> np.linspace(<span class="dv">36</span>,<span class="dv">37</span>,D)
y <span class="op">=</span> np.linspace(<span class="dv">32</span>,<span class="dv">33</span>,D)

xx,yy <span class="op">=</span> np.meshgrid(x,y)
zz <span class="op">=</span> func(xx,yy)

fig <span class="op">=</span> plt.figure()
ax <span class="op">=</span> fig.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)
surf <span class="op">=</span> ax.plot_surface(xx, yy, zz, cmap<span class="op">=</span>cm.coolwarm,linewidth<span class="op">=</span><span class="dv">0</span>, antialiased<span class="op">=</span><span class="va">False</span>)
plt.savefig(<span class="st">&#39;linear_app88rbf_01.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="linear_app88rbf_01.png" />

</div>
<p>İki tane tepe var. Şimdi bu fonksiyondan rasgele örneklem alalım, ve <span class="math inline">\(\Phi\)</span> üzerinden RBF ağırlıklarını hesaplayalım,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">xxx <span class="op">=</span> xx.reshape(D<span class="op">*</span>D)
yyy <span class="op">=</span> yy.reshape(D<span class="op">*</span>D)
zzz <span class="op">=</span> zz.reshape(D<span class="op">*</span>D)

idx <span class="op">=</span> np.random.choice(<span class="bu">range</span>(D<span class="op">*</span>D),S)

xr <span class="op">=</span> xxx[idx].reshape(S,<span class="dv">1</span>)
yr <span class="op">=</span> yyy[idx].reshape(S,<span class="dv">1</span>)
zr <span class="op">=</span> zzz[idx].reshape(S,<span class="dv">1</span>)
X <span class="op">=</span> np.hstack((xr,yr))

Phi <span class="op">=</span> np.exp(<span class="op">-</span>gamma<span class="op">*</span>cdist(X,X,metric<span class="op">=</span><span class="st">&#39;euclid&#39;</span>))

w <span class="op">=</span> np.dot(lin.pinv(Phi),zr)</code></pre></div>
<p>Ağırlıklarla fonksiyonu tekrar yaratmaya uğraşalım,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">a <span class="op">=</span> np.vstack((xxx,yyy))
d <span class="op">=</span> cdist(X,a.T)
d <span class="op">=</span> np.exp(<span class="op">-</span>gamma <span class="op">*</span> d)
dd <span class="op">=</span> np.dot(w.T,d)
znew <span class="op">=</span> dd.reshape(D,D)

fig <span class="op">=</span> plt.figure()
ax <span class="op">=</span> fig.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)
surf <span class="op">=</span> ax.plot_surface(xx, yy, znew, cmap<span class="op">=</span>cm.coolwarm,linewidth<span class="op">=</span><span class="dv">0</span>, antialiased<span class="op">=</span><span class="va">False</span>)
plt.savefig(<span class="st">&#39;linear_app88rbf_02.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="linear_app88rbf_02.png" />

</div>
<p>Pek optimizasyon yapmadık, ama orijinale benzidiği söylenebilir.</p>
<p>Not: <code>cdist</code> bir veri matrisindeki her satır ile her diğer satır arasında (tüm kombinasyonlar) mesafe hesabı yapar.</p>
<p>Yeni tek bir veri noktası için</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">xnew <span class="op">=</span> np.array([[<span class="fl">36.5</span>,<span class="fl">32.5</span>]])

<span class="bu">print</span> (np.multiply(w.T,np.exp(<span class="op">-</span>gamma<span class="op">*</span>lin.norm(X<span class="op">-</span>xnew,axis<span class="op">=</span><span class="dv">1</span>))).<span class="bu">sum</span>())</code></pre></div>
<pre><code>0.6423871447150892</code></pre>
<p>Bu yaklaşımı tüm dünyanın yeryüzü dağ, tepe veri tabanını oluşturmak için kullanabiliriz. 1 milyon veri yerine onun yüzden 3'u üzerinden RBF işlettikten sonra <span class="math inline">\(x,y,w\)</span> değerlerini tutarız, gerisini atarız. Bu üç değer geniş bir bölgeyi pürüzsüz fonksiyonlarla yaklaşık temsil etmenin en iyi yolu. Veri tabanı sadece bu değerleri taşıyacak.</p>
<p>Bizim bu konuya girmemizin sebebi Google Elevation API ile aldığımız yükseklik verilerini verimli şekilde kullanma ihtiyacı idi.</p>
<p>Simdi <code>scipy</code> ile ayni isleri yapalim,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">np.random.seed(<span class="dv">0</span>)

S <span class="op">=</span> <span class="dv">200</span>

x <span class="op">=</span> np.linspace(<span class="dv">36</span>,<span class="dv">37</span>,D)
y <span class="op">=</span> np.linspace(<span class="dv">32</span>,<span class="dv">33</span>,D)

xx,yy <span class="op">=</span> np.meshgrid(x,y)
znew <span class="op">=</span> func(xx,yy)
xx <span class="op">=</span> xx.reshape(D<span class="op">*</span>D)
yy <span class="op">=</span> yy.reshape(D<span class="op">*</span>D)
znew <span class="op">=</span> znew.reshape(D<span class="op">*</span>D)

<span class="im">from</span> scipy.interpolate <span class="im">import</span> Rbf
rbfi <span class="op">=</span> Rbf(xx,yy,znew,function<span class="op">=</span><span class="st">&#39;gaussian&#39;</span>)
znew <span class="op">=</span> rbfi(xx,yy)

xx <span class="op">=</span> xx.reshape(D,D)
yy <span class="op">=</span> yy.reshape(D,D)
znew <span class="op">=</span> znew.reshape(D,D)

fig <span class="op">=</span> plt.figure()
ax <span class="op">=</span> fig.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)
surf <span class="op">=</span> ax.plot_surface(xx, yy, znew, cmap<span class="op">=</span>cm.coolwarm,linewidth<span class="op">=</span><span class="dv">0</span>, antialiased<span class="op">=</span><span class="va">False</span>)
plt.savefig(<span class="st">&#39;linear_app88rbf_05.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="linear_app88rbf_05.png" />

</div>
<p>Not: <code>scipy</code> ile bize döndürülen ve ara değerleme için direk çağırılabilen objeyi gerekli her türlü bilgiyi içinde taşıyor. Yani modeli çıkartıp veriyi atıp, sadece bu objeyi (mesela <code>pickle</code> ile) diskte saklayabiliriz, bu tek başına yeterlidir.</p>
<p>Modelleme <code>scipy</code> İle, Tekrar Yaratmak Elle Yazılan Fonksiyon İle</p>
<p>Bir diğer yaklaşım veriyi örneklemek, <code>scipy</code> ile RBF'leri yaratmak, ama <code>sciy</code> parametrelerini kullanarak modeli kendimizin tekrar yaratması. Bunun değişik sebepleri olabilir, belki veriyi modelleyen bir yükseklik fonksiyonu üzerinde otomatik türev almak istiyoruz, ama <code>scipy</code> içindeki versiyon ile bunu yapamıyoruz. Ya da motor kapağı altında nelerin olup bittiğini daha iyi anlamak istiyoruz.</p>
<p>Her neyse, yine iki tepeli ortamı yaratıyoruz,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> mpl_toolkits.mplot3d <span class="im">import</span> Axes3D
<span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt
<span class="im">from</span> matplotlib <span class="im">import</span> cm

np.random.seed(<span class="dv">0</span>)

<span class="kw">def</span> func(x, y):
    s1 <span class="op">=</span> <span class="fl">0.2</span><span class="op">;</span> x1 <span class="op">=</span> <span class="fl">36.5</span><span class="op">;</span> y1 <span class="op">=</span> <span class="fl">32.5</span>
    s2 <span class="op">=</span> <span class="fl">0.4</span><span class="op">;</span> x2 <span class="op">=</span> <span class="fl">36.1</span><span class="op">;</span> y2 <span class="op">=</span> <span class="fl">32.8</span>
    g1 <span class="op">=</span> np.exp( <span class="dv">-4</span> <span class="op">*</span>np.log(<span class="dv">2</span>) <span class="op">*</span> ((x<span class="op">-</span>x1)<span class="op">**</span><span class="dv">2</span><span class="op">+</span>(y<span class="op">-</span>y1)<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> s1<span class="op">**</span><span class="dv">2</span>)
    g2 <span class="op">=</span> np.exp( <span class="dv">-2</span> <span class="op">*</span>np.log(<span class="dv">2</span>) <span class="op">*</span> ((x<span class="op">-</span>x2)<span class="op">**</span><span class="dv">2</span><span class="op">+</span>(y<span class="op">-</span>y2)<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> s2<span class="op">**</span><span class="dv">2</span>)    
    <span class="cf">return</span> g1 <span class="op">+</span> g2 

D <span class="op">=</span> <span class="dv">100</span>

x <span class="op">=</span> np.linspace(<span class="dv">36</span>,<span class="dv">37</span>,D)
y <span class="op">=</span> np.linspace(<span class="dv">32</span>,<span class="dv">33</span>,D)

xx,yy <span class="op">=</span> np.meshgrid(x,y)
zz <span class="op">=</span> func(xx,yy)</code></pre></div>
<p>Ve grafiklemeyi yapıyoruz,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">xx <span class="op">=</span> xx.reshape(D,D)
yy <span class="op">=</span> yy.reshape(D,D)
zz <span class="op">=</span> func(xx,yy)

fig <span class="op">=</span> plt.figure()
ax <span class="op">=</span> fig.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)
ax.view_init(elev<span class="op">=</span><span class="dv">29</span>, azim<span class="op">=</span><span class="dv">29</span>)
surf <span class="op">=</span> ax.plot_surface(xx, yy, zz, cmap<span class="op">=</span>cm.coolwarm,linewidth<span class="op">=</span><span class="dv">0</span>, antialiased<span class="op">=</span><span class="va">False</span>)
plt.savefig(<span class="st">&#39;linear_app88rbf_03.png&#39;</span>)</code></pre></div>
<p>Şimdi örneklem alıp RBF yaratalım,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> scipy.interpolate <span class="im">import</span> Rbf

S <span class="op">=</span> <span class="dv">50</span>
np.random.seed(<span class="dv">0</span>)
idx <span class="op">=</span> np.random.choice(<span class="bu">range</span>(D<span class="op">*</span>D),S)
xr <span class="op">=</span> xx.reshape(D<span class="op">*</span>D)[idx].reshape(S,<span class="dv">1</span>)
yr <span class="op">=</span> yy.reshape(D<span class="op">*</span>D)[idx].reshape(S,<span class="dv">1</span>)
zr <span class="op">=</span> zz.reshape(D<span class="op">*</span>D)[idx].reshape(S,<span class="dv">1</span>)

rbfi <span class="op">=</span> Rbf(xr,yr,zr,function<span class="op">=</span><span class="st">&#39;gaussian&#39;</span>,epsilon<span class="op">=</span><span class="fl">0.15</span>)</code></pre></div>
<p>Modelleme Gaussian RBF'ler üzerinden yapıldı. Üstteki <code>rbfi</code> değişkenini elde edince artık herhangi bir <span class="math inline">\(x\)</span>,<span class="math inline">\(y\)</span> kordinatı üzerinde <code>rbfi(x,y)</code> ile ara değerleme yaparak modelin hesapladığı bir <span class="math inline">\(z\)</span> değeri elde edebiliriz.</p>
<p>Peki arka planda bu hesaplama neye benziyor? Dokümantasyona bakınca</p>
<p><code>'gaussian': exp(-(r/self.epsilon)**2)</code></p>
<p>ifadesini görüyoruz, burada <code>r</code> yeni nokta ile bir RBF baz fonksiyonu arasındaki mesafe. Bir test noktası ile üstteki RBF'leri (D*D tane) arasındaki mesafe şöyle hesaplanabilir,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> dist_matrix(X, Y):
    sx <span class="op">=</span> np.<span class="bu">sum</span>(X<span class="op">**</span><span class="dv">2</span>, <span class="dv">1</span>)
    sy <span class="op">=</span> np.<span class="bu">sum</span>(Y<span class="op">**</span><span class="dv">2</span>, <span class="dv">1</span>)
    D2 <span class="op">=</span>  sx[:, np.newaxis] <span class="op">-</span> <span class="fl">2.0</span><span class="op">*</span>X.dot(Y.T) <span class="op">+</span> sy[np.newaxis, :] 
    D2[D2 <span class="op">&lt;</span> <span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span>
    D <span class="op">=</span> np.sqrt(D2)
    <span class="cf">return</span> D
    
test_1 <span class="op">=</span> np.array([[<span class="fl">36.0</span>,<span class="fl">32.0</span>]])
test_1_dist <span class="op">=</span> dist_matrix(test_1, rbfi.xi.T)
<span class="bu">print</span> (test_1_dist.shape)
<span class="bu">print</span> (test_1_dist[<span class="dv">0</span>][:<span class="dv">10</span>])</code></pre></div>
<pre><code>(1, 50)
[0.4229176  1.08927112 0.72276945 0.76827462 0.96299239 1.21064725
 0.85578867 0.94970984 0.80965755 0.76794254]</code></pre>
<p>O mesafeyi alıp eksi karesini hesaplayıp <code>exp</code>'ye vermek lazım. Tüm RBF'leri de bir şekilde dahil etmek lazım tabii, o da hesaplanan ağırlıklar ile üstteki sonucu çarpıp hepsini toplamakla olur. Gerekli parametreler <code>rbfi</code> içinde,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> (rbfi.epsilon)
<span class="bu">print</span> (rbfi.smooth)
<span class="bu">print</span> (rbfi.xi.shape)
<span class="bu">print</span> (rbfi.nodes.shape)</code></pre></div>
<pre><code>0.15
0.0
(2, 50)
(50,)</code></pre>
<p>Ağırlıklar <code>nodes</code>, RBF merkezleri <code>xi</code>, <code>epsilon</code> genel bir pürüz parametresi. İki test noktası üzerinde görelim, dikkat burada {} RBF'ler gözönüne alınacak,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">nodes <span class="op">=</span> rbfi.nodes.reshape(<span class="dv">1</span>,<span class="bu">len</span>(rbfi.nodes))
<span class="kw">def</span> gaussian(r,eps): <span class="cf">return</span> np.exp(<span class="op">-</span>(r<span class="op">/</span>eps)<span class="op">**</span><span class="dv">2</span>)

<span class="kw">def</span> f_interp(newp, rbfi):
    nodes <span class="op">=</span> rbfi.nodes.reshape(<span class="dv">1</span>,<span class="bu">len</span>(rbfi.nodes))
    newp_dist <span class="op">=</span> dist_matrix(newp, rbfi.xi.T)
    <span class="cf">return</span> np.dot(gaussian(newp_dist, rbfi.epsilon), nodes.T)

test_2 <span class="op">=</span> np.array([[<span class="fl">36.0</span>,<span class="fl">32.0</span>],[<span class="fl">36.1</span>,<span class="fl">31.9</span>]])
<span class="bu">print</span> (f_interp(test_2,rbfi))</code></pre></div>
<pre><code>[[-0.00387063]
 [-0.00337065]]</code></pre>
<p>Şimdi iki tepeli fonksiyonu RBF'ler üzerinde yaratalım,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">test_3 <span class="op">=</span> np.column_stack((xx.ravel(), yy.ravel()))
znewnew <span class="op">=</span> f_interp(test_3,rbfi).reshape(xx.shape)

fig <span class="op">=</span> plt.figure()
ax <span class="op">=</span> fig.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)
ax.view_init(elev<span class="op">=</span><span class="dv">29</span>, azim<span class="op">=</span><span class="dv">29</span>)
surf <span class="op">=</span> ax.plot_surface(xx, yy, znewnew, cmap<span class="op">=</span>cm.coolwarm,linewidth<span class="op">=</span><span class="dv">0</span>, antialiased<span class="op">=</span><span class="va">False</span>)
plt.savefig(<span class="st">&#39;linear_app88rbf_06.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="linear_app88rbf_06.png" />

</div>
<p>RBF Türev ve Hessian Matrisi</p>
<p>Ana formülü hatırlayalım,</p>
<p><span class="math display">\[
f(x) = \sum_{i=1}^{m} \beta_i \phi(|| x-x_i||)
\]</span></p>
<p>ki <span class="math inline">\(\beta_1,...,\beta_m\)</span> öyle seçiliyor ki</p>
<p><span class="math display">\[
f(x_i) = F(x_i), \quad i=1,2,...,m
\]</span></p>
<p>eşitliği tatmin edilsin. Burada <span class="math inline">\(F\)</span> modellenen ana fonksiyondur, ve <span class="math inline">\(\phi\)</span> bizim seçtiğimiz baz fonksiyondur. RBF'in türevi nedir? Analitik olarak hesaplayabiliriz,</p>
<p><span class="math display">\[
\frac{\partial f(x)}{\partial x} = \beta^T \frac{\partial g}{\partial x} =
\sum_{i=1}^{m} \beta_i \phi&#39;(r_i) \frac{\partial r_i}{\partial x} 
\]</span></p>
<p>öyle ki <span class="math inline">\(\phi&#39;(r) = \mathrm{d} \phi / \mathrm{d} r\)</span>, ve</p>
<p><span class="math display">\[
r_i(x) = ||x-x_i|| = \sqrt{(x-x_i)^T(x-x_i)} 
\qquad (1)
\]</span></p>
<p>Ayrıca</p>
<p><span class="math display">\[
\frac{\partial r_i}{\partial x} = \frac{1}{r_i(x)} (x-x_i)^T
\]</span></p>
<p>Hepsi bir arada [4]</p>
<p><span class="math display">\[
\frac{\partial f(x)}{\partial x} = \sum_{i=1}^{m} \frac{\beta_i\phi&#39;(r_i)}{r_i(x)}
(x-x_i)^T
\]</span></p>
<p>Hessian'ı alttaki gibi hesaplayabiliriz [3]. [4]'teki formül</p>
<p><span class="math display">\[
\frac{\partial^2 f(x)}{\partial x^2} = 
\sum_{i=1}^{m} \bigg\{ 
\phi&#39;(r_i) I + \bigg[\phi&#39;&#39;(r_i) - \frac{\phi&#39;(r_i)}{r_i(x)} \bigg] 
(x-x_i) \frac{\partial r_i}{\partial x}
\bigg\}
\qquad (2)
\]</span></p>
<p>Türetmek için, radyal vektörler <span class="math inline">\(\,w_k = (x - x_k)\in{\mathbb R}^n\,\)</span> tanımlanır, dikkat bunların <span class="math inline">\(\,dw_k = dx\)</span> türevleri aynı. Şimdi vektörleri tek bir matriste birleştirelim,</p>
<p><span class="math display">\[
\Omega = \big[\,w_1\;w_2\;\ldots\;w_m\big] \in {\mathbb R}^{n\times m} 
\]</span></p>
<p><span class="math display">\[
d\Omega = \big[\,dx\;dx\;\ldots\;dx\big] =  dx\,{\tt\large 1}^T 
\]</span></p>
<p>Dikkat <span class="math inline">\(\,r_j=\|w_j\|\,\)</span> öğelerinin kendisi <span class="math inline">\(\,r\in{\mathbb R}^m\)</span> vektörünün aynı zamanda ögesi. Kartezyen baz vektörleri <span class="math inline">\(\,e_k\in{\mathbb R}^m\)</span> üsttekini</p>
<p><span class="math display">\[w_k=\Omega\,e_k,\quad dx=d\Omega\,e_k,\quad r_j=e_j^Tr\]</span></p>
<p>şeklinde yazmamıza izin veriyor. RBF'i öğesel bazda uygulayarak indisli toplam notasyonundan kurtulmuş oluyoruz. Şimdi türevleri, diferansiyelleri</p>
<p><span class="math display">\[
g=\phi(r),\quad g&#39;=\phi&#39;(r),\quad g&#39;&#39;=\phi&#39;&#39;(r)\; \in{\mathbb R}^m 
\]</span></p>
<p><span class="math display">\[
dg=g&#39;\odot dr,\quad dg&#39;=g&#39;&#39;\odot dr \; \in{\mathbb R}^m 
\]</span></p>
<p>ile yazabiliriz, ki <span class="math inline">\(\odot\)</span> öğesel bazlı Hadamard çarpımıdır.</p>
<p>Ayrıca vektörler köşegen matrisler arasında geçiş yapabilmek faydalıdır, ki bu matrisleri büyük harfle belirteceğiz, mesela</p>
<p><span class="math display">\[
 R={\rm Diag}(r),\quad G=
{\rm Diag}(g),\quad G&#39;&#39;={\rm Diag}(g&#39;&#39;)\;\in{\mathbb R}^{m\times m} 
\]</span></p>
<p><span class="math display">\[
r = {\rm diag}(R),\quad g = {\rm diag}(G),\quad g&#39;&#39;=\ldots 
\]</span></p>
<p><span class="math display">\[
r  = R{\tt\large 1},\quad g = G{\tt\large 1},\quad g&#39;&#39;=\ldots 
\]</span></p>
<p><span class="math display">\[
dg = G&#39;dr,\quad dg&#39; = G&#39;&#39;dr 
\]</span></p>
<p>ayrıca iş kolaylaştırması için alttaki tanım faydalı,</p>
<p><span class="math display">\[
P=R^{-1}\quad\implies PR=I,\;\;p\odot r = {\tt\large 1}
\]</span></p>
<p>Şimdi ana ilişkiyi yazalım ve türevini alalım,</p>
<p><span class="math display">\[
r\odot r = {\rm diag}(\Omega^T\Omega) 
\]</span></p>
<p><span class="math display">\[
2r\odot dr = {\rm diag}(\Omega^Td\Omega+d\Omega^T\Omega)
\;=\; 2{\,\rm {diag}}(\Omega^Td\Omega) 
\]</span></p>
<p><span class="math display">\[
R\,dr = {\rm diag}(\Omega^Tdx\,{\tt\large 1}^T) \;=\; \Omega^Tdx 
\]</span></p>
<p><span class="math display">\[
dr = P\Omega^Tdx 
\]</span></p>
<p><span class="math display">\[
\frac{\partial r}{\partial x} = P\Omega^T 
\]</span></p>
<p><span class="math inline">\(i^{th}\)</span> bileşeni kontrol edersek (1) formülünü ortaya çıkartabileceğimizi görüyoruz, demek ki doğru yoldayız,</p>
<p><span class="math display">\[
e_i^T\bigg(\frac{\partial r}{\partial x}\bigg) = e_i^TP\Omega^T 
\]</span></p>
<p><span class="math display">\[
\frac{\partial r_i}{\partial x} 
\;=\; \frac{1}{r_i}\;e_i^T\Omega^T
\;=\; \frac{w_i^T}{\|w_i\|} 
\]</span></p>
<p>Model fonksiyonu (<span class="math inline">\(\beta\)</span> <span class="math inline">\(b\)</span> kullandık daha kısa)</p>
<p><span class="math display">\[f = b^Tg = b:g\]</span></p>
<p>İki nokta üst üste iz (trace) için Frobenius çarpım notasyonudur, mesela <span class="math inline">\(\;A:B = {\rm Tr}(A^TB)\)</span>.</p>
<p>Şimdi Hessian</p>
<p><span class="math display">\[
dJ = d\Omega\,PG&#39;B{\tt\large 1} + \Omega PdG&#39;B{\tt\large 1} + \Omega\,dP\,G&#39;B{\tt\large 1} 
\]</span></p>
<p><span class="math display">\[
= dx\,{\tt\large 1}^TPG&#39;B{\tt\large 1} + \Omega PB\,dg&#39; - \Omega (P\,dR\,P)G&#39;B{\tt\large 1}
\]</span></p>
<p><span class="math display">\[
 = dx\,({\tt\large 1}^TPG&#39;B{\tt\large 1}) +\Omega PB\,dg&#39; -\Omega PG&#39;PB\,dr
\]</span></p>
<p><span class="math display">\[
 = (G&#39;:PB)\,dx +\Omega PBG&#39;&#39;\,dr -\Omega PG&#39;PB\,dr
\]</span></p>
<p><span class="math display">\[
 = \Big((G&#39;:PB)I +\Omega PB(G&#39;&#39; - PG&#39;)P\Omega^T\Big)\,dx
\]</span></p>
<p><span class="math display">\[
H = \frac{\partial J}{\partial x}
 = (G&#39;:PB)I + \Omega PB(G&#39;&#39;-PG&#39;)P\Omega^T
\]</span></p>
<p><span class="math display">\[
= \Big((p\odot b):g&#39;\Big)\,I \;+\; 
\bigg(\frac{\partial r}{\partial x}\bigg)^T\Big(BG&#39;&#39;-BPG&#39;\Big)\bigg(\frac{\partial r}{\partial x}\bigg) 
\]</span></p>
<p>Pek öyle durmasa da bu formül (2) formülü ile aynı.</p>
<p>Akılda tutalım <span class="math inline">\((R,G,B)\)</span> matrisleri köşegen ve birbirleri ile sırabağımsız ilişkileri var, ama <span class="math inline">\(\,\Omega\,\)</span> matrisi tam matris ve diğer matrislerle sırabağımsız ilişkiye giremiyor.</p>
<p>Autograd ile Gradyan ve Hessian</p>
<p>Otomatik türev üzerinden de üstteki hesapları yapabiliriz. Daha önceki kodlarda iki dağlı veriden örneklem alıp RBF yaratmıştık, bu obje <code>rbfi</code> içinde, oradan devam edersek,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> autograd.numpy <span class="im">as</span> anp
<span class="im">import</span> autograd

<span class="kw">def</span> dist_matrix(X, Y):
    X <span class="op">=</span> X.reshape(<span class="dv">1</span>, X.shape[<span class="dv">0</span>])
    sx <span class="op">=</span> anp.<span class="bu">sum</span>(X<span class="op">**</span><span class="dv">2</span>, <span class="dv">1</span>)
    sy <span class="op">=</span> anp.<span class="bu">sum</span>(Y<span class="op">**</span><span class="dv">2</span>, <span class="dv">1</span>)
    D2 <span class="op">=</span>  sx[:, anp.newaxis] <span class="op">-</span> <span class="fl">2.0</span><span class="op">*</span>anp.dot(X,Y.T) <span class="op">+</span> sy[anp.newaxis, :] 
    D <span class="op">=</span> anp.sqrt(D2)
    <span class="cf">return</span> D
    
nodes <span class="op">=</span> rbfi.nodes.reshape(<span class="dv">1</span>,<span class="bu">len</span>(rbfi.nodes))
<span class="kw">def</span> gaussian(r,eps): <span class="cf">return</span> anp.exp(<span class="op">-</span>(r<span class="op">/</span>eps)<span class="op">**</span><span class="dv">2</span>)

<span class="kw">def</span> f_interp(newp):
    nodes <span class="op">=</span> rbfi.nodes.reshape(<span class="dv">1</span>,<span class="bu">len</span>(rbfi.nodes))    
    newp_dist <span class="op">=</span> dist_matrix(newp, rbfi.xi.T)
    <span class="cf">return</span> anp.dot(gaussian(newp_dist, rbfi.epsilon), nodes.T)

test_1 <span class="op">=</span> anp.array([<span class="fl">36.0</span>,<span class="fl">32.0</span>])
test_1_dist <span class="op">=</span> dist_matrix(test_1, rbfi.xi.T)
<span class="bu">print</span> (<span class="st">&#39;f&#39;</span>,f_interp(test_1))

grbf <span class="op">=</span> autograd.grad(f_interp)
hrbf <span class="op">=</span> autograd.hessian(f_interp)
<span class="bu">print</span> (<span class="st">&#39;gradyan&#39;</span>,grbf(test_1))
<span class="bu">print</span> (<span class="st">&#39;hessian&#39;</span>,hrbf(test_1))</code></pre></div>
<pre><code>f [[-0.00387063]]
gradyan [0.02331737 0.08191414]
hessian [[[[0.6466522  0.74921925]
   [0.74921925 1.92847522]]]]</code></pre>
<p>Rasgele Noktalar Seçmek</p>
<p>Fonksiyonu RBF ile temsil etmek için gereken Rasgele noktaları Hammersley noktaları adı verilen bir rasgele sayı üretme tekniği ile seçmek mümkün, bu şekilde son derece çetrefil fonksiyonlar bile az sayıda örneklem noktaları üzerinden temsil edilebiliyor [5]. Mesela altta 10 tane bu tür noktayı 2 boyut için seçtik. Sayılar 0 ile 1 arasında ama gereken aralığa ölçeklenerek, toplanarak taşınabilir.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> hammer
<span class="bu">print</span> (hammer.hammersley([<span class="dv">2</span>,<span class="dv">3</span>],<span class="dv">10</span>))</code></pre></div>
<pre><code>[[0.     0.    ]
 [0.1    0.    ]
 [0.2    0.5   ]
 [0.3    0.25  ]
 [0.4    0.75  ]
 [0.5    0.125 ]
 [0.6    0.625 ]
 [0.7    0.375 ]
 [0.8    0.875 ]
 [0.9    0.0625]]</code></pre>
<p>Mesela</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> mpl_toolkits.mplot3d <span class="im">import</span> Axes3D

<span class="kw">def</span> peaks(x,y):
    z <span class="op">=</span>  (<span class="dv">3</span><span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>x)<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> np.exp(<span class="op">-</span>(x<span class="op">**</span><span class="dv">2</span>) <span class="op">-</span> (y<span class="op">+</span><span class="dv">1</span>)<span class="op">**</span><span class="dv">2</span>) 
          <span class="op">-</span> <span class="dv">10</span><span class="op">*</span>(x<span class="op">/</span><span class="dv">5</span> <span class="op">-</span> x<span class="op">**</span><span class="dv">3</span> <span class="op">-</span> y<span class="op">**</span><span class="dv">5</span>) <span class="op">*</span> np.exp(<span class="op">-</span>x<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> y<span class="op">**</span><span class="dv">2</span>)
          <span class="op">-</span> <span class="dv">1</span><span class="op">/</span><span class="dv">3</span> <span class="op">*</span> np.exp(<span class="op">-</span>(x<span class="op">+</span><span class="dv">1</span>)<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> y<span class="op">**</span><span class="dv">2</span>)) 
    <span class="cf">return</span>(z)
 
n <span class="op">=</span> <span class="dv">20</span>
x <span class="op">=</span> <span class="dv">-3</span> <span class="op">+</span> <span class="dv">6</span><span class="op">*</span>hammer.hammersley([<span class="dv">2</span>,<span class="dv">3</span>],n)
z <span class="op">=</span> peaks(x[:,<span class="dv">0</span>],x[:,<span class="dv">1</span>])
xx, yy <span class="op">=</span> np.mgrid[<span class="op">-</span><span class="dv">3</span>:<span class="dv">3</span>:150j,<span class="op">-</span><span class="dv">3</span>:<span class="dv">3</span>:150j]
zz <span class="op">=</span> peaks(xx,yy)
fig<span class="op">=</span>plt.figure()
ax <span class="op">=</span> fig.add_subplot(<span class="dv">111</span>,projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)
ax.plot_surface(xx,yy,zz,rstride<span class="op">=</span><span class="dv">1</span>,cstride<span class="op">=</span><span class="dv">1</span>,color<span class="op">=</span><span class="st">&#39;c&#39;</span>,alpha<span class="op">=</span><span class="fl">0.3</span>,linewidth<span class="op">=</span><span class="dv">0</span>)
ax.scatter(x[:,<span class="dv">0</span>],x[:,<span class="dv">1</span>],z,color<span class="op">=</span><span class="st">&#39;k&#39;</span>,s<span class="op">=</span><span class="dv">20</span>)
plt.savefig(<span class="st">&#39;linear_app88rbf_07.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="linear_app88rbf_07.png" />

</div>
<p>Görüldüğü gibi oldukca çetrefil bir fonksiyon bu,</p>
<p><span class="math display">\[
f(x_1,x_2) = 3 (1 - x_1)^2 e^{-x_1^2-(-x_2^2 + 1)^2} - 
10 \bigg( \frac{x_1}{5} - x_1^3-x_2^5 \bigg) e^{-x_1^2 -x_2^2} - 
\frac{1}{3} e^{-(x_1 + 1)^2 - x_2^2}
\]</span></p>
<p>ama Hammersley tekniği ile kritik noktalarından örneklem alınabiliyor. [5]'te bu teknik ile üretilen yeni fonsiyonun gerçeğine çok yakın olacağını görüyoruz, 20 tane nokta ile!</p>
<p>Kaynaklar</p>
<p>[1] Neto, <em>Radial Basis Functions</em>, <a href="http://www.di.fc.ul.pt/~jpn/r/rbf/rbf.html" class="uri">http://www.di.fc.ul.pt/~jpn/r/rbf/rbf.html</a></p>
<p>[2] Pouderoux, <em>Adaptive Hierarchical RBF Interpolation for Creating Smooth Digital Elevation Models</em> <a href="https://hal.archives-ouvertes.fr/hal-00308008/document" class="uri">https://hal.archives-ouvertes.fr/hal-00308008/document</a></p>
<p>[3] Math Stackexchange, <em>The Hessian of a Radial Basis Function</em>, <a href="https://math.stackexchange.com/questions/3417706/the-hessian-of-a-radial-basis-function" class="uri">https://math.stackexchange.com/questions/3417706/the-hessian-of-a-radial-basis-function</a></p>
<p>[4] Mcdonald, <em>Global and local optimization using radial basis function response surface models</em>, <a href="https://www.sciencedirect.com/science/article/pii/S0307904X06002009" class="uri">https://www.sciencedirect.com/science/article/pii/S0307904X06002009</a></p>
<p>[5] Kroese, <em>Data Science and Machine Learning: Mathematical and Statistical Methods</em></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
