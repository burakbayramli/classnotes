\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Ders 11

Konumuz kesit seviyeleri (level sets). Bu alanda Sethian ve Osher otorite
sayýlýyor, 80'li yýllarda yayýnladýklarý makale ve kitaplarda konuyu etraflýca
iþlediler.

Elimizde bir eðri var diyelim (altta resimde $t=0$ anýndaki)

\includegraphics[width=20em]{2_11_01.jpg}

ve bu ``arayüz (interface)'' ya da duvar, bu eðri hareket ediyor. Ýlerliyor. Bu
ilerlemenin kendi normali (yani eðrinin her noktasýndaki teðetine dik) yönünde
olduðunu düþünelim. Bu ilerleme þeklini biz empoze ediyoruz, sonra formüllerin
buna göre nasýl þekillendiðini göreceðiz. Bu ilerleme sonunda mesela $t=0$'da
görülen þekilden $t=1$'deki þekle gelinmiþ olacak. En ideal þartlarda hýzýn
hiçbir noktada deðiþmediðini düþünebiliriz, yani hýz sabit. O zaman birim
zamanda sabit hýzda (diyelim o da 1), mesafe 1 katedilmiþ olur.

Eðrinin nasýl tarif edildiði anahtar. Eðriyi, o eðri üzerindeki belli yerlerde
noktalar üzerinden mi temsil etsem? Ki o her nokta bir bilinmeyen / deðiþkenle
genel formüle dahil edilse? O noktalarýn her birinde ayrý bir normal
diferansiyel denklem (ordinary differential eqution) olabilirdi, o denklemi
takip ederek bir sonraki noktaya gidebilirdim, vs. 

Fakat kesit seviyeleri böyle iþlemiyor. Hatta ilk akla gelen (gayet
doðal)parçacýklý üstteki fikir sayýsal hesaplarda çabucak bazý engellere
tosluyor. Mesela üstteki resimdeki örnek idealdi dedik, parçacýklar $t=1$'da
biraz yayýlýrlar, çok deðil, ama çok yayýlýyor da olabilirlerdi. Ya da ters
yönde eðime göre noktalar ayný noktada toplanabilirdi, bu sayýsal hesabý iyice
bozardý çünkü noktalar üst üste binerdi, aradaki farklarý doðru dürüst
hesaplayamazdýk.

Peki o zaman kesit seviyeleri bu problemleri nasýl çözüyor? Ondan önce kesit
seviyesi nedir? Kesit seviyesi bir ana fonksiyona göre tarif edilir, mesela
$\Phi(x,y)$'nin kesit seviyesi. Bu seviye $\Phi(x,y) = 0$ olabilir, yani
$\Phi(x,y)$'nin sýfýrdaki kesit seviyesine bakabiliriz.

Kesitleri üç boyutlu yüzey üzerinde yapýlan yatay kesitler olarak
düþünebiliriz. Üç boyutlu fonksiyonun o yatay düzlem üzerindeki hali, yansýmasý
bu kesittir. Birden fazla kesiti farklý kontur renkleri ile gösterebilirdik.
Mesela yeryüzeyi $x,y$ kordinatlarýndaki yükseklik (daðlar) verisini konturlar
olarak göstermek klasik bir topografi tekniðidir. Yapay bir veri üzerinde
görelim, $x,y$ ve yükseklik deyince üç boyutlu bir fonksiyondan bahsediyoruz,
onun ayrýksal halini mesela 10x10 boyutunda bir matris ile
gösterebiliriz. Formül

$$\Phi(x,y) = \exp \left( -2 \log(2) ((x-x_0)^2 + (y-y_0)^2) / s^2 \right) $$

\begin{minted}[fontsize=\footnotesize]{python}
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm

def Phi(x, y):
    s = 1.5; x1 = 5.0; y1 = 5.0
    g = np.exp( -2 *np.log(2) * ((x-x1)**2+(y-y1)**2) / s**2)
    return g
  
D = 10
x = np.linspace(0,10,D)
y = np.linspace(0,10,D)
xx,yy = np.meshgrid(x,y)
zz = Phi(xx,yy)

fig = plt.figure()
ax = fig.gca(projection='3d')
surf = ax.plot_surface(xx, yy, zz, cmap=cm.coolwarm,
                       linewidth=0, antialiased=False)
plt.savefig('2_11_02.png')

plt.figure()
contours = [0.1, 0.2, 0.3]
cs=plt.contour(xx,yy,zz,contours)
plt.clabel(cs,inline=1,fontsize=9)
plt.savefig('2_11_03.png')
\end{minted}

\includegraphics[width=20em]{2_11_02.png}
\includegraphics[width=20em]{2_11_03.png}

Tam ortasýna bir tepe koyduk, bir analitik fonksiyon kulladik ama bunu rahatlýk
amacýyla yaptýk, elle bazý deðerleri matriste gerekli yerlere direk koysak ayný
sonucu elde ederdik. Üstteki matrisin deðerlerini basarsak mesela þuna benzer,

\begin{minted}[fontsize=\footnotesize]{python}
np.set_printoptions(precision=3,suppress=True)
print (zz)
\end{minted}

\begin{verbatim}
[[0.    0.    0.    0.    0.    0.    0.    0.    0.    0.   ]
 [0.    0.    0.    0.002 0.005 0.005 0.002 0.    0.    0.   ]
 [0.    0.    0.005 0.026 0.062 0.062 0.026 0.005 0.    0.   ]
 [0.    0.002 0.026 0.146 0.343 0.343 0.146 0.026 0.002 0.   ]
 [0.    0.005 0.062 0.343 0.807 0.807 0.343 0.062 0.005 0.   ]
 [0.    0.005 0.062 0.343 0.807 0.807 0.343 0.062 0.005 0.   ]
 [0.    0.002 0.026 0.146 0.343 0.343 0.146 0.026 0.002 0.   ]
 [0.    0.    0.005 0.026 0.062 0.062 0.026 0.005 0.    0.   ]
 [0.    0.    0.    0.002 0.005 0.005 0.002 0.    0.    0.   ]
 [0.    0.    0.    0.    0.    0.    0.    0.    0.    0.   ]]
\end{verbatim}

Kontur grafiðinde üç tane konturu gösterdik, \verb!contours! deðiþkeni
listesinde tanýmlý.

Derse dönelim. Yani kesit seviyeleri bir eðriyi dolaylý (implicitely) tanýmlamýþ
oluyor. Ýki boyutlu bir eðriyi bir sürü nokta üzerinden tanýmlamak yerine, üç
boyutlu bir yüzeyin bir kesit üzerindeki yansýmasý üzerinden tanýmlýyoruz, yani
$\Phi(x,y) = 0$ gibi. Yani bir eðri, $\Phi(x,y) = 0$ denklemini {\em çözen}
$x,y$ deðerleri oluyor.

Basit bir örnek üzerinde görürsek, mesela $\Phi(x,y) = x^2 + y^2$. Bu
fonksiyonun kesit seviyelerini nasýl alýrým? $\Phi$'yi bir sabite eþitleyerek bu
seviyeleri elde edebilirim, $\Phi(x,y) = x^2 + y^2 = c$. $c$ pozitif olduðunda
elde edilen sonuçlar çember olacaktýr tabii, bu formül klasik, ünlü bir formül.

Üç boyutta $z=\Phi(x,y)$ $x,y,z$ kordinatýnda bir yüzeydir, bir kap þekli, onu
$z=c$ düzlemi ile kesersek o düzleme yansýyan eðri kesit seviyesi, bir
çember. Onu $x,y$ düzlemine indirirsek orada da bir çember görürüz. 

\includegraphics[width=20em]{2_11_04.jpg}

Kesit seviyelerin önemli bir avantajý üç boyuttaki tek fonksiyonu manipüle
etmeye izin vermesi, bu rahat, tek $\Phi$ ile mesela iki tane ayrý çember elde
edebilirdim.

\includegraphics[width=20em]{2_11_05.jpg}

Eðriyi ilerletmek için gradyan yönünü seçiyoruz. Bu yön eðrinin birim normali,

$$
\vec{n} = \frac{\grad \Phi}{|\grad \Phi|}
$$

Gradyanýn 1 olduðu özel durum için, yani $|\grad \Phi| = 1$, üstteki formül
basitleþir.

Eðrinin hareketini tanýmlayan bir diðer faktör eðriye etki eden hýz alaný, yani
$v$. Bu alan her $x,y$ noktasýnda tanýmlý $v(x,y)$ olarak gösterilebilir. Hepsi
bir arada olursa,

$$
\frac{\partial \Phi}{\partial t} + v \cdot \grad \Phi = 0 
\mlabel{1}
$$

Üstteki formülasyonun detaylý türetilmesi için bkz [3].

$v$ bir alandýr, her $x,y$ için farklý olabilir. $\Phi$'nin bir fonksiyonu da
olabilir. Yani hýz eðrinin ne durumda olduðuyla baðlantýlý olabilir, Çoðunlukla
$v$ mesela eðrinin kavisliliðine (curvature) baðlantýlandýrýlýr.

(1)'i þu þekilde tekrar yazarsak,

$$
\frac{\partial \Phi}{\partial t} + v \cdot
\frac{\grad \Phi}{|\grad \Phi|} |\grad \Phi| = 0 
$$

$\grad \Phi/|\grad \Phi|$ ifadesi egrinin normali $\vec{n}$, o zaman 

$$
\frac{\partial \Phi}{\partial t} + v \cdot n |\grad \Phi| = 0 
$$

elde ediyoruz, $v \cdot n$'e yeni bir isim verebilirim, ona hýz diyelim. Normal
yöndeki hýz, $F$, ve $\grad$ yerine $\nabla$ kullanýrsak,

$$
\frac{\partial \Phi}{\partial t} + F |\nabla \Phi| = 0 
$$

Bu hýz normal yöndedir. Ünlü kesit seviyesi formülü budur. Eðer $F$ sabit ise
biraz önce bahsettiðimiz yangýnýn yayýlma durumu ortaya çýkar. Ateþ bildiðimiz
gibi yakabildiði her yere gitmek ister, sürekli ileri doðru ilerler. $F$'nin
illa sabit olmasý gerekmez, $\nabla \Phi$'nin bir fonksiyonu bile olabilir, o
zaman onu $F(\nabla \Phi)$ yapardým. Mesela

$$
\kappa = \mdiv \left( \frac{\grad \Phi}{|\grad \Phi|} \right)
$$

Bu bir $F(\nabla \Phi)$ örneði, $\nabla \Phi$'nin bir fonksiyonu. Lineer deðil
doðal olarak, gayrý lineer iþlemler var.

Üstteki formül eðrinin kavisliliðiyle bir alaka kuruyor. Kavislilik üzerinden
eðri hareketi ilginç bir þey; mesela bir elipsi düþünelim, ve hareket içeri
doðru olsun.

\includegraphics[width=15em]{2_11_06.jpg}

Elipsin üst, kavisin daha az olduðu yerlerde içeri hareket (hýzý) daha az, çok
olduðu yerlerde daha fazla ise, o zaman deðiþim ardýndan bir çembere
ulaþýlacaktýr. Hatta aslýnda hangi ilk þekilden baþlarsak baþlayalým, gidiþat
ayný þekilde mükemmel bir çembere doðru olacaktýr.

Þimdiye kadar gördüklerimiz kesit seviyeleri. Bu denklemlerin bir de hesapsal
olarak sonlu farklar (finite difference) yöntemiyle çözüm formülleri var. Bu
formüller oldukca çetrefil. 

Þimdi hýzlý marþ (fast marching) kouþuna gelelim. Hýzlý marþ eðri ilerletmenin
çok hýzlý bir çözümü olduðu durumlar için. Çünkü bu özel durumda ``dalga'' on
kýsmý hep ayný þekilde ilerliyor. F'nin iþareti hiç deðiþmiyor, yani hareket hep
ayný genel yönde. Bu durumda kesit seviyeleri formülü, sonlu farklar hesabý
yerine hýzlý marþ yöntemi kullanýlabiliyor, çünkü çok farklý hareket þekli yok,
eðri gelip kendi üstüne dönemiyor, vs.

Hýzlý mars yöntemi aslýnda geliþ zamaný bazlý baþka bir formülasyonu
çözüyor.

$$
|\nabla T| F = 1
$$

Eðer $T(x,y)$ fonksiyonunu yayýlan dalga önünün $x,y$ noktasýna geliþ zamanýný
temsil ettiðini düþünürsek, tek boyutta katedilen mesafe $x = F T$, bu basit bir
mesafe eþittir hýz çarpý zaman sonucu. Mesafeye göre türev alýrsak,

$$
1 = F \frac{\ud T}{\ud x}
$$

Çok boyuttaki $\nabla T$ kullanýlabilir, çünkü gradyan $T$'nin kesit
seviyelerine dikgendir. O zaman

$$ \frac{1}{F} = |\nabla T| $$

denebilir. ya da 

$$ |\nabla T| T = 1$$

Hýzlý marþý nasýl kodlarým? Eðri ilerleme hesabýný eðriden ileri gidiþin
mesafesi hesabýna çevirebilirim. Eðriyi için alacak þekilde bir izgara
yaratabilirim,

\includegraphics[width=15em]{2_11_07.jpg}

Bu ýzgarayý baz alarak eðriye olan bir uzaklýðýn fonksiyonu $d(x,y)$'i bulmak
istiyorum. Eðri içini hesaba katalým, orada eðriden geriye bir uzaklýk olacak,
orada eksi, dýþarýda artý.

Uzaklýðý her izgara köþesi için hesaplamak istersem, ne yaparým?










[devam edecek]

Altta kýsayol bulmak için hýzlý marþ yöntemini görüyoruz, kod [1,2]'yi baz aldý. 

\begin{minted}[fontsize=\footnotesize]{python}
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy import ndimage
import util

def perform_fm(W, pstart, niter=np.inf, bound='sym', svg_rate=10):
    n = W.shape[0]
    neigh = np.array([[1, -1, 0, 0], [0, 0,  1, -1]])

    def symmetrize(x,n):
        if (x<0):
            x = -x;
        elif (x>=n):
            x = 2*(n-1)-x
        return x

    if bound=='per':
        boundary = lambda x: np.mod(x,n)
    else:
        boundary = lambda x: [symmetrize(x[0],n), symmetrize(x[1],n)] # todo

    ind2sub1 = lambda k: [int( (k-np.fmod(k,n))/n ), np.fmod(k,n)]
    sub2ind1 = lambda u: int( u[0]*n + u[1] )
    Neigh = lambda k,i: sub2ind1(boundary(ind2sub1(k) + neigh[:,i]))
    extract   = lambda x,I: x[I]
    extract1d = lambda x,I: extract(x.flatten(),I)

    nstart = pstart.shape[1]
    I = list( np.zeros( (nstart, 1) ) )
    for i in np.arange(0, nstart):
        I[i] = int( sub2ind1(pstart[:,i]) )

    D = np.zeros( (n,n) ) + np.inf # current distance
    for i in np.arange(0, nstart):
        D[pstart[0,i],pstart[1,i]] = 0

    S = np.zeros( (n,n) )
    for i in np.arange(0, nstart):
        S[pstart[0,i],pstart[1,i]] = 1 # open

    iter = 0
    q = 100  # maximum number of saves
    Dsvg = np.zeros( (n,n,q) )
    Ssvg = np.zeros( (n,n,q) )
    while ( not(I==[]) & (iter<=niter) ):
        iter = iter+1;
        if iter==niter:
            break
        j = np.argsort( extract1d(D,I)  )
        if np.ndim(j)==0:
            j = [j]
        j = j[0]
        i = I[j]
        a = I.pop(j)
        u = ind2sub1(i);
        S[u[0],u[1]] = -1
        J = []
        for k in np.arange(0,4):
            j = Neigh(i,k)
            if extract1d(S,j)!=-1:
                J.append(j)
                if extract1d(S,j)==0:
                    u = ind2sub1(j)
                    S[u[0],u[1]] = 1
                    I.append(j)
        DNeigh = lambda D,k: extract1d(D,Neigh(j,k))
        for j in J:
            dx = min(DNeigh(D,0), DNeigh(D,1))
            dy = min(DNeigh(D,2), DNeigh(D,3))
            u = ind2sub1(j)
            w = extract1d(W,j);
            Delta = 2*w - (dx-dy)**2
            if (Delta>=0):
                D[u[0],u[1]] = (dx + dy + np.sqrt(Delta))/ 2
            else:
                D[u[0],u[1]] = min(dx + w, dy + w)
        t = iter/svg_rate
        if (np.mod(iter,svg_rate)==0) & (t<q):
            print (t)
            Dsvg[:,:,int(t-1)] = D
            Ssvg[:,:,int(t-1)] = S

    Dsvg = Dsvg[:,:,:int(t-1)]
    Ssvg = Ssvg[:,:,:int(t-1)]
    return (D,Dsvg,Ssvg);
\end{minted}

\begin{minted}[fontsize=\footnotesize]{python}
def exo2(x0,W):
    n = W.shape[0]
    pstart = np.transpose(np.array([x0]))
    [D,Dsvg,Ssvg] = perform_fm(W, pstart, np.inf, 'sym',n*6)
    plt.figure();
    for i in np.arange(0,4):
        plt.subplot(2, 2, i+1)
        d = Dsvg[:,:,i]
        d[d==np.inf] = 0
        util.imageplot(d)
        plt.set_cmap('jet')        
    plt.savefig('out-450.png')
    return D
  
n = 40
W = np.ones( (n,n) )
x0 = [int(n/2), int(n/2)]

D = exo2(x0,W)

plt.figure()
displ = lambda D: np.cos(2*np.pi*5*D/np.max(D.flatten()) )
util.imageplot(displ(D))
plt.savefig('out-480.png')
\end{minted}

\begin{verbatim}
1.0
2.0
3.0
4.0
5.0
6.0
\end{verbatim}

\includegraphics[width=20em]{out-450.png}

\includegraphics[width=20em]{out-480.png}


\begin{minted}[fontsize=\footnotesize]{python}
def exo3(x0,W):
    n = W.shape[0]
    pstart = np.transpose(np.array([x0]))
    [D,Dsvg,Ssvg] = perform_fm(W, pstart, np.inf, 'sym',n*6)
    # display
    k = 8
    displ = lambda D: np.cos(2*np.pi*k*D / np.max(D.flatten()))
    plt.figure()
    util.imageplot(displ(D))
    plt.set_cmap('jet')
    plt.savefig('out-560.png')
    return D


n = 100
x = np.linspace(-1, 1, n)
[Y, X] = np.meshgrid(x, x)
sigma = .2
W = 1 + 8 * np.exp(-(X**2 + Y**2)/ (2*sigma**2))
util.imageplot(W)
plt.savefig('out-520.png')

x0 = [round(.1*n), round(.1*n)]
res = exo3(x0,W)
\end{minted}

\begin{verbatim}
1.0
2.0
3.0
4.0
5.0
6.0
7.0
8.0
9.0
10.0
11.0
12.0
13.0
14.0
15.0
16.0
\end{verbatim}

\includegraphics[width=20em]{out-520.png}

\includegraphics[width=20em]{out-560.png}

\begin{minted}[fontsize=\footnotesize]{python}
def exo4(tau,x0,x1,G):
    n = G.shape[0]
    Geval = lambda G,x: util.bilinear_interpolate(G[:,:,0], np.imag(x), np.real(x) ) + 1j * util.bilinear_interpolate(G[:,:,1],np.imag(x), np.real(x))
    niter = 1.5*n/tau;
    # init gamma
    gamma = [x1]
    xtgt = x0[0] + 1j*x0[1]
    for i in np.arange(0,niter):
        g = Geval(G, gamma[-1] )
        gamma.append( gamma[-1] - tau*g )
        if abs(gamma[-1]-xtgt)<1:
            break
    gamma.append( xtgt )
    return gamma
  
n = 100
x = np.linspace(-1, 1, n)
[Y, X] = np.meshgrid(x, x)
sigma = .2
W = 1 + 8 * np.exp(-(X**2 + Y**2)/ (2*sigma**2))
x0 = [round(.1*n), round(.1*n)]
D = exo3(x0,W)

G0 = util.grad(D)
d = np.sqrt(np.sum(G0**2, axis=2))
U = np.zeros((n,n,2))
U[:,:,0] = d
U[:,:,1] = d
G = G0 / U
tau = .8
x1 = round(.9*n) + 1j*round(.88*n)
gamma = [x1]

Geval = lambda G,x: util.bilinear_interpolate(G[:,:,0], np.imag(x), np.real(x) ) + 1j * util.bilinear_interpolate(G[:,:,1],np.imag(x), np.real(x))
g = Geval(G, gamma[-1] )
gamma.append( gamma[-1] - tau*g )
gamma = exo4(tau,x0,x1,G)

util.imageplot(W) 
plt.set_cmap('gray')
h = plt.plot(np.imag(gamma), np.real(gamma), '.b', linewidth=2)
h = plt.plot(x0[1], x0[0], '.r', markersize=20)
h = plt.plot(np.imag(x1), np.real(x1), '.g', markersize=20)
plt.savefig('out-760.png')
\end{minted}

\begin{verbatim}
1.0
2.0
3.0
4.0
5.0
6.0
7.0
8.0
9.0
10.0
11.0
12.0
13.0
14.0
15.0
16.0
\end{verbatim}

\includegraphics[width=20em]{out-760.png}




Kaynaklar

[1] Peyre, {\em Dijkstra and Fast Marching Algorithms},
\url{https://nbviewer.jupyter.org/github/gpeyre/numerical-tours/blob/master/python/fastmarching_0_implementing.ipynb}

[2] Peyre, \url{https://github/gpeyre/numerical-tours}

[3] Bayramli, Kýsmi Türevsel Denklemler, {\em Kesit Seviyeleri}

\end{document}
