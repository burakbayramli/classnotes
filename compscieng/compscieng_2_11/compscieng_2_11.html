<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Ders 2.11</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="ders-2.11">Ders 2.11</h1>
<p>Konumuz kesit seviyeleri (level sets). Bu alanda Sethian ve Osher
otorite sayılıyor, 80’li yıllarda yayınladıkları makale ve kitaplarda
konuyu etraflıca işlediler.</p>
<p>Elimizde bir eğri var diyelim (altta resimde <span
class="math inline">\(t=0\)</span> anındaki)</p>
<p><img src="2_11_01.jpg" /></p>
<p>ve bu “arayüz (interface)’’ ya da duvar, bu eğri hareket ediyor.
İlerliyor. Bu ilerlemenin kendi normali (yani eğrinin her noktasındaki
teğetine dik) yönünde olduğunu düşünelim. Bu ilerleme şeklini biz empoze
ediyoruz, sonra formüllerin buna göre nasıl şekillendiğini göreceğiz. Bu
ilerleme sonunda mesela <span class="math inline">\(t=0\)</span>’da
görülen şekilden <span class="math inline">\(t=1\)</span>’deki şekle
gelinmiş olacak. En ideal şartlarda hızın hiçbir noktada değişmediğini
düşünebiliriz, yani hız sabit. O zaman birim zamanda sabit hızda
(diyelim o da 1), mesafe 1 katedilmiş olur.</p>
<p>Eğrinin nasıl tarif edildiği anahtar. Eğriyi, o eğri üzerindeki belli
yerlerde noktalar üzerinden mi temsil etsem? Ki o her nokta bir
bilinmeyen / değişkenle genel formüle dahil edilse? O noktaların her
birinde ayrı bir normal diferansiyel denklem (ordinary differential
eqution) olabilirdi, o denklemi takip ederek bir sonraki noktaya
gidebilirdim, vs. </p>
<p>Fakat kesit seviyeleri böyle işlemiyor. Hatta ilk akla gelen (gayet
doğal)parçacıklı üstteki fikir sayısal hesaplarda çabucak bazı engellere
tosluyor. Mesela üstteki resimdeki örnek idealdi dedik, parçacıklar
<span class="math inline">\(t=1\)</span>’da biraz yayılırlar, çok değil,
ama çok yayılıyor da olabilirlerdi. Ya da ters yönde eğime göre noktalar
aynı noktada toplanabilirdi, bu sayısal hesabı iyice bozardı çünkü
noktalar üst üste binerdi, aradaki farkları doğru dürüst
hesaplayamazdık.</p>
<p>Peki o zaman kesit seviyeleri bu problemleri nasıl çözüyor? Ondan
önce kesit seviyesi nedir? Kesit seviyesi bir ana fonksiyona göre tarif
edilir, mesela <span class="math inline">\(\Phi(x,y)\)</span>’nin kesit
seviyesi. Bu seviye <span class="math inline">\(\Phi(x,y) = 0\)</span>
olabilir, yani <span class="math inline">\(\Phi(x,y)\)</span>’nin
sıfırdaki kesit seviyesine bakabiliriz.</p>
<p>Kesitleri üç boyutlu yüzey üzerinde yapılan yatay kesitler olarak
düşünebiliriz. Üç boyutlu fonksiyonun o yatay düzlem üzerindeki hali,
yansıması bu kesittir. Birden fazla kesiti farklı kontur renkleri ile
gösterebilirdik. Mesela yeryüzeyi <span
class="math inline">\(x,y\)</span> kordinatlarındaki yükseklik (dağlar)
verisini konturlar olarak göstermek klasik bir topografi tekniğidir.
Yapay bir veri üzerinde görelim, <span
class="math inline">\(x,y\)</span> ve yükseklik deyince üç boyutlu bir
fonksiyondan bahsediyoruz, onun ayrıksal halini mesela 10x10 boyutunda
bir matris ile gösterebiliriz. Formül</p>
<p><span class="math display">\[\Phi(x,y) = \exp \left( -2 \log(2)
((x-x_0)^2 + (y-y_0)^2) / s^2 \right) \]</span></p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpl_toolkits.mplot3d <span class="im">import</span> Axes3D</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> cm</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Phi(x, y):</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> <span class="fl">1.5</span><span class="op">;</span> x1 <span class="op">=</span> <span class="fl">5.0</span><span class="op">;</span> y1 <span class="op">=</span> <span class="fl">5.0</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    g <span class="op">=</span> np.exp( <span class="op">-</span><span class="dv">2</span> <span class="op">*</span>np.log(<span class="dv">2</span>) <span class="op">*</span> ((x<span class="op">-</span>x1)<span class="op">**</span><span class="dv">2</span><span class="op">+</span>(y<span class="op">-</span>y1)<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> s<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> g</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">10</span>,D)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">10</span>,D)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>xx,yy <span class="op">=</span> np.meshgrid(x,y)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>zz <span class="op">=</span> Phi(xx,yy)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>surf <span class="op">=</span> ax.plot_surface(xx, yy, zz, cmap<span class="op">=</span>cm.coolwarm,</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>                       linewidth<span class="op">=</span><span class="dv">0</span>, antialiased<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;2_11_02.png&#39;</span>)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>plt.figure()</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>contours <span class="op">=</span> [<span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.3</span>]</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>cs<span class="op">=</span>plt.contour(xx,yy,zz,contours)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>plt.clabel(cs,inline<span class="op">=</span><span class="dv">1</span>,fontsize<span class="op">=</span><span class="dv">9</span>)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;2_11_03.png&#39;</span>)</span></code></pre></div>
<p><img src="2_11_02.png" /> <img src="2_11_03.png" /></p>
<p>Tam ortasına bir tepe koyduk, bir analitik fonksiyon kulladik ama
bunu rahatlık amacıyla yaptık, elle bazı değerleri matriste gerekli
yerlere direk koysak aynı sonucu elde ederdik. Üstteki matrisin
değerlerini basarsak mesela şuna benzer,</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>np.set_printoptions(precision<span class="op">=</span><span class="dv">3</span>,suppress<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (zz)</span></code></pre></div>
<pre><code>[[0.    0.    0.    0.    0.    0.    0.    0.    0.    0.   ]
 [0.    0.    0.    0.002 0.005 0.005 0.002 0.    0.    0.   ]
 [0.    0.    0.005 0.026 0.062 0.062 0.026 0.005 0.    0.   ]
 [0.    0.002 0.026 0.146 0.343 0.343 0.146 0.026 0.002 0.   ]
 [0.    0.005 0.062 0.343 0.807 0.807 0.343 0.062 0.005 0.   ]
 [0.    0.005 0.062 0.343 0.807 0.807 0.343 0.062 0.005 0.   ]
 [0.    0.002 0.026 0.146 0.343 0.343 0.146 0.026 0.002 0.   ]
 [0.    0.    0.005 0.026 0.062 0.062 0.026 0.005 0.    0.   ]
 [0.    0.    0.    0.002 0.005 0.005 0.002 0.    0.    0.   ]
 [0.    0.    0.    0.    0.    0.    0.    0.    0.    0.   ]]</code></pre>
<p>Kontur grafiğinde üç tane konturu gösterdik, <code>contours</code>
değişkeni listesinde tanımlı.</p>
<p>Derse dönelim. Yani kesit seviyeleri bir eğriyi dolaylı (implicitely)
tanımlamış oluyor. İki boyutlu bir eğriyi bir sürü nokta üzerinden
tanımlamak yerine, üç boyutlu bir yüzeyin bir kesit üzerindeki yansıması
üzerinden tanımlıyoruz, yani <span class="math inline">\(\Phi(x,y) =
0\)</span> gibi. Yani bir eğri, <span class="math inline">\(\Phi(x,y) =
0\)</span> denklemini <em>çözen</em> <span
class="math inline">\(x,y\)</span> değerleri oluyor.</p>
<p>Basit bir örnek üzerinde görürsek, mesela <span
class="math inline">\(\Phi(x,y) = x^2 + y^2\)</span>. Bu fonksiyonun
kesit seviyelerini nasıl alırım? <span
class="math inline">\(\Phi\)</span>’yi bir sabite eşitleyerek bu
seviyeleri elde edebilirim, <span class="math inline">\(\Phi(x,y) = x^2
+ y^2 = c\)</span>. <span class="math inline">\(c\)</span> pozitif
olduğunda elde edilen sonuçlar çember olacaktır tabii, bu formül klasik,
ünlü bir formül.</p>
<p>Üç boyutta <span class="math inline">\(z=\Phi(x,y)\)</span> <span
class="math inline">\(x,y,z\)</span> kordinatında bir yüzeydir, bir kap
şekli, onu <span class="math inline">\(z=c\)</span> düzlemi ile kesersek
o düzleme yansıyan eğri kesit seviyesi, bir çember. Onu <span
class="math inline">\(x,y\)</span> düzlemine indirirsek orada da bir
çember görürüz.</p>
<p><img src="2_11_04.jpg" /></p>
<p>Kesit seviyelerin önemli bir avantajı üç boyuttaki tek fonksiyonu
manipüle etmeye izin vermesi, bu rahat, tek <span
class="math inline">\(\Phi\)</span> ile mesela iki tane ayrı çember elde
edebilirdim.</p>
<p><img src="2_11_05.jpg" /></p>
<p>Eğriyi ilerletmek için gradyan yönünü seçiyoruz. Bu yön eğrinin birim
normali,</p>
<p><span class="math display">\[
\vec{n} = \frac{\mathrm{grad} \Phi}{|\mathrm{grad} \Phi|}
\]</span></p>
<p>Gradyanın 1 olduğu özel durum için, yani <span
class="math inline">\(|\mathrm{grad} \Phi| = 1\)</span>, üstteki formül
basitleşir.</p>
<p>Eğrinin hareketini tanımlayan bir diğer faktör eğriye etki eden hız
alanı, yani <span class="math inline">\(v\)</span>. Bu alan her <span
class="math inline">\(x,y\)</span> noktasında tanımlı <span
class="math inline">\(v(x,y)\)</span> olarak gösterilebilir. Hepsi bir
arada olursa,</p>
<p><span class="math display">\[
\frac{\partial \Phi}{\partial t} + v \cdot \mathrm{grad} \Phi = 0
\qquad (1)
\]</span></p>
<p>Üstteki formülasyonun detaylı türetilmesi için bkz [3].</p>
<p><span class="math inline">\(v\)</span> bir alandır, her <span
class="math inline">\(x,y\)</span> için farklı olabilir. <span
class="math inline">\(\Phi\)</span>’nin bir fonksiyonu da olabilir. Yani
hız eğrinin ne durumda olduğuyla bağlantılı olabilir, Çoğunlukla <span
class="math inline">\(v\)</span> mesela eğrinin kavisliliğine
(curvature) bağlantılandırılır.</p>
<p>(1)’i şu şekilde tekrar yazarsak,</p>
<p><span class="math display">\[
\frac{\partial \Phi}{\partial t} + v \cdot
\frac{\mathrm{grad} \Phi}{|\mathrm{grad} \Phi|} |\mathrm{grad} \Phi| = 0
\]</span></p>
<p><span class="math inline">\(\mathrm{grad} \Phi/|\mathrm{grad}
\Phi|\)</span> ifadesi egrinin normali <span
class="math inline">\(\vec{n}\)</span>, o zaman</p>
<p><span class="math display">\[
\frac{\partial \Phi}{\partial t} + v \cdot n |\mathrm{grad} \Phi| = 0
\]</span></p>
<p>elde ediyoruz, <span class="math inline">\(v \cdot n\)</span>’e yeni
bir isim verebilirim, ona hız diyelim. Normal yöndeki hız, <span
class="math inline">\(F\)</span>, ve <span
class="math inline">\(\mathrm{grad}\)</span> yerine <span
class="math inline">\(\nabla\)</span> kullanırsak,</p>
<p><span class="math display">\[
\frac{\partial \Phi}{\partial t} + F |\nabla \Phi| = 0
\]</span></p>
<p>Bu hız normal yöndedir. Ünlü kesit seviyesi formülü budur. Eğer <span
class="math inline">\(F\)</span> sabit ise biraz önce bahsettiğimiz
yangının yayılma durumu ortaya çıkar. Ateş bildiğimiz gibi yakabildiği
her yere gitmek ister, sürekli ileri doğru ilerler. <span
class="math inline">\(F\)</span>’nin illa sabit olması gerekmez, <span
class="math inline">\(\nabla \Phi\)</span>’nin bir fonksiyonu bile
olabilir, o zaman onu <span class="math inline">\(F(\nabla
\Phi)\)</span> yapardım. Mesela</p>
<p><span class="math display">\[
\kappa = \mathrm{div} \left( \frac{\mathrm{grad} \Phi}{|\mathrm{grad}
\Phi|} \right)
\]</span></p>
<p>Bu bir <span class="math inline">\(F(\nabla \Phi)\)</span> örneği,
<span class="math inline">\(\nabla \Phi\)</span>’nin bir fonksiyonu.
Lineer değil doğal olarak, gayrı lineer işlemler var.</p>
<p>Üstteki formül eğrinin kavisliliğiyle bir alaka kuruyor. Kavislilik
üzerinden eğri hareketi ilginç bir şey; mesela bir elipsi düşünelim, ve
hareket içeri doğru olsun.</p>
<p><img src="2_11_06.jpg" /></p>
<p>Elipsin üst, kavisin daha az olduğu yerlerde içeri hareket (hızı)
daha az, çok olduğu yerlerde daha fazla ise, o zaman değişim ardından
bir çembere ulaşılacaktır. Hatta aslında hangi ilk şekilden başlarsak
başlayalım, gidişat aynı şekilde mükemmel bir çembere doğru
olacaktır.</p>
<p>Şimdiye kadar gördüklerimiz kesit seviyeleri. Bu denklemlerin bir de
hesapsal olarak sonlu farklar (finite difference) yöntemiyle çözüm
formülleri var. Bu formüller oldukca çetrefil.</p>
<p>Şimdi hızlı marş (fast marching) kouşuna gelelim. Hızlı marş eğri
ilerletmenin çok hızlı bir çözümü olduğu durumlar için. Çünkü bu özel
durumda “dalga’’ on kısmı hep aynı şekilde ilerliyor. F’nin işareti hiç
değişmiyor, yani hareket hep aynı genel yönde. Bu durumda kesit
seviyeleri formülü, sonlu farklar hesabı yerine hızlı marş yöntemi
kullanılabiliyor, çünkü çok farklı hareket şekli yok, eğri gelip kendi
üstüne dönemiyor, vs.</p>
<p>Hızlı mars yöntemi aslında geliş zamanı bazlı başka bir formülasyonu
çözüyor.</p>
<p><span class="math display">\[
|\nabla T| F = 1
\]</span></p>
<p>Eğer <span class="math inline">\(T(x,y)\)</span> fonksiyonunu yayılan
dalga önünün <span class="math inline">\(x,y\)</span> noktasına geliş
zamanını temsil ettiğini düşünürsek, tek boyutta katedilen mesafe <span
class="math inline">\(x = F T\)</span>, bu basit bir mesafe eşittir hız
çarpı zaman sonucu. Mesafeye göre türev alırsak,</p>
<p><span class="math display">\[
1 = F \frac{\mathrm{d} T}{\mathrm{d} x}
\]</span></p>
<p>Çok boyuttaki <span class="math inline">\(\nabla T\)</span>
kullanılabilir, çünkü gradyan <span class="math inline">\(T\)</span>’nin
kesit seviyelerine dikgendir. O zaman</p>
<p><span class="math display">\[ \frac{1}{F} = |\nabla T| \]</span></p>
<p>denebilir. ya da</p>
<p><span class="math display">\[ |\nabla T| T = 1\]</span></p>
<p>Hızlı marşı nasıl kodlarım? Eğri ilerleme hesabını eğriden ileri
gidişin mesafesi hesabına çevirebilirim. Eğriyi için alacak şekilde bir
izgara yaratabilirim,</p>
<p><img src="2_11_07.jpg" /></p>
<p>Bu ızgarayı baz alarak eğriye olan bir uzaklığın fonksiyonu <span
class="math inline">\(d(x,y)\)</span>’i bulmak istiyorum. Eğri içini
hesaba katalım, orada eğriden geriye bir uzaklık olacak, orada eksi,
dışarıda artı.</p>
<p>Uzaklığı her izgara köşesi için hesaplamak istersem, ne yaparım?</p>
<p>Altta kısayol bulmak için hızlı marş yöntemini görüyoruz, kod
[1,2]’yi baz aldı.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> ndimage</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> util</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> perform_fm(W, pstart, niter<span class="op">=</span>np.inf, bound<span class="op">=</span><span class="st">&#39;sym&#39;</span>, svg_rate<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> W.shape[<span class="dv">0</span>]</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    neigh <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>]])</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> symmetrize(x,n):</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (x<span class="op">&lt;</span><span class="dv">0</span>):</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>            x <span class="op">=</span> <span class="op">-</span>x<span class="op">;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> (x<span class="op">&gt;=</span>n):</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>            x <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>(n<span class="op">-</span><span class="dv">1</span>)<span class="op">-</span>x</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> bound<span class="op">==</span><span class="st">&#39;per&#39;</span>:</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        boundary <span class="op">=</span> <span class="kw">lambda</span> x: np.mod(x,n)</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        boundary <span class="op">=</span> <span class="kw">lambda</span> x: [symmetrize(x[<span class="dv">0</span>],n), symmetrize(x[<span class="dv">1</span>],n)] <span class="co"># todo</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    ind2sub1 <span class="op">=</span> <span class="kw">lambda</span> k: [<span class="bu">int</span>( (k<span class="op">-</span>np.fmod(k,n))<span class="op">/</span>n ), np.fmod(k,n)]</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    sub2ind1 <span class="op">=</span> <span class="kw">lambda</span> u: <span class="bu">int</span>( u[<span class="dv">0</span>]<span class="op">*</span>n <span class="op">+</span> u[<span class="dv">1</span>] )</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    Neigh <span class="op">=</span> <span class="kw">lambda</span> k,i: sub2ind1(boundary(ind2sub1(k) <span class="op">+</span> neigh[:,i]))</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    extract   <span class="op">=</span> <span class="kw">lambda</span> x,I: x[I]</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    extract1d <span class="op">=</span> <span class="kw">lambda</span> x,I: extract(x.flatten(),I)</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    nstart <span class="op">=</span> pstart.shape[<span class="dv">1</span>]</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>    I <span class="op">=</span> <span class="bu">list</span>( np.zeros( (nstart, <span class="dv">1</span>) ) )</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> np.arange(<span class="dv">0</span>, nstart):</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>        I[i] <span class="op">=</span> <span class="bu">int</span>( sub2ind1(pstart[:,i]) )</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>    D <span class="op">=</span> np.zeros( (n,n) ) <span class="op">+</span> np.inf <span class="co"># current distance</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> np.arange(<span class="dv">0</span>, nstart):</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>        D[pstart[<span class="dv">0</span>,i],pstart[<span class="dv">1</span>,i]] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>    S <span class="op">=</span> np.zeros( (n,n) )</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> np.arange(<span class="dv">0</span>, nstart):</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>        S[pstart[<span class="dv">0</span>,i],pstart[<span class="dv">1</span>,i]] <span class="op">=</span> <span class="dv">1</span> <span class="co"># open</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>    <span class="bu">iter</span> <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>    q <span class="op">=</span> <span class="dv">100</span>  <span class="co"># maximum number of saves</span></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>    Dsvg <span class="op">=</span> np.zeros( (n,n,q) )</span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>    Ssvg <span class="op">=</span> np.zeros( (n,n,q) )</span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> ( <span class="kw">not</span>(I<span class="op">==</span>[]) <span class="op">&amp;</span> (<span class="bu">iter</span><span class="op">&lt;=</span>niter) ):</span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>        <span class="bu">iter</span> <span class="op">=</span> <span class="bu">iter</span><span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">iter</span><span class="op">==</span>niter:</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> np.argsort( extract1d(D,I)  )</span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> np.ndim(j)<span class="op">==</span><span class="dv">0</span>:</span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> [j]</span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> j[<span class="dv">0</span>]</span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> I[j]</span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> I.pop(j)</span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> ind2sub1(i)<span class="op">;</span></span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>        S[u[<span class="dv">0</span>],u[<span class="dv">1</span>]] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>        J <span class="op">=</span> []</span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> np.arange(<span class="dv">0</span>,<span class="dv">4</span>):</span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> Neigh(i,k)</span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> extract1d(S,j)<span class="op">!=-</span><span class="dv">1</span>:</span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a>                J.append(j)</span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> extract1d(S,j)<span class="op">==</span><span class="dv">0</span>:</span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a>                    u <span class="op">=</span> ind2sub1(j)</span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a>                    S[u[<span class="dv">0</span>],u[<span class="dv">1</span>]] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a>                    I.append(j)</span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a>        DNeigh <span class="op">=</span> <span class="kw">lambda</span> D,k: extract1d(D,Neigh(j,k))</span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> J:</span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a>            dx <span class="op">=</span> <span class="bu">min</span>(DNeigh(D,<span class="dv">0</span>), DNeigh(D,<span class="dv">1</span>))</span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a>            dy <span class="op">=</span> <span class="bu">min</span>(DNeigh(D,<span class="dv">2</span>), DNeigh(D,<span class="dv">3</span>))</span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a>            u <span class="op">=</span> ind2sub1(j)</span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a>            w <span class="op">=</span> extract1d(W,j)<span class="op">;</span></span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a>            Delta <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>w <span class="op">-</span> (dx<span class="op">-</span>dy)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (Delta<span class="op">&gt;=</span><span class="dv">0</span>):</span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true" tabindex="-1"></a>                D[u[<span class="dv">0</span>],u[<span class="dv">1</span>]] <span class="op">=</span> (dx <span class="op">+</span> dy <span class="op">+</span> np.sqrt(Delta))<span class="op">/</span> <span class="dv">2</span></span>
<span id="cb4-76"><a href="#cb4-76" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb4-77"><a href="#cb4-77" aria-hidden="true" tabindex="-1"></a>                D[u[<span class="dv">0</span>],u[<span class="dv">1</span>]] <span class="op">=</span> <span class="bu">min</span>(dx <span class="op">+</span> w, dy <span class="op">+</span> w)</span>
<span id="cb4-78"><a href="#cb4-78" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> <span class="bu">iter</span><span class="op">/</span>svg_rate</span>
<span id="cb4-79"><a href="#cb4-79" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (np.mod(<span class="bu">iter</span>,svg_rate)<span class="op">==</span><span class="dv">0</span>) <span class="op">&amp;</span> (t<span class="op">&lt;</span>q):</span>
<span id="cb4-80"><a href="#cb4-80" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span> (t)</span>
<span id="cb4-81"><a href="#cb4-81" aria-hidden="true" tabindex="-1"></a>            Dsvg[:,:,<span class="bu">int</span>(t<span class="op">-</span><span class="dv">1</span>)] <span class="op">=</span> D</span>
<span id="cb4-82"><a href="#cb4-82" aria-hidden="true" tabindex="-1"></a>            Ssvg[:,:,<span class="bu">int</span>(t<span class="op">-</span><span class="dv">1</span>)] <span class="op">=</span> S</span>
<span id="cb4-83"><a href="#cb4-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-84"><a href="#cb4-84" aria-hidden="true" tabindex="-1"></a>    Dsvg <span class="op">=</span> Dsvg[:,:,:<span class="bu">int</span>(t<span class="op">-</span><span class="dv">1</span>)]</span>
<span id="cb4-85"><a href="#cb4-85" aria-hidden="true" tabindex="-1"></a>    Ssvg <span class="op">=</span> Ssvg[:,:,:<span class="bu">int</span>(t<span class="op">-</span><span class="dv">1</span>)]</span>
<span id="cb4-86"><a href="#cb4-86" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (D,Dsvg,Ssvg)<span class="op">;</span></span></code></pre></div>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> exo2(x0,W):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> W.shape[<span class="dv">0</span>]</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    pstart <span class="op">=</span> np.transpose(np.array([x0]))</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    [D,Dsvg,Ssvg] <span class="op">=</span> perform_fm(W, pstart, np.inf, <span class="st">&#39;sym&#39;</span>,n<span class="op">*</span><span class="dv">6</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    plt.figure()<span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> np.arange(<span class="dv">0</span>,<span class="dv">4</span>):</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        plt.subplot(<span class="dv">2</span>, <span class="dv">2</span>, i<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        d <span class="op">=</span> Dsvg[:,:,i]</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        d[d<span class="op">==</span>np.inf] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        util.imageplot(d)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        plt.set_cmap(<span class="st">&#39;jet&#39;</span>)        </span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    plt.savefig(<span class="st">&#39;out-450.png&#39;</span>)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> D</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">40</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>W <span class="op">=</span> np.ones( (n,n) )</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>x0 <span class="op">=</span> [<span class="bu">int</span>(n<span class="op">/</span><span class="dv">2</span>), <span class="bu">int</span>(n<span class="op">/</span><span class="dv">2</span>)]</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> exo2(x0,W)</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>plt.figure()</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>displ <span class="op">=</span> <span class="kw">lambda</span> D: np.cos(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span><span class="dv">5</span><span class="op">*</span>D<span class="op">/</span>np.<span class="bu">max</span>(D.flatten()) )</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>util.imageplot(displ(D))</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;out-480.png&#39;</span>)</span></code></pre></div>
<pre><code>1.0
2.0
3.0
4.0
5.0
6.0</code></pre>
<p><img src="out-450.png" /></p>
<p><img src="out-480.png" /></p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> exo3(x0,W):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> W.shape[<span class="dv">0</span>]</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    pstart <span class="op">=</span> np.transpose(np.array([x0]))</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    [D,Dsvg,Ssvg] <span class="op">=</span> perform_fm(W, pstart, np.inf, <span class="st">&#39;sym&#39;</span>,n<span class="op">*</span><span class="dv">6</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># display</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> <span class="dv">8</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    displ <span class="op">=</span> <span class="kw">lambda</span> D: np.cos(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>k<span class="op">*</span>D <span class="op">/</span> np.<span class="bu">max</span>(D.flatten()))</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    plt.figure()</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    util.imageplot(displ(D))</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    plt.set_cmap(<span class="st">&#39;jet&#39;</span>)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    plt.savefig(<span class="st">&#39;out-560.png&#39;</span>)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> D</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, n)</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>[Y, X] <span class="op">=</span> np.meshgrid(x, x)</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="fl">.2</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>W <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">8</span> <span class="op">*</span> np.exp(<span class="op">-</span>(X<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> Y<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span> (<span class="dv">2</span><span class="op">*</span>sigma<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>util.imageplot(W)</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;out-520.png&#39;</span>)</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>x0 <span class="op">=</span> [<span class="bu">round</span>(<span class="fl">.1</span><span class="op">*</span>n), <span class="bu">round</span>(<span class="fl">.1</span><span class="op">*</span>n)]</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> exo3(x0,W)</span></code></pre></div>
<pre><code>1.0
2.0
3.0
4.0
5.0
6.0
7.0
8.0
9.0
10.0
11.0
12.0
13.0
14.0
15.0
16.0</code></pre>
<p><img src="out-520.png" /></p>
<p><img src="out-560.png" /></p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> exo4(tau,x0,x1,G):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> G.shape[<span class="dv">0</span>]</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    Geval <span class="op">=</span> <span class="kw">lambda</span> G,x: util.bilinear_interpolate(G[:,:,<span class="dv">0</span>], np.imag(x), np.real(x) ) <span class="op">+</span> <span class="ot">1j</span> <span class="op">*</span> util.bilinear_interpolate(G[:,:,<span class="dv">1</span>],np.imag(x), np.real(x))</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    niter <span class="op">=</span> <span class="fl">1.5</span><span class="op">*</span>n<span class="op">/</span>tau<span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># init gamma</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    gamma <span class="op">=</span> [x1]</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    xtgt <span class="op">=</span> x0[<span class="dv">0</span>] <span class="op">+</span> <span class="ot">1j</span><span class="op">*</span>x0[<span class="dv">1</span>]</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> np.arange(<span class="dv">0</span>,niter):</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        g <span class="op">=</span> Geval(G, gamma[<span class="op">-</span><span class="dv">1</span>] )</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        gamma.append( gamma[<span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> tau<span class="op">*</span>g )</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">abs</span>(gamma[<span class="op">-</span><span class="dv">1</span>]<span class="op">-</span>xtgt)<span class="op">&lt;</span><span class="dv">1</span>:</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    gamma.append( xtgt )</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> gamma</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, n)</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>[Y, X] <span class="op">=</span> np.meshgrid(x, x)</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="fl">.2</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>W <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">8</span> <span class="op">*</span> np.exp(<span class="op">-</span>(X<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> Y<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span> (<span class="dv">2</span><span class="op">*</span>sigma<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>x0 <span class="op">=</span> [<span class="bu">round</span>(<span class="fl">.1</span><span class="op">*</span>n), <span class="bu">round</span>(<span class="fl">.1</span><span class="op">*</span>n)]</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> exo3(x0,W)</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>G0 <span class="op">=</span> util.grad(D)</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> np.sqrt(np.<span class="bu">sum</span>(G0<span class="op">**</span><span class="dv">2</span>, axis<span class="op">=</span><span class="dv">2</span>))</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> np.zeros((n,n,<span class="dv">2</span>))</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>U[:,:,<span class="dv">0</span>] <span class="op">=</span> d</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>U[:,:,<span class="dv">1</span>] <span class="op">=</span> d</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> G0 <span class="op">/</span> U</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>tau <span class="op">=</span> <span class="fl">.8</span></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>x1 <span class="op">=</span> <span class="bu">round</span>(<span class="fl">.9</span><span class="op">*</span>n) <span class="op">+</span> <span class="ot">1j</span><span class="op">*</span><span class="bu">round</span>(<span class="fl">.88</span><span class="op">*</span>n)</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>gamma <span class="op">=</span> [x1]</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>Geval <span class="op">=</span> <span class="kw">lambda</span> G,x: util.bilinear_interpolate(G[:,:,<span class="dv">0</span>], np.imag(x), np.real(x) ) <span class="op">+</span> <span class="ot">1j</span> <span class="op">*</span> util.bilinear_interpolate(G[:,:,<span class="dv">1</span>],np.imag(x), np.real(x))</span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> Geval(G, gamma[<span class="op">-</span><span class="dv">1</span>] )</span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>gamma.append( gamma[<span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> tau<span class="op">*</span>g )</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>gamma <span class="op">=</span> exo4(tau,x0,x1,G)</span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>util.imageplot(W) </span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a>plt.set_cmap(<span class="st">&#39;gray&#39;</span>)</span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> plt.plot(np.imag(gamma), np.real(gamma), <span class="st">&#39;.b&#39;</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> plt.plot(x0[<span class="dv">1</span>], x0[<span class="dv">0</span>], <span class="st">&#39;.r&#39;</span>, markersize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> plt.plot(np.imag(x1), np.real(x1), <span class="st">&#39;.g&#39;</span>, markersize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;out-760.png&#39;</span>)</span></code></pre></div>
<pre><code>1.0
2.0
3.0
4.0
5.0
6.0
7.0
8.0
9.0
10.0
11.0
12.0
13.0
14.0
15.0
16.0</code></pre>
<p><img src="out-760.png" /></p>
<p>Kaynaklar</p>
<p>[1] Peyre, <em>Dijkstra and Fast Marching Algorithms</em>, <a
href="https://nbviewer.jupyter.org/github/gpeyre/numerical-tours/blob/master/python/fastmarching_0_implementing.ipynb">https://nbviewer.jupyter.org/github/gpeyre/numerical-tours/blob/master/python/fastmarching_0_implementing.ipynb</a></p>
<p>[2] Peyre, <a
href="https://github/gpeyre/numerical-tours">https://github/gpeyre/numerical-tours</a></p>
<p>[3] Bayramlı, Kısmi Türevsel Denklemler, <em>Kesit
Seviyeleri</em></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
