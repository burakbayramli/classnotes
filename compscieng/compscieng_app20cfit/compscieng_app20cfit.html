<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Eğri Uydurma, Aradeğerleme (Interpolation)</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="eğri-uydurma-aradeğerleme-interpolation">Eğri Uydurma,
Aradeğerleme (Interpolation)</h1>
<p>Diyelim ki elimizde alttaki veri var.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.arange(<span class="dv">1</span>,<span class="dv">7</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.array([<span class="dv">10</span>, <span class="fl">5.49</span>, <span class="fl">0.89</span>, <span class="op">-</span><span class="fl">0.14</span>, <span class="op">-</span><span class="fl">1.07</span>, <span class="fl">0.84</span>])</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>plt.plot(x,y,<span class="st">&#39;.&#39;</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="op">-</span><span class="dv">2</span>,<span class="dv">12</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">0</span>,<span class="dv">7</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_1_21_01.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_1_21_01.png" /></p>
<p>Bu veriye istediğimiz kadar bükümü olan bir eğri nasıl uydururuz?
“İstediğimiz kadar bükümü olan eğri’’ polinom çağrısı yapabilir.. Mesela
bir polinom eğri,</p>
<p><span class="math display">\[ y = c_1 x^3 + c_2x^2 + c_3x + c_4
\]</span></p>
<p>olarak gösterilebilir. Mesela bazı gelişigüzel sabit değerler <span
class="math inline">\(c_1=1,c_2-20,c_3=1,c_4=-4\)</span> sabitlerinden
alttaki görüntü çıkar,</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>x2 <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">10</span>,<span class="dv">1000</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>c_1 <span class="op">=</span> <span class="fl">2.</span><span class="op">;</span> c_2 <span class="op">=</span> <span class="op">-</span><span class="fl">20.</span><span class="op">;</span> c_3 <span class="op">=</span> <span class="fl">1.</span><span class="op">;</span> c_4 <span class="op">=</span> <span class="op">-</span><span class="dv">4</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>y2 <span class="op">=</span> c_1<span class="op">*</span>x2<span class="op">**</span><span class="dv">3</span> <span class="op">+</span> c_2<span class="op">*</span>x2<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> c_3<span class="op">*</span>x2 <span class="op">+</span> c_4</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>plt.plot(x2,y2)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_1_21_02.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_1_21_02.png" /></p>
<p>Eğri iki kere bükülebiliyor çünkü formül küpsel. Karesel olsa sadece
bir kere bükülebilirdi. Peki karesel, ya da küpsel ya da daha üst
derecedeki polinomları veriye nasıl uydururuz? Acaba lineer regresyonu
bir şekilde kullanabilir miyiz? Ama lineer regresyon, adı üstünde,
“lineer’’, yani doğrusal. Doğrusal olmayan bir şeyi nasıl uyduracağız?
Şimdi lineer regresyonun neyi uydurduğunu hatırlayalım,</p>
<p><span class="math display">\[ y = c_1 z_1 + c_2 z_2 + .. + c_nz_n
\]</span></p>
<p>Bu çok boyutlu, her biri birer vektör olan <span
class="math inline">\(z_1,..,z_n\)</span> ile tek vektör <span
class="math inline">\(y\)</span> ilişkisini girdi olarak alıyor (üstteki
formülü ya vektörsel işlem olarak ya da <span
class="math inline">\(y,z_i\)</span> öğelerinin teker teker formüle
geçildiği şekilde görebiliriz).</p>
<p>Acaba şöyle bir numara yapamaz mıyız? Eğer elimizdeki tek boyutlu
veriyi alıp, onun tamamının bir kere karesini, bir kere küpünü, vs. ayrı
ayrı alıp her sonucu sanki ayrı bir boyutlarmış gibi lineer regresyona
verirsek, otomatik olarak eğri uydurmuş olmaz mıyız ?! Yani üstteki
örnek için <span
class="math inline">\(z_1=x^3,z_2=x^2,z_3=x,z_4=1\)</span> olacak,
matris formunda,</p>
<p><span class="math display">\[ A =
\left[\begin{array}{rrrr}
x_1^3 &amp; x_1^2 &amp; x_1 &amp; 1 \\
x_2^3 &amp; x_2^2 &amp; x_2 &amp; 1 \\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots \\
x_m^3 &amp; x_m^2 &amp; x_m &amp; 1
\end{array}\right]
\]</span></p>
<p>ki <span class="math inline">\(x_i\)</span>, <span
class="math inline">\(x\)</span> vektörünün tek bir öğesini temsil
ediyor. Gerisi bildiğimiz En Az Kareler yöntemi ile <span
class="math inline">\(Ax=b\)</span>’yi, ya da üstteki notasyona göre
<span class="math inline">\(Ac=y\)</span> çözmek, <span
class="math inline">\((A^TA)^{-1}A^Tc\)</span> ile (tabii QR kullanmak
daha iyi ama bu basit örnek için önemli değil). Baştaki örneği çözelim
mesela</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.linalg <span class="im">as</span> lin</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.array([x<span class="op">**</span><span class="dv">3</span>, x<span class="op">**</span><span class="dv">2</span>, x, np.ones(<span class="bu">len</span>(x))]).T</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> np.dot(np.dot(lin.pinv(np.dot(A.T,A)),A.T),y)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (A, <span class="st">&#39;</span><span class="ch">\n\n</span><span class="st">&#39;</span>, res)</span></code></pre></div>
<pre><code>[[   1.    1.    1.    1.]
 [   8.    4.    2.    1.]
 [  27.    9.    3.    1.]
 [  64.   16.    4.    1.]
 [ 125.   25.    5.    1.]
 [ 216.   36.    6.    1.]] 

[  0.03925926   0.42313492  -6.5032672   16.12666667]</code></pre>
<p>Kütüphane çağrısı <code>polyfit</code> kullanırsak,</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (np.polyfit(x,y,<span class="dv">3</span>))</span></code></pre></div>
<pre><code>[  0.03925926   0.42313492  -6.5032672   16.12666667]</code></pre>
<p>Tıpatıp aynı sonuç çıktı, çünkü büyük bir ihtimalle
<code>polyfit</code> aynı tekniği kullanıyor!</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>plt.plot(x,y,<span class="st">&#39;.&#39;</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="op">-</span><span class="dv">2</span>,<span class="dv">12</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">0</span>,<span class="dv">7</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>yy <span class="op">=</span> res[<span class="dv">0</span>]<span class="op">*</span>x<span class="op">**</span><span class="dv">3</span> <span class="op">+</span> res[<span class="dv">1</span>]<span class="op">*</span>x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> res[<span class="dv">2</span>]<span class="op">*</span>x <span class="op">+</span> res[<span class="dv">3</span>]</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>plt.plot(x,y,<span class="st">&#39;.&#39;</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>plt.plot(x,yy)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_1_21_03.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_1_21_03.png" /></p>
<p>Uyum fena değil! Not: eğri kesikli çıktı çünkü çok az sayıda veri
var.</p>
<p>Lagrange Aradeğerlemesi (Lagrange Interpolation)</p>
<p>En eski ve en yaygın uygulaması olan aradeğerleme fonksiyonlarından
biri JL Lagrange tarafından yayınlanmış olandır. Pratik faydalarının
yaninda bu tekniğin önemli bazı teorik sonuçları var, bu sebeple
yaklaşık ya da olmayan entegrasyon ve türev alma teknikleri fonksiyonun
Lagrange aradeğerlemesi ile temsilini baz alıyor [1, sf. 268].</p>
<p>Lagrange tekniğinin önemli bir özelliği yaklaşık temsil edilecek
fonksiyondan seçilen değerler üzerinde, o noktalarda aynen verinin
söylediği değerleri tekrar üretebilmesi. Yani eğer <span
class="math inline">\(f(x)\)</span>’i bir <span
class="math inline">\(f_h(x)\)</span> ile yaklaşık temsil etmişsek, ve
eğer <span class="math inline">\(f(1) = 3\)</span> ise, aradeğerleme
sonrası <span class="math inline">\(f_h(1) = 3\)</span> olacaktır, ve bu
üzerinden aradeğerleme yapılmış tüm veri noktaları için doğru olacaktır.
Ayrıca bir diğer özellik üzerinden aradeğerleme yapılan <span
class="math inline">\(x\)</span> değerlerinin gelişigüzel seçilebilmesi,
eşit aralıkta alınma gibi bir zorunluluk yok.</p>
<p>Şimdi diyelim ki elde modellenen <span
class="math inline">\(f(x)\)</span> için elde <span
class="math inline">\(n\)</span> tane <span
class="math inline">\(x_1,x_2,...,x_n\)</span> değeri var, ki</p>
<p><span class="math display">\[
f(x_i) = y_i, \qquad i=1,2,..,n
\]</span></p>
<p>Çözmek istediğimiz problem mümkün olan az derecede olan bir polinom
<span class="math inline">\(P_m(x)\)</span> yaratmak öyle ki bu polinom
eldeki <span class="math inline">\((x_i,y_i)\)</span> veri noktalarını
temsil edebilsin, yani</p>
<p><span class="math display">\[
P_m(x_i) = y_i, \qquad i=1,2,..,n
\]</span></p>
<p>Burada <span class="math inline">\(m\)</span> altsembolü dereceyi
göstermek için kullanılıyor.</p>
<p>Daha önce söylediğimiz gibi veri noktalarında aradeğerleme ve veri
aynı sonuçta olmalı.</p>
<p>Bu amaçla <span class="math inline">\(n\)</span> tane ayrı ayrı
polinom <span class="math inline">\(p_i(x)\)</span> yaratacağız, ve bu
polinomlar öyle tasarlanacak ki <span class="math inline">\(x_i\)</span>
noktasında biri aktif olacak, diğerleri yokolacak. Bu bize bir delta
fonksiyonunu hatırlatabilir, bu doğru, şu sonucu istiyoruz,</p>
<p><span class="math display">\[
p_i(x_j) = \delta_{ij} = \left(
\begin{array}{ll}
1 &amp; \textrm{eğer } j = i  \\
0 &amp; \textrm{eğer } j \ne i
\end{array} \right.
\]</span></p>
<p>ki <span class="math inline">\(\delta_{ij}\)</span> Kronecker delta
fonksiyonu. Eger <span class="math inline">\(p_i(x)\)</span>’lerin <span
class="math inline">\(j \ne i\)</span> olacak sekilde <span
class="math inline">\(x_j\)</span> noktalarında yokolmasını istiyorsak,
onu <span class="math inline">\((x-x_j)\)</span> faktörlerinin bir
çarpımı olarak yazabiliriz,</p>
<p><span class="math display">\[
p_i(x) = C_i \prod_{j \ne i} (x-x_j)
\]</span></p>
<p>Sabit <span class="math inline">\(C_i\)</span> normalize edici bir
değer. Üstteki çarpımda <span class="math inline">\((x-x_i)\)</span>
yok, onu dışarıda bırakarak <span class="math inline">\(p_i\)</span>
elde ettik. Bir faktör hep dışarıda olacağı için <span
class="math inline">\(p_i(x)\)</span> polinomunun derecesi hep <span
class="math inline">\((n-1)\)</span> olacaktır. Normalizasyon sabiti
<span class="math inline">\(C_i\)</span> hesaplamak için <span
class="math inline">\(p_i(x_i)=1\)</span> olduğunu hatırlayalım ve bu
değeri elde etmek için <span class="math inline">\(C_i = 1 / \prod_{j
\ne i} (x_i - x_j)\)</span> sabiti gerekecektir, o zaman</p>
<p><span class="math display">\[
p_i(x) = \frac
{\prod_{j \ne i} (x - x_j)}
{\prod_{j \ne i} (x_i - x_j)},
\quad i=1,2,..,n
\]</span></p>
<p>Her <span class="math inline">\(p_i(x)\)</span> polinomu <span
class="math inline">\(x_i\)</span> haricinde diğer her noktada
yokolacağı için <span class="math inline">\(P_m\)</span> polinomu <span
class="math inline">\(p_i(x)\)</span>’lerin bir lineer kombinasyonu,
toplamı olarak temsil edilebilir,</p>
<p><span class="math display">\[
P_m(x) =  \sum_{i=1}^{n} p_i (x) y_i
\]</span></p>
<p>Bir <span class="math inline">\(x_j\)</span> için hesap ne diyor?</p>
<p><span class="math display">\[
P_m(x_j) = \sum_{i=1}^{n} p_i(x_j) y_i =  \sum_{i=1}^{n} \delta_{ij} y_i
= y_j
\]</span></p>
<p>Doğru gözüküyor. Genel formda şunu yazabiliriz,</p>
<p><span class="math display">\[
P_m (x) = \sum_{i=1}^{n}
\frac{\prod_{j \ne i} (x - x_j)}{\prod_{j \ne i} (x_i - x_j)}
\]</span></p>
<p>Eğer <span class="math inline">\(n=2\)</span> olsaydı, eldeki iki
tane <span class="math inline">\((x_1,y_1)\)</span> ve <span
class="math inline">\((x_2,y_2)\)</span> için</p>
<p><span class="math display">\[
P_1(x) =
\frac{(x-x_2)}{(x_1-x_2)} y_1 +
\frac{(x-x_1)}{(x_2-x_1)} y_2
\]</span></p>
<p>Bu tabii ki iki noktadan geçen düz bir çizgiyi temsil ediyor.</p>
<p>Eğer <span class="math inline">\(n=3\)</span> olsaydı, üç noktadan
geçen bir parabol elde edilirdi,</p>
<p><span class="math display">\[
P_2(x) =
\frac{(x-x_2)(x-x_3)}{(x_1-x_2)(x_1-x_3)} y_1 +
\frac{(x-x_1)(x-x_3)}{(x_2-x_1)(x_2-x_3)} y_2 +
\frac{(x-x_1)(x-x_2)}{(x_3-x_1)(x_3-x_2)} y_3
\]</span></p>
<p>Altta örnek olarak <span class="math inline">\(\sin(5x)\)</span>’ten
alınmış 8 veri noktası ile aradeğerleme yapan bir örnek görüyoruz,</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Lagrange(x, y, n, xi):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>   yi <span class="op">=</span> <span class="fl">0e0</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>   <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>      p <span class="op">=</span> <span class="fl">1e0</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> (j <span class="op">!=</span> i): p <span class="op">*=</span> (xi <span class="op">-</span> x[j])<span class="op">/</span>(x[i] <span class="op">-</span> x[j])</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>      yi <span class="op">+=</span> p <span class="op">*</span> y[i]</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> yi</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>n  <span class="op">=</span> <span class="dv">8</span>  </span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>ni <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>)                                                   </span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="co"># f(x) = sin(5*x), x degerleri gelisiguzel secilmis </span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>x[<span class="dv">1</span>] <span class="op">=</span> <span class="fl">0.15</span><span class="op">;</span> x[<span class="dv">2</span>] <span class="op">=</span> <span class="fl">0.2</span><span class="op">;</span> x[<span class="dv">3</span>] <span class="op">=</span> <span class="fl">0.3</span><span class="op">;</span> x[<span class="dv">4</span>] <span class="op">=</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>x[<span class="dv">5</span>] <span class="op">=</span> <span class="fl">0.8</span> <span class="op">;</span> x[<span class="dv">6</span>] <span class="op">=</span> <span class="fl">1.1</span><span class="op">;</span> x[<span class="dv">7</span>] <span class="op">=</span> <span class="fl">1.4</span><span class="op">;</span> x[<span class="dv">8</span>] <span class="op">=</span> <span class="fl">1.7</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>): y[i] <span class="op">=</span> np.sin(<span class="dv">5</span><span class="op">*</span>x[i])</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>xx <span class="op">=</span> []<span class="op">;</span> yy <span class="op">=</span> []<span class="op">;</span> real <span class="op">=</span> []</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a><span class="co"># x[1] ile x[8] arasinda esit aralikli x&#39;ler yarat</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a><span class="co"># daha fazla nokta olsun</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>xis <span class="op">=</span> np.linspace(x[<span class="dv">1</span>],x[<span class="op">-</span><span class="dv">1</span>],ni)</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,ni<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>   xi <span class="op">=</span> xis[i<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>   yi <span class="op">=</span> Lagrange(x,y,n,xi)</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>   xx.append(xi)</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>   yy.append(yi)</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>   real.append(np.sin(<span class="dv">5</span><span class="op">*</span>xi)<span class="op">+</span><span class="fl">0.02</span>)</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>xx <span class="op">=</span> np.array(xx)</span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>yy <span class="op">=</span> np.array(yy)</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>real <span class="op">=</span> np.array(real)</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>plt.plot(xx,yy)</span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>plt.plot(x,y)</span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>plt.plot(xx,real,<span class="st">&#39;--&#39;</span>)</span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a>plt.legend([<span class="st">&#39;Lagrange&#39;</span>,<span class="st">u&#39;Seçilen Noktalar&#39;</span>,<span class="st">&#39;Gerçek&#39;</span>])</span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app20cfit1_01.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_app20cfit1_01.png" /></p>
<p>İlmikler (Knots)</p>
<p>[4], [5], yazılarındaki konuları genişletelim. Bu yazılardan
biliyoruz ki basit regresyon</p>
<p><span class="math display">\[ y_i = \beta_0 + \beta_1 x_i +
\epsilon_i\]</span></p>
<p>denklemini temel alıyor, onu veriye uyduruyor. Bu uydurma için
kullandığımız <span class="math inline">\(A,x,b\)</span> matrisleri,
vektörleri var. Sihirli formülü biliyoruz,</p>
<p><span class="math display">\[ \hat{y} = X(X^TX)^{-1}X^Ty
\]</span></p>
<p>Şimdi bu formüldeki <span class="math inline">\(X\)</span> içindeki
değerleri farklı “bazlar’’ olarak görmek faydalı olacaktır. Tek
değişkenli durumda mesela bu baz</p>
<p><span class="math display">\[ X =
\left[\begin{array}{cc}
1 &amp; x_1 \\ \vdots &amp; \vdots \\ 1 &amp; x_n
\end{array}\right]
\]</span></p>
<p>Eğer karesel bir formülü uyduruyorsak, yani</p>
<p><span class="math display">\[ y_i = \beta_0 + \beta_1x_i +
\beta_2x_i^2 + \epsilon_i \]</span></p>
<p>baz</p>
<p><span class="math display">\[ X =
\left[\begin{array}{ccc}
1 &amp; x_1 &amp; x_1^2\\
\vdots &amp; \vdots &amp; \vdots \\
1 &amp; x_n &amp; x_n^2
\end{array}\right]
\]</span></p>
<p>olur. Bu bakış açısını yorumlamak zor değil, regresyonun temeli
değişkenlerin katsayılarını bulmaktır, o zaman <span
class="math inline">\(1,x,x^2\)</span> değişkenleri için de, ya da
herhangi bir başka baz bulmak için aynı teknik kullanılabilir çünkü
karesel, küpsel bazlar kullanıyor olsak bile bu değerleri önceden
hesaplayıp matrise koyduğumuz için kullandığımız sihirli formül hala
lineer bir problemi çözüyor. Hala değişkenler var, onlar bazı katsayılar
ile çarpılıp toplanarak veriye uydurulacak, ve sihirli formül bu en
optimal katsayıları bulacak.</p>
<p>Baz fikri ile devam edelim, alttaki veriye bakalım (gösterilen
çizgilerin daha bulunmamış olduğunu varsayalım),</p>
<p><img src="compscieng_app20_04.png" /></p>
<p>Bu bir kırılmış değnek (broken stick) modeli, <span
class="math inline">\(x=0.6\)</span> öncesinde belli bir eğimi olan bir
düz çizgi var, sonrasında başka bir eğrisi olan bir düz çizgi var.
Kırılma noktasını biliyoruz, ya da regresyonun hangi noktadan geçmesini
istediğimizi, ilmik noktasını (knot) biliyoruz, bu durumda baz
nedir?</p>
<p><span class="math display">\[
(x-0.6)_{+}
\]</span></p>
<p>fonksiyonudur. Tanımdaki altsimge + şunu ifade eder: herhangi bir
sayı <span class="math inline">\(u\)</span> eğer pozitif ise <span
class="math inline">\(u_{+} = u\)</span>’dur, eğer değil ise <span
class="math inline">\(u_{+} = 0\)</span> değerine sahiptir. Bunun
amaçlarımız için mükemmel bir baz fonksiyonu olacağını
görebiliyoruz,</p>
<p><span class="math display">\[y_i = \beta_0 + \beta_1x_i +
\beta_{11}(x_i-0.6)_{+} + \epsilon_i \]</span></p>
<p>Bu fonksiyonun <span class="math inline">\(0.6\)</span>’ya kadar
belli bir eğimi olacak, fakat <span class="math inline">\(0.6\)</span>
ardından bu eğime bir “ek’’ yapılmaya başlanacak, <span
class="math inline">\(\beta_{11}\)</span> bu ekin ne kadar olacağını
yakalayacak.</p>
<p>O zaman sihirli formüle verilecek matris</p>
<p><span class="math display">\[
X =
\left[\begin{array}{ccc}
1 &amp; x_1 &amp; (x_1 - 0.6)_{+} \\
\vdots &amp; \vdots &amp; \vdots \\
1 &amp; x_n &amp; (x_n - 0.6)_{+}
\end{array}\right]
\]</span></p>
<p>Regresyon çözümü bize her baz için gerekli katsayıyı (kesiyi, eğimi)
verecektir.</p>
<p>Daha abartarak (!) bir sürü ilmik üzerinden bir sürü baz
tanımlayabilirdik, o zaman ufak ufak pek çok düz çizgiyi veriye uydurmak
mümkün olurdu, mesela</p>
<p><span class="math display">\[ X =
\left[\begin{array}{cccccc}
1 &amp; x_1 &amp; (x_1 - 0.5)_{+} &amp; (x_1 - 0.55)_{+} &amp; \dots
&amp; (x_1 - 0.96)_{+}\\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; x_1 &amp; (x_1 - 0.5)_{+} &amp; (x_1 - 0.55)_{+} &amp; \dots
&amp; (x_1 - 0.96)_{+}
\end{array}\right]
\]</span></p>
<p><img src="compscieng_app20_05.png" /></p>
<p>(Resimde ilmikler 400,500,.. gibi değerlerde, yani bazlar <span
class="math inline">\((x_1-500)_{+}\)</span> şeklinde olurdu)</p>
<p>Bilinen tek ilmik üzerinden en basit örneği görelim,</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.formula.api <span class="im">as</span> smf</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(<span class="st">&#39;2inclines.csv&#39;</span>)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>reslin <span class="op">=</span> smf.ols(<span class="st">&#39;y ~ 1 + x + I((x-55)*(x&gt;55))&#39;</span>, data<span class="op">=</span>df).fit()</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (reslin.summary())</span></code></pre></div>
<pre><code>                            OLS Regression Results                            
==============================================================================
Dep. Variable:                      y   R-squared:                       0.957
Model:                            OLS   Adj. R-squared:                  0.956
Method:                 Least Squares   F-statistic:                     1081.
Date:                Thu, 12 Jan 2017   Prob (F-statistic):           4.96e-67
Time:                        14:27:42   Log-Likelihood:                -243.44
No. Observations:                 100   AIC:                             492.9
Df Residuals:                      97   BIC:                             500.7
Df Model:                           2                                         
Covariance Type:            nonrobust                                         
==========================================================================================
                             coef    std err          t      P&gt;|t|      [95.0% Conf. Int.]
------------------------------------------------------------------------------------------
Intercept                 15.7364      0.701     22.447      0.000        14.345    17.128
x                          0.2956      0.019     15.422      0.000         0.258     0.334
I((x - 55) * (x &gt; 55))     0.3530      0.040      8.926      0.000         0.275     0.432
==============================================================================
Omnibus:                       15.710   Durbin-Watson:                   2.312
Prob(Omnibus):                  0.000   Jarque-Bera (JB):                4.411
Skew:                          -0.025   Prob(JB):                        0.110
Kurtosis:                       1.972   Cond. No.                         148.
==============================================================================

Warnings:
[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.</code></pre>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>df.set_index(<span class="st">&#39;x&#39;</span>).y.plot()</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app20_07.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_app20_07.png" /></p>
<p>Bulunan katsayılar üstteki grafiğe uyuyor.</p>
<p>İlmik Seçmek</p>
<p>[6, sf. 65] bu tekniği bir adım ilerletiyor; eğer ilmik seçmek
isteseydik ne yapardık? Bu durumda üstteki gibi pek çok mümkün bazı
regresyona verirdik, ama bu sefer regülarizasyon üzerinden eğer ise
yaramayanları cezalandırırsak, çok küçülen katsayılar bizim için önemsiz
sayılacaktır ve katsayısı yüksek olanlar elde tutulabilir.
Regularizasyon icin {}.</p>
<p>[6]’in cezalandırma formülasyonu bize bir Ridge regresyonu veriyor.
Alttaki veride denedik,</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(<span class="st">&#39;cave.csv&#39;</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>df.C.plot()</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app20_06.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_app20_06.png" /></p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.formula.api <span class="im">as</span> sm</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="st">&quot;C ~ 1 + Temp + I((Temp &gt; 10)*(Temp-10)) + I((Temp &gt; 15)*(Temp-15)) +&quot;</span> <span class="op">+</span> <span class="op">\</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;I((Temp &gt; 20)*(Temp-20)) + I((Temp &gt; 25)*(Temp-25)) +&quot;</span> <span class="op">+</span> <span class="op">\</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;I((Temp &gt; 30)*(Temp-30)) + I((Temp &gt; 35)*(Temp-35)) +&quot;</span> <span class="op">+</span> <span class="op">\</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;I((Temp &gt; 40)*(Temp-40)) + I((Temp &gt; 45)*(Temp-45)) +&quot;</span> <span class="op">+</span> <span class="op">\</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;I((Temp &gt; 50)*(Temp-50)) + I((Temp &gt; 55)*(Temp-55)) &quot;</span> </span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> sm.ols(formula<span class="op">=</span>f, data<span class="op">=</span>df).fit_regularized(L1_wt<span class="op">=</span><span class="fl">0.0</span>)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>y_true <span class="op">=</span> df[<span class="st">&#39;C&#39;</span>]</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>y_pred <span class="op">=</span> model.predict(df)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>ss_total <span class="op">=</span> np.<span class="bu">sum</span>((y_true <span class="op">-</span> np.mean(y_true))<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>ss_residual <span class="op">=</span> np.<span class="bu">sum</span>((y_true <span class="op">-</span> y_pred)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>r_squared <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> (ss_residual <span class="op">/</span> ss_total)</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;</span><span class="ch">\n</span><span class="ss">R-squared: </span><span class="sc">{</span>r_squared<span class="sc">:.4f}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<pre><code>                            OLS Regression Results                            
==============================================================================
Dep. Variable:                      C   R-squared:                       0.962
Model:                            OLS   Adj. R-squared:                  0.956
Method:                 Least Squares   F-statistic:                     177.4
Date:                Thu, 12 Jan 2017   Prob (F-statistic):           2.03e-50
Time:                        13:13:45   Log-Likelihood:                -185.82
No. Observations:                  90   AIC:                             395.6
Df Residuals:                      78   BIC:                             425.6
Df Model:                          11                                         
Covariance Type:            nonrobust                                         
================================================================================================
                                   coef    std err          t      P&gt;|t|      [95.0% Conf. Int.]
------------------------------------------------------------------------------------------------
Intercept                       31.8192      1.354     23.494      0.000        29.123    34.515
Temp                             0.3800      0.204      1.863      0.066        -0.026     0.786
I((Temp &gt; 10) * (Temp - 10))    -0.0764      0.497     -0.154      0.878        -1.065     0.912
I((Temp &gt; 15) * (Temp - 15))    -0.0524      0.651     -0.081      0.936        -1.348     1.243
I((Temp &gt; 20) * (Temp - 20))    -0.0027      0.673     -0.004      0.997        -1.342     1.337
I((Temp &gt; 25) * (Temp - 25))    -0.1210      0.674     -0.179      0.858        -1.463     1.221
I((Temp &gt; 30) * (Temp - 30))    -0.3380      0.674     -0.501      0.618        -1.681     1.005
I((Temp &gt; 35) * (Temp - 35))    -0.0869      0.674     -0.129      0.898        -1.429     1.256
I((Temp &gt; 40) * (Temp - 40))     0.1147      0.674      0.170      0.865        -1.227     1.457
I((Temp &gt; 45) * (Temp - 45))     0.0320      0.670      0.048      0.962        -1.302     1.366
I((Temp &gt; 50) * (Temp - 50))    -0.0149      0.598     -0.025      0.980        -1.205     1.176
I((Temp &gt; 55) * (Temp - 55))    -0.6336      0.295     -2.144      0.035        -1.222    -0.045
==============================================================================
Omnibus:                        7.572   Durbin-Watson:                   1.924
Prob(Omnibus):                  0.023   Jarque-Bera (JB):                7.180
Skew:                          -0.575   Prob(JB):                       0.0276
Kurtosis:                       3.770   Cond. No.                         691.
==============================================================================

Warnings:
[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.</code></pre>
<p>İstatistiki modelleri irdelemek bilimden ziyada biraz sanattır, fakat
üstteki sonuçlarda (Temp-30) katsayısının mutlak değerinin orta
bölgedeki diğerlerine göre daha yüksek olduğunu görüyoruz. Grafiğe
bakılınca bu mantıklı gözüküyor.</p>
<p>Alternatif İlmik İfadeleri</p>
<p>Bazen sayısal hesaplarda üstte gördüğümüz <span
class="math inline">\(u_{+}\)</span> ifadesinin <span
class="math inline">\(\max(0,x-a)\)</span> ile formülize edildiğini
görüyoruz. Yani,</p>
<p><span class="math display">\[
y = \beta_0 + \beta_1 x + \beta_{2}(x-a)_{+} +  \beta_{3}(x-b)_{+} + ...
\]</span></p>
<p>yerine</p>
<p><span class="math display">\[
y = \beta_0 + \beta_1 x + \beta_{2}\max(0,x-a) +  \beta_{3}\max(0,x-b) +
...
\]</span></p>
<p>ki <span class="math inline">\(a,b\)</span> ilmik noktaları. Bu
kullanım da aynı sonuç veriyor, düşünürsek <span
class="math inline">\(\max\)</span> ifadesi <span
class="math inline">\(x\)</span> değeri <span
class="math inline">\(a\)</span> değerini geçinceye kadar 0, ondan sonra
<span class="math inline">\(x-a\)</span> verecek, bu da <span
class="math inline">\(u_{+}\)</span> gibi bir kullanım ile aynı.</p>
<p>Mesela</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>a,b,c,d <span class="op">=</span> (<span class="dv">1</span>, <span class="op">-</span><span class="fl">1.4</span>, <span class="dv">2</span>, <span class="fl">2.5</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">5</span>,<span class="dv">100</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>knots <span class="op">=</span> [<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x):</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">+</span> <span class="op">\</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>           b<span class="op">*</span>np.<span class="bu">max</span>([<span class="dv">0</span>,x<span class="op">-</span>knots[<span class="dv">0</span>]]) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>           c<span class="op">*</span>np.<span class="bu">max</span>([<span class="dv">0</span>,x<span class="op">-</span>knots[<span class="dv">1</span>]]) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>           d<span class="op">*</span>np.<span class="bu">max</span>([<span class="dv">0</span>,x<span class="op">-</span>knots[<span class="dv">2</span>]])</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>       </span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.array([f(xx) <span class="cf">for</span> xx <span class="kw">in</span> x])</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>plt.plot(x,y,<span class="st">&#39;.&#39;</span>)</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app20_10.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_app20_10.png" /></p>
<p>Rasgele bazı ağırlıklarla <span
class="math inline">\(x=2,3,4\)</span> noktalarında aktif olan
ilmiklerle üstteki grafiği çıkarttık. Regresyon bağlamında bir
optimizasyon rutinine (illa lineer regresyon olması gerekmez) veriye
bakarak bir hatanın minimize edilmesi üzerinden en optimal <span
class="math inline">\(a,b,c,d\)</span> ağırlıklarını buldurmak ta
mümkündür.</p>
<p>Peki <span class="math inline">\(\max\)</span> yerine baska bir
fonksiyon kullanabilir miydik? <span
class="math inline">\(\max\)</span>’in sonucta yaptigi belli bir esik
degerinden once 0 sonrasinda baska bir deger vermek degil midir? Evet.
Bu tur bir “karar’’ fonksiyonu sigmoid ile de elde edilebilir.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>alpha <span class="op">=</span> <span class="fl">5.0</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sig(x,a):</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> <span class="dv">1</span><span class="op">/</span>(<span class="dv">1</span><span class="op">+</span>np.exp(<span class="op">-</span>alpha<span class="op">*</span>(x<span class="op">-</span>a)))</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">100</span>)</span></code></pre></div>
<div class="sourceCode" id="cb17"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> sig(x,<span class="dv">0</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>plt.plot(x,y)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app20_11.png&#39;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb18"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> sig(x,<span class="dv">3</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>plt.plot(x,y)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app20_12.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_app20_11.png" /> <img
src="compscieng_app20_12.png" /></p>
<p>Normal sigmoid üst soldaki, fakat <span
class="math inline">\(x-a\)</span> ile onu da istediğimiz noktaya
kaydırabiliyoruz. <span class="math inline">\(\alpha\)</span>
parametresi 0’dan 1’e geçişin ne kadar sert olduğunu kontrol ediyor.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>rho <span class="op">=</span> <span class="fl">7.0</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sig2(x,a):</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> (x<span class="op">-</span>a)<span class="op">*</span><span class="dv">1</span><span class="op">/</span>(<span class="dv">1</span><span class="op">+</span>np.exp(<span class="op">-</span>rho<span class="op">*</span>(x<span class="op">-</span>a)))</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>a,b,c,d <span class="op">=</span> (<span class="dv">1</span>, <span class="op">-</span><span class="fl">1.4</span>, <span class="dv">2</span>, <span class="fl">2.5</span>)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">5</span>,<span class="dv">100</span>)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>knots <span class="op">=</span> [<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x):</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">+</span> <span class="op">\</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>           b<span class="op">*</span>sig2(x,knots[<span class="dv">0</span>]) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>           c<span class="op">*</span>sig2(x,knots[<span class="dv">1</span>]) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>           d<span class="op">*</span>sig2(x,knots[<span class="dv">2</span>])</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>           </span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.array([f(xx) <span class="cf">for</span> xx <span class="kw">in</span> x])</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>plt.plot(x,y)</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app20_13.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_app20_13.png" /></p>
<p>Daha yumuşak, pürüzsüz bir fonksiyon elde etmiş olduk. Bu birleşik
eğrinin türevini almak ta daha kolay olacaktır. Gerçi otomatik türev
paketleri artık içinde <span class="math inline">\(\max\)</span> bile
olan ifadelerin türevini alabiliyor, fakat üsttekinin sembolik türevi
rahatça alınabilir, bu seçeneğin elde olması iyidir.</p>
<p>Küpsel Spline Eğrileri (Cubic Splines)</p>
<p>Baz seçerken elimizde pek çok seçenek var, mesela küpsel spline
eğrileri uydurmak için</p>
<p><span class="math display">\[
(1,x,x^2,x^3,(x-k_1)_{+}^3,(x-k_2)_{+}^3,(x-k_3)_{+}^3,.. )\]</span></p>
<p>gibi bir baz kullanabiliriz, ilmikler <span
class="math inline">\(k_1,..,k_K\)</span> olarak gider, genel olarak</p>
<p><span class="math display">\[ f(x) = \beta_0 + \beta_1x + \beta_2 x^2
+ \beta_3 x^3 +
\sum_{s=1}^{K} \beta_{3+s} (x-k_s)^3_{+}
\]</span></p>
<p>formülü verilir. Bu baza kırpılmış güç bazı (truncated power basis)
ismi de veriliyor.</p>
<p>Bir örnek üzerinde görelim,</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>dfcube <span class="op">=</span> pd.read_csv(<span class="st">&#39;cube.csv&#39;</span>)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>df2 <span class="op">=</span> dfcube.set_index(<span class="st">&#39;x&#39;</span>)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>df2.y.plot()</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app20_09.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_app20_09.png" /></p>
<p>İlmik noktalarını seçelim, 8 ve 13 noktasında olsun,</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.api <span class="im">as</span> sm</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>dfcube <span class="op">=</span> pd.read_csv(<span class="st">&#39;cube.csv&#39;</span>)</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>dfcube.loc[:,<span class="st">&#39;1&#39;</span>] <span class="op">=</span> <span class="fl">1.</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>dfcube.loc[:,<span class="st">&#39;x2&#39;</span>] <span class="op">=</span> dfcube.x<span class="op">**</span><span class="dv">2</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>dfcube.loc[:,<span class="st">&#39;x3&#39;</span>] <span class="op">=</span> dfcube.x<span class="op">**</span><span class="dv">3</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>k1 <span class="op">=</span> dfcube.x<span class="op">-</span><span class="dv">8</span><span class="op">;</span> dfcube.loc[k1<span class="op">&gt;</span><span class="dv">0</span>,<span class="st">&#39;k1&#39;</span>] <span class="op">=</span> k1<span class="op">**</span><span class="dv">3</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>k2 <span class="op">=</span> dfcube.x<span class="op">-</span><span class="dv">13</span><span class="op">;</span> dfcube.loc[k2<span class="op">&gt;</span><span class="dv">0</span>,<span class="st">&#39;k2&#39;</span>] <span class="op">=</span> k2<span class="op">**</span><span class="dv">3</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>dfcube <span class="op">=</span> dfcube.fillna(<span class="dv">0</span>)</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> dfcube[[<span class="st">&#39;1&#39;</span>,<span class="st">&#39;x&#39;</span>,<span class="st">&#39;x2&#39;</span>,<span class="st">&#39;x3&#39;</span>,<span class="st">&#39;k1&#39;</span>,<span class="st">&#39;k2&#39;</span>]]</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> dfcube.y</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> sm.OLS(y,X).fit()</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (f.params)</span></code></pre></div>
<pre><code>1     1.586781
x     1.747705
x2   -0.381304
x3    0.030443
k1   -0.092883
k2    0.138559
dtype: float64</code></pre>
<div class="sourceCode" id="cb23"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>dfcube[<span class="st">&#39;yy&#39;</span>] <span class="op">=</span> f.params[<span class="dv">0</span>]<span class="op">*</span>dfcube[<span class="st">&#39;1&#39;</span>] <span class="op">+</span> f.params[<span class="dv">1</span>]<span class="op">*</span>dfcube.x <span class="op">+</span> <span class="op">\</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>               f.params[<span class="dv">2</span>]<span class="op">*</span>dfcube.x2 <span class="op">+</span> f.params[<span class="dv">3</span>]<span class="op">*</span>dfcube.x3 <span class="op">+</span> <span class="op">\</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>               f.params[<span class="dv">4</span>]<span class="op">*</span>dfcube.k1 <span class="op">+</span> f.params[<span class="dv">5</span>]<span class="op">*</span>dfcube.k2 </span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>dfcube[<span class="st">&#39;y&#39;</span>] <span class="op">=</span> y</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>df2 <span class="op">=</span> dfcube.set_index(<span class="st">&#39;x&#39;</span>)</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>df2[[<span class="st">&#39;y&#39;</span>,<span class="st">&#39;yy&#39;</span>]].plot()</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>plt.axvline(x<span class="op">=</span><span class="dv">8</span>,color<span class="op">=</span><span class="st">&#39;c&#39;</span>)</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>plt.axvline(x<span class="op">=</span><span class="dv">13</span>,color<span class="op">=</span><span class="st">&#39;c&#39;</span>)</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app20_08.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_app20_08.png" /></p>
<p>Kısıtlanmış Küpsel Spline Eğrileri (Restricted Cubic Splines)</p>
<p>Üstteki metot iyi işliyor, fakat bazen başta ve sondaki parçaların
eğri değil tam düz olması istenebiliyor, yani “eteklerde’’ düzleştirme
amaçlanıyor. Bu özel formülasyon için bkz. [3, sf. 24]. Bu yaklaşımı baz
alan kod [1]’in Python çevrimini altta veriyoruz. Metota verilen isim
kısıtlanmış küpsel spline eğrileri, ya da doğal spline eğrileri (natural
splines).</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.linalg <span class="im">as</span> lin</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rcs(x,y,knots):</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(y)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> knots</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    X1 <span class="op">=</span> x</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    q <span class="op">=</span> <span class="bu">len</span>(k)<span class="op">-</span><span class="dv">1</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    myX<span class="op">=</span>np.zeros((n,<span class="bu">len</span>(knots)<span class="op">-</span><span class="dv">2</span>))</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(q<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>        tmp1 <span class="op">=</span> (x<span class="op">-</span>k[j])<span class="op">**</span><span class="dv">3</span> <span class="op">*</span> (x<span class="op">&gt;</span>k[j])</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>        tmp2 <span class="op">=</span> (x<span class="op">-</span>k[q<span class="op">-</span><span class="dv">1</span>])<span class="op">**</span><span class="dv">3</span> <span class="op">*</span> (x<span class="op">&gt;</span>k[q<span class="op">-</span><span class="dv">1</span>])<span class="op">*</span>(k[q]<span class="op">-</span>k[j])</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>        XX<span class="op">=</span> tmp1<span class="op">-</span>tmp2<span class="op">/</span>(k[q]<span class="op">-</span>k[q<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>        tmp1 <span class="op">=</span> (x<span class="op">-</span>k[q])<span class="op">**</span><span class="dv">3</span> <span class="op">*</span> (x<span class="op">&gt;</span>k[q])</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>        tmp2 <span class="op">=</span> (k[q<span class="op">-</span><span class="dv">1</span>]<span class="op">-</span>k[j])</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>        XX <span class="op">=</span> XX<span class="op">+</span>tmp1<span class="op">*</span>tmp2<span class="op">/</span>(k[q]<span class="op">-</span>k[q<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>        myX[:,j]<span class="op">=</span>XX</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> np.hstack( (np.ones((n,<span class="dv">1</span>)),np.reshape(X1,(n,<span class="dv">1</span>)),myX) )</span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>    bhat <span class="op">=</span> np.linalg.lstsq(X,y)[<span class="dv">0</span>]</span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>    bhatt <span class="op">=</span> np.zeros(<span class="bu">len</span>(knots)<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>    bhatt[<span class="bu">len</span>(bhat)] <span class="op">=</span> (bhat[<span class="dv">2</span>:]<span class="op">*</span>(k[<span class="dv">0</span>:<span class="op">-</span><span class="dv">2</span>]<span class="op">-</span>k[<span class="op">-</span><span class="dv">1</span>])).<span class="bu">sum</span>()</span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a>    bhatt[<span class="bu">len</span>(bhat)] <span class="op">=</span> bhatt[<span class="bu">len</span>(bhat)] <span class="op">/</span> (k[<span class="op">-</span><span class="dv">1</span>]<span class="op">-</span>k[<span class="op">-</span><span class="dv">2</span>])</span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a>    bhatt <span class="op">=</span> np.hstack([bhatt, <span class="dv">0</span>])    </span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a>    bhatt[<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> (bhat[<span class="dv">2</span>:]<span class="op">*</span>(k[<span class="dv">0</span>:<span class="op">-</span><span class="dv">2</span>]<span class="op">-</span>k[<span class="op">-</span><span class="dv">2</span>])).<span class="bu">sum</span>()</span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a>    bhatt[<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> bhatt[<span class="op">-</span><span class="dv">1</span>] <span class="op">/</span> (k[<span class="op">-</span><span class="dv">2</span>]<span class="op">-</span>k[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a>    bhat <span class="op">=</span> np.hstack((bhat, bhatt[<span class="op">-</span><span class="dv">2</span>:]))</span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> bhat</span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> speval(x,coefs,knots):</span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true" tabindex="-1"></a>    tmp <span class="op">=</span> coefs[<span class="dv">0</span>] <span class="op">+</span> coefs[<span class="dv">1</span>]<span class="op">*</span>x </span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(knots)): </span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true" tabindex="-1"></a>         tmp <span class="op">=</span> tmp <span class="op">+</span> coefs[k<span class="op">+</span><span class="dv">2</span>]<span class="op">*</span>((x<span class="op">-</span>knots[k])<span class="op">**</span><span class="dv">3</span>)<span class="op">*</span>(x<span class="op">&gt;</span>knots[k])</span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tmp</span></code></pre></div>
<div class="sourceCode" id="cb25"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.random.randn(<span class="dv">300</span>)<span class="op">*</span>np.sqrt(<span class="dv">2</span>)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>e <span class="op">=</span> np.random.randn(<span class="dv">300</span>)<span class="op">*</span>np.sqrt(<span class="fl">0.5</span>)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.sin(x)<span class="op">+</span>e</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame([x,y]).T</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>df.columns <span class="op">=</span> [<span class="st">&#39;x&#39;</span>,<span class="st">&#39;y&#39;</span>]</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.sort_values(by<span class="op">=</span><span class="st">&#39;x&#39;</span>)</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (df.head())</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>knots<span class="op">=</span>np.array([<span class="op">-</span><span class="fl">5.5938</span>, <span class="op">-</span><span class="fl">3.7732</span>, <span class="op">-</span><span class="fl">1.9526</span>, <span class="op">-</span><span class="fl">0.1320</span>, <span class="fl">1.6886</span>, <span class="fl">3.5092</span>, <span class="fl">5.3298</span>])<span class="op">;</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>bhat <span class="op">=</span> rcs(df.x,df.y,knots)</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (bhat)</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>df[<span class="st">&#39;spline&#39;</span>] <span class="op">=</span> speval(df.x, bhat, knots)</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>df2 <span class="op">=</span> df.set_index(<span class="st">&#39;x&#39;</span>)</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>df2[[<span class="st">&#39;y&#39;</span>,<span class="st">&#39;spline&#39;</span>]].plot()</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k <span class="kw">in</span> knots: plt.plot(k,speval(k,bhat,knots),<span class="st">&#39;rd&#39;</span>)</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app20_01.png&#39;</span>)</span></code></pre></div>
<pre><code>            x         y
156 -4.037867  0.786392
214 -3.442141  0.716684
101 -3.331777  0.400504
249 -3.178510 -1.019875
235 -3.131058  0.309575
[ 2.60209869  0.37061018 -0.09614395  0.3059325  -0.30256291 -0.05312331
  0.33303297 -0.24924314  0.06210785]</code></pre>
<p><img src="compscieng_app20_01.png" /></p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>dfcube <span class="op">=</span> pd.read_csv(<span class="st">&#39;cube.csv&#39;</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>dfcube <span class="op">=</span> dfcube.sort_values(by<span class="op">=</span><span class="st">&#39;x&#39;</span>)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>knots<span class="op">=</span>np.array([<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">8</span>,<span class="dv">14</span>,<span class="fl">14.5</span>])<span class="op">;</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>bhat <span class="op">=</span> rcs(dfcube.x,dfcube.y,knots)</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (bhat)</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>dfcube[<span class="st">&#39;spline&#39;</span>] <span class="op">=</span> speval(dfcube.x, bhat, knots)</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>df2 <span class="op">=</span> dfcube.set_index(<span class="st">&#39;x&#39;</span>)</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>df2[[<span class="st">&#39;y&#39;</span>,<span class="st">&#39;spline&#39;</span>]].plot()</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k <span class="kw">in</span> knots: plt.plot(k,speval(k,bhat,knots),<span class="st">&#39;rd&#39;</span>)</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app20_03.png&#39;</span>)</span></code></pre></div>
<pre><code>[ 3.16368016  0.17418578  0.02336622 -0.01432746 -0.05277535  0.42087813
 -0.37714154]</code></pre>
<p><img src="compscieng_app20_03.png" /></p>
<p>Spline Eğrileri</p>
<p>Diyelim ki elimizde 4 <span class="math inline">\(x_i,y_i\)</span>
noktası var, ve bu noktalardan geçen, hepsinden <em>kesinlikle</em>
geçen, yaklaşıksal bir eğri oluşturmak istiyoruz. Spline yöntemi her iki
nokta arasını farklı bir küpsel (üçüncü derece) polinom ile temsil
etmektir. Tekrar dikkat: tüm noktaları temsile edebilecek farklı
polinomları toplamıyoruz, her aralıkta başka bir polinom fonksiyonu
parçasını devreye sokuyoruz. Parçalar niye küpsel olarak seçildi? Çünkü
küpsel bir eğri yeterince kavis sağlayabilir ve aynı zamanda çok fazla
inişli çıkışlı, sivri değildir, yeterince pürüzsüz bir eğrinin ortaya
çıkmasını sağlar.</p>
<p><img src="spline1.png" /></p>
<p>Her <span class="math inline">\(i=0,..,n+1\)</span> için</p>
<p><span class="math display">\[ p(x) = p_i(x) = a_i + b_i(x-x_i) +
c_i(x-x_i)^2 + d_i(x-x_i)^3
\qquad (1)
\]</span></p>
<p>kullanalım. Noktalar <span class="math inline">\(x_i\)</span> olarak
gösteriliyor, ve her noktada aktif olan bir <span
class="math inline">\(p_i\)</span> spline olacak, o noktadan bir
sonrakine kadar eğriyi bu <span class="math inline">\(p_i\)</span>
tanımlayacak. Noktaların sayısını <span class="math inline">\(n\)</span>
yerine <span class="math inline">\(n+1\)</span> olarak aldık böylece
<span class="math inline">\(n\)</span> eğri parçası ile çalışmamız
mümkün olacak. Her spline bir küpsel polinom ise niye bu küpsel polinomu
en basit şekliyle</p>
<p><span class="math display">\[ p(x) = a_i + b_ix + c_ix^2 + d_ix^3
\]</span></p>
<p>olarak tanımlamadık? Çünkü iki üstteki form ile çalışmak daha rahat.
Mesela, eğer <span class="math inline">\(x\)</span> için <span
class="math inline">\(x_i\)</span> değrini verirsek, ki bu <span
class="math inline">\(x_1\)</span> ya da <span
class="math inline">\(x_2\)</span> olabilirdi, o zaman parantez içinde
<span class="math inline">\(x_i - x_i\)</span> sayesinde tüm terimler
sıfır oluyor, geriye sadece <span class="math inline">\(a_i\)</span>
kalıyor.</p>
<p>Parçaların uçlarının birbirini tutması, ve tüm şeklin sürekli,
akışkan bir şekilde gözükmesi için ise birkaç koşulu bizim tanımlamamız,
ve zorlamamız gerekli. Önce en basit olanı: bir önceki parça ile bir
sonraki parça orta nokta üzerinde aynı değere sahip olmalı. <span
class="math inline">\(i=1,..,n+1\)</span> için</p>
<p><span class="math display">\[ p_i (x_{i+1}) = p_{i+1}(x_{i+1})
\]</span></p>
<p>Bir diğer basit gereklilik, her <span
class="math inline">\(x_i\)</span>’ye tekabül eden spline fonksiyonun
elimizdeki <span class="math inline">\(y_i\)</span> değerini
vermesi,</p>
<p><span class="math display">\[ p_i(x_i) = y_i \]</span></p>
<p>“Tüm noktalardan kesinlikle geçmeli’’ demiştik. Son parça bir istisna
oluşturuyor, bu son parçanın fonksiyonu hem son noktayı, hem de ondan
bir önceki nokta için kullanılmalı, bir önceden en sona kadar aynı
fonksiyon üzerindeyiz.</p>
<p><span class="math display">\[ p_{n}(x_n) = y_{n+1} \]</span></p>
<p>Sistemi daha detaylı olarak görmek gerekirse, tüm denklemleri
yazalım,</p>
<p><span class="math display">\[ p_1(x)  = a_1 + b_1(x-x_1) +
c_1(x-x_1)^2 + d_1(x-x_1)^3\]</span></p>
<p><span class="math display">\[ p_2(x)  = a_2 + b_2(x-x_2) +
c_2(x-x_2)^2 + d_1(x-x_2)^3\]</span></p>
<p><span class="math display">\[ \vdots \]</span></p>
<p><span class="math display">\[ p_n(x)  = a_n + b_n(x-x_n) +
c_n(x-x_n)^2 + d_3(x-x_n)^3\]</span></p>
<p>Üç noktalı şöyle bir grafik düşünelim,</p>
<p><img src="spline2.png" /></p>
<p>Üstte bahsettiğimiz gibi, <span class="math inline">\(p_1(x_1) = a_1
= y_1\)</span> olacak, ve tüm indisler için bu geçerli. Ayrıca <span
class="math inline">\(x_2\)</span> noktasında bir önceki parça ve
sonraki parça aynı değere sahip olmalı demiştik, yani mesela <span
class="math inline">\(p_1\)</span>’in sonunda (üstteki ilk parça) <span
class="math inline">\(x_2\)</span> noktası vardır, ve aynı noktada <span
class="math inline">\(p_2\)</span> başlayacaktır, o noktada <span
class="math display">\[ p_1(x_2) = a_1 + b_1h_1 + c_1h_1^2 +
d_1h_1^3  \]</span></p>
<p>ve bu denklem <span class="math inline">\(p_2(x_2) = a_2 =
y_2\)</span>’ye eşit. Bir de, daha önce gördük, <span
class="math inline">\(a_1 = y_1\)</span> ise, o zaman</p>
<p><span class="math display">\[ y_2 = p_1(x_2) = y_1 + b_1h_1 +
c_1h_1^2 + d_1h_1^3 \]</span></p>
<p>haline gelir. Hepsini birarada yazıyoruz (<span
class="math inline">\(y\)</span>’yi sağ tarafa aldık)</p>
<p><span class="math display">\[ y_1 + b_1h_1 + c_1h_1^2 + d_1h_1^3 =
y_2
\qquad (2)
\]</span></p>
<p><span class="math display">\[ y_2 + b_2h_2 + c_2h_2^2 + d_2h_2^3 =
y_3 \]</span></p>
<p><span class="math display">\[ \vdots \]</span></p>
<p><span class="math display">\[ y_n + b_nh_n + c_nh_n^2 + d_nh_n^3 =
y_n \]</span></p>
<p>ki <span class="math inline">\(h_1 \equiv x_2 - x_1\)</span>, <span
class="math inline">\(h_2 \equiv x_3 - x_2\)</span> olarak tanımladık,
<span class="math inline">\(\equiv\)</span> işareti “tanımlamak (defined
as)’’ anlamına geliyor, <span class="math inline">\(h\)</span> harfi bir
tür kısaltma olarak kullanıldı. Fakat kesintisizlik için parçaların
uçlarının bitişmesi yeterli değil. Mesela alttaki figürün de uçları
birleşiktir,</p>
<p><img src="spline3.png" /></p>
<p>Demek ki ek bazı şartlar lazım. Bu ek şart “süreklilik’’ olabilir.
Mesela alttaki örnek sürekli değildir.</p>
<p><img src="spline5.png" /></p>
<p>Ya da daha iyisi, fonksiyonun her noktada “türevi alınabilir’’ olma
şartı. Mesela altta koyu yuvarlaklı gösterilen noktada fonksiyonun
türevi alınamaz.</p>
<p><img src="spline4.png" /></p>
<p>O zaman şartı koyalım – Fonksiyonun her noktasında, ikinci türev
sürekli alınabilmeli. Bu çok ağır / net bir şart aslında, ve hakikaten
çok pürüzsüz (smooth) fonksiyonların oluşmasına sebep oluyor. Şimdi
bunun ne anlamına biraz daha yakından bakalım. Biliyoruz ki futbol
sahalarının etrafında koşu alanı vardır. Bu alan şöyledir.</p>
<p><img src="spline6.png" /></p>
<p>Bu şekil iki ayrı figürün birleşimidir aslında, düz çizgiler ve iki
tane yarı çember. Üstteki düz çizgili kısım sonsuz kere türevi
alınabilir bir fonksiyondur. Değil mi? Düz çizgi sabit bir sayıdır, 1.
türev sıfır, ikinci türev yine sıfır, böyle gider. Peki yarı çember olan
kısımlar? Aynı şekilde. Peki her noktada durum böyle midir? Kritik
noktalar ufak yuvarlaklarla gösterilen yerler (altta)</p>
<p><img src="spline7.png" /></p>
<p>Bu noktalarda kaç kere “sürekli türevler’’ alınabilir? Cevap, sadece
bir kere. Çünkü iki kere türev alınınca ne olacağına bakalım, düz
kısımda ikinci, üçüncü, vs. türev sıfır. Peki yarı çember? Onun ikinci
türevi sıfır olmayan sabit bir sayı. O zaman fonksiyonun tamamının (düz
çizgi ve yarı çemberin beraber) 2. türevini grafiklesek, şöyle bir şekil
ortaya çıkardı,</p>
<p><img src="spline8.png" /></p>
<p>ve bu grafikte görüyoruz ki bir zıplama var. Bu zıplama yüzünden
süreklilik (2. türevde) bozulmuş oldu. O zaman spline düzgün, pürüzsüz
olsun istiyorsak, her noktada, yani bağlantı noktalarında, sağdaki ve
soldaki parçanın birinci ve ikinci türevinin aynı olması şartını
koyabiliriz, o zaman bu noktalarda fonksiyonun tamamı iki kere sürekli
türevi alınabilir hale gelir. Parçaların kendisi üzerinde bu şartı
tanımlamaya gerek yok, çünkü orada polinom kullanacağımızı belirttik
zaten, polinomlar sonsuz kere sürekli türevi alınabilen objelerdir.</p>
<p>Denklem sistemimize iki tane daha şart gerekiyor. Bu şartlar
fonksiyonun ilk noktada ve son noktada ikinci türevinin sıfır olması
şartı olabilir. Her hangi yöndeki bir çizgi <span
class="math inline">\(y = ax + b\)</span>’nin iki kere türevi alınınca
sıfır gelir, yani bu şart fonksiyonumuzun son noktalarda, fonksiyonun
“aşağı yukarı aynı yönde’’ olacak şekilde düz olarak devam etmesi
anlamına geliyor. Yaklaşıksal bağlamda fena bir şart değil.</p>
<p>O zaman ana formüllerimize dönelim, ve mesela <span
class="math inline">\(p_1(x),p_2(x)\)</span>’in türevini alalım,</p>
<p><span class="math display">\[ p_1&#39;(x) = b_1 + 2c_1h_1 + 3d_1h_1^2
\]</span></p>
<p><span class="math display">\[ p_2&#39;(x) = b_2 + 2c_2h_2 + 3d_2h_2^2
\]</span></p>
<p><span class="math display">\[ \vdots \]</span></p>
<p>Türevleri eşitleyelim <span class="math inline">\(p_1&#39;(x_2) =
p_2&#39;(x_2)\)</span>.</p>
<p><span class="math display">\[ p_1&#39;(x_2) = b_1 + 2c_1h_1 +
3d_1h_1^2 \]</span></p>
<p><span class="math display">\[  p_2&#39;(x_2) = b_2 \]</span></p>
<p>Üstteki niye sadece <span class="math inline">\(b_2\)</span> oldu?
Çünkü <span class="math inline">\(x_i-x_i\)</span> numarası onun için de
geçerli, geriye sadece <span class="math inline">\(b_2\)</span> kaldı.
Hepsi bir arada</p>
<p><span class="math display">\[  b_1 + 2c_1h_1 + 3d_1h_1^2  = b_2
\qquad (3)\]</span></p>
<p><span class="math display">\[  b_2 + 2c_2h_2 + 3d_2h_2^2 = b_3
\]</span></p>
<p><span class="math display">\[ \vdots \]</span></p>
<p><span class="math display">\[  b_{n-1} + 2c_{n-1}h_{n-1} +
3d_{n-1}h_{n-1}^2 =  b_n \]</span></p>
<p>İkinci türevler için benzer bir durum var, bu sefer sol taraftan
<span class="math inline">\(b\)</span>’ler yokoluyor,</p>
<p><span class="math display">\[ 2c_1 + 6d_1h_1 = 2c_2
\qquad (4) \]</span></p>
<p><span class="math display">\[ 2c_2 + 6d_2h_2 = 2c_3 \]</span></p>
<p><span class="math display">\[ \vdots \]</span></p>
<p><span class="math display">\[ 2c_{n-1} + 6d_{n-1}h_{n-1} = 2c_n
\]</span></p>
<p>İlk ve son ikinci türevi sıfıra eşitlemeyi unutmayalım. Son türev</p>
<p><span class="math display">\[ 2c_n + 6d_nh_n = 2c_{n+1} = 0
\]</span></p>
<p>İlk türev</p>
<p><span class="math display">\[ p_1&#39;&#39;(x_1) =  c_1 +
6d_1(x_1-x_1)  = c_1 = 0\]</span></p>
<p><span class="math display">\[ 6d_1(x_1-x_1) \]</span> sıfır olur</p>
<p>Denklem (4)’den başlayan bölümü tekrar düzenlersek,</p>
<p><span class="math display">\[ d_1 = \frac{ c_2 - c_1}{3h_1}
\qquad (5) \]</span></p>
<p><span class="math display">\[ d_2 = \frac{ c_3 - c_2}{3h_2}
\]</span></p>
<p><span class="math display">\[ \vdots \]</span></p>
<p><span class="math display">\[ d_n = \frac{ c_{n+1} - c_n}{3h_n}
\]</span></p>
<p>Üstteki denklemleri (2) ve (3)’e geri koyarsak,</p>
<p><span class="math display">\[ b_1 + \frac{ c_2 + 2c_1}{3}h_1 = s_1
\qquad (7) \]</span></p>
<p><span class="math display">\[ b_2 + \frac{ c_3 + 2c_2}{3}h_1 = s_2
\]</span></p>
<p><span class="math display">\[ \vdots \]</span></p>
<p><span class="math display">\[ b_n + \frac{ c_{n+1} + 2c_n}{3}h_n =
s_n \]</span></p>
<p>ki <span class="math inline">\(s_1 \equiv \frac{y_2 - y_1}{h_1}, s_2
\equiv \frac{y_3 - y_2}{h_2}\)</span>.</p>
<ol start="3" type="1">
<li>ifadesini alıp tekrar düzenlersek,</li>
</ol>
<p><span class="math display">\[  2c_1h_1 + 3d_1h_1^2  = b_2 -
b_1\]</span></p>
<p><span class="math inline">\(3d_1h_1\)</span> için başka bir ifade
kullanabiliriz, eğer (5)’i tekrar düzenlersek,</p>
<p><span class="math display">\[ 3h_1d_1 = c_2 - c_1\]</span></p>
<p>ve iki üstteki formüle koyarsak</p>
<p><span class="math display">\[  2c_1h_1 + (c_2 - c_1)h_1  = b_2 -
b_1\]</span></p>
<p><span class="math display">\[  2c_1h_1 + c_2h_1 - c_1h_1  = b_2 -
b_1\]</span></p>
<p><span class="math display">\[  c_1h_1 + c_2h_1  = b_2 -
b_1\]</span></p>
<p><span class="math display">\[  (c_1 + c_2) h_1  = b_2 -
b_1\]</span></p>
<p>Bu ifade tüm <span class="math inline">\(i\)</span> noktaları için
geçerli, hepsi bir arada</p>
<p><span class="math display">\[  (c_1 + c_2) h_1  = b_2 - b_1
\qquad (6)\]</span></p>
<p><span class="math display">\[  (c_2 + c_3) h_2  = b_3 -
b_2\]</span></p>
<p><span class="math display">\[ \vdots \]</span></p>
<p><span class="math display">\[  (c_{n-1} + c_n) h_{n-1}  = b_n -
b_{n-1}\]</span></p>
<p>(7)’deki ardı ardına gelen denklemleri birbirinden çıkartıp sonucu 3
ile çarparsak,</p>
<p><span class="math display">\[ c_1h_1 + 2c_2(h_1 + h_2) + c_3h_2 =
3(s_2 - s_1) \]</span></p>
<p><span class="math display">\[ c_2h_2 + 2c_3(h_2 + h_3) + c_4h_3 =
3(s_3 - s_2) \]</span></p>
<p><span class="math display">\[ \vdots \]</span></p>
<p><span class="math display">\[ c_{n-1}h_{n-1} + 2c_n(h_{n-1} + h_{n})
+ c_{n+1}h_n = 3(s_n - s_{n-1}) \]</span></p>
<p>Bu formüller birarada düşünülürse, bilinmeyenleri <span
class="math inline">\(c_2,c_3,..,c_n\)</span> olan normal (ordinary)
<span class="math inline">\(n-1\)</span> tane lineer denklemdirler, ve
bir matris çarpımı olarak düşünülebilirler.</p>
<p><span class="math inline">\(c_1h_1\)</span> matris formunda yok çünkü
<span class="math inline">\(c_1=0\)</span>.</p>
<p><span class="math display">\[
\left[\begin{array}{cccccc}
2(h_1+h_2) &amp; h_2 &amp; 0 &amp; 0 &amp; ... &amp; 0 \\
h_2 &amp; 2(h_2+h_3) &amp; h_3 &amp; 0 &amp; .. &amp; 0  \\
0 &amp; h_3 &amp; 2(h_3+h_4) &amp; h_4 &amp; .. &amp; 0 \\
0 &amp; 0 &amp; h_4 &amp; 2(h_4+h_5) &amp; ... &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp;
\vdots  \\
0 &amp; 0 &amp; .. &amp; 0 &amp; h_{n-1} &amp; 2(h_{n-1}+h_n)
\end{array}\right]
\left[\begin{array}{r}
c_2 \\ c_3 \\ \vdots \\ c_n
\end{array}\right]
\]</span></p>
<p>Bu denklem sağ tarafta suna eşit</p>
<p><span class="math display">\[
\left[\begin{array}{r}
3(s_2 - s_1) \\
3(s_3 - s_2) \\
3(s_4 - s_3) \\
\vdots \\
3(s_n - s_{n-1})
\end{array}\right]
\]</span></p>
<p>Bir üçgen köşegen (tridiagonal) matris iki tane ikili köşegen
(bidiagonal) matrisin çarpımına eşittir. LU çarpanlarına ayırma işlemi
de, bkz [11], bize bu matrisleri sağlayacaktır.</p>
<p><span class="math display">\[ Ax = b \]</span></p>
<p>şu hale gelir</p>
<p><span class="math display">\[ LUx = b \]</span></p>
<p>Şimdi eğer <span class="math inline">\(Ux = y\)</span> kabul edersek,
yani yeni bir değişkeni dahil edersek, <span
class="math inline">\(L\)</span>’i bulduktan sonra</p>
<p><span class="math display">\[ Ly = b \]</span></p>
<p>kabul edebiliriz, ve bu formülü de <span
class="math inline">\(y\)</span> için çözmek çok kolaydır. Sonra çözülen
<span class="math inline">\(y\)</span>’yi alıp geriye sokma
(backsubstitution) ile <span class="math inline">\(x\)</span>’i buluruz,
yani</p>
<p><span class="math display">\[ Ux = y \]</span></p>
<p>denklemini çözeriz.</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.linalg <span class="im">as</span> lin</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.array( [[<span class="fl">3.</span>,<span class="op">-</span><span class="fl">3.</span>,<span class="dv">0</span>,<span class="dv">0</span>],</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>               [<span class="op">-</span><span class="fl">3.</span>,<span class="fl">8.</span>,<span class="op">-</span><span class="fl">2.</span>,<span class="dv">0</span>],</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>               [<span class="dv">0</span>,<span class="fl">1.</span>,<span class="fl">2.</span>,<span class="fl">4.</span>],</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>               [<span class="dv">0</span>,<span class="dv">0</span>,<span class="op">-</span><span class="fl">2.</span>,<span class="fl">6.</span>]])</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>p,l,u <span class="op">=</span> lin.lu(a)</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>Ly <span class="op">=</span> np.array([[<span class="fl">7.</span>,<span class="fl">8.</span>,<span class="fl">2.</span>,<span class="op">-</span><span class="fl">3.</span>]])</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> lin.solve(l,Ly.T)</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> lin.solve(u,y)</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (x)</span></code></pre></div>
<pre><code>[[ 5.44047619]
 [ 3.10714286]
 [ 0.26785714]
 [-0.41071429]]</code></pre>
<p>Spline yöntemine dönersek, elimizdeki veri ve kod şöyle olsun</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.linalg <span class="im">as</span> lin</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>xx <span class="op">=</span> np.array([<span class="fl">4.</span>,<span class="fl">9.</span>,<span class="fl">12.</span>,<span class="fl">16.</span>,<span class="fl">22.</span>])</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>yy <span class="op">=</span> np.array([<span class="fl">157.</span>,<span class="fl">41.</span>,<span class="fl">145.</span>,<span class="fl">92.</span>,<span class="fl">7.</span>])</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> np.diff(xx)</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>dy <span class="op">=</span> np.diff(yy)</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> dy <span class="op">/</span> h</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>ds <span class="op">=</span> np.diff(s)</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>s3 <span class="op">=</span> <span class="dv">3</span> <span class="op">*</span> ds</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.array([[ <span class="dv">2</span><span class="op">*</span>(h[<span class="dv">0</span>]<span class="op">+</span>h[<span class="dv">1</span>]), h[<span class="dv">1</span>], <span class="dv">0</span>],</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>              [ h[<span class="dv">1</span>], <span class="dv">2</span><span class="op">*</span>(h[<span class="dv">1</span>]<span class="op">+</span>h[<span class="dv">2</span>]), h[<span class="dv">2</span>]],</span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>              [ <span class="dv">0</span>, h[<span class="dv">2</span>], <span class="dv">2</span><span class="op">*</span>(h[<span class="dv">2</span>]<span class="op">+</span>h[<span class="dv">3</span>])]])</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>p,l,u <span class="op">=</span> lin.lu(a)</span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> lin.solve(l,s3.T)</span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> lin.solve(u,y)</span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (c)</span></code></pre></div>
<pre><code>[ 13.45756677 -13.90702275   2.64390455]</code></pre>
<p><span class="math inline">\(c\)</span>’ler bulunduktan sonra <span
class="math inline">\(h\)</span>’lerle beraber kullanılarak <span
class="math inline">\(d\)</span>’ler bulunur, vs, ve tüm spline
parçalarının katsayıları ortaya çıkartılır.</p>
<p>Kodlar</p>
<p>Bazı kodlar altta bulunabilir. İlk önce SciPy ile B-spline, ilmikleri
biz dışarıdan tanımladık,</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.interpolate <span class="im">import</span> splev, splrep</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">10</span>)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.sin(x)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>tck <span class="op">=</span> splrep(x, y, t<span class="op">=</span>[<span class="dv">4</span>,<span class="dv">8</span>]) <span class="co"># ilmikler t icinde</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>x2 <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">200</span>)</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>y2 <span class="op">=</span> splev(x2, tck)</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>plt.plot(x, y, <span class="st">&#39;o&#39;</span>, x2, y2)</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_1_21_05.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_1_21_05.png" /></p>
<p>Alttaki kodlar tüm eğrinin verideki her noktayı ilmik olarak görmesi
gerektiğine göre yazılmıştır, yani her veri noktası aynı zamanda bir
ilmiktir.</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Splines(data):</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    np1<span class="op">=</span><span class="bu">len</span>(data)</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span>np1<span class="op">-</span><span class="dv">1</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    X,Y <span class="op">=</span> <span class="bu">zip</span>(<span class="op">*</span>data)</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> [<span class="bu">float</span>(x) <span class="cf">for</span> x <span class="kw">in</span> X]</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>    Y <span class="op">=</span> [<span class="bu">float</span>(y) <span class="cf">for</span> y <span class="kw">in</span> Y]</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> Y[:]</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> [<span class="fl">0.0</span>]<span class="op">*</span>(n)</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> [<span class="fl">0.0</span>]<span class="op">*</span>(n)</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> [X[i<span class="op">+</span><span class="dv">1</span>]<span class="op">-</span>X[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>    alpha <span class="op">=</span> [<span class="fl">0.0</span>]<span class="op">*</span>n</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n):</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>        alpha[i] <span class="op">=</span> <span class="dv">3</span><span class="op">/</span>h[i]<span class="op">*</span>(a[i<span class="op">+</span><span class="dv">1</span>]<span class="op">-</span>a[i]) <span class="op">-</span> <span class="dv">3</span><span class="op">/</span>h[i<span class="op">-</span><span class="dv">1</span>]<span class="op">*</span>(a[i]<span class="op">-</span>a[i<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> [<span class="fl">0.0</span>]<span class="op">*</span>np1</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>    L <span class="op">=</span> [<span class="fl">0.0</span>]<span class="op">*</span>np1</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> [<span class="fl">0.0</span>]<span class="op">*</span>np1</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> [<span class="fl">0.0</span>]<span class="op">*</span>np1</span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>    L[<span class="dv">0</span>] <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span> u[<span class="dv">0</span>] <span class="op">=</span> z[<span class="dv">0</span>] <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n):</span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a>        L[i] <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>(X[i<span class="op">+</span><span class="dv">1</span>]<span class="op">-</span>X[i<span class="op">-</span><span class="dv">1</span>]) <span class="op">-</span> h[i<span class="op">-</span><span class="dv">1</span>]<span class="op">*</span>u[i<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a>        u[i] <span class="op">=</span> h[i]<span class="op">/</span>L[i]</span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a>        z[i] <span class="op">=</span> (alpha[i]<span class="op">-</span>h[i<span class="op">-</span><span class="dv">1</span>]<span class="op">*</span>z[i<span class="op">-</span><span class="dv">1</span>])<span class="op">/</span>L[i]</span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a>    L[n] <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span> z[n] <span class="op">=</span> c[n] <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a>        c[j] <span class="op">=</span> z[j] <span class="op">-</span> u[j]<span class="op">*</span>c[j<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a>        b[j] <span class="op">=</span> (a[j<span class="op">+</span><span class="dv">1</span>]<span class="op">-</span>a[j])<span class="op">/</span>h[j] <span class="op">-</span> (h[j]<span class="op">*</span>(c[j<span class="op">+</span><span class="dv">1</span>]<span class="op">+</span><span class="dv">2</span><span class="op">*</span>c[j]))<span class="op">/</span><span class="dv">3</span></span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a>        d[j] <span class="op">=</span> (c[j<span class="op">+</span><span class="dv">1</span>]<span class="op">-</span>c[j])<span class="op">/</span>(<span class="dv">3</span><span class="op">*</span>h[j])</span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true" tabindex="-1"></a>    splines <span class="op">=</span> []</span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true" tabindex="-1"></a>        splines.append((a[i],b[i],c[i],d[i],X[i]))</span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> splines,X[n]</span>
<span id="cb34-34"><a href="#cb34-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-35"><a href="#cb34-35" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> splinesToPlot(splines,xn,res):</span>
<span id="cb34-36"><a href="#cb34-36" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span><span class="bu">len</span>(splines)</span>
<span id="cb34-37"><a href="#cb34-37" aria-hidden="true" tabindex="-1"></a>    perSpline <span class="op">=</span> <span class="bu">int</span>(res<span class="op">/</span>n)</span>
<span id="cb34-38"><a href="#cb34-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> perSpline <span class="op">&lt;</span> <span class="dv">3</span>: perSpline <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb34-39"><a href="#cb34-39" aria-hidden="true" tabindex="-1"></a>    X<span class="op">=</span>[]</span>
<span id="cb34-40"><a href="#cb34-40" aria-hidden="true" tabindex="-1"></a>    Y<span class="op">=</span>[]</span>
<span id="cb34-41"><a href="#cb34-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb34-42"><a href="#cb34-42" aria-hidden="true" tabindex="-1"></a>        S <span class="op">=</span> splines[i]</span>
<span id="cb34-43"><a href="#cb34-43" aria-hidden="true" tabindex="-1"></a>        x0 <span class="op">=</span> S[<span class="dv">4</span>]</span>
<span id="cb34-44"><a href="#cb34-44" aria-hidden="true" tabindex="-1"></a>        x1 <span class="op">=</span> splines[i<span class="op">+</span><span class="dv">1</span>][<span class="dv">4</span>]</span>
<span id="cb34-45"><a href="#cb34-45" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> np.linspace(x0,x1,perSpline)</span>
<span id="cb34-46"><a href="#cb34-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> xi <span class="kw">in</span> x:</span>
<span id="cb34-47"><a href="#cb34-47" aria-hidden="true" tabindex="-1"></a>            X.append(xi)</span>
<span id="cb34-48"><a href="#cb34-48" aria-hidden="true" tabindex="-1"></a>            h<span class="op">=</span>(xi<span class="op">-</span>S[<span class="dv">4</span>])</span>
<span id="cb34-49"><a href="#cb34-49" aria-hidden="true" tabindex="-1"></a>            Y.append(S[<span class="dv">0</span>]<span class="op">+</span>S[<span class="dv">1</span>]<span class="op">*</span>h <span class="op">+</span> S[<span class="dv">2</span>]<span class="op">*</span>h<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> S[<span class="dv">3</span>]<span class="op">*</span>h<span class="op">**</span><span class="dv">3</span>)</span>
<span id="cb34-50"><a href="#cb34-50" aria-hidden="true" tabindex="-1"></a>    S<span class="op">=</span>splines[n<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb34-51"><a href="#cb34-51" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span>np.linspace(S[<span class="dv">4</span>],xn,perSpline)</span>
<span id="cb34-52"><a href="#cb34-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> xi <span class="kw">in</span> x:</span>
<span id="cb34-53"><a href="#cb34-53" aria-hidden="true" tabindex="-1"></a>        X.append(xi)</span>
<span id="cb34-54"><a href="#cb34-54" aria-hidden="true" tabindex="-1"></a>        h<span class="op">=</span>(xi<span class="op">-</span>S[<span class="dv">4</span>])</span>
<span id="cb34-55"><a href="#cb34-55" aria-hidden="true" tabindex="-1"></a>        Y.append(S[<span class="dv">0</span>]<span class="op">+</span>S[<span class="dv">1</span>]<span class="op">*</span>h <span class="op">+</span> S[<span class="dv">2</span>]<span class="op">*</span>h<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> S[<span class="dv">3</span>]<span class="op">*</span>h<span class="op">**</span><span class="dv">3</span>)</span>
<span id="cb34-56"><a href="#cb34-56" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb34-57"><a href="#cb34-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> X,Y</span></code></pre></div>
<div class="sourceCode" id="cb35"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> Spline</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="kw">lambda</span> n: np.linspace(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>,n)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="kw">lambda</span> x: np.cos(np.sin(np.pi<span class="op">*</span>x))</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>E<span class="op">=</span><span class="dv">200</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> <span class="bu">list</span>(<span class="bu">zip</span>(x(n),f(x(n))))</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>splines,xn <span class="op">=</span> Spline.Splines(data)</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>X,Y <span class="op">=</span> Spline.splinesToPlot(splines,xn,E)</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>plt.plot(X,Y,<span class="st">&#39;r--&#39;</span>)</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>plt.plot(x(<span class="dv">300</span>),f(x(<span class="dv">300</span>)),<span class="st">&#39;k&#39;</span>)</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_1_21_04.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_1_21_04.png" /></p>
<p>Bir diğer örnek</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> LUdecomp3 <span class="im">import</span> <span class="op">*</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> curvatures(xData,yData):</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(xData) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> np.zeros(n)</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> np.ones(n<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>    e <span class="op">=</span> np.zeros(n)</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> np.zeros(n<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>    c[<span class="dv">0</span>:n<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> xData[<span class="dv">0</span>:n<span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> xData[<span class="dv">1</span>:n]</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>    d[<span class="dv">1</span>:n] <span class="op">=</span> <span class="fl">2.0</span><span class="op">*</span>(xData[<span class="dv">0</span>:n<span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> xData[<span class="dv">2</span>:n<span class="op">+</span><span class="dv">1</span>])</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>    e[<span class="dv">1</span>:n] <span class="op">=</span> xData[<span class="dv">1</span>:n] <span class="op">-</span> xData[<span class="dv">2</span>:n<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>    k[<span class="dv">1</span>:n] <span class="op">=</span><span class="fl">6.0</span><span class="op">*</span>(yData[<span class="dv">0</span>:n<span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> yData[<span class="dv">1</span>:n]) <span class="op">\</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>             <span class="op">/</span> (xData[<span class="dv">0</span>:n<span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> xData[<span class="dv">1</span>:n]) <span class="op">\</span></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>             <span class="op">-</span><span class="fl">6.0</span><span class="op">*</span>(yData[<span class="dv">1</span>:n] <span class="op">-</span> yData[<span class="dv">2</span>:n<span class="op">+</span><span class="dv">1</span>]) <span class="op">\</span></span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>             <span class="op">/</span> (xData[<span class="dv">1</span>:n] <span class="op">-</span> xData[<span class="dv">2</span>:n<span class="op">+</span><span class="dv">1</span>])</span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>    LUdecomp3(c,d,e)</span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>    LUsolve3(c,d,e,k)</span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> k    </span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evalSpline(xData,yData,k,x):</span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> findSegment(xData,x):</span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a>        iLeft <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a>        iRight <span class="op">=</span> <span class="bu">len</span>(xData)<span class="op">-</span> <span class="dv">1</span></span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="dv">1</span>:</span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>              <span class="cf">if</span> (iRight<span class="op">-</span>iLeft) <span class="op">&lt;=</span> <span class="dv">1</span>: <span class="cf">return</span> iLeft</span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a>              i <span class="op">=</span>(iLeft <span class="op">+</span> iRight)<span class="op">//</span><span class="dv">2</span> <span class="co"># Changed / to // for integer division</span></span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a>              <span class="cf">if</span> x <span class="op">&lt;</span> xData[i]: iRight <span class="op">=</span> i</span>
<span id="cb36-29"><a href="#cb36-29" aria-hidden="true" tabindex="-1"></a>              <span class="cf">else</span>: iLeft <span class="op">=</span> i</span>
<span id="cb36-30"><a href="#cb36-30" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb36-31"><a href="#cb36-31" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> findSegment(xData,x)</span>
<span id="cb36-32"><a href="#cb36-32" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> xData[i] <span class="op">-</span> xData[i<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb36-33"><a href="#cb36-33" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> ((x <span class="op">-</span> xData[i<span class="op">+</span><span class="dv">1</span>])<span class="op">**</span><span class="dv">3</span><span class="op">/</span>h <span class="op">-</span> (x <span class="op">-</span> xData[i<span class="op">+</span><span class="dv">1</span>])<span class="op">*</span>h)<span class="op">*</span>k[i]<span class="op">/</span><span class="fl">6.0</span> <span class="op">\</span></span>
<span id="cb36-34"><a href="#cb36-34" aria-hidden="true" tabindex="-1"></a>        <span class="op">-</span> ((x <span class="op">-</span> xData[i])<span class="op">**</span><span class="dv">3</span><span class="op">/</span>h <span class="op">-</span> (x <span class="op">-</span> xData[i])<span class="op">*</span>h)<span class="op">*</span>k[i<span class="op">+</span><span class="dv">1</span>]<span class="op">/</span><span class="fl">6.0</span> <span class="op">\</span></span>
<span id="cb36-35"><a href="#cb36-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">+</span> (yData[i]<span class="op">*</span>(x <span class="op">-</span> xData[i<span class="op">+</span><span class="dv">1</span>]) <span class="op">-</span> yData[i<span class="op">+</span><span class="dv">1</span>]<span class="op">*</span>(x <span class="op">-</span> xData[i]))<span class="op">/</span>h</span>
<span id="cb36-36"><a href="#cb36-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> y</span>
<span id="cb36-37"><a href="#cb36-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-38"><a href="#cb36-38" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>: </span>
<span id="cb36-39"><a href="#cb36-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-40"><a href="#cb36-40" aria-hidden="true" tabindex="-1"></a>    xData <span class="op">=</span> np.array([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>],<span class="bu">float</span>)</span>
<span id="cb36-41"><a href="#cb36-41" aria-hidden="true" tabindex="-1"></a>    yData <span class="op">=</span> np.array([<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>],<span class="bu">float</span>)</span>
<span id="cb36-42"><a href="#cb36-42" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> curvatures(xData,yData)</span>
<span id="cb36-43"><a href="#cb36-43" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="fl">1.5</span>    </span>
<span id="cb36-44"><a href="#cb36-44" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;y =&quot;</span>,evalSpline(xData,yData,k,x))</span>
<span id="cb36-45"><a href="#cb36-45" aria-hidden="true" tabindex="-1"></a>    </span></code></pre></div>
<div class="sourceCode" id="cb37"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd, cubicSpline</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(<span class="st">&#39;in.csv&#39;</span>)</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> cubicSpline.curvatures(np.array(df.x), np.array(df.y))</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (res)</span></code></pre></div>
<pre><code>[ 0.         -2.27960615  0.5983445  -2.14369027 -0.5421918  -0.9485407
  4.83823742  1.40244849 -0.82589911 -1.3439826   2.52298704  0.        ]</code></pre>
<p>Kodlar</p>
<p><a href="LUdecomp3.py">LUdecomp3.py</a>, <a
href="cubicSpline.py">cubicSpline.py</a>, <a
href="Spline.py">Spline.py</a></p>
<p>Kaynaklar</p>
<p>[1] Beu, <em>Introduction to Numerical Programming A Practical Guide
for Scientists and Engineers Using Python and C/C++</em></p>
<p>[2] Ruppert, <em>Semiparametric Regression</em></p>
<p>[3] Harrell, <em>Regression Modeling Strategies, 2nd Edition</em></p>
<p>[4] Bayramlı, Lineer Cebir, <em>Ders 16</em></p>
<p>[5] Bayramlı, İstatistik, <em>Lineer Regresyon</em></p>
<p>[6] Bantis, <em>Restricted Cubic Spline</em>, <a
href="https://uk.mathworks.com/matlabcentral/fileexchange/41241-restricted-cubic-spline">https://uk.mathworks.com/matlabcentral/fileexchange/41241-restricted-cubic-spline</a></p>
<p>[7] Vrbik, <em>MATH 2P20 NUMERICAL ANALYSIS I Lecture Notes</em>, <a
href="http://spartan.ac.brocku.ca/~jvrbik/MATH2P20/notes.pdf">http://spartan.ac.brocku.ca/~jvrbik/MATH2P20/notes.pdf</a></p>
<p>[8] Ertel, <em>Advanced Mathematics for Engineers Lecture
No. 14</em>, <a
href="http://www.youtube.com/watch?v=3rHBCglD1LQ">http://www.youtube.com/watch?v=3rHBCglD1LQ</a></p>
<p>[9] Ertel, <em>Advanced Mathematics for Engineers Lecture
No. 15</em>, <a
href="http://www.youtube.com/watch?v=nA0YpqraP9A">http://www.youtube.com/watch?v=nA0YpqraP9A</a></p>
<p>[10] Recktenwald, <em>Numerical Methods with MATLAB Implementations
and Applications</em></p>
<p>[11] Bayramlı, Lineer Cebir, <em>Ders 4</em></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
