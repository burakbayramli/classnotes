<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Dalga Denklemi (Wave Equation)</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="dalga-denklemi-wave-equation">Dalga Denklemi (Wave
Equation)</h1>
<p>Denklem [1],</p>
<p><span class="math display">\[
\frac{\partial^2 y}{\partial x^2}  =
\frac{1}{c^2}\frac{\partial^2 y}{\partial t^2}
\]</span></p>
<p>Denkleme yakından bakarsak onun bir kısmı türevsel denklem (PDE)
olduğunu görürüz. İki tane bağımsız değişken temel alınıyor, <span
class="math inline">\(x,t\)</span>. Ayrıca denklem 2. derece, çünkü
ikinci türevi içeriyor. Bu bilgiler denklemi çözmek için önemli [2].</p>
<p>Çözümde bir başlangıç şartı gerekli çünkü diferansiyel denklemleri
“entegre ederken’’ daha doğrusu ileri doğru geçen zamanda hesaplarken
bir başlangıç noktası gerekiyor, bunun için bir teli kaldırıp (geçici
bir süre üçgen haline getirip) oradan bıraktığımızı düşünebiliriz, ki bu
üçgen şekli alttaki gibi modellenebilir,</p>
<p><span class="math display">\[
y(x,t=0)=\begin{cases}
1.25 x/L , &amp;x\leq 0.8 L ,\\
(5-5x/L), &amp;x&gt; 0.8 L,
\end{cases}
\]</span></p>
<p>İkinci bir başlangıç şartı daha lazım, 2. derece başlangıç şartı bu.
Teli, ipi gerip üçgen yaptım ama sonra durup tekrar bıraktım, bu da bir
başlangıç şartı, durağan durumdan başlama şartı.</p>
<p><span class="math display">\[
\frac{\partial y} {\partial t}(x,t=0) =0
\]</span></p>
<p>Çözüme bu şartlarla başlayabilirdik ama baştaki problem tanımını
hatırlarsak ek bazı şartlar daha koymuştuk, bu şartlar, kısıtlamalar her
an için geçerli, ipler iki ucundan (hareket etmeyen) duvarlara
bağlı.</p>
<p><span class="math display">\[
y(0,t) \equiv 0, \quad y(L,t) \equiv 0
\]</span></p>
<p>[analitik çözüm atlandı]</p>
<p>Yaklaşıksal hesap için <span class="math inline">\(x,t\)</span>
eksenleri düşünebiliriz, ve bu eksenlerde sadece belli noktalardaki
hesaplar yapılacak, <span class="math inline">\(x\)</span> için
aralıklar <span class="math inline">\(\Delta x\)</span> genişliğinde,
<span class="math inline">\(t\)</span> için <span
class="math inline">\(\Delta t\)</span> genişliğinde, aralık büyüklüğünü
biz tanımlayacağız. Yani hesap noktaları <span
class="math inline">\(i=1,2,3,...\)</span> için <span
class="math inline">\(i \Delta t\)</span>’de, <span
class="math inline">\(x\)</span> için <span
class="math inline">\(j=1,2,..\)</span> ile <span
class="math inline">\(j \Delta t\)</span>’de.</p>
<p><img src="compscieng_app17wave_03.png" /></p>
<p>Yaklaşıksallıkta bir diğer kullanılacak teknik merkezi farklılıklar,
burada <span class="math inline">\(x\)</span> için sola/sağa, <span
class="math inline">\(t\)</span> için yukarı/aşağı olacak şekilde iki
Taylor açılımı yapıyoruz,</p>
<p><span class="math display">\[
y(x +\Delta x, t)  = y(x,t) +
\frac{\partial U}{\partial x}\Delta x + \frac{1}{2}
\frac{\partial^2 U}{\partial x^2}(\Delta x)^2 + \cdots
\]</span></p>
<p><span class="math display">\[
y(x -\Delta x, t)  = y(x,t) -
\frac{\partial U}{\partial x} \Delta x + \frac{1} {2}
\frac{\partial^2 U}{\partial x^2} (\Delta x)^2 - \cdots
\]</span></p>
<p><span class="math display">\[
y(x, y +\Delta t)  = y(x,t) +
\frac{\partial U}{\partial t}\Delta y + \frac{1}{2}
\frac{\partial^2 U}{\partial t^2}(\Delta t)^2 + \cdots
\]</span></p>
<p><span class="math display">\[
y(x, y -\Delta t) = y(x,t) -
\frac{\partial U}{\partial t} \Delta t + \frac{1} {2}
\frac{\partial^2 U}{\partial t^2} (\Delta t)^2 - \cdots
\]</span></p>
<p>Noktalı yerlerdeki terimleri yok sayıyoruz (2. derece yaklaşıklama
yapmış olduk yani, bu önemli, yaklaşık temsilin kuvvetini gösteriyor bir
anlamda), sonra her değişkenin iki açılımını birbiri ile topluyoruz.
Toplama sonrası tek sayı terimlerinin iptal olduğunu görürüz, ve
kalanlar,</p>
<p><span class="math display">\[
\frac{\partial^2 y(x,t)}{\partial x^2} \simeq
\frac{y(x+\Delta x,t)+y(x-\Delta x,t)-2 y(x,t)}{(\Delta x)^2}
\]</span></p>
<p><span class="math display">\[
\frac{\partial^2 y(x,t)}{\partial t^2} \simeq
\frac{y(x,t+\Delta t) +y(x, y-\Delta t)-2 y(x,t)}{(\Delta t)^2}
\]</span></p>
<p>olacaktır. İndisler üzerinden belirtirsek,</p>
<p><span class="math display">\[
\frac{\partial^2 y }{\partial t^2} \simeq
\frac{y_{i,j+1}+y_{i,j-1}-2 y_{i,j}}{(\Delta t)^2}, \quad
\frac{\partial^2 y}{\partial x^2} \simeq
\frac{y_{i+1,j}+y_{i-1,j}-2 y_{i,j}} {(\Delta x)^2}.
\]</span></p>
<p>Üstteki formülleri dalga denklemindeki yerlerine koyarsak,</p>
<p><span class="math display">\[
\frac{y_{i,j+1}+y_{i,j-1}-2 y_{i,j}} {c^2 (\Delta t)^2}  =
\frac{y_{i+1,j}+y_{i-1,j}-2 y_{i,j}} {(\Delta x)^2}
\qquad (2)
\]</span></p>
<p>Tabii dikkat edersek geçmiş <span class="math inline">\(j-1\)</span>
ve gelecek <span class="math inline">\(j+1\)</span> birbirine karışmış
durumda, bize lazım olan geleceğin hesabının eşitliğin sol tarafında
olması geri kalan her şey sağda olacak şekilde tekrar düzenlersek,</p>
<p><span class="math display">\[
y_{i,j+1}  = 2 y_{i,j}-y_{i,j-1}+ \frac{c^2 } {c&#39;^{2}}
\left [ y_{i+1,j}+y_{i-1,j}-2 y_{i,j}\right], \quad c&#39; { = }
\frac {\Delta x}{\Delta t}
\qquad (1)
\]</span></p>
<p>Hesap için üstteki resmi hatırlayalım, <span
class="math inline">\(i,j+1\)</span> hücresine dört diğer hücreden ok
çizilmiş, aslında bu oklar üstteki formülün hesabını anlatıyor, o anki
<span class="math inline">\(t\)</span> zamanından üç hesap ve geçmişten
<span class="math inline">\(i,j-1\)</span> hesabına bakarak gelecekteki
değeri hesaplıyoruz. Bu hesaplama çok verimli olacak çünkü herhangi bir
anda hafızada tutulması gereken <span
class="math inline">\(y(i,j)\)</span> haricinde sadece üç tane değer
var.</p>
<p>Son bir problem başlangıç anı ile alakalı, resimdeki bilinmesi
gereken o üç hücrenin başlangıç <span class="math inline">\(j=1\)</span>
anında olduğunu düşünürsek, ve <span
class="math inline">\(j=2\)</span>’yi hesaplamamız gerekiyor, eksi
zamana doğru bir gidişat lazım, yani <span
class="math inline">\(j=-1\)</span> zamanı. Başlangıç bilgisi <span
class="math inline">\(j=1\)</span> var, ama <span
class="math inline">\(j=-1\)</span> yok. Buradaki bilgiyi nasıl
alacağız?</p>
<p>Denklemsel olarak bir ek koşul daha ekleyerek, ilk başta hem teli
çekip üçgen haline getirmiştik, bir de başlangıç anında telin hızı
sıfırdır diyeceğiz. Bu mantıksız değil, tel çekildi, tutuluyor.. hareket
yok. Denklem olarak <span class="math inline">\(\partial y / \partial
t(x,0)\)</span> sıfır diyeceğiz. Sonra bu denklemin merkezi farklılık
açılımını yapacağız ve oradan gelen eşitlikleri ana (1)’e sokarak sadece
<span class="math inline">\(j=2\)</span> için özel bir formül elde
etmeyi umuyoruz.</p>
<p><span class="math display">\[
\frac{\partial y}{\partial t}(x,0) \simeq
\frac{y(x, \Delta t)- y(x, -\Delta t)}{2\Delta t}=0, \
\Rightarrow \ y_{i, 0} = y_{i,2}
\]</span></p>
<p>(1)’e sokunca</p>
<p><span class="math display">\[
y_{i,2} = y_{i,1}+ \frac{c^2} {c&#39;^2}
\left [ y_{i+1,1}+y_{i-1,1}-2 y_{i,1}\right]
\]</span></p>
<p>Dikkat bu denklem sadece <span class="math inline">\(j=2\)</span>
için. Bundan sonraki her <span class="math inline">\(j\)</span> için ana
(1) formülü işleyecektir.</p>
<p>Stabilite, von Neumann</p>
<p>Çözümün stabil olması için <span class="math inline">\(c \le
\frac{\Delta x}{\Delta t}\)</span> şartının doğru olması gerekir, ve
çoğunlukla <span class="math inline">\(\Delta x\)</span> bizim
kontrolümüzde olmaz, problemin dayattığı bir büyüklük olur, <span
class="math inline">\(c\)</span> fiziki modelin bir parçasıdır, o zaman
<span class="math inline">\(\Delta t\)</span>’nin diğer verili
parametrelere göre şarta uygun seçilmesi gerekir. Şarta von Neumann ya
da Courant stabilite şartı ismi veriliyor.</p>
<p>Türetmek için alttaki gibi bir yaklaşım [3] kullanılabilir. Fakat
ilerlemeden önce Euler denkleminden türetilen bazı ek formülleri
görelim, bu formüller birazdan işimize yarayacak. Euler formülü
hatırlarsak,</p>
<p><span class="math display">\[
e^{ix} = \cos (x) + i\sin(x)
\]</span></p>
<p>Üstteki formülü <span class="math inline">\(-x\)</span> için
yazarsak,</p>
<p><span class="math display">\[
e^{-ix} = \cos (-x) + i\sin(-x)
\]</span></p>
<p>olur. Kosinüs’ün simetrik davranışı, yani <span
class="math inline">\(\cos(-x)=\cos(x)\)</span> ve <span
class="math inline">\(-\sin(x)=\sin(-x)\)</span> olması sebebiyle,
üstteki</p>
<p><span class="math display">\[
= \cos(x) - i\sin(x)
\]</span></p>
<p>olarak yazılabilir. Şimdi eğer <span
class="math inline">\(e^{ix}\)</span> ve <span
class="math inline">\(e^{-ix}\)</span>’i toplarsak, önceden gördüğümüz
açılımlar üzerinden,</p>
<p><span class="math display">\[
e^{ix} + e^{-ix} = 2\cos(x)
\]</span></p>
<p>olur, çünkü eksi işaretli <span class="math inline">\(\sin\)</span>
artı olanla beraber iptal olur. Tekrar düzenlersek,</p>
<p><span class="math display">\[
\cos(x) = \frac{1}{2} (e^{ix} + e^{-ix})
\qquad (3)
\]</span></p>
<p>Benzer bir eşitliği <span class="math inline">\(e^{ix} -
e^{-ix}\)</span> üzerinden elde edebiliriz,</p>
<p><span class="math display">\[
e^{ix} - e^{-ix} = 2i\sin(x)
\]</span></p>
<p>Tekrar düzenleyince aynen biraz önce bir <span
class="math inline">\(\cos\)</span> tanımı elde ettiğimiz gibi bir de
<span class="math inline">\(\sin\)</span> tanımı elde ederiz,</p>
<p><span class="math display">\[
\sin(x) = \frac{1}{2i} (e^{ix} - e^{-ix})
\]</span></p>
<p>Dalga kısmi denklemi ne idi?</p>
<p><span class="math display">\[
\partial_t^2 y(x,t) = c(x)^2 \partial_x^2 y(x,t)
\]</span></p>
<p>[2] notasyonu <span class="math inline">\(c\)</span> yerine <span
class="math inline">\(c(x)\)</span> kullanmış. Şimdi stabilite şartını
türetmek için çözümün basit bir düzlem dalgası (plane wave) olduğunu
farz edeceğiz [1], yani çözüm</p>
<p><span class="math display">\[
y(x,t) = e^{i(kx-\omega t)}
\]</span></p>
<p>formunda olacak. Bu formu ayrıksallaştırıp kısmı türevsel forma
sokunca çıkan eşitlikler üzerinden bir stabilite şartı elde etmek
amacımız. [3] notasyonu yerine [2]’imsi notasyon kullanacağız, yani
<span class="math inline">\(x,t\)</span> indisleri <span
class="math inline">\(i,j\)</span> yerine <span
class="math inline">\(j,n\)</span>, herhalde hayali sayı <span
class="math inline">\(i\)</span> ile karışıklık olmasın diye böyle
seçilmiş. O zaman <span class="math inline">\(x \to j \Delta x\)</span>,
<span class="math inline">\(t \to n \Delta t\)</span> olur.</p>
<p>Alttaki analitik soldaki formül ayrıksal şu hale gelir,</p>
<p><span class="math display">\[
y(x,t) = e^{i(kx - \omega t)} \to
y_{j,n} = e^{i(kj\Delta x - \omega n \Delta t)}
\]</span></p>
<p>Peki bu formülleri (2) bağlamında nasıl kullanacağız? Aslında bu çok
basit.</p>
<p>Mesela <span class="math inline">\(y_{j+1,n}\)</span> için ayrıksal
uzayda bir adım atmış oluyoruz, bu adımın basit dalga formülünde
karşılığı</p>
<p><span class="math display">\[
y_{j+1,n} = e^{i ( k(j+1)\Delta x - \omega n \Delta t )}
\]</span></p>
<p>Karışık gibi duruyor fakat <span class="math inline">\(e\)</span>
bazlı işlem yapmanın faydasını göreceğiz şimdi,</p>
<p><span class="math display">\[
= e^{i k \Delta x} e^{i(k j \Delta x - \omega n \Delta t)}
\]</span></p>
<p>Bir <span class="math inline">\(e\)</span> bazlı terimi dışarı çekmiş
olduk. Geri kalan sağdaki <span class="math inline">\(e\)</span> bloğuna
bakınca onun <span class="math inline">\(y_{j,n}\)</span> olduğunu
görüyoruz! O zaman</p>
<p><span class="math display">\[
y_{j+1,n} = e^{i k \Delta x} y_{j,n}
\]</span></p>
<p>Benzer bir işlemi <span class="math inline">\(y_{j-1,n}\)</span> için
de gerçekleştirebiliriz,</p>
<p><span class="math display">\[
y_{j-1,n} = e^{-i k \Delta x} e^{i(k j \Delta x - \omega n \Delta t)}
\]</span></p>
<p><span class="math display">\[
= e^{-i k \Delta x} y_{j,n}
\]</span></p>
<p>Teknik ayrıksal zaman üzerinde de işliyor,</p>
<p><span class="math display">\[
y_{j,n+1}  = e^{-i k \Delta t} y_{j,n}
\]</span></p>
<p><span class="math display">\[
y_{j,n-1}  = e^{i k \Delta t} y_{j,n}
\]</span></p>
<p>O zaman bu öğeleri dalga denklemi (2)’ye sokabiliriz. O denklemi
[2]’ye göre birazcık değiştirip tekrar verelim,</p>
<p><span class="math display">\[
\frac{y_{j,n+1} - 2 y_{j,n} + y_{j,n-1} }{\Delta t^2} =
c_j^2 \left[ \frac{ y_{j+1,n} - 2 y_{j,n} + y_{j-1,n} }{\Delta
x^2}  \right]
\]</span></p>
<p>Şimdi üstteki formülde sonlu ayrıksal terimleri, yani <span
class="math inline">\(y_{j,n+1}\)</span>, <span
class="math inline">\(y_{j,n-1}\)</span>, <span
class="math inline">\(y_{j+1,n}\)</span>, ve <span
class="math inline">\(y_{j-1,n}\)</span> terimlerini, biraz önce
bulduğumuz üstel terimlerle değiştirelim,</p>
<p><span class="math display">\[
e^{i(k j \Delta x - \omega n \Delta t)} \left[
\frac{ e^{i\omega \Delta t} - 2  + e^{-i\omega \Delta t}  }
     {\Delta t^2}\right] =
c^2 \left[
\frac{e^{ik\Delta x} - 2 + e^{-ik\Delta x}}
     {\Delta x^2}
\right] e^{i(k j \Delta x - \omega n \Delta t)}
\]</span></p>
<p><span class="math inline">\(c_j \to c\)</span> geçişi her <span
class="math inline">\(j \Delta x\)</span> noktasına göre tanımlanıyor
muhakkak.</p>
<p>Devam edelim, son formülde basitleştirme yapılabilir, en sol ve
sağdaki terimler iptal olabilir,</p>
<p><span class="math display">\[
\left[
\frac{ e^{i\omega \Delta t} - 2  + e^{-i\omega \Delta t}  }
     {\Delta t^2}\right] =
c^2 \left[
\frac{e^{ik\Delta x} - 2 + e^{-ik\Delta x}}
     {\Delta x^2}
\right]
\]</span></p>
<p>Geri kalanları tekrar düzenleyelim,</p>
<p><span class="math display">\[
e^{i\omega \Delta t} + e^{-i\omega \Delta t} - 2 =
c^2 \frac{\Delta t^2}{\Delta x^2} [ e^{ik\Delta x} - e^{-ik\Delta x} -
2]
\]</span></p>
<p>Hayali terimlerden kurtulmak istiyoruz tabii, bu noktada (3)’teki
kosinüs tanımını tekrar hatırlayalım, onu kullanırsak, eşitliğin
solundaki iki terim ve sağındaki iki terim için ayrı ayrı,</p>
<p><span class="math display">\[
2 \cos(\omega \Delta t) - 2 = c^2 \frac{\Delta t^2}{\Delta x^2}
(2 \cos(k\Delta x) - 2)
\]</span></p>
<p>Herşeyi 2 ile bölelim,</p>
<p><span class="math display">\[
\cos(\omega \Delta t) - 1 = c^2 \frac{\Delta t^2}{\Delta x^2}
(\cos(k\Delta x) - 1)
\qquad (4)
\]</span></p>
<p>Şimdi bir diğer trigonometrik eşitliği kullanacağız [4],</p>
<p><span class="math display">\[
2\sin^2(x) = 1 - \cos (2x)
\]</span></p>
<p>Biraz degistirirsek,</p>
<p><span class="math display">\[
\sin (x) = \sqrt{1 - \cos (2x)}
\]</span></p>
<p>Ya da</p>
<p><span class="math display">\[
\sin (\frac{x}{2}) = \pm \sqrt{1 - \cos (x)}
\]</span></p>
<p>Bu eşitliğin (4) ifadesini nasıl basitleştireceğini görmek zor
değil,</p>
<p><span class="math display">\[
\sin^2(\omega \frac{\Delta t}{r}) =
c^2 \frac{\Delta t^2}{\Delta x^2} \sin^2 (k \frac{\Delta x}{2} )
\]</span></p>
<p>Karelerden kurtulabiliriz,</p>
<p><span class="math display">\[
\sin(\omega \frac{\Delta t}{r}) =
c \frac{\Delta t}{\Delta x} \sin (k \frac{\Delta x}{2} )
\]</span></p>
<p>İşte bu basit denklem sayısal analizin en temel bulgularından birine
götürdü bizi.</p>
<p>Üstteki denklemin reel sonuçlara sahip olması için</p>
<p><span class="math display">\[
c \frac{\Delta t}{\Delta x} \le 1
\]</span></p>
<p>olmalıdır. Bu koşul artık ünlü olan Courant-Friedrichs-Lewy (CFL)
koşulu, ya da kriteridir. Bu koşul iki tür hızın arasında bir ilişki
kurar, biri fiziksel hız, ki fiziksel ortamda dalganın yayılma hızı bu,
diğeri ise “algoritmik hız’’ bir anlamda, bizim tanımladığımız ızgaranın
genişliği <span class="math inline">\(\Delta x\)</span> bölü yine bizim
seçtiğimiz zaman aralığı <span class="math inline">\(\Delta
t\)</span>.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>rho <span class="op">=</span> <span class="fl">0.01</span><span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>ten <span class="op">=</span> <span class="fl">40.</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> np.sqrt(ten<span class="op">/</span>rho)               </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>c1 <span class="op">=</span> c<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>ratio <span class="op">=</span>  c<span class="op">*</span>c<span class="op">/</span>(c1<span class="op">*</span>c1)  <span class="co"># CFL kriteri = 1</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co"># dongunun her adiminda sadece uc zaman dilimi yeterli, o sebeple</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># xi [_,3] boyutunda. </span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>xi <span class="op">=</span> np.zeros((<span class="dv">101</span>,<span class="dv">3</span>), <span class="bu">float</span>)                            </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="dv">101</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">81</span>):</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>   xi[i, <span class="dv">0</span>] <span class="op">=</span> <span class="fl">0.00125</span><span class="op">*</span>i         </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span> (<span class="dv">81</span>, <span class="dv">101</span>):</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>   xi[i, <span class="dv">0</span>] <span class="op">=</span> <span class="fl">0.1</span> <span class="op">-</span> <span class="fl">0.005</span><span class="op">*</span>(i <span class="op">-</span> <span class="dv">80</span>) </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()  </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">100</span>): </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    xi[i,<span class="dv">1</span>] <span class="op">=</span> xi[i,<span class="dv">0</span>] <span class="op">+</span> <span class="fl">0.5</span><span class="op">*</span>ratio<span class="op">*</span>(xi[i<span class="op">+</span><span class="dv">1</span>,<span class="dv">0</span>] <span class="op">+</span> xi[i<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>] <span class="op">-</span><span class="dv">2</span><span class="op">*</span>xi[i,<span class="dv">0</span>])  </span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">100</span>):</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>   <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">100</span>):              </span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>      xi[i,<span class="dv">2</span>] <span class="op">=</span> <span class="fl">2.</span><span class="op">*</span>xi[i,<span class="dv">1</span>]<span class="op">-</span>xi[i,<span class="dv">0</span>]<span class="op">+</span>ratio<span class="op">*</span>(xi[i<span class="op">+</span><span class="dv">1</span>,<span class="dv">1</span>]<span class="op">+</span>xi[i<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>]<span class="op">-</span><span class="dv">2</span><span class="op">*</span>xi[i,<span class="dv">1</span>])</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>   <span class="cf">if</span> j <span class="op">%</span> <span class="dv">5</span> <span class="op">==</span> <span class="dv">0</span>:      </span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>      plt.grid(<span class="va">True</span>)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>      plt.xlim(<span class="dv">0</span>, <span class="dv">101</span>)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>      plt.ylim(<span class="op">-</span><span class="fl">0.15</span>, <span class="fl">0.15</span>)</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>      plt.plot(k,xi[k,<span class="dv">2</span>])</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>      plt.savefig(<span class="st">&#39;/tmp/string-</span><span class="sc">%02d</span><span class="st">.png&#39;</span> <span class="op">%</span> j)</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>      plt.clf()</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>   <span class="co"># bitti, 1,2 indisi yeni 0,1 olacak</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>   <span class="cf">for</span> m <span class="kw">in</span> <span class="bu">range</span> (<span class="dv">0</span>,<span class="dv">101</span>):</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>      xi[m, <span class="dv">0</span>] <span class="op">=</span> xi[m, <span class="dv">1</span>]</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>      xi[m, <span class="dv">1</span>] <span class="op">=</span> xi[m, <span class="dv">2</span>]</span></code></pre></div>
<p><img src="string-00.png" /></p>
<p><img src="string-25.png" /></p>
<p><img src="string-55.png" /></p>
<p><img src="string-85.png" /></p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>os.system(<span class="st">&quot;convert -loop 0 -delay 100 /tmp/string*.png string.gif&quot;</span>)</span></code></pre></div>
<p>Animasyonlu sonucu [5]’te bulabiliriz.</p>
<p>Tek Boyutlu Lineer Taşınım Akımı (Convection)</p>
<p>Tek boyutlu lineer taşınım akımı, ya da tek boyutlu lineer yatay
iletim (advection), CFD hakkında bir şeyler öğrenmek için güzel
fırsatlar içeriyor. Bu ufak denklemin bize ne kadar çok şey öğreteceğini
görmek bizi şaşırtabilir. Denklem,</p>
<p><span class="math display">\[
\frac{\partial u}{\partial t} +
c \frac{\partial u}{\partial x}  = 0
\qquad (2)
\]</span></p>
<p>Dikkat bu bir dalga denklemi olarak bilinir, fakat esas dalga
denkleminin kısmi türevsel formu ikinci kısmi türevi içeriyor, bkz [7].
Üstteki denklem verili başlangıç şartlarına göre bir basit dalganın
şekil değiştirmeden <span class="math inline">\(c\)</span> hızında
yayılmasını temsil eder. Başlangıç şartlarını <span
class="math inline">\(u(x,0) = u_0(x)\)</span> olarak gösterirsek,
denklemin kesin analitik çözümü <span class="math inline">\(u(x,y) =
u_0(x-ct)\)</span>.</p>
<p>Üstteki formülü süreklilik denkleminin [8] bir formu olarak ta
görebiliriz [9, sf. 557]. Süreklilik denklemi</p>
<p><span class="math display">\[
\frac{\partial \rho}{\partial t}  + \nabla \cdot (\rho \bar{u} ) = 0
\]</span></p>
<p>idi, bu formülü tek boyutta düşünürsek ve sabit hız <span
class="math inline">\(\bar{u} = c\)</span> alırsak (2)’ye ulaşırız.</p>
<p>Denklemi hem zaman, hem uzay bağlamında ayrıksallaştıracağız. Türev
tanımından (ve limit ifadesini çıkartınca),</p>
<p><span class="math display">\[
\frac{\partial u}{\partial x} \approx
\frac{u(x+\Delta x) - u(x)}{\Delta x}
\]</span></p>
<p>olduğunu biliyoruz. Şimdi zamanda İleri Farklılık (Forward
Difference), uzayda Geriye Farklılık (Backward Difference) kullanalım..
Ve eğer <span class="math inline">\(x\)</span> eksenini <span
class="math inline">\(N\)</span> parçaya ayırırsak ve bu parçaları <span
class="math inline">\(i=0,..,N\)</span> ile indekslersek, ve en ufak
zaman adımını da <span class="math inline">\(\Delta t\)</span> ile
gösterip o adımı <span class="math inline">\(n\)</span> ile
indislersek,</p>
<p><span class="math display">\[
\frac{u_i^{n+1} - u_i^n}{\Delta t} + c \frac{u_i^{n} - u_{i-1}^n}{\Delta
x} = 0
\]</span></p>
<p>ki <span class="math inline">\(n\)</span> ve <span
class="math inline">\(n+1\)</span> ardı ardına olan iki zaman adımı,
<span class="math inline">\(i-1\)</span> ve <span
class="math inline">\(i\)</span> ise ayrıksallaştırılmış iki <span
class="math inline">\(x\)</span> yeri oluyor. Eğer başlangıç koşulları
verilmiş ise o zaman bu ayrıksal sistemde tek bilinmeyen <span
class="math inline">\(u_i^{n+1}\)</span>’dir. Denklemi tekrar
düzenlersek bilinmeyen için yeni bir formül elde edebiliriz,</p>
<p><span class="math display">\[
u_i^{n+1} = u_i^n - c \frac{\Delta t}{\Delta x} ( u_i^n - u_{i-1}^n )
\qquad (1)
\]</span></p>
<p>Yeri temsil eden <span class="math inline">\(x\)</span> eksenini eşit
aralıklı parçalara böleceğiz, bir tek boyutlu ızgara yaratacağız,
genişlik 2 birim olacak, <code>nx</code> değişkeni kaç tane ızgara
noktası olduğunu tanımlayacak, <code>dx</code> iki nokta arasındaki
uzaklık.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time, sys</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>nx <span class="op">=</span> <span class="dv">41</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>dx <span class="op">=</span> <span class="dv">2</span> <span class="op">/</span> (nx<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>nt <span class="op">=</span> <span class="dv">25</span>  </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> <span class="fl">.025</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> <span class="dv">1</span>    </span></code></pre></div>
<p>Başlangıç şartlarını tanımlamak lazım, başlangıç hızı <span
class="math inline">\(u_0\)</span> aralık <span
class="math inline">\(0.5 \leq x \leq 1\)</span> içinde <span
class="math inline">\(u = 2\)</span>, diğer her yerde <span
class="math inline">\(u = 1\)</span>.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> np.ones(nx)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>u[<span class="bu">int</span>(<span class="fl">.5</span> <span class="op">/</span> dx):<span class="bu">int</span>(<span class="dv">1</span> <span class="op">/</span> dx <span class="op">+</span> <span class="dv">1</span>)] <span class="op">=</span> <span class="dv">2</span>  </span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(u)</span></code></pre></div>
<pre class="text"><code>[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 2. 2. 2. 2. 2. 2. 2. 2. 2. 2. 2. 1. 1. 1.
 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]</code></pre>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>plt.plot(np.linspace(<span class="dv">0</span>, <span class="dv">2</span>, nx), u)<span class="op">;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app45cfd1_01.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_app45cfd1_01.png" /></p>
<p>Üstteki bir fonksiyon türü aslında, ona görüntüsü sebebiyle “şapka
fonksiyonu’’ ismi de veriliyor.</p>
<p>Şimdi taşınım akımı denkleminin ayrıksal kodlamasına gelelim, burada
sonlu farklılık (finite difference) yaklaşımı kullanıyoruz, <span
class="math inline">\(u\)</span> vektörü içindeki her öge için (1)
formülünü işleteceğiz.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>un <span class="op">=</span> np.ones(nx)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(nt):</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    un <span class="op">=</span> u.copy() </span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, nx):</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        u[i] <span class="op">=</span> un[i] <span class="op">-</span> c <span class="op">*</span> dt <span class="op">/</span> dx <span class="op">*</span> (un[i] <span class="op">-</span> un[i<span class="op">-</span><span class="dv">1</span>])        </span></code></pre></div>
<p>Üstteki işlemle zamanı ileri sardık ve fonksiyon belli bir noktaya
geldi. Nereye geldi?</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>plt.plot(np.linspace(<span class="dv">0</span>, <span class="dv">2</span>, nx), u)<span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app45cfd1_02.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_app45cfd1_02.png" /></p>
<p>Evet, başlangıç fonksiyonu hakikaten sağa doğru taşındı. Fakat artık
fonksiyon bir şapka değil. Ne oldu? Sonuç yaklaşık temsilin kalitesiyle
alakalı, <code>dx</code> ve <code>dt</code> küçültüldükçe kalite
artacaktır, ve şapkaya daha çok benzeyen sonuçlar görülecektir.</p>
<p>Gayrı Lineer Taşınım Akımı (Nonlinear Convection)</p>
<p>Şimdi biraz önceki teknikleri kullanarak gayrı lineer taşınım akımı
kodlayacağız, tek boyutta denklem,</p>
<p><span class="math display">\[
\frac{\partial u}{\partial t} +
u  \frac{\partial u}{\partial c}  = 0
\]</span></p>
<p>Dikkat edersek önceki denklemdeki <span
class="math inline">\(c\)</span> ile çarpım yerine şimdi <span
class="math inline">\(u\)</span> ile çarpım var, bu sebeple formülün
ikinci terimi gayrı lineer hale geldi. Eğer ayrıksallaştırma işlemini
tekrar uygularsak, alttaki sonuca erişiriz,</p>
<p><span class="math display">\[
u_i^{n+1} = u_i^n -  u_i^n \frac{\Delta t}{\Delta x} ( u_i^n - u_{i-1}^n
)
\]</span></p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>nx <span class="op">=</span> <span class="dv">41</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>dx <span class="op">=</span> <span class="dv">2</span> <span class="op">/</span> (nx <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>nt <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> <span class="fl">.025</span> </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> np.ones(nx)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>u[<span class="bu">int</span>(<span class="fl">.5</span> <span class="op">/</span> dx) : <span class="bu">int</span>(<span class="dv">1</span> <span class="op">/</span> dx <span class="op">+</span> <span class="dv">1</span>)] <span class="op">=</span> <span class="dv">2</span>  </span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>un <span class="op">=</span> np.ones(nx)</span></code></pre></div>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>un <span class="op">=</span> np.ones(nx)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(nt):</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    un <span class="op">=</span> u.copy() </span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, nx):</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        u[i] <span class="op">=</span> un[i] <span class="op">-</span> un[i] <span class="op">*</span> dt <span class="op">/</span> dx <span class="op">*</span> (un[i] <span class="op">-</span> un[i<span class="op">-</span><span class="dv">1</span>])        </span></code></pre></div>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>plt.plot(np.linspace(<span class="dv">0</span>, <span class="dv">2</span>, nx), u)<span class="op">;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app45cfd1_03.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_app45cfd1_03.png" /></p>
<p>Yakınsama (Convergence)</p>
<p>Lineer taşınım hesabında ortaya çıkan tepe şeklinin ızgara
çözünülürlüğü ile alakalı olduğunu söylemiştik. Bunu birkaç farklı
çözünürlük ile deneyerek görelim. İlk gördüğümüz sonuç
<code>nx=41</code> kullandı. Arttıralım,</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> linearconv(nx):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    dx <span class="op">=</span> <span class="dv">2</span> <span class="op">/</span> (nx <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    nt <span class="op">=</span> <span class="dv">20</span>    </span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> <span class="fl">.025</span>  </span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> np.ones(nx)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    u[<span class="bu">int</span>(<span class="fl">.5</span><span class="op">/</span>dx):<span class="bu">int</span>(<span class="dv">1</span> <span class="op">/</span> dx <span class="op">+</span> <span class="dv">1</span>)] <span class="op">=</span> <span class="dv">2</span>  </span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    un <span class="op">=</span> np.ones(nx)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(nt):</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        un <span class="op">=</span> u.copy() </span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, nx):</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>            u[i] <span class="op">=</span> un[i] <span class="op">-</span> c <span class="op">*</span> dt <span class="op">/</span> dx <span class="op">*</span> (un[i] <span class="op">-</span> un[i<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    plt.plot(np.linspace(<span class="dv">0</span>, <span class="dv">2</span>, nx), u)<span class="op">;</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>linearconv(<span class="dv">61</span>)</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app45cfd1_04.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_app45cfd1_04.png" /></p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>linearconv(<span class="dv">71</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app45cfd1_05.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_app45cfd1_05.png" /></p>
<p>Gittikçe daha fazla şapka fonsiyonuna benzer sonuçlar alıyoruz. Şimdi
dikkat, bir kez daha arttıralım,</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>linearconv(<span class="dv">85</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app45cfd1_06.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_app45cfd1_06.png" /></p>
<p>Bu sonuç şapka fonksiyonuna benzemiyor. Ne oldu?</p>
<p>Hesaplananları düşünürsek, yer ekseni üzerinde dalganın hareketini
hesaplıyoruz, fakat her adımda <span class="math inline">\(\Delta t =
0.025\)</span> farzederk bu hesapları yapıyoruz. Üstteki yanlış sonuçta
<span class="math inline">\(\Delta t\)</span> zaman aralığında öyle bir
adım attık ki bu adım <code>dx</code>’in büyüklüğünden daha fazla. Bu
durum ilk denemelerde ortaya çıkmadı çünkü <code>dx</code> yeterince
büyük tutulmuştu. Fakat onu küçültükçe bir noktada hesap patladı.</p>
<p>Stabilite için <span class="math inline">\(\Delta t\)</span> adımını
<span class="math inline">\(\Delta x\)</span> ile ilişkilendirecek bir
formül faydalıdır, böyle bir formül var,</p>
<p><span class="math display">\[
\sigma = \frac{u \Delta t}{\Delta x} \le \sigma_{max}
\]</span></p>
<p><span class="math inline">\(u\)</span> dalganın hızı, <span
class="math inline">\(\sigma\)</span> degiskeni Courant sayısı, ve <span
class="math inline">\(\sigma_{max}\)</span> stabiliteyi sağlayacak üst
limit. Çoğunlukla <span class="math inline">\(\sigma_{max} = 1\)</span>
seçilir. Bu ilişkinin türetilmesini [12]’de bulabiliriz.</p>
<p>Diffusion (Yayınım) Denklemi</p>
<p>Tek boyuttaki yayınım denklemi,</p>
<p><span class="math display">\[
\frac{\partial u}{\partial t} = \nu \frac{\partial^2 u}{\partial x^2}
\]</span></p>
<p>Dikkat edersek bu denklemde bir ikinci kısmı türev var. Denklemin o
kısmını Merkezi Farklar yaklaşımı ile ayrıksal hale getireceğiz, bu
yaklaşım İleri Farklar ve Geriye Farklar yaklaşımlarının birleştirilmesi
ile elde edilir.</p>
<p>Önce Taylor serilerini hatırlarsak, genel tanım</p>
<p><span class="math display">\[
f(x+h) = f(x) + h f&#39;(x) + \frac{h^2}{2} f&#39;&#39;(x) + ...
\]</span></p>
<p>Biz <span class="math inline">\(u_{i+1}\)</span> ve <span
class="math inline">\(u_{i-1}\)</span> açılımını Taylor serisi ile
yapmak istiyoruz, daha önce belirttiğimiz gibi bir önceki ve sonraki
<span class="math inline">\(x\)</span> değerleri <span
class="math inline">\(\Delta x\)</span> uzaklığında, yani bir önceki</p>
<p><span class="math display">\[
u(x-\Delta x) = u(x) - \Delta x f&#39;(x) + \frac{h^2}{2} u&#39;&#39;(x)
+ ...
\]</span></p>
<p>İşaretin eksi olmasına dikkat, ve sonraki</p>
<p><span class="math display">\[
u(x+\Delta x) = u(x) + \Delta x f&#39;(x) + \frac{h^2}{2} u&#39;&#39;(x)
+ ...
\]</span></p>
<p>Şimdi indisleriyle <span class="math inline">\(u\)</span> için ve
[6]’deki formuyla yazalım,</p>
<p><span class="math display">\[
u_{i+1} = u_i + \Delta x \frac{\partial u}{\partial x}\bigg|_i +
\frac{\Delta x^2}{2} \frac{\partial ^2 u}{\partial x^2}\bigg|_i +
\frac{\Delta x^3}{3!} \frac{\partial ^3 u}{\partial x^3}\bigg|_i +
O(\Delta x^4)
\]</span></p>
<p><span class="math display">\[
u_{i-1} = u_i - \Delta x \frac{\partial u}{\partial x}\bigg|_i +
\frac{\Delta x^2}{2} \frac{\partial ^2 u}{\partial x^2}\bigg|_i -
\frac{\Delta x^3}{3!} \frac{\partial ^3 u}{\partial x^3}\bigg|_i +
O(\Delta x^4)
\]</span></p>
<p>Bir üstteki denklemin ilk hali $u_i = u_{i-1} … $ ile ama ufak bir
yer değişimi ile görülen biçim elde edilmiş.</p>
<p>Son iki formülü toplarsak bazı terimlerin ters işaretli olması
sebebiyle iptal olacağını görebiriliz. Ayrıca yaklaşık temsil açısından
<span class="math inline">\(O(\Delta x^4)\)</span> ve daha üstü
kuvvetleri yok sayarsak,</p>
<p><span class="math display">\[
u_{i+1} + u_{i-1} =
2u_i+\Delta x^2 \frac{\partial ^2 u}{\partial x^2}\bigg|_i +
O(\Delta x^4)
\]</span></p>
<p><span class="math inline">\(\frac{\partial ^2 u}{\partial
x^2}\bigg|_i\)</span> için çözersek ve tekrar düzenlersek,</p>
<p><span class="math display">\[
\frac{\partial ^2 u}{\partial x^2}=\frac{u_{i+1}-2u_{i}+u_{i-1}}{\Delta
x^2} + O(\Delta x^2)
\]</span></p>
<p><span class="math inline">\(O(\Delta x^2)\)</span> ifadesi <span
class="math inline">\(O(\Delta x^4)\)</span> terimi <span
class="math inline">\(\Delta x^2\)</span> ile bölününce ortaya
çıktı.</p>
<p>Artık 1D yayınım formülünün nihai ayrıksal halini yazabiliriz,</p>
<p><span class="math display">\[
\frac{u_{i}^{n+1}-u_{i}^{n}}{\Delta t} =
\nu\frac{u_{i+1}^{n}-2u_{i}^{n}+u_{i-1}^{n}}{\Delta x^2}
\]</span></p>
<p>Daha önce olduğu gibi başlangıç koşuları tanımlı ise tek bilinmeyen
<span class="math inline">\(u_{i}^{n+1}\)</span>, bu bilinmeyen
eşitliğin solunda kalacak şekilde tekrar düzenlersek,</p>
<p><span class="math display">\[
u_{i}^{n+1} =
u_{i}^{n}+\frac{\nu\Delta t}{\Delta
x^2}(u_{i+1}^{n}-2u_{i}^{n}+u_{i-1}^{n})
\]</span></p>
<p>Üstteki denklem bize çözümü adım adım ilerletmemizi sağlayacak. Ama
bir başlangıç koşuluna ihtiyacımız var, daha önceki favorimize
dönebiliriz, şapka fonksiyonu. <span
class="math inline">\(t=2\)</span>’de <span
class="math inline">\(u=0\)</span>, <span class="math inline">\(0.5\le
x\le 1\)</span> aralığında ise <span
class="math inline">\(u=1\)</span>.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>nx <span class="op">=</span> <span class="dv">41</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>dx <span class="op">=</span> <span class="dv">2</span> <span class="op">/</span> (nx <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>nt <span class="op">=</span> <span class="dv">20</span> </span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>nu <span class="op">=</span> <span class="fl">0.3</span> </span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="fl">.2</span> </span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> sigma <span class="op">*</span> dx<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> nu </span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> np.ones(nx)     </span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>u[<span class="bu">int</span>(<span class="fl">.5</span> <span class="op">/</span> dx):<span class="bu">int</span>(<span class="dv">1</span> <span class="op">/</span> dx <span class="op">+</span> <span class="dv">1</span>)] <span class="op">=</span> <span class="dv">2</span> </span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>un <span class="op">=</span> np.ones(nx)</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(nt): </span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    un <span class="op">=</span> u.copy() </span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, nx <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>        u[i] <span class="op">=</span> un[i] <span class="op">+</span> nu <span class="op">*</span> dt <span class="op">/</span> dx<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> (un[i<span class="op">+</span><span class="dv">1</span>] <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> un[i] <span class="op">+</span> un[i<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>plt.plot(np.linspace(<span class="dv">0</span>, <span class="dv">2</span>, nx), u)<span class="op">;</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app45cfd2_01.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_app45cfd2_01.png" /></p>
<p>2D Taşınım (2D Convection)</p>
<p>2 boyuta geçme zamanı geldi. 2D lineer taşınım akımını (convection)
temsil eden parçalı kısmi diferansiyel denklem,</p>
<p><span class="math display">\[
\frac{\partial u}{\partial t} +
c\frac{\partial u}{\partial x} +
c\frac{\partial  u}{\partial y} = 0
\]</span></p>
<p>Bu 1D lineer taşınım akımı ile neredeyse aynı formda, sadece şimdi
tek yersel boyut yerine iki tane boyutumuz var, <span
class="math inline">\(x\)</span> ve <span
class="math inline">\(y\)</span>.</p>
<p>Ayrıksal hale getirmek için aynı yaklaşımı kullanacağız, zaman
adımlarını ileri farklar, konumsal değişkenleri ise geriye farklar
yöntemi ile ayrıksal yapacağız. 1D durumda <span
class="math inline">\(i\)</span> altsimgesini konumda olan hareketlilik
için kullanmıştık, <span
class="math inline">\(u_{i}^n-u_{i-1}^n\)</span> mesela. Şimdi, 2D
durumda, ikinci bir altsimge <span class="math inline">\(j\)</span>
ekliyoruz, <span class="math inline">\(y\)</span> boyutunu böylece
indislemiş olacağız.</p>
<p>Tüm bunları kullanarak ayrıksal forma erişmek zor değil,</p>
<p><span class="math display">\[
\frac{u_{i,j}^{n+1}-u_{i,j}^n}{\Delta t} +
c\frac{u_{i, j}^n-u_{i-1,j}^n}{\Delta x} +
c\frac{u_{i,j}^n-u_{i,j-1}^n}{\Delta y}=0
\]</span></p>
<p>Daha önce olduğu gibi tek bilinmeyene göre tekrar düzenleyelim,</p>
<p><span class="math display">\[
u_{i,j}^{n+1} =
u_{i,j}^n-c \frac{\Delta t}{\Delta x}(u_{i,j}^n-u_{i-1,j}^n) -
c \frac{\Delta t}{\Delta y}(u_{i,j}^n-u_{i,j-1}^n)
\]</span></p>
<p>Denklemi alttaki başlangıç şartlarına göre çözeceğiz,</p>
<p><span class="math display">\[
u(x,y) = \begin{cases}
\begin{matrix}
2\ &amp; 0.5 \leq x, y \leq 1   &amp; \text{için}  \cr
1\ &amp; \text{diğer her yerde}
\end{matrix}\end{cases}
\]</span></p>
<p>Sınır şartları</p>
<p><span class="math display">\[
u = 1\ \text{değeri } \begin{cases}
\begin{matrix}
x =  0,\ 2 \cr
y =  0,\ 2 \end{matrix}\end{cases}
\text{ için }
\]</span></p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpl_toolkits.mplot3d <span class="im">import</span> Axes3D    </span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> cm</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>nx <span class="op">=</span> <span class="dv">81</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>ny <span class="op">=</span> <span class="dv">81</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>nt <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>dx <span class="op">=</span> <span class="dv">2</span> <span class="op">/</span> (nx <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>dy <span class="op">=</span> <span class="dv">2</span> <span class="op">/</span> (ny <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="fl">.2</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> sigma <span class="op">*</span> dx</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">2</span>, nx)</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">2</span>, ny)</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> np.ones((ny, nx)) <span class="co">##create a 1xn vector of 1&#39;s</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>un <span class="op">=</span> np.ones((ny, nx)) <span class="co">##</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>u[<span class="bu">int</span>(<span class="fl">.5</span> <span class="op">/</span> dy):<span class="bu">int</span>(<span class="dv">1</span> <span class="op">/</span> dy <span class="op">+</span> <span class="dv">1</span>),<span class="bu">int</span>(<span class="fl">.5</span> <span class="op">/</span> dx):<span class="bu">int</span>(<span class="dv">1</span> <span class="op">/</span> dx <span class="op">+</span> <span class="dv">1</span>)] <span class="op">=</span> <span class="dv">2</span> </span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, subplot_kw<span class="op">=</span>{<span class="st">&#39;projection&#39;</span>: <span class="st">&#39;3d&#39;</span>})</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>X, Y <span class="op">=</span> np.meshgrid(x, y)                            </span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>surf <span class="op">=</span> ax.plot_surface(X, Y, u[:], cmap<span class="op">=</span>cm.viridis)</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app45cfd3_01.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_app45cfd3_01.png" /></p>
<p>İki boyutta zamanı ileri saralım şimdi. Tüm <span
class="math inline">\(i\)</span> ve <span
class="math inline">\(j\)</span>’leri işleyebilmek için bir içiçe geçmiş
döngü gerekiyor bize. Python dilinde <code>for</code> kullanmak çok
optimal değildir, ama alttaki kod neler olduğunu gösterebilmek için
yardımcı olacaktır.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> np.ones((ny, nx))</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>u[<span class="bu">int</span>(<span class="fl">.5</span> <span class="op">/</span> dy):<span class="bu">int</span>(<span class="dv">1</span> <span class="op">/</span> dy <span class="op">+</span> <span class="dv">1</span>), <span class="bu">int</span>(<span class="fl">.5</span> <span class="op">/</span> dx):<span class="bu">int</span>(<span class="dv">1</span> <span class="op">/</span> dx <span class="op">+</span> <span class="dv">1</span>)] <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(nt <span class="op">+</span> <span class="dv">1</span>): </span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    un <span class="op">=</span> u.copy()</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    row, col <span class="op">=</span> u.shape</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, row):</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, col):</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>            tmp1 <span class="op">=</span> (c <span class="op">*</span> dt <span class="op">/</span> dx <span class="op">*</span> (un[j, i] <span class="op">-</span> un[j, i <span class="op">-</span> <span class="dv">1</span>]))</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>            tmp2 <span class="op">=</span> (c <span class="op">*</span> dt <span class="op">/</span> dy <span class="op">*</span> (un[j, i] <span class="op">-</span> un[j <span class="op">-</span> <span class="dv">1</span>, i]))</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>            u[j, i] <span class="op">=</span> (un[j, i] <span class="op">-</span> tmp1 <span class="op">-</span> tmp2)</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>            u[<span class="dv">0</span>, :] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>            u[<span class="op">-</span><span class="dv">1</span>, :] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>            u[:, <span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>            u[:, <span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, subplot_kw<span class="op">=</span>{<span class="st">&#39;projection&#39;</span>: <span class="st">&#39;3d&#39;</span>})</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>surf2 <span class="op">=</span> ax.plot_surface(X, Y, u[:], cmap<span class="op">=</span>cm.viridis)</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app45cfd3_02.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_app45cfd3_02.png" /></p>
<p>Burgers’in Denklemi</p>
<p>Bu denklem tek boyutta şuna benziyor</p>
<p><span class="math display">\[
\frac{\partial u}{\partial t} + u \frac{\partial u}{\partial x} =
\nu \frac{\partial ^2u}{\partial x^2}
\]</span></p>
<p>Görüldüğü gibi bu formül gayrı lineer taşınım akımı (convection) ile
yayınım (diffusion) formüllerinin birleşimi. O zaman denklemi önce
gördüğümüz teknikler ile ayrıksal hale getirebiliriz.</p>
<p><span class="math display">\[
\frac{u_i^{n+1}-u_i^n}{\Delta t} + u_i^n \frac{u_i^n - u_{i-1}^n}{\Delta
x} =
\nu \frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{\Delta x^2}
\]</span></p>
<p>Daha önce olduğu gibi başlangıç koşulumuz var, ona göre denklemi
tekrar düzenliyoruz,</p>
<p><span class="math display">\[
u_i^{n+1} =
u_i^n - u_i^n \frac{\Delta t}{\Delta x} (u_i^n - u_{i-1}^n) +
\nu \frac{\Delta t}{\Delta x^2}(u_{i+1}^n - 2u_i^n + u_{i-1}^n)
\]</span></p>
<p>Bu örnekte farklı bir başlangıç şartı kullanacağız.</p>
<p><span class="math display">\[
u = -\frac{2 \nu}{\phi} \frac{\partial \phi}{\partial x} + 4
\]</span></p>
<p><span class="math display">\[
\phi = \exp \bigg(\frac{-x^2}{4 \nu} \bigg) + \exp \bigg(\frac{-(x-2
\pi)^2}{4 \nu} \bigg)
\]</span></p>
<p>Bu başlangıç şartlarına göre Burgers denkleminin analitik çözümü
biliniyor,</p>
<p><span class="math display">\[
u = -\frac{2 \nu}{\phi} \frac{\partial \phi}{\partial x} + 4
\]</span></p>
<p><span class="math display">\[
\phi = \exp \bigg(\frac{-(x-4t)^2}{4 \nu (t+1)} \bigg) + \exp
\bigg(\frac{-(x-4t -2 \pi)^2}{4 \nu(t+1)} \bigg)
\]</span></p>
<p>Sınır şartı</p>
<p><span class="math display">\[
u(0) = u(2\pi)
\]</span></p>
<p>Fakat başlangıç şartını belli ızgara noktalarında işletebilmek
istiyoruz, fakat üstteki formülde çetrefil bir form var, birşeylerin
türevi vs var. Ne yapacağız? Paket <code>sympy</code>
kullanılabilir.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sympy</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sympy.utilities.lambdify <span class="im">import</span> lambdify</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sympy <span class="im">import</span> init_printing</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>init_printing(use_latex<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>x, nu, t <span class="op">=</span> sympy.symbols(<span class="st">&#39;x nu t&#39;</span>)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>phi <span class="op">=</span> (sympy.exp(<span class="op">-</span>(x <span class="op">-</span> <span class="dv">4</span> <span class="op">*</span> t)<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> (<span class="dv">4</span> <span class="op">*</span> nu <span class="op">*</span> (t <span class="op">+</span> <span class="dv">1</span>))) <span class="op">+</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>       sympy.exp(<span class="op">-</span>(x <span class="op">-</span> <span class="dv">4</span> <span class="op">*</span> t <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> sympy.pi)<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> (<span class="dv">4</span> <span class="op">*</span> nu <span class="op">*</span> (t <span class="op">+</span> <span class="dv">1</span>))))</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>phiprime <span class="op">=</span> phi.diff(x)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> <span class="op">-</span><span class="dv">2</span> <span class="op">*</span> nu <span class="op">*</span> (phiprime <span class="op">/</span> phi) <span class="op">+</span> <span class="dv">4</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>ufunc <span class="op">=</span> lambdify((t, x, nu), u)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ufunc(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">3</span>))</span></code></pre></div>
<pre class="text"><code>3.49170664206445</code></pre>
<div class="sourceCode" id="cb20"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>nx <span class="op">=</span> <span class="dv">101</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>nt <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>dx <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> np.pi <span class="op">/</span> (nx <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>nu <span class="op">=</span> <span class="fl">.07</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> dx <span class="op">*</span> nu</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">2</span> <span class="op">*</span> np.pi, nx)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>un <span class="op">=</span> np.empty(nx)</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> np.asarray([ufunc(t, x0, nu) <span class="cf">for</span> x0 <span class="kw">in</span> x])</span></code></pre></div>
<div class="sourceCode" id="cb21"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">11</span>, <span class="dv">7</span>), dpi<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>plt.plot(x, u, marker<span class="op">=</span><span class="st">&#39;o&#39;</span>, lw<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>plt.xlim([<span class="dv">0</span>, <span class="dv">2</span> <span class="op">*</span> np.pi])</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>plt.ylim([<span class="dv">0</span>, <span class="dv">10</span>])<span class="op">;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app45cfd2_02.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_app45cfd2_02.png" /></p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(nt):</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    un <span class="op">=</span> u.copy()</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, nx<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>        u[i] <span class="op">=</span> un[i] <span class="op">-</span> un[i] <span class="op">*</span> dt <span class="op">/</span> dx <span class="op">*</span>(un[i] <span class="op">-</span> un[i<span class="op">-</span><span class="dv">1</span>]) <span class="op">+</span> nu <span class="op">*</span> dt <span class="op">/</span> dx<span class="op">**</span><span class="dv">2</span> <span class="op">*\</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>                (un[i<span class="op">+</span><span class="dv">1</span>] <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> un[i] <span class="op">+</span> un[i<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    u[<span class="dv">0</span>] <span class="op">=</span> un[<span class="dv">0</span>] <span class="op">-</span> un[<span class="dv">0</span>] <span class="op">*</span> dt <span class="op">/</span> dx <span class="op">*</span> (un[<span class="dv">0</span>] <span class="op">-</span> un[<span class="op">-</span><span class="dv">2</span>]) <span class="op">+</span> nu <span class="op">*</span> dt <span class="op">/</span> dx<span class="op">**</span><span class="dv">2</span> <span class="op">*\</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>                (un[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> un[<span class="dv">0</span>] <span class="op">+</span> un[<span class="op">-</span><span class="dv">2</span>])</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    u[<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> u[<span class="dv">0</span>]</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>u_analytical <span class="op">=</span> np.asarray([ufunc(nt <span class="op">*</span> dt, xi, nu) <span class="cf">for</span> xi <span class="kw">in</span> x])</span></code></pre></div>
<div class="sourceCode" id="cb23"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">11</span>, <span class="dv">7</span>), dpi<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>plt.plot(x,u, marker<span class="op">=</span><span class="st">&#39;o&#39;</span>, lw<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">&#39;Hesapsal&#39;</span>)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>plt.plot(x, u_analytical, label<span class="op">=</span><span class="st">&#39;Analitik&#39;</span>)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>plt.xlim([<span class="dv">0</span>, <span class="dv">2</span> <span class="op">*</span> np.pi])</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>plt.ylim([<span class="dv">0</span>, <span class="dv">10</span>])</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>plt.legend()<span class="op">;</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_app45cfd2_03.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_app45cfd2_03.png" /></p>
<p>Alternatif Anlatim [9, sf. 559]</p>
<p>Tek boyutta Burgers’in denklemi,</p>
<p><span class="math display">\[
\frac{\partial u}{\partial t} + \epsilon u \frac{\partial u}{\partial x}
= 0
\]</span></p>
<p>olarak ta gösterilebilir. Denklemin muhafazakar formu
(ayrıksallaştırmada işi kolaylaştırıyor),</p>
<p><span class="math display">\[
\frac{\partial u}{\partial t} + \epsilon \frac{\partial (u^2 /
2)}{\partial x} = 0
\]</span></p>
<p><span class="math inline">\(u^2\)</span> nereden geldi? <span
class="math inline">\(u^2\)</span> üzerinde <span
class="math inline">\(\partial / \partial x\)</span> türevi uygulanınca
Zincirleme Kanunu ile <span class="math inline">\(2 u \cdot \partial u /
\partial x\)</span> elde ederdik, o zaman bu formülü 2 ile bölerek iki
üstteki forma erisebiliriz.</p>
<p>Bu denklem taşınım formülünün bir şekli bir anlamda, eğer dalga hızı
<span class="math inline">\(c = \epsilon u\)</span> dersek. Dikkat
edersek bu durumda dalga hızı dalga boyuna (amplitude) oranlı hale
geliyor, yani dalganın üst tarafında hız daha artacak. Denkleme eklenen
bir gayri lineerlik ilginç davranışlara yol açıyor. Taşınım formülünde
dalganın her kısmı aynı hızda hareket eder, “taşınır’’, ve bu sebeple
dalga şeklinde bir değişim olmaz. Ama dalganın üst kısmı alt kısmına
göre daha hızlı hareket ederse şekil değişimi olur, dalganın üstü daha
ileri gider, şok dalgası (shock wave) denen durumu ortaya çıkartır.</p>
<p>Kaynaklar</p>
<p>[1] Bayramlı, <em>Fizik, Isı ve Dalga Denklemleri</em></p>
<p>[2] Igel, <em>Computers, Waves, Simulations, Coursera Lecture, Week
3, von Neumann Analysis</em>, <a
href="https://www.coursera.org/learn/computers-waves-simulations">https://www.coursera.org/learn/computers-waves-simulations</a></p>
<p>[3] Landau, <em>Landau Computational Physics Course, Video
Lectures</em>, <a
href="https://www.youtube.com/playlist?list=PLnWQ_pnPVzmJnp794rQXIcwJIjwy7Nb2U">https://www.youtube.com/playlist?list=PLnWQ_pnPVzmJnp794rQXIcwJIjwy7Nb2U</a></p>
<p>[4] Bayramlı, <em>Diferansiyel Denklemler, Ekler,
Trigonometri</em></p>
<p>[5] Bayramlı, <em>Animasyon</em>, <a
href="https://raw.githubusercontent.com/burakbayramli/classnotes/master/compscieng/compscieng_app17wave/string.gif">https://raw.githubusercontent.com/burakbayramli/classnotes/master/compscieng/compscieng_app17wave/string.gif</a></p>
<p>[6] Barba, <em>12 steps to Navier–Stokes, Ders 1</em>, <a
href="https://nbviewer.jupyter.org/github/barbagroup/CFDPython/tree/master/lessons/">https://nbviewer.jupyter.org/github/barbagroup/CFDPython/tree/master/lessons/</a></p>
<p>[7] Bayramlı, <em>Fizik, Isı ve Dalga Denklemlerini Türetmek</em></p>
<p>[8] Bayramlı, <em>Fizik, Akış Dinamiği</em></p>
<p>[9] Landau, <em>Computational Physics</em></p>
<p>[10] Mittleman, <em>Applied Electromagnetics ENGN1560 Brown
Lecture</em></p>
<p>[11] Logan, <em>Applied Mathematics, Third Edition</em></p>
<p>[12] Bayramlı, <em>Hesapsal Bilim, Dalga Denklemi</em></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
