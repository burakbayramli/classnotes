<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  
  
  
  
</head>
<body>
<h1 id="dalga-denklemi-wave-equation">Dalga Denklemi (Wave Equation)</h1>
<p>Denklem [1],</p>
<p><span class="math display">\[
\frac{\partial^2 y}{\partial x^2}  =
\frac{1}{c^2}\frac{\partial^2 y}{\partial t^2}
\]</span></p>
<p>Denkleme yakından bakarsak onun bir kısmı türevsel denklem (PDE) olduğunu görürüz. İki tane bağımsız değişken temel alınıyor, <span class="math inline">\(x,t\)</span>. Ayrıca denklem 2. derece, çünkü ikinci türevi içeriyor. Bu bilgiler denklemi çözmek için önemli [2].</p>
<p>Çözümde bir başlangıç şartı gerekli çünkü diferansiyel denklemleri &quot;entegre ederken'' daha doğrusu ileri doğru geçen zamanda hesaplarken bir başlangıç noktası gerekiyor, bunun için bir teli kaldırıp (geçici bir süre üçgen haline getirip) oradan bıraktığımızı düşünebiliriz, ki bu üçgen şekli alttaki gibi modellenebilir,</p>
<p><span class="math display">\[
y(x,t=0)=\begin{cases}
1.25 x/L , &amp;x\leq 0.8 L ,\\
(5-5x/L), &amp;x&gt; 0.8 L,
\end{cases} 
\]</span></p>
<p>İkinci bir başlangıç şartı daha lazım, 2. derece başlangıç şartı bu. Teli, ipi gerip üçgen yaptım ama sonra durup tekrar bıraktım, bu da bir başlangıç şartı, durağan durumdan başlama şartı.</p>
<p><span class="math display">\[
\frac{\partial y} {\partial t}(x,t=0) =0
\]</span></p>
<p>Çözüme bu şartlarla başlayabilirdik ama baştaki problem tanımını hatırlarsak ek bazı şartlar daha koymuştuk, bu şartlar, kısıtlamalar her an için geçerli, ipler iki ucundan (hareket etmeyen) duvarlara bağlı.</p>
<p><span class="math display">\[
y(0,t) \equiv 0, \quad y(L,t) \equiv 0
\]</span></p>
<p>[analitik çözüm atlandı]</p>
<p>Yaklaşıksal hesap için <span class="math inline">\(x,t\)</span> eksenleri düşünebiliriz, ve bu eksenlerde sadece belli noktalardaki hesaplar yapılacak, <span class="math inline">\(x\)</span> için aralıklar <span class="math inline">\(\Delta x\)</span> genişliğinde, <span class="math inline">\(t\)</span> için <span class="math inline">\(\Delta t\)</span> genişliğinde, aralık büyüklüğünü biz tanımlayacağız. Yani hesap noktaları <span class="math inline">\(i=1,2,3,...\)</span> için <span class="math inline">\(i \Delta t\)</span>'de, <span class="math inline">\(x\)</span> için <span class="math inline">\(j=1,2,..\)</span> ile <span class="math inline">\(j \Delta t\)</span>'de.</p>
<div class="figure">
<img src="compscieng_app17wave_03.png" />

</div>
<p>Yaklaşıksallıkta bir diğer kullanılacak teknik merkezi farklılıklar, burada <span class="math inline">\(x\)</span> için sola/sağa, <span class="math inline">\(t\)</span> için yukarı/aşağı olacak şekilde iki Taylor açılımı yapıyoruz,</p>
<p><span class="math display">\[
y(x +\Delta x, t)  = y(x,t) +
\frac{\partial U}{\partial x}\Delta x + \frac{1}{2}
\frac{\partial^2 U}{\partial x^2}(\Delta x)^2 + \cdots
\]</span></p>
<p><span class="math display">\[
y(x -\Delta x, t)  = y(x,t) -
\frac{\partial U}{\partial x} \Delta x + \frac{1} {2}
\frac{\partial^2 U}{\partial x^2} (\Delta x)^2 - \cdots
\]</span></p>
<p><span class="math display">\[
y(x, y +\Delta t)  = y(x,t) +
\frac{\partial U}{\partial t}\Delta y + \frac{1}{2}
\frac{\partial^2 U}{\partial t^2}(\Delta t)^2 + \cdots
\]</span></p>
<p><span class="math display">\[
y(x, y -\Delta t) = y(x,t) -
\frac{\partial U}{\partial t} \Delta t + \frac{1} {2}
\frac{\partial^2 U}{\partial t^2} (\Delta t)^2 - \cdots
\]</span></p>
<p>Noktalı yerlerdeki terimleri yok sayıyoruz (2. derece yaklaşıklama yapmış olduk yani, bu önemli, yaklaşık temsilin kuvvetini gösteriyor bir anlamda), sonra her değişkenin iki açılımını birbiri ile topluyoruz. Toplama sonrası tek sayı terimlerinin iptal olduğunu görürüz, ve kalanlar,</p>
<p><span class="math display">\[
\frac{\partial^2 y(x,t)}{\partial x^2} \simeq
\frac{y(x+\Delta x,t)+y(x-\Delta x,t)-2 y(x,t)}{(\Delta x)^2}
\]</span></p>
<p><span class="math display">\[
\frac{\partial^2 y(x,t)}{\partial t^2} \simeq
\frac{y(x,t+\Delta t) +y(x, y-\Delta t)-2 y(x,t)}{(\Delta t)^2}
\]</span></p>
<p>olacaktır. İndisler üzerinden belirtirsek,</p>
<p><span class="math display">\[
\frac{\partial^2 y }{\partial t^2} \simeq
\frac{y_{i,j+1}+y_{i,j-1}-2 y_{i,j}}{(\Delta t)^2}, \quad
\frac{\partial^2 y}{\partial x^2} \simeq
\frac{y_{i+1,j}+y_{i-1,j}-2 y_{i,j}} {(\Delta x)^2}.
\]</span></p>
<p>Üstteki formülleri dalga denklemindeki yerlerine koyarsak,</p>
<p><span class="math display">\[
\frac{y_{i,j+1}+y_{i,j-1}-2 y_{i,j}} {c^2 (\Delta t)^2}  =
\frac{y_{i+1,j}+y_{i-1,j}-2 y_{i,j}} {(\Delta x)^2}
\qquad (2)
\]</span></p>
<p>Tabii dikkat edersek geçmiş <span class="math inline">\(j-1\)</span> ve gelecek <span class="math inline">\(j+1\)</span> birbirine karışmış durumda, bize lazım olan geleceğin hesabının eşitliğin sol tarafında olması geri kalan her şey sağda olacak şekilde tekrar düzenlersek,</p>
<p><span class="math display">\[
y_{i,j+1}  = 2 y_{i,j}-y_{i,j-1}+ \frac{c^2 } {c&#39;^{2}}
\left [ y_{i+1,j}+y_{i-1,j}-2 y_{i,j}\right], \quad c&#39; { = }
\frac {\Delta x}{\Delta t}
\qquad (1)
\]</span></p>
<p>Hesap için üstteki resmi hatırlayalım, <span class="math inline">\(i,j+1\)</span> hücresine dört diğer hücreden ok çizilmiş, aslında bu oklar üstteki formülün hesabını anlatıyor, o anki <span class="math inline">\(t\)</span> zamanından üç hesap ve geçmişten <span class="math inline">\(i,j-1\)</span> hesabına bakarak gelecekteki değeri hesaplıyoruz. Bu hesaplama çok verimli olacak çünkü herhangi bir anda hafızada tutulması gereken <span class="math inline">\(y(i,j)\)</span> haricinde sadece üç tane değer var.</p>
<p>Son bir problem başlangıç anı ile alakalı, resimdeki bilinmesi gereken o üç hücrenin başlangıç <span class="math inline">\(j=1\)</span> anında olduğunu düşünürsek, ve <span class="math inline">\(j=2\)</span>'yi hesaplamamız gerekiyor, eksi zamana doğru bir gidişat lazım, yani <span class="math inline">\(j=-1\)</span> zamanı. Başlangıç bilgisi <span class="math inline">\(j=1\)</span> var, ama <span class="math inline">\(j=-1\)</span> yok. Buradaki bilgiyi nasıl alacağız?</p>
<p>Denklemsel olarak bir ek koşul daha ekleyerek, ilk başta hem teli çekip üçgen haline getirmiştik, bir de başlangıç anında telin hızı sıfırdır diyeceğiz. Bu mantıksız değil, tel çekildi, tutuluyor.. hareket yok. Denklem olarak <span class="math inline">\(\partial y / \partial t(x,0)\)</span> sıfır diyeceğiz. Sonra bu denklemin merkezi farklılık açılımını yapacağız ve oradan gelen eşitlikleri ana (1)'e sokarak sadece <span class="math inline">\(j=2\)</span> için özel bir formül elde etmeyi umuyoruz.</p>
<p><span class="math display">\[
\frac{\partial y}{\partial t}(x,0) \simeq
\frac{y(x, \Delta t)- y(x, -\Delta t)}{2\Delta t}=0, \
\Rightarrow \ y_{i, 0} = y_{i,2}
\]</span></p>
<p>(1)'e sokunca</p>
<p><span class="math display">\[
y_{i,2} = y_{i,1}+ \frac{c^2} {c&#39;^2}
\left [ y_{i+1,1}+y_{i-1,1}-2 y_{i,1}\right]
\]</span></p>
<p>Dikkat bu denklem sadece <span class="math inline">\(j=2\)</span> için. Bundan sonraki her <span class="math inline">\(j\)</span> için ana (1) formülü işleyecektir.</p>
<p>Stabilite, von Neumann</p>
<p>Çözümün stabil olması için <span class="math inline">\(c \le \frac{\Delta x}{\Delta t}\)</span> şartının doğru olması gerekir, ve çoğunlukla <span class="math inline">\(\Delta x\)</span> bizim kontrolümüzde olmaz, problemin dayattığı bir büyüklük olur, <span class="math inline">\(c\)</span> fiziki modelin bir parçasıdır, o zaman <span class="math inline">\(\Delta t\)</span>'nin diğer verili parametrelere göre şarta uygun seçilmesi gerekir. Şarta von Neumann ya da Courant stabilite şartı ismi veriliyor.</p>
<p>Türetmek için alttaki gibi bir yaklaşım [3] kullanılabilir. Fakat ilerlemeden önce Euler denkleminden türetilen bazı ek formülleri görelim, bu formüller birazdan işimize yarayacak. Euler formülü hatırlarsak,</p>
<p><span class="math display">\[
e^{ix} = \cos (x) + i\sin(x)
\]</span></p>
<p>Üstteki formülü <span class="math inline">\(-x\)</span> için yazarsak,</p>
<p><span class="math display">\[
e^{-ix} = \cos (-x) + i\sin(-x)
\]</span></p>
<p>olur. Kosinüs'ün simetrik davranışı, yani <span class="math inline">\(\cos(-x)=\cos(x)\)</span> ve <span class="math inline">\(-\sin(x)=\sin(-x)\)</span> olması sebebiyle, üstteki</p>
<p><span class="math display">\[
= \cos(x) - i\sin(x)
\]</span></p>
<p>olarak yazılabilir. Şimdi eğer <span class="math inline">\(e^{ix}\)</span> ve <span class="math inline">\(e^{-ix}\)</span>'i toplarsak, önceden gördüğümüz açılımlar üzerinden,</p>
<p><span class="math display">\[
e^{ix} + e^{-ix} = 2\cos(x)
\]</span></p>
<p>olur, çünkü eksi işaretli <span class="math inline">\(\sin\)</span> artı olanla beraber iptal olur. Tekrar düzenlersek,</p>
<p><span class="math display">\[
\cos(x) = \frac{1}{2} (e^{ix} + e^{-ix})
\qquad (3)
\]</span></p>
<p>Benzer bir eşitliği <span class="math inline">\(e^{ix} - e^{-ix}\)</span> üzerinden elde edebiliriz,</p>
<p><span class="math display">\[
e^{ix} - e^{-ix} = 2i\sin(x)
\]</span></p>
<p>Tekrar düzenleyince aynen biraz önce bir <span class="math inline">\(\cos\)</span> tanımı elde ettiğimiz gibi bir de <span class="math inline">\(\sin\)</span> tanımı elde ederiz,</p>
<p><span class="math display">\[
\sin(x) = \frac{1}{2i} (e^{ix} - e^{-ix})
\]</span></p>
<p>Dalga kısmi denklemi ne idi?</p>
<p><span class="math display">\[
\partial_t^2 y(x,t) = c(x)^2 \partial_x^2 y(x,t)
\]</span></p>
<p>[2] notasyonu <span class="math inline">\(c\)</span> yerine <span class="math inline">\(c(x)\)</span> kullanmış. Şimdi stabilite şartını türetmek için çözümün basit bir düzlem dalgası (plane wave) olduğunu farz edeceğiz [1], yani çözüm</p>
<p><span class="math display">\[
y(x,t) = e^{i(kx-\omega t)}
\]</span></p>
<p>formunda olacak. Bu formu ayrıksallaştırıp kısmı türevsel forma sokunca çıkan eşitlikler üzerinden bir stabilite şartı elde etmek amacımız. [3] notasyonu yerine [2]'imsi notasyon kullanacağız, yani <span class="math inline">\(x,t\)</span> indisleri <span class="math inline">\(i,j\)</span> yerine <span class="math inline">\(j,n\)</span>, herhalde hayali sayı <span class="math inline">\(i\)</span> ile karışıklık olmasın diye böyle seçilmiş. O zaman <span class="math inline">\(x \to j \Delta x\)</span>, <span class="math inline">\(t \to n \Delta t\)</span> olur.</p>
<p>Alttaki analitik soldaki formül ayrıksal şu hale gelir,</p>
<p><span class="math display">\[
y(x,t) = e^{i(kx - \omega t)} \to
y_{j,n} = e^{i(kj\Delta x - \omega n \Delta t)}
\]</span></p>
<p>Peki bu formülleri (2) bağlamında nasıl kullanacağız? Aslında bu çok basit.</p>
<p>Mesela <span class="math inline">\(y_{j+1,n}\)</span> için ayrıksal uzayda bir adım atmış oluyoruz, bu adımın basit dalga formülünde karşılığı</p>
<p><span class="math display">\[
y_{j+1,n} = e^{i ( k(j+1)\Delta x - \omega n \Delta t )}
\]</span></p>
<p>Karışık gibi duruyor fakat <span class="math inline">\(e\)</span> bazlı işlem yapmanın faydasını göreceğiz şimdi,</p>
<p><span class="math display">\[
= e^{i k \Delta x} e^{i(k j \Delta x - \omega n \Delta t)}
\]</span></p>
<p>Bir <span class="math inline">\(e\)</span> bazlı terimi dışarı çekmiş olduk. Geri kalan sağdaki <span class="math inline">\(e\)</span> bloğuna bakınca onun <span class="math inline">\(y_{j,n}\)</span> olduğunu görüyoruz! O zaman</p>
<p><span class="math display">\[
y_{j+1,n} = e^{i k \Delta x} y_{j,n}
\]</span></p>
<p>Benzer bir işlemi <span class="math inline">\(y_{j-1,n}\)</span> için de gerçekleştirebiliriz,</p>
<p><span class="math display">\[
y_{j-1,n} = e^{-i k \Delta x} e^{i(k j \Delta x - \omega n \Delta t)}
\]</span></p>
<p><span class="math display">\[
 = e^{-i k \Delta x} y_{j,n}
\]</span></p>
<p>Teknik ayrıksal zaman üzerinde de işliyor,</p>
<p><span class="math display">\[
y_{j,n+1}  = e^{-i k \Delta t} y_{j,n}
\]</span></p>
<p><span class="math display">\[
y_{j,n-1}  = e^{i k \Delta t} y_{j,n}
\]</span></p>
<p>O zaman bu öğeleri dalga denklemi (2)'ye sokabiliriz. O denklemi [2]'ye göre birazcık değiştirip tekrar verelim,</p>
<p><span class="math display">\[
\frac{y_{j,n+1} - 2 y_{j,n} + y_{j,n-1} }{\Delta t^2} =
c_j^2 \left[ \frac{ y_{j+1,n} - 2 y_{j,n} + y_{j-1,n} }{\Delta x^2}  \right]
\]</span></p>
<p>Şimdi üstteki formülde sonlu ayrıksal terimleri, yani <span class="math inline">\(y_{j,n+1}\)</span>, <span class="math inline">\(y_{j,n-1}\)</span>, <span class="math inline">\(y_{j+1,n}\)</span>, ve <span class="math inline">\(y_{j-1,n}\)</span> terimlerini, biraz önce bulduğumuz üstel terimlerle değiştirelim,</p>
<p><span class="math display">\[
e^{i(k j \Delta x - \omega n \Delta t)} \left[
\frac{ e^{i\omega \Delta t} - 2  + e^{-i\omega \Delta t}  }
     {\Delta t^2}\right] =
c^2 \left[
\frac{e^{ik\Delta x} - 2 + e^{-ik\Delta x}}
     {\Delta x^2}
\right] e^{i(k j \Delta x - \omega n \Delta t)}
\]</span></p>
<p><span class="math inline">\(c_j \to c\)</span> geçişi her <span class="math inline">\(j \Delta x\)</span> noktasına göre tanımlanıyor muhakkak.</p>
<p>Devam edelim, son formülde basitleştirme yapılabilir, en sol ve sağdaki terimler iptal olabilir,</p>
<p><span class="math display">\[
\left[
\frac{ e^{i\omega \Delta t} - 2  + e^{-i\omega \Delta t}  }
     {\Delta t^2}\right] =
c^2 \left[
\frac{e^{ik\Delta x} - 2 + e^{-ik\Delta x}}
     {\Delta x^2}
\right]
\]</span></p>
<p>Geri kalanları tekrar düzenleyelim,</p>
<p><span class="math display">\[
e^{i\omega \Delta t} + e^{-i\omega \Delta t} - 2 =
c^2 \frac{\Delta t^2}{\Delta x^2} [ e^{ik\Delta x} - e^{-ik\Delta x} - 2]
\]</span></p>
<p>Hayali terimlerden kurtulmak istiyoruz tabii, bu noktada (3)'teki kosinüs tanımını tekrar hatırlayalım, onu kullanırsak, eşitliğin solundaki iki terim ve sağındaki iki terim için ayrı ayrı,</p>
<p><span class="math display">\[
2 \cos(\omega \Delta t) - 2 = c^2 \frac{\Delta t^2}{\Delta x^2}
(2 \cos(k\Delta x) - 2)
\]</span></p>
<p>Herşeyi 2 ile bölelim,</p>
<p><span class="math display">\[
\cos(\omega \Delta t) - 1 = c^2 \frac{\Delta t^2}{\Delta x^2}
(\cos(k\Delta x) - 1)
\qquad (4)
\]</span></p>
<p>Şimdi bir diğer trigonometrik eşitliği kullanacağız [4],</p>
<p><span class="math display">\[
2\sin^2(x) = 1 - \cos (2x)
\]</span></p>
<p>Biraz degistirirsek,</p>
<p><span class="math display">\[
\sin (x) = \sqrt{1 - \cos (2x)}
\]</span></p>
<p>Ya da</p>
<p><span class="math display">\[
\sin (\frac{x}{2}) = \pm \sqrt{1 - \cos (x)}
\]</span></p>
<p>Bu eşitliğin (4) ifadesini nasıl basitleştireceğini görmek zor değil,</p>
<p><span class="math display">\[
\sin^2(\omega \frac{\Delta t}{r}) =
c^2 \frac{\Delta t^2}{\Delta x^2} \sin^2 (k \frac{\Delta x}{2} )
\]</span></p>
<p>Karelerden kurtulabiliriz,</p>
<p><span class="math display">\[
\sin(\omega \frac{\Delta t}{r}) =
c \frac{\Delta t}{\Delta x} \sin (k \frac{\Delta x}{2} )
\]</span></p>
<p>İşte bu basit denklem sayısal analizin en temel bulgularından birine götürdü bizi.</p>
<p>Üstteki denklemin reel sonuçlara sahip olması için</p>
<p><span class="math display">\[
c \frac{\Delta t}{\Delta x} \le 1
\]</span></p>
<p>olmalıdır. Bu koşul artık ünlü olan Courant-Friedrichs-Lewy (CFL) koşulu, ya da kriteridir. Bu koşul iki tür hızın arasında bir ilişki kurar, biri fiziksel hız, ki fiziksel ortamda dalganın yayılma hızı bu, diğeri ise &quot;algoritmik hız'' bir anlamda, bizim tanımladığımız ızgaranın genişliği <span class="math inline">\(\Delta x\)</span> bölü yine bizim seçtiğimiz zaman aralığı <span class="math inline">\(\Delta t\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">rho <span class="op">=</span> <span class="fl">0.01</span><span class="op">;</span>
ten <span class="op">=</span> <span class="fl">40.</span><span class="op">;</span>
c <span class="op">=</span> np.sqrt(ten<span class="op">/</span>rho)               
c1 <span class="op">=</span> c<span class="op">;</span>
ratio <span class="op">=</span>  c<span class="op">*</span>c<span class="op">/</span>(c1<span class="op">*</span>c1)  <span class="co"># CFL kriteri = 1</span>
<span class="co"># dongunun her adiminda sadece uc zaman dilimi yeterli, o sebeple</span>
<span class="co"># xi [_,3] boyutunda. </span>
xi <span class="op">=</span> np.zeros((<span class="dv">101</span>,<span class="dv">3</span>), <span class="bu">float</span>)                            
k <span class="op">=</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="dv">101</span>)

<span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">81</span>):
   xi[i, <span class="dv">0</span>] <span class="op">=</span> <span class="fl">0.00125</span><span class="op">*</span>i         
<span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span> (<span class="dv">81</span>, <span class="dv">101</span>):
   xi[i, <span class="dv">0</span>] <span class="op">=</span> <span class="fl">0.1</span> <span class="op">-</span> <span class="fl">0.005</span><span class="op">*</span>(i <span class="op">-</span> <span class="dv">80</span>) 

fig <span class="op">=</span> plt.figure()  
<span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">100</span>): 
    xi[i,<span class="dv">1</span>] <span class="op">=</span> xi[i,<span class="dv">0</span>] <span class="op">+</span> <span class="fl">0.5</span><span class="op">*</span>ratio<span class="op">*</span>(xi[i<span class="op">+</span><span class="dv">1</span>,<span class="dv">0</span>] <span class="op">+</span> xi[i<span class="dv">-1</span>,<span class="dv">0</span>] <span class="dv">-2</span><span class="op">*</span>xi[i,<span class="dv">0</span>])  
    
<span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">100</span>):
   <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">100</span>):              
      xi[i,<span class="dv">2</span>] <span class="op">=</span> <span class="fl">2.</span><span class="op">*</span>xi[i,<span class="dv">1</span>]<span class="op">-</span>xi[i,<span class="dv">0</span>]<span class="op">+</span>ratio<span class="op">*</span>(xi[i<span class="op">+</span><span class="dv">1</span>,<span class="dv">1</span>]<span class="op">+</span>xi[i<span class="dv">-1</span>,<span class="dv">1</span>]<span class="op">-</span><span class="dv">2</span><span class="op">*</span>xi[i,<span class="dv">1</span>])
   <span class="cf">if</span> j <span class="op">%</span> <span class="dv">5</span> <span class="op">==</span> <span class="dv">0</span>:      
      plt.grid(<span class="va">True</span>)
      plt.xlim(<span class="dv">0</span>, <span class="dv">101</span>)
      plt.ylim(<span class="op">-</span><span class="fl">0.15</span>, <span class="fl">0.15</span>)
      plt.plot(k,xi[k,<span class="dv">2</span>])
      plt.savefig(<span class="st">&#39;/tmp/string-</span><span class="sc">%02d</span><span class="st">.png&#39;</span> <span class="op">%</span> j)
      plt.clf()
   <span class="co"># bitti, 1,2 indisi yeni 0,1 olacak</span>
   <span class="cf">for</span> m <span class="kw">in</span> <span class="bu">range</span> (<span class="dv">0</span>,<span class="dv">101</span>):
      xi[m, <span class="dv">0</span>] <span class="op">=</span> xi[m, <span class="dv">1</span>]
      xi[m, <span class="dv">1</span>] <span class="op">=</span> xi[m, <span class="dv">2</span>]</code></pre></div>
<p><img src="string-00.png" /> <img src="string-25.png" /></p>
<p><img src="string-55.png" /> <img src="string-85.png" /></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">!</span> convert <span class="op">-</span>loop <span class="dv">0</span> <span class="op">-</span>delay <span class="dv">100</span> <span class="op">/</span>tmp<span class="op">/</span>string<span class="op">*</span>.png string.gif</code></pre></div>
<p>Animasyonlu sonucu [5]'te bulabiliriz.</p>
<p>Tek Boyutlu Lineer Taşınım Akımı (Convection)</p>
<p>Tek boyutlu lineer taşınım akımı, ya da tek boyutlu lineer yatay iletim (advection), CFD hakkında bir şeyler öğrenmek için güzel fırsatlar içeriyor. Bu ufak denklemin bize ne kadar çok şey öğreteceğini görmek bizi şaşırtabilir. Denklem,</p>
<p><span class="math display">\[
\frac{\partial u}{\partial t} +
c \frac{\partial u}{\partial x}  = 0
\qquad (2)
\]</span></p>
<p>Dikkat bu bir dalga denklemi olarak bilinir, fakat esas dalga denkleminin kısmi türevsel formu ikinci kısmi türevi içeriyor, bkz [7]. Üstteki denklem verili başlangıç şartlarına göre bir basit dalganın şekil değiştirmeden <span class="math inline">\(c\)</span> hızında yayılmasını temsil eder. Başlangıç şartlarını <span class="math inline">\(u(x,0) = u_0(x)\)</span> olarak gösterirsek, denklemin kesin analitik çözümü <span class="math inline">\(u(x,y) = u_0(x-ct)\)</span>.</p>
<p>Üstteki formülü süreklilik denkleminin [8] bir formu olarak ta görebiliriz [9, sf. 557]. Süreklilik denklemi</p>
<p><span class="math display">\[
\frac{\partial \rho}{\partial t}  + \nabla \cdot (\rho \bar{u} ) = 0
\]</span></p>
<p>idi, bu formülü tek boyutta düşünürsek ve sabit hız <span class="math inline">\(\bar{u} = c\)</span> alırsak (2)'ye ulaşırız.</p>
<p>Denklemi hem zaman, hem uzay bağlamında ayrıksallaştıracağız. Türev tanımından (ve limit ifadesini çıkartınca),</p>
<p><span class="math display">\[
\frac{\partial u}{\partial x} \approx
\frac{u(x+\Delta x) - u(x)}{\Delta x}
\]</span></p>
<p>olduğunu biliyoruz. Şimdi zamanda İleri Farklılık (Forward Difference), uzayda Geriye Farklılık (Backward Difference) kullanalım.. Ve eğer <span class="math inline">\(x\)</span> eksenini <span class="math inline">\(N\)</span> parçaya ayırırsak ve bu parçaları <span class="math inline">\(i=0,..,N\)</span> ile indekslersek, ve en ufak zaman adımını da <span class="math inline">\(\Delta t\)</span> ile gösterip o adımı <span class="math inline">\(n\)</span> ile indislersek,</p>
<p><span class="math display">\[
\frac{u_i^{n+1} - u_i^n}{\Delta t} + c \frac{u_i^{n} - u_{i-1}^n}{\Delta x} = 0
\]</span></p>
<p>ki <span class="math inline">\(n\)</span> ve <span class="math inline">\(n+1\)</span> ardı ardına olan iki zaman adımı, <span class="math inline">\(i-1\)</span> ve <span class="math inline">\(i\)</span> ise ayrıksallaştırılmış iki <span class="math inline">\(x\)</span> yeri oluyor. Eğer başlangıç koşulları verilmiş ise o zaman bu ayrıksal sistemde tek bilinmeyen <span class="math inline">\(u_i^{n+1}\)</span>'dir. Denklemi tekrar düzenlersek bilinmeyen için yeni bir formül elde edebiliriz,</p>
<p><span class="math display">\[
u_i^{n+1} = u_i^n - c \frac{\Delta t}{\Delta x} ( u_i^n - u_{i-1}^n )
\qquad (1)
\]</span></p>
<p>Yeri temsil eden <span class="math inline">\(x\)</span> eksenini eşit aralıklı parçalara böleceğiz, bir tek boyutlu ızgara yaratacağız, genişlik 2 birim olacak, <code>nx</code> değişkeni kaç tane ızgara noktası olduğunu tanımlayacak, <code>dx</code> iki nokta arasındaki uzaklık.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> time, sys
nx <span class="op">=</span> <span class="dv">41</span>
dx <span class="op">=</span> <span class="dv">2</span> <span class="op">/</span> (nx<span class="dv">-1</span>)
nt <span class="op">=</span> <span class="dv">25</span>  
dt <span class="op">=</span> <span class="fl">.025</span>
c <span class="op">=</span> <span class="dv">1</span>    </code></pre></div>
<p>Başlangıç şartlarını tanımlamak lazım, başlangıç hızı <span class="math inline">\(u_0\)</span> aralık <span class="math inline">\(0.5 \leq x \leq 1\)</span> içinde <span class="math inline">\(u = 2\)</span>, diğer her yerde <span class="math inline">\(u = 1\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">u <span class="op">=</span> np.ones(nx)
u[<span class="bu">int</span>(.<span class="dv">5</span> <span class="op">/</span> dx):<span class="bu">int</span>(<span class="dv">1</span> <span class="op">/</span> dx <span class="op">+</span> <span class="dv">1</span>)] <span class="op">=</span> <span class="dv">2</span>  
<span class="bu">print</span>(u)</code></pre></div>
<pre><code>[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 2. 2. 2. 2. 2. 2. 2. 2. 2. 2. 2. 1. 1. 1.
 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">plt.plot(np.linspace(<span class="dv">0</span>, <span class="dv">2</span>, nx), u)<span class="op">;</span>
plt.savefig(<span class="st">&#39;compscieng_app45cfd1_01.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="compscieng_app45cfd1_01.png" />

</div>
<p>Üstteki bir fonksiyon türü aslında, ona görüntüsü sebebiyle &quot;şapka fonksiyonu'' ismi de veriliyor.</p>
<p>Şimdi taşınım akımı denkleminin ayrıksal kodlamasına gelelim, burada sonlu farklılık (finite difference) yaklaşımı kullanıyoruz, <span class="math inline">\(u\)</span> vektörü içindeki her öge için (1) formülünü işleteceğiz.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">un <span class="op">=</span> np.ones(nx)
<span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(nt):
    un <span class="op">=</span> u.copy() 
    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, nx):
        u[i] <span class="op">=</span> un[i] <span class="op">-</span> c <span class="op">*</span> dt <span class="op">/</span> dx <span class="op">*</span> (un[i] <span class="op">-</span> un[i<span class="dv">-1</span>])        </code></pre></div>
<p>Üstteki işlemle zamanı ileri sardık ve fonksiyon belli bir noktaya geldi. Nereye geldi?</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">plt.plot(np.linspace(<span class="dv">0</span>, <span class="dv">2</span>, nx), u)<span class="op">;</span>
plt.savefig(<span class="st">&#39;compscieng_app45cfd1_02.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="compscieng_app45cfd1_02.png" />

</div>
<p>Evet, başlangıç fonksiyonu hakikaten sağa doğru taşındı. Fakat artık fonksiyon bir şapka değil. Ne oldu? Sonuç yaklaşık temsilin kalitesiyle alakalı, <code>dx</code> ve <code>dt</code> küçültüldükçe kalite artacaktır, ve şapkaya daha çok benzeyen sonuçlar görülecektir.</p>
<p>Gayrı Lineer Taşınım Akımı (Nonlinear Convection)</p>
<p>Şimdi biraz önceki teknikleri kullanarak gayrı lineer taşınım akımı kodlayacağız, tek boyutta denklem,</p>
<p><span class="math display">\[
\frac{\partial u}{\partial t} +
u  \frac{\partial u}{\partial c}  = 0
\]</span></p>
<p>Dikkat edersek önceki denklemdeki <span class="math inline">\(c\)</span> ile çarpım yerine şimdi <span class="math inline">\(u\)</span> ile çarpım var, bu sebeple formülün ikinci terimi gayrı lineer hale geldi. Eğer ayrıksallaştırma işlemini tekrar uygularsak, alttaki sonuca erişiriz,</p>
<p><span class="math display">\[
u_i^{n+1} = u_i^n -  u_i^n \frac{\Delta t}{\Delta x} ( u_i^n - u_{i-1}^n )
\]</span></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">nx <span class="op">=</span> <span class="dv">41</span>
dx <span class="op">=</span> <span class="dv">2</span> <span class="op">/</span> (nx <span class="op">-</span> <span class="dv">1</span>)
nt <span class="op">=</span> <span class="dv">20</span>
dt <span class="op">=</span> <span class="fl">.025</span> 
u <span class="op">=</span> np.ones(nx)
u[<span class="bu">int</span>(.<span class="dv">5</span> <span class="op">/</span> dx) : <span class="bu">int</span>(<span class="dv">1</span> <span class="op">/</span> dx <span class="op">+</span> <span class="dv">1</span>)] <span class="op">=</span> <span class="dv">2</span>  
un <span class="op">=</span> np.ones(nx)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">un <span class="op">=</span> np.ones(nx)
<span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(nt):
    un <span class="op">=</span> u.copy() 
    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, nx):
        u[i] <span class="op">=</span> un[i] <span class="op">-</span> un[i] <span class="op">*</span> dt <span class="op">/</span> dx <span class="op">*</span> (un[i] <span class="op">-</span> un[i<span class="dv">-1</span>])        </code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">plt.plot(np.linspace(<span class="dv">0</span>, <span class="dv">2</span>, nx), u)<span class="op">;</span>
plt.savefig(<span class="st">&#39;compscieng_app45cfd1_03.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="compscieng_app45cfd1_03.png" />

</div>
<p>Yakınsama (Convergence)</p>
<p>Lineer taşınım hesabında ortaya çıkan tepe şeklinin ızgara çözünülürlüğü ile alakalı olduğunu söylemiştik. Bunu birkaç farklı çözünürlük ile deneyerek görelim. İlk gördüğümüz sonuç <code>nx=41</code> kullandı. Arttıralım,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> linearconv(nx):
    dx <span class="op">=</span> <span class="dv">2</span> <span class="op">/</span> (nx <span class="op">-</span> <span class="dv">1</span>)
    nt <span class="op">=</span> <span class="dv">20</span>    
    dt <span class="op">=</span> <span class="fl">.025</span>  
    c <span class="op">=</span> <span class="dv">1</span>

    u <span class="op">=</span> np.ones(nx)
    u[<span class="bu">int</span>(.<span class="dv">5</span><span class="op">/</span>dx):<span class="bu">int</span>(<span class="dv">1</span> <span class="op">/</span> dx <span class="op">+</span> <span class="dv">1</span>)] <span class="op">=</span> <span class="dv">2</span>  

    un <span class="op">=</span> np.ones(nx)

    <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(nt):
        un <span class="op">=</span> u.copy() 
        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, nx):
            u[i] <span class="op">=</span> un[i] <span class="op">-</span> c <span class="op">*</span> dt <span class="op">/</span> dx <span class="op">*</span> (un[i] <span class="op">-</span> un[i<span class="dv">-1</span>])
        
    plt.plot(np.linspace(<span class="dv">0</span>, <span class="dv">2</span>, nx), u)<span class="op">;</span>

linearconv(<span class="dv">61</span>)
plt.savefig(<span class="st">&#39;compscieng_app45cfd1_04.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="compscieng_app45cfd1_04.png" />

</div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">linearconv(<span class="dv">71</span>)
plt.savefig(<span class="st">&#39;compscieng_app45cfd1_05.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="compscieng_app45cfd1_05.png" />

</div>
<p>Gittikçe daha fazla şapka fonsiyonuna benzer sonuçlar alıyoruz. Şimdi dikkat, bir kez daha arttıralım,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">linearconv(<span class="dv">85</span>)
plt.savefig(<span class="st">&#39;compscieng_app45cfd1_06.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="compscieng_app45cfd1_06.png" />

</div>
<p>Bu sonuç şapka fonksiyonuna benzemiyor. Ne oldu?</p>
<p>Hesaplananları düşünürsek, yer ekseni üzerinde dalganın hareketini hesaplıyoruz, fakat her adımda <span class="math inline">\(\Delta t = 0.025\)</span> farzederk bu hesapları yapıyoruz. Üstteki yanlış sonuçta <span class="math inline">\(\Delta t\)</span> zaman aralığında öyle bir adım attık ki bu adım <code>dx</code>'in büyüklüğünden daha fazla. Bu durum ilk denemelerde ortaya çıkmadı çünkü <code>dx</code> yeterince büyük tutulmuştu. Fakat onu küçültükçe bir noktada hesap patladı.</p>
<p>Stabilite için <span class="math inline">\(\Delta t\)</span> adımını <span class="math inline">\(\Delta x\)</span> ile ilişkilendirecek bir formül faydalıdır, böyle bir formül var,</p>
<p><span class="math display">\[
\sigma = \frac{u \Delta t}{\Delta x} \le \sigma_{max}
\]</span></p>
<p><span class="math inline">\(u\)</span> dalganın hızı, <span class="math inline">\(\sigma\)</span> degiskeni Courant sayısı, ve <span class="math inline">\(\sigma_{max}\)</span> stabiliteyi sağlayacak üst limit. Çoğunlukla <span class="math inline">\(\sigma_{max} = 1\)</span> seçilir. Bu ilişkinin türetilmesini [12]'de bulabiliriz.</p>
<p>Diffusion (Yayınım) Denklemi</p>
<p>Tek boyuttaki yayınım denklemi,</p>
<p><span class="math display">\[
\frac{\partial u}{\partial t} = \nu \frac{\partial^2 u}{\partial x^2}
\]</span></p>
<p>Dikkat edersek bu denklemde bir ikinci kısmı türev var. Denklemin o kısmını Merkezi Farklar yaklaşımı ile ayrıksal hale getireceğiz, bu yaklaşım İleri Farklar ve Geriye Farklar yaklaşımlarının birleştirilmesi ile elde edilir.</p>
<p>Önce Taylor serilerini hatırlarsak, genel tanım</p>
<p><span class="math display">\[
f(x+h) = f(x) + h f&#39;(x) + \frac{h^2}{2} f&#39;&#39;(x) + ...
\]</span></p>
<p>Biz <span class="math inline">\(u_{i+1}\)</span> ve <span class="math inline">\(u_{i-1}\)</span> açılımını Taylor serisi ile yapmak istiyoruz, daha önce belirttiğimiz gibi bir önceki ve sonraki <span class="math inline">\(x\)</span> değerleri <span class="math inline">\(\Delta x\)</span> uzaklığında, yani bir önceki</p>
<p><span class="math display">\[
u(x-\Delta x) = u(x) - \Delta x f&#39;(x) + \frac{h^2}{2} u&#39;&#39;(x) + ...
\]</span></p>
<p>İşaretin eksi olmasına dikkat, ve sonraki</p>
<p><span class="math display">\[
u(x+\Delta x) = u(x) + \Delta x f&#39;(x) + \frac{h^2}{2} u&#39;&#39;(x) + ...
\]</span></p>
<p>Şimdi indisleriyle <span class="math inline">\(u\)</span> için ve [6]'deki formuyla yazalım,</p>
<p><span class="math display">\[
u_{i+1} = u_i + \Delta x \frac{\partial u}{\partial x}\bigg|_i +
\frac{\Delta x^2}{2} \frac{\partial ^2 u}{\partial x^2}\bigg|_i +
\frac{\Delta x^3}{3!} \frac{\partial ^3 u}{\partial x^3}\bigg|_i +
O(\Delta x^4)
\]</span></p>
<p><span class="math display">\[
u_{i-1} = u_i - \Delta x \frac{\partial u}{\partial x}\bigg|_i +
\frac{\Delta x^2}{2} \frac{\partial ^2 u}{\partial x^2}\bigg|_i -
\frac{\Delta x^3}{3!} \frac{\partial ^3 u}{\partial x^3}\bigg|_i +
O(\Delta x^4)
\]</span></p>
<p>Bir üstteki denklemin ilk hali $u_i = u_{i-1} ... $ ile ama ufak bir yer değişimi ile görülen biçim elde edilmiş.</p>
<p>Son iki formülü toplarsak bazı terimlerin ters işaretli olması sebebiyle iptal olacağını görebiriliz. Ayrıca yaklaşık temsil açısından <span class="math inline">\(O(\Delta x^4)\)</span> ve daha üstü kuvvetleri yok sayarsak,</p>
<p><span class="math display">\[
u_{i+1} + u_{i-1} =
2u_i+\Delta x^2 \frac{\partial ^2 u}{\partial x^2}\bigg|_i +
O(\Delta x^4)
\]</span></p>
<p><span class="math inline">\(\frac{\partial ^2 u}{\partial x^2}\bigg|_i\)</span> için çözersek ve tekrar düzenlersek,</p>
<p><span class="math display">\[
\frac{\partial ^2 u}{\partial x^2}=\frac{u_{i+1}-2u_{i}+u_{i-1}}{\Delta x^2} + O(\Delta x^2)
\]</span></p>
<p><span class="math inline">\(O(\Delta x^2)\)</span> ifadesi <span class="math inline">\(O(\Delta x^4)\)</span> terimi <span class="math inline">\(\Delta x^2\)</span> ile bölününce ortaya çıktı.</p>
<p>Artık 1D yayınım formülünün nihai ayrıksal halini yazabiliriz,</p>
<p><span class="math display">\[
\frac{u_{i}^{n+1}-u_{i}^{n}}{\Delta t} =
\nu\frac{u_{i+1}^{n}-2u_{i}^{n}+u_{i-1}^{n}}{\Delta x^2}
\]</span></p>
<p>Daha önce olduğu gibi başlangıç koşuları tanımlı ise tek bilinmeyen <span class="math inline">\(u_{i}^{n+1}\)</span>, bu bilinmeyen eşitliğin solunda kalacak şekilde tekrar düzenlersek,</p>
<p><span class="math display">\[
u_{i}^{n+1} =
u_{i}^{n}+\frac{\nu\Delta t}{\Delta x^2}(u_{i+1}^{n}-2u_{i}^{n}+u_{i-1}^{n})
\]</span></p>
<p>Üstteki denklem bize çözümü adım adım ilerletmemizi sağlayacak. Ama bir başlangıç koşuluna ihtiyacımız var, daha önceki favorimize dönebiliriz, şapka fonksiyonu. <span class="math inline">\(t=2\)</span>'de <span class="math inline">\(u=0\)</span>, <span class="math inline">\(0.5\le x\le 1\)</span> aralığında ise <span class="math inline">\(u=1\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">nx <span class="op">=</span> <span class="dv">41</span>
dx <span class="op">=</span> <span class="dv">2</span> <span class="op">/</span> (nx <span class="op">-</span> <span class="dv">1</span>)
nt <span class="op">=</span> <span class="dv">20</span> 
nu <span class="op">=</span> <span class="fl">0.3</span> 
sigma <span class="op">=</span> <span class="fl">.2</span> 
dt <span class="op">=</span> sigma <span class="op">*</span> dx<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> nu 


u <span class="op">=</span> np.ones(nx)     
u[<span class="bu">int</span>(.<span class="dv">5</span> <span class="op">/</span> dx):<span class="bu">int</span>(<span class="dv">1</span> <span class="op">/</span> dx <span class="op">+</span> <span class="dv">1</span>)] <span class="op">=</span> <span class="dv">2</span> 

un <span class="op">=</span> np.ones(nx)

<span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(nt): 
    un <span class="op">=</span> u.copy() 
    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, nx <span class="op">-</span> <span class="dv">1</span>):
        u[i] <span class="op">=</span> un[i] <span class="op">+</span> nu <span class="op">*</span> dt <span class="op">/</span> dx<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> (un[i<span class="op">+</span><span class="dv">1</span>] <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> un[i] <span class="op">+</span> un[i<span class="dv">-1</span>])
        
plt.plot(np.linspace(<span class="dv">0</span>, <span class="dv">2</span>, nx), u)<span class="op">;</span>
plt.savefig(<span class="st">&#39;compscieng_app45cfd2_01.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="compscieng_app45cfd2_01.png" />

</div>
<p>2D Taşınım (2D Convection)</p>
<p>2 boyuta geçme zamanı geldi. 2D lineer taşınım akımını (convection) temsil eden parçalı kısmi diferansiyel denklem,</p>
<p><span class="math display">\[
\frac{\partial u}{\partial t} +
c\frac{\partial u}{\partial x} +
c\frac{\partial  u}{\partial y} = 0
\]</span></p>
<p>Bu 1D lineer taşınım akımı ile neredeyse aynı formda, sadece şimdi tek yersel boyut yerine iki tane boyutumuz var, <span class="math inline">\(x\)</span> ve <span class="math inline">\(y\)</span>.</p>
<p>Ayrıksal hale getirmek için aynı yaklaşımı kullanacağız, zaman adımlarını ileri farklar, konumsal değişkenleri ise geriye farklar yöntemi ile ayrıksal yapacağız. 1D durumda <span class="math inline">\(i\)</span> altsimgesini konumda olan hareketlilik için kullanmıştık, <span class="math inline">\(u_{i}^n-u_{i-1}^n\)</span> mesela. Şimdi, 2D durumda, ikinci bir altsimge <span class="math inline">\(j\)</span> ekliyoruz, <span class="math inline">\(y\)</span> boyutunu böylece indislemiş olacağız.</p>
<p>Tüm bunları kullanarak ayrıksal forma erişmek zor değil,</p>
<p><span class="math display">\[
\frac{u_{i,j}^{n+1}-u_{i,j}^n}{\Delta t} +
c\frac{u_{i, j}^n-u_{i-1,j}^n}{\Delta x} +
c\frac{u_{i,j}^n-u_{i,j-1}^n}{\Delta y}=0
\]</span></p>
<p>Daha önce olduğu gibi tek bilinmeyene göre tekrar düzenleyelim,</p>
<p><span class="math display">\[
u_{i,j}^{n+1} =
u_{i,j}^n-c \frac{\Delta t}{\Delta x}(u_{i,j}^n-u_{i-1,j}^n) -
c \frac{\Delta t}{\Delta y}(u_{i,j}^n-u_{i,j-1}^n)
\]</span></p>
<p>Denklemi alttaki başlangıç şartlarına göre çözeceğiz,</p>
<p><span class="math display">\[
u(x,y) = \begin{cases}
\begin{matrix}
2\ &amp; 0.5 \leq x, y \leq 1   &amp; \text{için}  \cr
1\ &amp; \text{diğer her yerde}
\end{matrix}\end{cases}
\]</span></p>
<p>Sınır şartları</p>
<p><span class="math display">\[
u = 1\ \text{değeri } \begin{cases}
\begin{matrix}
x =  0,\ 2 \cr
y =  0,\ 2 \end{matrix}\end{cases}
\text{ için }
\]</span></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> mpl_toolkits.mplot3d <span class="im">import</span> Axes3D    
<span class="im">from</span> matplotlib <span class="im">import</span> cm
nx <span class="op">=</span> <span class="dv">81</span>
ny <span class="op">=</span> <span class="dv">81</span>
nt <span class="op">=</span> <span class="dv">100</span>
c <span class="op">=</span> <span class="dv">1</span>
dx <span class="op">=</span> <span class="dv">2</span> <span class="op">/</span> (nx <span class="op">-</span> <span class="dv">1</span>)
dy <span class="op">=</span> <span class="dv">2</span> <span class="op">/</span> (ny <span class="op">-</span> <span class="dv">1</span>)
sigma <span class="op">=</span> <span class="fl">.2</span>
dt <span class="op">=</span> sigma <span class="op">*</span> dx

x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">2</span>, nx)
y <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">2</span>, ny)

u <span class="op">=</span> np.ones((ny, nx)) <span class="co">##create a 1xn vector of 1&#39;s</span>
un <span class="op">=</span> np.ones((ny, nx)) <span class="co">##</span>

u[<span class="bu">int</span>(.<span class="dv">5</span> <span class="op">/</span> dy):<span class="bu">int</span>(<span class="dv">1</span> <span class="op">/</span> dy <span class="op">+</span> <span class="dv">1</span>),<span class="bu">int</span>(.<span class="dv">5</span> <span class="op">/</span> dx):<span class="bu">int</span>(<span class="dv">1</span> <span class="op">/</span> dx <span class="op">+</span> <span class="dv">1</span>)] <span class="op">=</span> <span class="dv">2</span> 

fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">11</span>, <span class="dv">7</span>), dpi<span class="op">=</span><span class="dv">100</span>)
ax <span class="op">=</span> fig.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)                      
X, Y <span class="op">=</span> np.meshgrid(x, y)                            
surf <span class="op">=</span> ax.plot_surface(X, Y, u[:], cmap<span class="op">=</span>cm.viridis)
plt.savefig(<span class="st">&#39;compscieng_app45cfd3_01.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="compscieng_app45cfd3_01.png" />

</div>
<p>İki boyutta zamanı ileri saralım şimdi. Tüm <span class="math inline">\(i\)</span> ve <span class="math inline">\(j\)</span>'leri işleyebilmek için bir içiçe geçmiş döngü gerekiyor bize. Python dilinde <code>for</code> kullanmak çok optimal değildir, ama alttaki kod neler olduğunu gösterebilmek için yardımcı olacaktır.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">u <span class="op">=</span> np.ones((ny, nx))
u[<span class="bu">int</span>(.<span class="dv">5</span> <span class="op">/</span> dy):<span class="bu">int</span>(<span class="dv">1</span> <span class="op">/</span> dy <span class="op">+</span> <span class="dv">1</span>), <span class="bu">int</span>(.<span class="dv">5</span> <span class="op">/</span> dx):<span class="bu">int</span>(<span class="dv">1</span> <span class="op">/</span> dx <span class="op">+</span> <span class="dv">1</span>)] <span class="op">=</span> <span class="dv">2</span>

<span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(nt <span class="op">+</span> <span class="dv">1</span>): 
    un <span class="op">=</span> u.copy()
    row, col <span class="op">=</span> u.shape
    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, row):
        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, col):
            tmp1 <span class="op">=</span> (c <span class="op">*</span> dt <span class="op">/</span> dx <span class="op">*</span> (un[j, i] <span class="op">-</span> un[j, i <span class="op">-</span> <span class="dv">1</span>]))
            tmp2 <span class="op">=</span> (c <span class="op">*</span> dt <span class="op">/</span> dy <span class="op">*</span> (un[j, i] <span class="op">-</span> un[j <span class="op">-</span> <span class="dv">1</span>, i]))
            u[j, i] <span class="op">=</span> (un[j, i] <span class="op">-</span> tmp1 <span class="op">-</span> tmp2)
            u[<span class="dv">0</span>, :] <span class="op">=</span> <span class="dv">1</span>
            u[<span class="op">-</span><span class="dv">1</span>, :] <span class="op">=</span> <span class="dv">1</span>
            u[:, <span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span>
            u[:, <span class="dv">-1</span>] <span class="op">=</span> <span class="dv">1</span>

fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">11</span>, <span class="dv">7</span>), dpi<span class="op">=</span><span class="dv">100</span>)
ax <span class="op">=</span> fig.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)
surf2 <span class="op">=</span> ax.plot_surface(X, Y, u[:], cmap<span class="op">=</span>cm.viridis)
plt.savefig(<span class="st">&#39;compscieng_app45cfd3_02.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="compscieng_app45cfd3_02.png" />

</div>
<p>Burgers'in Denklemi</p>
<p>Bu denklem tek boyutta şuna benziyor</p>
<p><span class="math display">\[
\frac{\partial u}{\partial t} + u \frac{\partial u}{\partial x} =
\nu \frac{\partial ^2u}{\partial x^2}
\]</span></p>
<p>Görüldüğü gibi bu formül gayrı lineer taşınım akımı (convection) ile yayınım (diffusion) formüllerinin birleşimi. O zaman denklemi önce gördüğümüz teknikler ile ayrıksal hale getirebiliriz.</p>
<p><span class="math display">\[
\frac{u_i^{n+1}-u_i^n}{\Delta t} + u_i^n \frac{u_i^n - u_{i-1}^n}{\Delta x} =
\nu \frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{\Delta x^2}
\]</span></p>
<p>Daha önce olduğu gibi başlangıç koşulumuz var, ona göre denklemi tekrar düzenliyoruz,</p>
<p><span class="math display">\[
u_i^{n+1} =
u_i^n - u_i^n \frac{\Delta t}{\Delta x} (u_i^n - u_{i-1}^n) +
\nu \frac{\Delta t}{\Delta x^2}(u_{i+1}^n - 2u_i^n + u_{i-1}^n)
\]</span></p>
<p>Bu örnekte farklı bir başlangıç şartı kullanacağız.</p>
<p><span class="math display">\[
u = -\frac{2 \nu}{\phi} \frac{\partial \phi}{\partial x} + 4 
\]</span></p>
<p><span class="math display">\[
\phi = \exp \bigg(\frac{-x^2}{4 \nu} \bigg) + \exp \bigg(\frac{-(x-2 \pi)^2}{4 \nu} \bigg)
\]</span></p>
<p>Bu başlangıç şartlarına göre Burgers denkleminin analitik çözümü biliniyor,</p>
<p><span class="math display">\[
u = -\frac{2 \nu}{\phi} \frac{\partial \phi}{\partial x} + 4
\]</span></p>
<p><span class="math display">\[
\phi = \exp \bigg(\frac{-(x-4t)^2}{4 \nu (t+1)} \bigg) + \exp \bigg(\frac{-(x-4t -2 \pi)^2}{4 \nu(t+1)} \bigg)
\]</span></p>
<p>Sınır şartı</p>
<p><span class="math display">\[
u(0) = u(2\pi)
\]</span></p>
<p>Fakat başlangıç şartını belli ızgara noktalarında işletebilmek istiyoruz, fakat üstteki formülde çetrefil bir form var, birşeylerin türevi vs var. Ne yapacağız? Paket <code>sympy</code> kullanılabilir.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> sympy
<span class="im">from</span> sympy.utilities.lambdify <span class="im">import</span> lambdify
<span class="im">from</span> sympy <span class="im">import</span> init_printing
init_printing(use_latex<span class="op">=</span><span class="va">True</span>)

x, nu, t <span class="op">=</span> sympy.symbols(<span class="st">&#39;x nu t&#39;</span>)
phi <span class="op">=</span> (sympy.exp(<span class="op">-</span>(x <span class="op">-</span> <span class="dv">4</span> <span class="op">*</span> t)<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> (<span class="dv">4</span> <span class="op">*</span> nu <span class="op">*</span> (t <span class="op">+</span> <span class="dv">1</span>))) <span class="op">+</span>
       sympy.exp(<span class="op">-</span>(x <span class="op">-</span> <span class="dv">4</span> <span class="op">*</span> t <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> sympy.pi)<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> (<span class="dv">4</span> <span class="op">*</span> nu <span class="op">*</span> (t <span class="op">+</span> <span class="dv">1</span>))))
phiprime <span class="op">=</span> phi.diff(x)

u <span class="op">=</span> <span class="dv">-2</span> <span class="op">*</span> nu <span class="op">*</span> (phiprime <span class="op">/</span> phi) <span class="op">+</span> <span class="dv">4</span>
ufunc <span class="op">=</span> lambdify((t, x, nu), u)
<span class="bu">print</span>(ufunc(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">3</span>))</code></pre></div>
<pre><code>3.49170664206445</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">nx <span class="op">=</span> <span class="dv">101</span>
nt <span class="op">=</span> <span class="dv">100</span>
dx <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> np.pi <span class="op">/</span> (nx <span class="op">-</span> <span class="dv">1</span>)
nu <span class="op">=</span> <span class="fl">.07</span>
dt <span class="op">=</span> dx <span class="op">*</span> nu

x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">2</span> <span class="op">*</span> np.pi, nx)
un <span class="op">=</span> np.empty(nx)
t <span class="op">=</span> <span class="dv">0</span>

u <span class="op">=</span> np.asarray([ufunc(t, x0, nu) <span class="cf">for</span> x0 <span class="kw">in</span> x])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">plt.figure(figsize<span class="op">=</span>(<span class="dv">11</span>, <span class="dv">7</span>), dpi<span class="op">=</span><span class="dv">100</span>)
plt.plot(x, u, marker<span class="op">=</span><span class="st">&#39;o&#39;</span>, lw<span class="op">=</span><span class="dv">2</span>)
plt.xlim([<span class="dv">0</span>, <span class="dv">2</span> <span class="op">*</span> np.pi])
plt.ylim([<span class="dv">0</span>, <span class="dv">10</span>])<span class="op">;</span>
plt.savefig(<span class="st">&#39;compscieng_app45cfd2_02.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="compscieng_app45cfd2_02.png" />

</div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(nt):
    un <span class="op">=</span> u.copy()
    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, nx<span class="dv">-1</span>):
        u[i] <span class="op">=</span> un[i] <span class="op">-</span> un[i] <span class="op">*</span> dt <span class="op">/</span> dx <span class="op">*</span>(un[i] <span class="op">-</span> un[i<span class="dv">-1</span>]) <span class="op">+</span> nu <span class="op">*</span> dt <span class="op">/</span> dx<span class="op">**</span><span class="dv">2</span> <span class="op">*\</span>
                (un[i<span class="op">+</span><span class="dv">1</span>] <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> un[i] <span class="op">+</span> un[i<span class="dv">-1</span>])
    u[<span class="dv">0</span>] <span class="op">=</span> un[<span class="dv">0</span>] <span class="op">-</span> un[<span class="dv">0</span>] <span class="op">*</span> dt <span class="op">/</span> dx <span class="op">*</span> (un[<span class="dv">0</span>] <span class="op">-</span> un[<span class="op">-</span><span class="dv">2</span>]) <span class="op">+</span> nu <span class="op">*</span> dt <span class="op">/</span> dx<span class="op">**</span><span class="dv">2</span> <span class="op">*\</span>
                (un[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> un[<span class="dv">0</span>] <span class="op">+</span> un[<span class="op">-</span><span class="dv">2</span>])
    u[<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> u[<span class="dv">0</span>]
        
u_analytical <span class="op">=</span> np.asarray([ufunc(nt <span class="op">*</span> dt, xi, nu) <span class="cf">for</span> xi <span class="kw">in</span> x])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">plt.figure(figsize<span class="op">=</span>(<span class="dv">11</span>, <span class="dv">7</span>), dpi<span class="op">=</span><span class="dv">100</span>)
plt.plot(x,u, marker<span class="op">=</span><span class="st">&#39;o&#39;</span>, lw<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">&#39;Hesapsal&#39;</span>)
plt.plot(x, u_analytical, label<span class="op">=</span><span class="st">&#39;Analitik&#39;</span>)
plt.xlim([<span class="dv">0</span>, <span class="dv">2</span> <span class="op">*</span> np.pi])
plt.ylim([<span class="dv">0</span>, <span class="dv">10</span>])
plt.legend()<span class="op">;</span>
plt.savefig(<span class="st">&#39;compscieng_app45cfd2_03.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="compscieng_app45cfd2_03.png" />

</div>
<p>Alternatif Anlatim [9, sf. 559]</p>
<p>Tek boyutta Burgers'in denklemi,</p>
<p><span class="math display">\[
\frac{\partial u}{\partial t} + \epsilon u \frac{\partial u}{\partial x} = 0
\]</span></p>
<p>olarak ta gösterilebilir. Denklemin muhafazakar formu (ayrıksallaştırmada işi kolaylaştırıyor),</p>
<p><span class="math display">\[
\frac{\partial u}{\partial t} + \epsilon \frac{\partial (u^2 / 2)}{\partial x} = 0
\]</span></p>
<p><span class="math inline">\(u^2\)</span> nereden geldi? <span class="math inline">\(u^2\)</span> üzerinde <span class="math inline">\(\partial / \partial x\)</span> türevi uygulanınca Zincirleme Kanunu ile <span class="math inline">\(2 u \cdot \partial u / \partial x\)</span> elde ederdik, o zaman bu formülü 2 ile bölerek iki üstteki forma erisebiliriz.</p>
<p>Bu denklem taşınım formülünün bir şekli bir anlamda, eğer dalga hızı <span class="math inline">\(c = \epsilon u\)</span> dersek. Dikkat edersek bu durumda dalga hızı dalga boyuna (amplitude) oranlı hale geliyor, yani dalganın üst tarafında hız daha artacak. Denkleme eklenen bir gayri lineerlik ilginç davranışlara yol açıyor. Taşınım formülünde dalganın her kısmı aynı hızda hareket eder, &quot;taşınır'', ve bu sebeple dalga şeklinde bir değişim olmaz. Ama dalganın üst kısmı alt kısmına göre daha hızlı hareket ederse şekil değişimi olur, dalganın üstü daha ileri gider, şok dalgası (shock wave) denen durumu ortaya çıkartır.</p>
<p>Kaynaklar</p>
<p>[1] Bayramlı, <em>Fizik, Isı ve Dalga Denklemleri</em></p>
<p>[2] Igel, <em>Computers, Waves, Simulations, Coursera Lecture, Week 3, von Neumann Analysis</em>, <a href="https://www.coursera.org/learn/computers-waves-simulations" class="uri">https://www.coursera.org/learn/computers-waves-simulations</a></p>
<p>[3] Landau, <em>Landau Computational Physics Course, Video Lectures</em>, <a href="https://www.youtube.com/playlist?list=PLnWQ_pnPVzmJnp794rQXIcwJIjwy7Nb2U" class="uri">https://www.youtube.com/playlist?list=PLnWQ_pnPVzmJnp794rQXIcwJIjwy7Nb2U</a></p>
<p>[4] Bayramlı, <em>Diferansiyel Denklemler, Ekler, Trigonometri</em></p>
<p>[5] Bayramlı, <em>Animasyon</em>, <a href="https://raw.githubusercontent.com/burakbayramli/classnotes/master/compscieng/compscieng_app17wave/string.gif" class="uri">https://raw.githubusercontent.com/burakbayramli/classnotes/master/compscieng/compscieng_app17wave/string.gif</a></p>
<p>[6] Barba, <em>12 steps to Navier–Stokes, Ders 1</em>, <a href="https://nbviewer.jupyter.org/github/barbagroup/CFDPython/tree/master/lessons/" class="uri">https://nbviewer.jupyter.org/github/barbagroup/CFDPython/tree/master/lessons/</a></p>
<p>[7] Bayramlı, <em>Fizik, Isı ve Dalga Denklemlerini Türetmek</em></p>
<p>[8] Bayramlı, <em>Fizik, Akış Dinamiği</em></p>
<p>[9] Landau, <em>Computational Physics</em></p>
<p>[10] Mittleman, <em>Applied Electromagnetics ENGN1560 Brown Lecture</em></p>
<p>[11] Logan, <em>Applied Mathematics, Third Edition</em></p>
<p>[12] Bayramlı, <em>Hesapsal Bilim, Dalga Denklemi</em></p>
</body>
</html>
