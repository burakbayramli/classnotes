<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Sonlu Hacim (Finite Volume) Yöntemi</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="sonlu-hacim-finite-volume-yöntemi">Sonlu Hacim (Finite Volume)
Yöntemi</h1>
<p>Üç boyutlu kütle muhafazası üzerinden süreklilik formül [2]’de
işlendi. Şimdi tek boyutlu ortamda muhafaza kanunlarını işleyeceğiz, gaz
dinamiği, genel aerodinamik konularında bu yaklaşım faydalı olacak.
Sayısal çözmeye çalışılacak problemler, ki sonlu hacim (finite volume
-FV-) yöntemi burada lazım, muhafaza kanunları içeren hiperbolik
sistemleridir (hyperbolic systems of conservation laws). Bu tür
sistemler zamana bağlı çoğunlukla gayrı lineer kısmi türevsel
denklemlerdir (nonlinear PDE), ve aslında basit yapıları vardır. Tek
yersel boyutta şuna benzerler [3, sf. 1],</p>
<p><span class="math display">\[
\frac{\partial }{\partial t} u(x,t) +
\frac{\partial }{\partial x} f(u(x,t)) = 0
\qquad (1)
\]</span></p>
<p>Daha önce [1]’de Burgers’in denklemini görmüştük, bir PDE,</p>
<p><span class="math display">\[
u_t + uu_x = 0
\qquad (2a)
\]</span></p>
<p>Bu denklem (1) ışığında düşünülebilir, eğer <span
class="math inline">\(f(u) = u^2/2\)</span> tanımlarsak, (1) formülü,
yani <span class="math inline">\(u_t + f(u)_x = 0\)</span>, formül (2a)
ile aynıdır. O zaman,</p>
<p><span class="math display">\[
u_t + f(u)_x = 0, \qquad f(u) = \frac{1}{2}u^2
\qquad (2b)
\]</span></p>
<p>İleride lazım olur, (1)’i açarsak [6, sf. 29],</p>
<p><span class="math display">\[
\frac{\partial u}{\partial t} +
f&#39;(u) \frac{\partial u}{\partial x} = 0
\qquad (5)
\]</span></p>
<p>denklemi de doğrudur, ki <span class="math inline">\(f&#39;(u) =
\frac{\mathrm{d} f}{\mathrm{d} u}\)</span>.</p>
<ol start="2" type="1">
<li>türünden denklemleri tek boyutta çözmeyi işleyeceğiz öncelikle,
çünkü çok boyutta çözüm tek boyuta indirgenerek yapılabiliyor.</li>
</ol>
<p>Hiperbolik denklemleri analitik, kesin (exact) çözmek için birkaç
konuyu yakından anlamak lazım. Birincisi Riemann problemleri; bu
yaklaşımla hiperbolik PDE’nin başlangıç koşulu kesintili (discontinuous)
bir fonksiyonla belirtiliyor ve bu çözümleri çoğu durumda daha
rahatlaştırılıyor, diğeri hiperbolik muhafaza kanunlarının entegral
formu.</p>
<p>İleride hiperbolik denklemleri FV ile sayısal çözerken de Riemann
yaklaşımı faydalı olacak. Kesintili başlangıç içeren denklemler
çözebilmek önemli çünkü FV ile sayısal çözüm yaparken uzayı parçalara
bölüyoruz, ve her iki parçayı bir kesintili başlangıç içeren Riemann
problemi olarak temsil ediyoruz, bu pek çok parça ortaya çıkartır tabii,
bu sebeple tipik bir FV yaklaşımı her adımda pek çok Riemann problemini
çözecektir.</p>
<p>Entegral form lazım, çünkü sınırlı farklılıklarda (finite difference)
olduğu gibi ayrıksal olan fonksiyonun eşit aralıklarda tanımlı bir
ızgaranın seçilmiş belli noktaları değil, her bölge, parçanın
ortalaması, yani entegrali.</p>
<p>Entegral form ile başlayalım. Aslında diferansiyel form entegral
formden türetilmiştir -bu türetim pürüzsüzlük faraziyesi üzerinden
yapılmıştır-. Özellikle kesintili başlangıç şartları olduğu durumlarda
diferansiyel formun her yerde düzgün işlemesi mümkün değil, çünkü
kesintilerde türev alınamıyor. Ayrıca pür kesintisiz olsa bile şok
oluşumu denen sebeplerle türevsel fonksiyonlar çözülemiyor. Bu
problemlerle başedebilmek için entegral formu kullanmak gerekecek.</p>
<p>Bu formu [12]’de bulabiliriz.</p>
<p>Riemann Problemi</p>
<p>Kesintili ve iki parça içeren bir fonksiyon ile Burgers denkleminin
çözümü mümkün; bu aslında basit, <span class="math inline">\(u_t + u u_x
= 0\)</span> denklemi için başlangıç şartları</p>
<p><span class="math display">\[
u(x,0) =
\left\{ \begin{array}{ll}
u_l &amp; x &lt; 0 \\
u_r &amp; x &gt; 0
\end{array} \right.
\qquad (9)
\]</span></p>
<p>olduğu durumda çözüm özgün bir zayıf çözümdür, eğer <span
class="math inline">\(u_l &gt; u_r\)</span> ise (bu mümkün seçeneklerden
birincisi)</p>
<p><span class="math display">\[
u(x,t) =
\left\{ \begin{array}{ll}
u_l &amp; x &lt; st \\
u_r &amp; x &gt; st
\end{array} \right.
\]</span></p>
<p>ki <span class="math inline">\(s\)</span> şok hızıdır. Ya da</p>
<p><span class="math display">\[
u(x,t) =
\left\{ \begin{array}{ll}
u_l &amp; x/t &lt; s \\
u_r &amp; x/t &gt; s
\end{array} \right.
\]</span></p>
<p>Kesinti noktası <span class="math inline">\(s\)</span> hızında sağa
ilerler, <span class="math inline">\(t\)</span> anında olacağı yer <span
class="math inline">\(st\)</span>’dir.</p>
<p><img src="compscieng_bpp50fv1_01.png" /></p>
<p>Karakteristik Eğriler</p>
<p>Üstteki çözümü anlamak, hatta ona ulaşmak için karakteristik eğriler
faydalı oluyor. Karakteristik eğrilerle <span
class="math inline">\(x,t\)</span> ilişkisine odaklanıyoruz, <span
class="math inline">\(u\)</span>’nun zamana göre değişmediği duruma
bakıyoruz (yani <span class="math inline">\(\mathrm{d} u / \mathrm{d} t
= 0\)</span>) ve bu başlangıçtan bir <span
class="math inline">\(\mathrm{d} x / \mathrm{d} t\)</span> türevine
erişmeye uğraşıyoruz, ve seçilen bazı başlangıç noktaları ve sabit bir
eğim için ortaya çıkan grafiği inceliyoruz. Türev basit bir dalga
denkleminde,</p>
<p><span class="math display">\[
x&#39;(t) = a, \quad x(0) = x_0
\]</span></p>
<p>olur daha çetrefil dalgalarda farklı. <span
class="math inline">\(\mathrm{d} x / \mathrm{d} t\)</span> elde etmek
için <span class="math inline">\(t\)</span> ve <span
class="math inline">\(x\)</span> değişkenleri olduğunu ve <span
class="math inline">\(x = x(t)\)</span> olduğunu hatırlayalım, yani
<span class="math inline">\(u = u(x,t) = u(x(t),t)\)</span> olur. İki
değişkenli fonksionlar üzerinde genel zincirleme kanununu [10]’da
gördük, mesela <span class="math inline">\(g(x(t),y(t))\)</span> için
<span class="math inline">\(\mathrm{d} g / \mathrm{d} t\)</span></p>
<p><span class="math display">\[
\frac{\mathrm{d} g}{\mathrm{d} t} =
\frac{\partial g}{\partial x} \cdot \frac{\mathrm{d} x}{\mathrm{d} t} +
\frac{\partial g}{\partial y} \cdot \frac{\mathrm{d} y}{\mathrm{d} t}
\]</span></p>
<p>İki değişkenli <span class="math inline">\(u\)</span>’nun zamana göre
türevi o zaman [9, sf. 17],</p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d} t} u (x(t),t)) =
\frac{\partial u}{\partial x} \frac{\mathrm{d} x}{\mathrm{d} t} +
\frac{\partial u}{\partial t} \cancelto{1}{\frac{\mathrm{d}
t}{\mathrm{d} t}}
\]</span></p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d} t} u (x(t),t)) =
\frac{\partial u}{\partial x} \frac{\mathrm{d} x}{\mathrm{d} t} +
\frac{\partial u}{\partial t}
\]</span></p>
<p>Üsttekini sıfıra eşitlersek,</p>
<p><span class="math display">\[
u_t  + u_x x&#39;(t) = 0
\]</span></p>
<p>(2a)’yı hatırlayalım ve üstteki formülle eşleştirelim, Burgers
denklemi için <span class="math inline">\(x&#39;(t) = u\)</span> elde
ederdik. Karakteristik diferansiyel denklemi,</p>
<p><span class="math display">\[
x&#39;(t) = u(x(t),t), \qquad x(0) = x_0
\]</span></p>
<p>Not: İki üsttekini (5) ile eşleyerek</p>
<p><span class="math display">\[
f&#39;(u) = \frac{\mathrm{d} x(t)}{\mathrm{d} t}
\]</span></p>
<p>karakteristik diferansiyeli de doğru.</p>
<p>Bu denklemi grafiklemek için <span class="math inline">\(t,x\)</span>
yerine <span class="math inline">\(x,t\)</span> bazlı düşünmek daha iyi
(bir önceki grafikle alakayı görmek için, her iki grafikte <span
class="math inline">\(x\)</span> değişkeni yatay kordinatta oluyor)
altta bir başlangıç <span class="math inline">\(x_0\)</span> seçiyoruz,
ve buradan yukarı doğru <span class="math inline">\(u(x_0)\)</span>
eğiminde (çünkü <span class="math inline">\(&#39;x = u\)</span>
demiştik) bir çizgi gidiyor. Ama dikkat hayal etmek için eğimi tersine
çevirmek lazım, giriş Calculus’ta eğimler <span
class="math inline">\(y/t\)</span>, <span
class="math inline">\(z/t\)</span> bazında düşünülür burada <span
class="math inline">\(t/x\)</span>.</p>
<p>Devam edelim, ayrıca Riemann problemi çözdüğümüzü unutmayalım, <span
class="math inline">\(u\)</span> değerleri değişik <span
class="math inline">\(x\)</span> noktalarında bir değerden diğerine
geçiyor, bir <span class="math inline">\(u_L\)</span> var, bir de <span
class="math inline">\(u_R\)</span> var, eğimler bu değerleri yansıtmalı.
Grafikleme sonrası,</p>
<p><img src="compscieng_bpp50fv1_03.png" /></p>
<p>O zihindeki ters çevirme işleminden önceki hali göstermek gerekirse,
alttaki gibi</p>
<p><img src="compscieng_bpp50fv1_04.png" /></p>
<p>Görüldüğü gibi sıfırdan küçük <span
class="math inline">\(x\)</span>’ler için <span
class="math inline">\(u_L\)</span> devrede orada bizim klasik bildiğimiz
eğim daha fazla, sıfırdan yukarı çıkınca eğim azalıyor, çünkü orada
<span class="math inline">\(u_R\)</span> daha küçük.</p>
<p>Şimdi iki üstteki ana grafiğe tekrar bakarsak, orada bir problem
gözüküyor [11, 10:13]. Soldan gelen ve sağdan gelen karakteristikler
kesişiyor. O zaman o noktada iki çözüm olurdu. Bu nasıl mümkün olabilir
ki? Doğanın o noktada yaptığı şudur; oraya bir şok yerleştirmek, o
bölgeyi bir şok bölgesi haline getirmek. O bölgede, çizgi üzerinde eğim
<span class="math inline">\(s\)</span> olacak ve bu <span
class="math inline">\(s\)</span> aslında <span
class="math inline">\(u_L\)</span> ve <span
class="math inline">\(u_R\)</span>’nin ortalaması.</p>
<p><span class="math inline">\(st\)</span> değeri nereden geliyor? <span
class="math inline">\(x,u\)</span>, <span
class="math inline">\(x,t\)</span> grafiklerini <span
class="math inline">\(x\)</span>’ler çakışacak şekilde alt alta
gösterelim, ve <span class="math inline">\(x,t\)</span> grafiğinde bir
<span class="math inline">\(t\)</span> noktası işaretleyelim (yatay
çizgi), O çizginin şok bölgesini kestiği yerden aşağı doğru <span
class="math inline">\(x,u\)</span> grafiğine inelim, alttaki grafikte o
noktadaki <span class="math inline">\(u\)</span> değeri <span
class="math inline">\(t\)</span> anındaki çözüm <span
class="math inline">\(u(x,t)\)</span>.</p>
<p><img src="compscieng_bpp50fv1_05.png" /></p>
<p>O noktada katedilmiş mesafe <span class="math inline">\(st\)</span>
çünkü o noktada <span class="math inline">\(x&#39;(t) = s\)</span>. Bu
işlemi daha önceki <span class="math inline">\(t\)</span> zamanları için
yaparsak, kesikli sarı çizgi ortaya çıkacaktır. Bu da dalganın sağa
doğru akışını gösteriyor bir bakıma.</p>
<p>Şok hızını cebirsel bulalım. Daha önce tek boyutlu lineer taşınım
akımı (convection) ile gördüğümüz durum burada da var, orada çözüm <span
class="math inline">\(u(x,y) = u_0(x-ct)\)</span> idi, dalga hızı <span
class="math inline">\(c\)</span>. Şimdi hız <span
class="math inline">\(u\)</span> bu <span
class="math inline">\(s\)</span> şok hızınını verir, Burgers için hesabı
<span class="math inline">\(s = (u_l + u_r) / 2\)</span>. Şok hızının
hesabı için kesinti bölgesinin yeterince uzağında <span
class="math inline">\(M\)</span> ve <span
class="math inline">\(-M\)</span> noktalarını seçelim, bu iki nokta
arasındaki toplam kütlenin / dalganın değişiminin hızı şok hızı <span
class="math inline">\(s\)</span> olacaktır.</p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d} t} \int_{-M}^{M} u(x,t) \mathrm{d} x =
f(u_l) - f(u_r)
\qquad (8)
\]</span></p>
<p>Salt entegralin nasıl hesaplanacağına bakarsak [3, sf. 31],</p>
<p><span class="math display">\[
\int_{-M}^{M} u(x,t) \mathrm{d} x =
\int_{-M}^{st} u_l \mathrm{d} x +
\int_{st}^{M} u_r \mathrm{d} x
\]</span></p>
<p><span class="math display">\[
= (M+st)u_l + (M-st)u_r
\]</span></p>
<p>Şimdi zaman türevini geri koyalım, bu sağ tarafta <span
class="math inline">\(s(u_l-u_r)\)</span> verir, hepsi bir arada,</p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d} t} \int_{-M}^{M} u(x,t) \mathrm{d} x =
s(u_l-u_r)
\]</span></p>
<p>(8)’in sağ tarafını üstteki formüle koyunca,</p>
<p><span class="math display">\[
f(u_l) - f(u_r) = s(u_l-u_r)
\]</span></p>
<p><span class="math display">\[
s = \frac{f(u_l) - f(u_r)}{u_l-u_r}
\]</span></p>
<p>Böylece genel bir ifade elde ettik. Burgers denklemi özelinde, <span
class="math inline">\(f(u) = u^2 / 2\)</span> olduğuna göre,</p>
<p><span class="math display">\[
f(u_l) - f(u_r) = \frac{1}{2} u_l^2 -  \frac{1}{2} u_r^2
\]</span></p>
<p>O zaman</p>
<p><span class="math display">\[
\frac{1}{2} (u_l + u_r)(u_l - u_r) = s(u_l-u_r)
\]</span></p>
<p>diyebiliriz [5, sf. 46], basitleştirince,</p>
<p><span class="math display">\[
s = \frac{1}{2} (u_l + u_r)
\]</span></p>
<p>Seyreltilmiş Dalga</p>
<p>İkinci seçenek, seyreltilmiş dalga sonucu, bu zayıf çözüm başlangıçta
<span class="math inline">\(u_l &lt; u_r\)</span> olduğu zaman ortaya
çıkıyor.</p>
<p><img src="compscieng_bpp50fv1_02.png" /></p>
<p>Daha önceki formu tekrarlarsak, karakteristik ve <span
class="math inline">\(x,u\)</span> grafiği alt alta,</p>
<p><img src="compscieng_bpp50fv1_06.png" /></p>
<p>Bu grafikte karakteristik çizgilerini bulmak kolay değil, <span
class="math inline">\(u_L\)</span>, <span
class="math inline">\(u_R\)</span> kısımları yapılabilir ama ortadaki
kısmı anlamak için bu sefer <span class="math inline">\(x,u\)</span>
grafiğinden dönerek <span class="math inline">\(x,t\)</span>’ye gitmek
gerekiyor. Altta <span class="math inline">\(u_R \cdot t\)</span> ve
<span class="math inline">\(u_L \cdot t\)</span> noktaları bulunduktan
sonra doğal olan onların düz çizgi ile birleştirilmesidir, bu çizgi de
karakteristiklerdeki o yayılma (fan) şeklini ortaya çıkartır, tam
ortasnda da tabii ki şok cizgisi olacaktır.</p>
<p>Bir çözüm, ki zayıf çözümlerde (bu konu ileride işlenecek), alttaki
gibi olabilir,</p>
<p><span class="math display">\[
u(x,t) =
\left\{ \begin{array}{ll}
u_l &amp; x &lt; u_l t  \\
x/t &amp; u_l t \le x \le u_r t \\
u_r &amp; x &gt; u_r t
\end{array} \right.
\]</span></p>
<p>Sağ taraf yine daha önce olduğu gibi şu hale çevirilebilir (ki
birazdan görülecek kodu anlamak için de bu form faydalı)</p>
<p><span class="math display">\[
u(x,t) =
\left\{ \begin{array}{ll}
u_l &amp; x/t &lt; u_l \\
x/t &amp; u_l \le x/t \le u_r  \\
u_r &amp; x/t &gt; u_r
\end{array} \right.
\]</span></p>
<p>Çözümün Burgers denklemi için doğru olduğunun sağlamasını
yapabiliriz, [9, sf. 34], mesela orta şart <span
class="math inline">\(u_l \le x/t \le u_r\)</span> kısmına bakalım, bu
çözümü (2a)’ya sokarsak,</p>
<p><span class="math display">\[
\frac{\partial u}{\partial t} + u \frac{\partial u}{\partial x} =
\frac{\partial }{\partial t} \left( \frac{x}{t}  \right) +
\frac{x}{t} \frac{\partial }{\partial x} \left( \frac{x}{t}  \right) =
-\frac{x}{t^2} + \frac{x}{t} \frac{1}{t} = 0
\]</span></p>
<p>İlk ve üçüncü şartın çözüm olduğu bariz çünkü sabit sayılar, ve
türevleri alınırken sıfırlanacaklar.</p>
<p>Entropi</p>
<p>Aslında üstteki seyreltilmiş dalga çözümü tek mümkün çözüm değil. Bu
çözüm bir zayıf çözüm (ileride göreceğiz) bu sebeple özgün değiller.
Mesela <span class="math inline">\(u_L = 0\)</span>, <span
class="math inline">\(u_R = 1\)</span> örnekleri üzerinden alttakiler de
birer çözüm olabilirdi [4, sf. 27],</p>
<p><img src="compscieng_bpp50fv1_07.png" /></p>
<p>Çözümler soldan sağa doğru,</p>
<p><span class="math display">\[
u(x,t) =
\left\{ \begin{array}{ll}
0 &amp; x &lt; \frac{1}{2} t  \\
1 &amp; x &gt; \frac{1}{2} t  \\
\end{array} \right.
\]</span></p>
<p>Hız <span class="math inline">\(s\)</span> tabii ki daha önceki
formülden hesaplandı,</p>
<p><span class="math display">\[
s = \frac{u_R^2 / 2 - u_L^2 / 2 }{u_R - u_L} = 1/2
\]</span></p>
<p>Ve</p>
<p><span class="math display">\[
u(x,t) =
\left\{ \begin{array}{ll}
0 &amp; x &lt; \frac{1}{3} t  \\
\frac{2}{3} &amp; \frac{1}{3} t &lt; x &lt; \frac{5}{6} t  \\
1 &amp; x &gt; \frac{5}{6} t  
\end{array} \right.
\]</span></p>
<p>Fakat bu çözümler fiziksel değildir. Niye? Çünkü grafiklere dikkat
edersek her iki durumda da bazı karakteristik çizgiler <em>şoktan</em>
dışarı çıkıyorlar, kıyasla en başta ilk karakteristik grafiğinde
karakteristikler şoka doğru gidiyorlar. Karakteristikler bir anlamda
bilgi akışının temsil ediyorlar, deterministik bir denklemi baz alan bir
evrimsel, dinamik denklem her zaman başlangıç verisinden başlayarak
ileri gitmelidir. Fakat hemen üstteki iki çözümde şok noktasında yeni
bilgi yaratılıyor. Bir diğer açıdan [6, sf. 35] belirtmek gerekirse,
istediğimiz, bir karakteristiği zamanı geriye sararak başlangıç şartına
bağlayabilmektir. Üstteki iki çözümde bunu yapmak mümkün değil.</p>
<p>Animasyon</p>
<p>Altta Burgers denkleminin şok ve seyreltilmiş dalga formu için
çözümlerini animasyon olarak bulabiliriz.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> qf(q): <span class="cf">return</span> <span class="fl">0.5</span><span class="op">*</span>q<span class="op">*</span>q</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> exact_riemann_solution(xi,u_l,u_r):</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Shock wave</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> u_l <span class="op">&gt;</span> u_r: </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        shock_speed <span class="op">=</span> (qf(u_l)<span class="op">-</span>qf(u_r))<span class="op">/</span>(u_l<span class="op">-</span>u_r)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> (xi <span class="op">&lt;</span> shock_speed)<span class="op">*</span>u_l <span class="op">\</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>          <span class="op">+</span> (xi <span class="op">&gt;=</span>shock_speed)<span class="op">*</span>u_r</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> q</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Rarefaction wave</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:  </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> (xi<span class="op">&lt;=</span>u_l)<span class="op">*</span>u_l <span class="op">\</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>          <span class="op">+</span> (xi<span class="op">&gt;=</span>u_r)<span class="op">*</span>u_r <span class="op">\</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>          <span class="op">+</span> (u_l<span class="op">&lt;</span>xi)<span class="op">*</span>(xi<span class="op">&lt;</span>u_r)<span class="op">*</span>xi</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> q</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> shock():</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    u_l, u_r <span class="op">=</span> <span class="fl">5.0</span>, <span class="fl">1.0</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i,t <span class="kw">in</span> <span class="bu">enumerate</span>(np.linspace(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">6</span>)):</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        outfile <span class="op">=</span> <span class="st">&#39;rieout/shock-</span><span class="sc">%02d</span><span class="st">.png&#39;</span> <span class="op">%</span> i</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">3</span>))</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">1000</span>)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> np.array([exact_riemann_solution(xi<span class="op">/</span>(t<span class="op">+</span><span class="fl">1e-10</span>),u_l,u_r) <span class="cf">for</span> xi <span class="kw">in</span> x])</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        ax.set_xlim(<span class="op">-</span><span class="dv">4</span>,<span class="dv">4</span>)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        ax.plot(x,q,<span class="st">&#39;-k&#39;</span>,lw<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        ax.set_title(<span class="st">&#39;t=</span><span class="sc">%f</span><span class="st">&#39;</span> <span class="op">%</span> t)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        plt.savefig(outfile)</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>shock() </span></code></pre></div>
<p><img src="rieout/shock-00.png" /></p>
<p><img src="rieout/shock-04.png" /></p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rarefaction():</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    u_l, u_r <span class="op">=</span> <span class="fl">2.0</span>, <span class="fl">4.0</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i,t <span class="kw">in</span> <span class="bu">enumerate</span>(np.linspace(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">6</span>)):</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        outfile <span class="op">=</span> <span class="st">&#39;rieout/rarefaction-</span><span class="sc">%02d</span><span class="st">.png&#39;</span> <span class="op">%</span> (t<span class="op">*</span><span class="dv">10</span>)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">3</span>))</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">1000</span>)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> np.array([exact_riemann_solution(xi<span class="op">/</span>(t<span class="op">+</span><span class="fl">1e-10</span>),u_l,u_r) <span class="cf">for</span> xi <span class="kw">in</span> x])</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        ax.set_xlim(<span class="op">-</span><span class="dv">4</span>,<span class="dv">4</span>)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        ax.plot(x,q,<span class="st">&#39;-k&#39;</span>,lw<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        ax.set_title(<span class="st">&#39;t=</span><span class="sc">%f</span><span class="st">&#39;</span> <span class="op">%</span> t)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        plt.savefig(outfile)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>rarefaction()</span></code></pre></div>
<p><img src="rieout/rarefaction-02.png" /></p>
<p><img src="rieout/rarefaction-06.png" /></p>
<p>Animasyon olarak</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> convert <span class="op">-</span>delay <span class="dv">20</span> <span class="op">-</span>loop <span class="dv">0</span> rieout<span class="op">/</span>shock<span class="op">*</span>.png shock.gif</span></code></pre></div>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> convert <span class="op">-</span>delay <span class="dv">20</span> <span class="op">-</span>loop <span class="dv">0</span> rieout<span class="op">/</span>rare<span class="op">*</span>.png rarefaction.gif</span></code></pre></div>
<p>Animasyon sonuç dosyaları [7] ve [8]’de bulunabilir.</p>
<p>Amaç bir diferansiyel denklemi sayısal olarak çözmek. Metot olarak
sonlu farklılık (finite difference -FD-) yöntemi daha önce işlendi, bu
yöntemde bir sürekli fonksiyonun değerlerini ayrıksal noktalar üzerinden
temsil etmeye uğraşıyorduk. Bu noktalar bir ekseni eşit aralıklara
bölerek ortaya çıkartılıyordu, mesela altta görülen bir tepeyle başlayıp
inen <span class="math inline">\(f\)</span> fonksiyonu <span
class="math inline">\(i-2,i-1,i,..\)</span> noktalarında <span
class="math inline">\(x_i\)</span> değerleri üzerinden <span
class="math inline">\(u_i = u(x_i)\)</span> ile tanımlanıyordu.</p>
<p><img src="13-22-29.png" /></p>
<p>Sonlu hacim (FV) yönteminde durum biraz farklı; bir fonksiyonu belli
noktalarındaki noktasal değerlerle değil, belli aralıklar arasında kalan
değerlerinin <em>averajı</em> olarak temsil ediyoruz.</p>
<p><img src="13-22-34.png" /></p>
<p>Farklı bir grafik</p>
<p><img src="13-16-00.png" /></p>
<p>İki üstte görülen grafikte mesela <span
class="math inline">\(i\)</span> ile <span
class="math inline">\(i+1\)</span> noktası ortasındaki <span
class="math inline">\(i+1/2\)</span> noktası ve <span
class="math inline">\(i\)</span> ile <span
class="math inline">\(i-1\)</span> noktası ortasındaki <span
class="math inline">\(i-1/2\)</span> arasında kalan fonksiyonun averajı
alınacak, ona <span class="math inline">\(&lt; u_i &gt;\)</span> ya da
<span class="math inline">\(\overline{u}_i\)</span> diyoruz.</p>
<p><span class="math display">\[
\overline{u}_i = \frac{1}{\Delta x} \int_{x_{i-1/2}}^{x_{i+1/2}} u(x)
\mathrm{d} x
\]</span></p>
<p>Dikkat; <span class="math inline">\(i-1,i-2\)</span> değerleri <span
class="math inline">\(i\)</span> referanslı olduğu için eksi içerikli,
<span class="math inline">\(i=4\)</span> olsaydı onlar <span
class="math inline">\(3,2,..\)</span> diye gidebilirdi. Ayrıca FD
yönteminin aksine, indis değerlerine tekabül eden <span
class="math inline">\(x_i,x_{i+1}\)</span> değerleri herhangi bir yerde
olabilir, böylece eşit aralıklı olmayan ızgaralarla çalışmamız mümkün
olur, bu FV yönteminin kuvvetlerinden biri.</p>
<p>Gerçi biz bu anlatımda ve kodda eşit aralık farz edeceğiz, <span
class="math inline">\(\Delta x\)</span>, <span
class="math inline">\(h_x\)</span> burada devreye girer.</p>
<p><img src="12-20-00.png" /></p>
<p>Muhafaza Kanunu Hesaplamak</p>
<p>Notasyonda <span class="math inline">\(f\)</span> akış (flux) için
kullanılır [14], <span class="math inline">\(\Delta x\)</span> için
<span class="math inline">\(h_x\)</span>,</p>
<p><span class="math display">\[
\overline{u}_i =  \frac{1}{h_x} \int_{x_{i-1/2}}^{x_{i+1/2}} u(x)
\mathrm{d} x
\qquad (1)
\]</span></p>
<p>[17] yazısında muhafaza kanununun entegral formunu görmüştük,</p>
<p><span class="math display">\[
\int_{x_1}^{x_2} \rho(x,t_2) \mathrm{d} x =
\int_{x_1}^{x_2} \rho(x,t_1) \mathrm{d} x  +
\int_{t_1}^{t_2} \rho(x_1,t) v(x_1,t) \mathrm{d} t -
\int_{t_1}^{t_2}  \rho(x_2,t) v(x_2,t) \mathrm{d} t
\]</span></p>
<p><span class="math inline">\(f(\rho) = \rho(x,t) v(x,t)\)</span>
denebilir, ya da herhangi daha genel olarak <span
class="math inline">\(\rho\)</span> yerine herhangi bir ölçüm <span
class="math inline">\(u\)</span> için <span class="math inline">\(f(u) =
u(x,t) v(x,t)\)</span>, o zaman, ve biraz yer değişim sonrası,</p>
<p><span class="math display">\[
\int_{x_1}^{x_2} u(x,t_2) \mathrm{d} x -
\int_{x_1}^{x_2} u(x,t_1) \mathrm{d} x  +
\int_{t_1}^{t_2} f(x_2,t) \mathrm{d} t  -
\int_{t_1}^{t_2} f(x_1,t) \mathrm{d} t = 0
\]</span></p>
<p>Bu formülü her sonlu hacim hücresi için kullanacağız. Zaman indisleri
<span class="math inline">\(t,t+1\)</span> olacak, üstte <span
class="math inline">\(t_1,t_2\)</span> yerine. Yer için <span
class="math inline">\(x_1,x_2\)</span> yerine bir <span
class="math inline">\(j\)</span> indisi merkezli <span
class="math inline">\(x_{j-1/2}\)</span> ve <span
class="math inline">\(x_{j+1/2}\)</span>. Devam edelim, <span
class="math inline">\(u(x_1,t_1)\)</span> içinde <span
class="math inline">\(x_{j-1/2}\)</span> ve <span
class="math inline">\(t_l\)</span> oluyor, (zaman <span
class="math inline">\(l\)</span> indisi) ona da <span
class="math inline">\(u_{j-1}^l\)</span> diyelim. <span
class="math inline">\(x_2\)</span> yerine <span
class="math inline">\(x_{j+1/2}\)</span>, sonuncuda zamanın hala
değişken olduğu durum <span class="math inline">\(u_{j+1}\)</span>
olsun. Eğer <span class="math inline">\(x\)</span> değişken ise, zaman
indisi <span class="math inline">\(t_2 = t_{l+1}\)</span> için <span
class="math inline">\(u^{l}\)</span>. Üstteki formülü bu notasyonla
değiştirip istenen zaman ve yer aralıklarına uygularsak,</p>
<p><span class="math display">\[
\int_{x_{j-1/2}}^{x_{j+1/2}} u^{l+1} \mathrm{d} x -
\int_{x_{j-1/2}}^{x_{j+1/2}} u^{l} \mathrm{d} x  +
\int_{t_l}^{t_{l+1}} f(u_{j+1/2}) \mathrm{d} t  -
\int_{t_l}^{t_{l+1}} f(u_{j-1/2}) \mathrm{d} t = 0
\]</span></p>
<p>Her şeyi <span class="math inline">\(h_x\)</span> ile bölelim,</p>
<p><span class="math display">\[
\frac{1}{h_x} \int_{x_{j-1/2}}^{x_{j+1/2}} u^{l+1} \mathrm{d} x -
\frac{1}{h_x} \int_{x_{j-1/2}}^{x_{j+1/2}} u^{l} \mathrm{d} x  +
\frac{1}{h_x} \int_{t_l}^{t_{l+1}} f(u_{j+1/2}) \mathrm{d} t  -
\frac{1}{h_x} \int_{t_l}^{t_{l+1}} f(u_{j-1/2}) \mathrm{d} t = 0
\]</span></p>
<p>Bu formülde (1)’de tanımlanan ortalama formunu görüyoruz, kısaltma
amaçlı <span class="math inline">\(\overline{u}_{j,l}\)</span> notasyonu
oralarda kullanabiliriz,</p>
<p><span class="math display">\[
\overline{u}_{j,l+1} - \overline{u}_{j,l} +
\frac{1}{h_x} \int_{t_l}^{t_{l+1}} f(u_{j+1/2}) \mathrm{d} t  -
\frac{1}{h_x} \int_{t_l}^{t_{l+1}} f(u_{j-1/2}) \mathrm{d} t = 0
\]</span></p>
<p>Şimdi son iki terime dikkat edelim, bu iki entegral zaman üzerinden
alınıyor, fakat Riemann problemini hatırlarsak çözüm <span
class="math inline">\(u(x,t)\)</span> sadece <span
class="math inline">\(x/t\)</span> değişkeni üzerinden düşünülebilir, ve
eğer <span class="math inline">\(x\)</span> değişmiyorsa (ki öyle çünkü
üstteki iki entegral <span class="math inline">\(t\)</span> üzerinden,
<span class="math inline">\(x\)</span> aynı) o zaman <span
class="math inline">\(\mathrm{d} t\)</span> üzerinden entegral yerine,
sabit <span class="math inline">\(u\)</span> ile bir ayrıksal <span
class="math inline">\(h_t\)</span> çarpımı yeterlidir. Öyle ya sabit
<span class="math inline">\(u\)</span> üzerinden ve yine sabit / bilinen
<span class="math inline">\(t\)</span> adımı <span
class="math inline">\(h_t\)</span> üzerinden alan bir dikdörtgendir, bu
alanın hesabı için çetrefil entegral yerine direk çarpım yeterli..
Mesela ilk entegral,</p>
<p><span class="math display">\[
\frac{1}{h_x} \int_{t_l}^{t_{l+1}} f(u_{j+1/2}) \mathrm{d} t =
\frac{h_t}{h_x} f(u_{j+1/2})
\]</span></p>
<p>olarak hesaplanabilir, çünkü <span class="math inline">\(u\)</span>
değeri <span class="math inline">\(x = x_{j \pm 1/2}\)</span> üzerinde
değişmiyor. Aynı durum ikinci entegral için de geçerli, o zaman iki
üstteki formül</p>
<p><span class="math display">\[
\overline{u}_{j,l+1} = \overline{u}_{j,l} -
\frac{h_t}{h_x} ( f(u_{j+1/2}) - f(u_{j-1/2}) )
\qquad (2)
\]</span></p>
<p>olacak. Böylece <span class="math inline">\(l\)</span> anındaki <span
class="math inline">\(j\)</span> hücresinin ortalamasını bir sonraki
zaman adımı <span class="math inline">\(l+1\)</span>’e nasıl
aktaracağımızı, oraya geçiş yapacağımızın formülünü bulmuş olduk.</p>
<p>Eğer <span class="math inline">\(\frac{1}{h_x} \int_{t_l}^{t_{l+1}}
f(u_{j+1/2}) \mathrm{d} t\)</span> entegralini entegral içindekiler
çarpı <span class="math inline">\(h_t\)</span> ile gösterebiliyorsak,
tüm entegrali <span class="math inline">\(h_t\)</span> ile bölmek bize
yaklaşık, “sayısal’’ bir <span
class="math inline">\(f(u_{j+1/2})\)</span> verecektir, ona büyük harf
ile <span class="math inline">\(F_{j+1/2}^l\)</span> diyelim, formülü
[16, sf. 103]</p>
<p><span class="math display">\[
F_{j+1/2}^l = \frac{1}{h_t} \int_{t_l}^{t_{l+1}} f(u_{j+1/2,l})
\mathrm{d} t
\]</span></p>
<p><span class="math inline">\(F\)</span>’ye sayısal akış (numerical
flux) ismi de veriliyor. O zaman (2) formülü “akış diferansiyel
formunda’’ da yazılabilir,</p>
<p><span class="math display">\[
\overline{u}_{j,l+1} = \overline{u}_{j,l} -
\frac{h_t}{h_x} ( F_{j+1/2,l} - F_{j-1/2,l} )
\]</span></p>
<p>Sayısal akışı elde etmek için bize bir sayısal <span
class="math inline">\(u\)</span> lazım, bunu FV ile bulacağız, sonra bu
<span class="math inline">\(u\)</span>’ları bildiğimiz <span
class="math inline">\(f()\)</span> akışına verince sayısal <span
class="math inline">\(F\)</span> elde edilecek.</p>
<p>Bu kod alttaki gibidir,</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.integrate <span class="im">as</span> integrate</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>alpha <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>beta  <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> init(z, alpha, beta):</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> alpha <span class="op">+</span> beta<span class="op">*</span>np.sin(z)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co"># </span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="co">#  u_t + f(u)_x = 0 denklemi icin akis (flux) fonksiyonu </span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> flux(u):</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fl">0.5</span><span class="op">*</span>u<span class="op">**</span><span class="dv">2</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> godunov_flux(uval):</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    fhat <span class="op">=</span> np.zeros((<span class="bu">len</span>(uval),<span class="dv">1</span>))</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="bu">len</span>(uval)<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        ul <span class="op">=</span> uval[i]<span class="op">;</span> ur <span class="op">=</span> uval[i<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        s<span class="op">=</span>(ul<span class="op">+</span>ur)<span class="op">/</span><span class="dv">2</span><span class="op">;</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> ul <span class="op">&gt;</span> ur:</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>                fhat[i] <span class="op">=</span> flux(ur)</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>                fhat[i] <span class="op">=</span> flux(ul)</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> ul <span class="op">&lt;</span> ur:</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> ur <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>                fhat[i] <span class="op">=</span> flux(ur)</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> ul <span class="op">&gt;</span> <span class="fl">0.</span>:</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>                fhat[i] <span class="op">=</span> flux(ul)</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>                fhat[i] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fhat</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>np.pi</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>N  <span class="op">=</span> <span class="dv">80</span></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">2.0</span></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(a,b,N)     </span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>dx <span class="op">=</span> (b<span class="op">-</span>a)<span class="op">/</span>(N<span class="op">-</span><span class="dv">1</span>)<span class="op">;</span>  </span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> np.zeros((<span class="bu">len</span>(x)<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>))<span class="op">;</span> </span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,N<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>    u[i] <span class="op">=</span> (<span class="fl">1.0</span><span class="op">/</span>dx)<span class="op">*</span>integrate.quad(init, x[i], x[i<span class="op">+</span><span class="dv">1</span>], args<span class="op">=</span>(alpha,beta))[<span class="dv">0</span>]</span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> dx<span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>np.amax(np.amax(u)))</span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> t <span class="op">&lt;</span> T:</span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a>    fR <span class="op">=</span> godunov_flux(u) </span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a>    fL <span class="op">=</span> np.roll(fR,<span class="dv">1</span>)</span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a>    u <span class="op">-=</span> dt<span class="op">/</span>dx<span class="op">*</span>(fR <span class="op">-</span> fL)</span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> t<span class="op">+</span>dt</span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a>    i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">%</span> <span class="dv">5</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true" tabindex="-1"></a>        plt.figure()</span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true" tabindex="-1"></a>        plt.plot(u)</span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true" tabindex="-1"></a>        plt.ylim(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>)</span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true" tabindex="-1"></a>        plt.savefig(<span class="st">&#39;/tmp/out-</span><span class="sc">%03d</span><span class="st">.png&#39;</span> <span class="op">%</span> i)</span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true" tabindex="-1"></a>        plt.close(<span class="st">&#39;all&#39;</span>)</span></code></pre></div>
<p>Kodda ilk önce başlangıç fonksiyonu tanımlandı, içinde sinüs olan
<code>init</code> bu; Bu fonksiyonun hücre bazında
<code>integrate.quad</code> ile entegrali alındı, böylece her hücreyi
temsil eden o tek değeri elde ettik.</p>
<p><img src="12-19-02.png" /></p>
<p>FV yöntemi bundan sonra o hücreler üzerinden hesabını yapacak,
dinamik denklemi zamanda ilerletirken bunun hücrelerdeki o temsili değer
üzerinden yapacak.</p>
<p>Hücrelerin FV matematiği şöyle; mesela yanyana iki hücreye bakarsak,
üstteki resimde <span class="math inline">\(x_{i-2}\)</span> ve <span
class="math inline">\(x_{i-1}\)</span> diyelim, soldan ilk iki hücre, bu
iki değer sanki bir Riemann problemini andırmıyor mu? Evet; ve
Godunov’un icat ettiği FV çözümü için kullanılan teknik te zaten budur.
İki hücre ortasındaki <span class="math inline">\(x_{i-1/2}\)</span>
noktası hücre sınırı kabul edilir ve önceki sonraki değerler <span
class="math inline">\(u_L\)</span> ve <span
class="math inline">\(u_R\)</span> imiş gibi Riemann çözümü işletilir.
Bu işlem tüm yanyana hücreler için işletilince bir zaman dilimi çözümü
elde edilir, sonraki zaman dilimi için bu işlem tekrar baştan
hesaplanır.</p>
<p>Şimdi <span class="math inline">\(x_{i}\)</span> ile <span
class="math inline">\(x_{i+1}\)</span> arasındaki <span
class="math inline">\(x_{1+1/2}\)</span> sınırını baz alıp, önce
gördüğümüz Riemann çözümünü baz alarak şunu yazalım [16, sf. 109],</p>
<p><span class="math inline">\(u_i^l \ge u_{i+1}^l\)</span> için,</p>
<p><span class="math display">\[
u^\star_{i+1/2} =
\left\{ \begin{array}{lll}
u_i^l &amp; \textrm{eğer} &amp; s &gt; (x-x_{i+1/2}) / t  \\
u_{i+1}^l &amp; \textrm{eğer} &amp; s &lt; (x-x_{i+1/2}) / t
\end{array} \right.
\]</span></p>
<p>Daha önce gördük <span class="math inline">\(s\)</span> dalga hızı,
bu örnekte <span class="math inline">\(s = (u_i^n +
u_{i+1}^n)/2\)</span>.</p>
<p><span class="math inline">\(u_i^l &lt; u_{i+1}^l\)</span> için,</p>
<p><span class="math display">\[
u^\star_{i+1/2} =
\left\{ \begin{array}{lll}
u_i^l &amp; \textrm{eğer} &amp; (x-x_{i+1/2})/t \le u_i^l   \\
(x-x_{i+1/2})/t &amp; \textrm{eğer} &amp; u_i^l &lt; (x-x_{i+1/2})/t
&lt; u_{i+1}^l   \\
u_{i+1}^l &amp; \textrm{eğer} &amp; (x-x_{i+1/2})/t \ge u_{i+1}^l   \\
\end{array} \right.
\]</span></p>
<p>Bir kez Riemann çözümü elde edilince Godunov sayısal akışı <span
class="math inline">\(u^\star_{i+1/2}\)</span> ile kolayca
hesaplanabilir, akış fonksiyonu <span class="math inline">\(f()\)</span>
üzerinden <span class="math inline">\(F =
f(u^\star_{i+1/2})\)</span>.</p>
<p>Üstteki formülleri daha da kolaylaştırmak mümkün, Godunov akışlarını
<span class="math inline">\(x = x_{i+1/2}\)</span> noktasında
hesapladığımız için bunu formülde <span class="math inline">\(x\)</span>
yerine koyunca,</p>
<p><span class="math inline">\(u_i^l \ge u_{i+1}^l\)</span> için,</p>
<p><span class="math display">\[
u^\star_{i+1/2} =
\left\{ \begin{array}{lll}
u_i^l &amp; \textrm{eğer} &amp; s &gt; 0  \\
u_{i+1}^l &amp; \textrm{eğer} &amp; s &lt; 0
\end{array} \right.
\]</span></p>
<p><span class="math inline">\(u_i^l &lt; u_{i+1}^l\)</span> için,</p>
<p><span class="math display">\[
u^\star_{i+1/2} =
\left\{ \begin{array}{lll}
u_i^l &amp; \textrm{eğer} &amp; 0 \le u_i^l   \\
(x-x_{i+1/2})/t &amp; \textrm{eğer} &amp; u_i^l &lt; 0 &lt;
u_{i+1}^l   \\
u_{i+1}^l &amp; \textrm{eğer} &amp; 0 \ge u_{i+1}^l   \\
\end{array} \right.
\]</span></p>
<p>Kod içinde üstte görülen hesabı tüm hücreler için yaptık, <span
class="math inline">\(i\)</span>,<span
class="math inline">\(i+1\)</span>,<span
class="math inline">\(i+2\)</span>.. ve <span
class="math inline">\(F_{j+1/2,l}\)</span> hesabından bir önceki <span
class="math inline">\(F_{j-1/2,l}\)</span>, kod içinde önceki
<code>fL</code> sonraki <code>fR</code>, onun için <code>np.roll</code>
ile vektör içindeki değerleri bir ilerleterek önceki ve sonraki
hücrelerin aynı hizaya düşmesini sağlıyoruz böylece <span
class="math inline">\(F_{j+1/2,l}-F_{j-1/2,l}\)</span> hesabı kolay bir
şekilde <code>fR-fL</code> ile bulunabiliyor.</p>
<p>Belli <span class="math inline">\(t\)</span> anlarından alınmış
görüntüler altta bulunabilir.</p>
<p><img src="out-005.png" /> <img src="out-010.png" /> <img
src="out-020.png" /> <img src="out-030.png" /></p>
<p>Animasyon [13],</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> convert <span class="op">-</span>delay <span class="dv">20</span> <span class="op">-</span>loop <span class="dv">0</span> <span class="op">/</span>tmp<span class="op">/</span>out<span class="op">-*</span>.png wave.gif</span></code></pre></div>
<p>Kaynaklar</p>
<p>[1] Bayramlı, <em>Hesapsal Bilim, Hesapsal Sıvı Dinamiğine
Giriş</em></p>
<p>[2] Bayramlı, <em>Fizik, Gazlar, Sıvılar 1</em></p>
<p>[3] Leveque, <em>Numerical Methods for Conservation Laws</em></p>
<p>[4] Mishra, <em>Numerical methods for conservation laws and related
equations</em></p>
<p>[5] Cooper, <em>Introduction to PDEs with Matlab</em></p>
<p>[6] Hesthaven, <em>Numerical Methods for Conservation Laws</em></p>
<p>[7] Bayramlı, <em>Animasyon, Şok Dalgası</em>, <a
href="https://github.com/burakbayramli/classnotes/raw/master/compscieng/compscieng_bpp50fv/shock.gif">https://github.com/burakbayramli/classnotes/raw/master/compscieng/compscieng_bpp50fv/shock.gif</a></p>
<p>[8] Bayramlı, <em>Animasyon, Seyrelen (Rarefaction) Dalga</em> <a
href="https://github.com/burakbayramli/classnotes/raw/master/compscieng/compscieng_bpp50fv/rarefaction.gif">https://github.com/burakbayramli/classnotes/raw/master/compscieng/compscieng_bpp50fv/rarefaction.gif</a></p>
<p>[9] Lee, <em>AM 260, Computational Fluid Dynamics</em>, <a
href="https://users.soe.ucsc.edu/~dongwook/wp-content/uploads/2021/am260/html/">https://users.soe.ucsc.edu/~dongwook/wp-content/uploads/2021/am260/html/</a></p>
<p>[10] Bayramlı, <em>Cok Degiskenli Calculus, Ders 11</em></p>
<p>[11] Muller, {Learn CFD, Lecture 15 - Part b}, <a
href="https://youtu.be/f8fuMRFZYwQ">https://youtu.be/f8fuMRFZYwQ</a></p>
<p>[12] Bayramlı, <em>Fizik, Gazlar, Sıvılar 2</em></p>
<p>[13] Bayramlı, <em>Animasyon, Godunov Sonlu Hacim Yontemi ile Burgers
Denklem Cozumu</em> <a
href="https://github.com/burakbayramli/classnotes/raw/master/compscieng/compscieng_bpp50fv/wave.gif">https://github.com/burakbayramli/classnotes/raw/master/compscieng/compscieng_bpp50fv/wave.gif</a></p>
<p>[14] Kloeckner, <em>Numerical Methods for Partial Differential
Equations CS555 / MATH555 / CSE510</em> <a
href="https://relate.cs.illinois.edu/course/cs555-s20/">https://relate.cs.illinois.edu/course/cs555-s20/</a></p>
<p>[16] Lee, <em>Computational Fluid Dynamics</em></p>
<p>[17] Bayramlı, <em>Fizik, Gazlar, Sivilar - 2</em></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
