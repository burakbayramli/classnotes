<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  
  
  
  
</head>
<body>
<h1 id="sonlu-hacim-finite-volume-yöntemi">Sonlu Hacim (Finite Volume) Yöntemi</h1>
<p>Üç boyutlu kütle muhafazası üzerinden süreklilik formül [2]'de işlendi. Şimdi tek boyutlu ortamda muhafaza kanunlarını işleyeceğiz, gaz dinamiği, genel aerodinamik konularında bu yaklaşım faydalı olacak. Sayısal çözmeye çalışılacak problemler, ki sonlu hacim (finite volume -FV-) yöntemi burada lazım, muhafaza kanunları içeren hiperbolik sistemleridir (hyperbolic systems of conservation laws). Bu tür sistemler zamana bağlı çoğunlukla gayrı lineer kısmi türevsel denklemlerdir (nonlinear PDE), ve aslında basit yapıları vardır. Tek yersel boyutta şuna benzerler [3, sf. 1],</p>
<p><span class="math display">\[
\frac{\partial }{\partial t} u(x,t) + 
\frac{\partial }{\partial x} f(u(x,t)) = 0
\qquad (1)
\]</span></p>
<p>Daha önce [1]'de Burgers'in denklemini görmüştük, bir PDE,</p>
<p><span class="math display">\[
u_t + uu_x = 0
\qquad (2a)
\]</span></p>
<p>Bu denklem (1) ışığında düşünülebilir, eğer <span class="math inline">\(f(u) = u^2/2\)</span> tanımlarsak, (1) formülü, yani <span class="math inline">\(u_t + f(u)_x = 0\)</span>, formül (2a) ile aynıdır. O zaman,</p>
<p><span class="math display">\[
u_t + f(u)_x = 0, \qquad f(u) = \frac{1}{2}u^2
\qquad (2b)
\]</span></p>
<p>İleride lazım olur, (1)'i açarsak [6, sf. 29],</p>
<p><span class="math display">\[
\frac{\partial u}{\partial t} + 
f&#39;(u) \frac{\partial u}{\partial x} = 0
\qquad (5)
\]</span></p>
<p>denklemi de doğrudur, ki <span class="math inline">\(f&#39;(u) = \frac{\mathrm{d} f}{\mathrm{d} u}\)</span>.</p>
<ol start="2" style="list-style-type: decimal">
<li>türünden denklemleri tek boyutta çözmeyi işleyeceğiz öncelikle, çünkü çok boyutta çözüm tek boyuta indirgenerek yapılabiliyor.</li>
</ol>
<p>Hiperbolik denklemleri analitik, kesin (exact) çözmek için birkaç konuyu yakından anlamak lazım. Birincisi Riemann problemleri; bu yaklaşımla hiperbolik PDE'nin başlangıç koşulu kesintili (discontinuous) bir fonksiyonla belirtiliyor ve bu çözümleri çoğu durumda daha rahatlaştırılıyor, diğeri hiperbolik muhafaza kanunlarının entegral formu.</p>
<p>İleride hiperbolik denklemleri FV ile sayısal çözerken de Riemann yaklaşımı faydalı olacak. Kesintili başlangıç içeren denklemler çözebilmek önemli çünkü FV ile sayısal çözüm yaparken uzayı parçalara bölüyoruz, ve her iki parçayı bir kesintili başlangıç içeren Riemann problemi olarak temsil ediyoruz, bu pek çok parça ortaya çıkartır tabii, bu sebeple tipik bir FV yaklaşımı her adımda pek çok Riemann problemini çözecektir.</p>
<p>Entegral form lazım, çünkü sınırlı farklılıklarda (finite difference) olduğu gibi ayrıksal olan fonksiyonun eşit aralıklarda tanımlı bir ızgaranın seçilmiş belli noktaları değil, her bölge, parçanın ortalaması, yani entegrali.</p>
<p>Entegral form ile başlayalım. Aslında diferansiyel form entegral formden türetilmiştir -bu türetim pürüzsüzlük faraziyesi üzerinden yapılmıştır-. Özellikle kesintili başlangıç şartları olduğu durumlarda diferansiyel formun her yerde düzgün işlemesi mümkün değil, çünkü kesintilerde türev alınamıyor. Ayrıca pür kesintisiz olsa bile şok oluşumu denen sebeplerle türevsel fonksiyonlar çözülemiyor. Bu problemlerle başedebilmek için entegral formu kullanmak gerekecek.</p>
<p>Bu formu [12]'de bulabiliriz.</p>
<p>Riemann Problemi</p>
<p>Kesintili ve iki parça içeren bir fonksiyon ile Burgers denkleminin çözümü mümkün; bu aslında basit, <span class="math inline">\(u_t + u u_x = 0\)</span> denklemi için başlangıç şartları</p>
<p><span class="math display">\[
u(x,0) = 
\left\{ \begin{array}{ll}
u_l &amp; x &lt; 0 \\
u_r &amp; x &gt; 0 
\end{array} \right.
\qquad (9)
\]</span></p>
<p>olduğu durumda çözüm özgün bir zayıf çözümdür, eğer <span class="math inline">\(u_l &gt; u_r\)</span> ise (bu mümkün seçeneklerden birincisi)</p>
<p><span class="math display">\[
u(x,t) = 
\left\{ \begin{array}{ll}
u_l &amp; x &lt; st \\
u_r &amp; x &gt; st 
\end{array} \right.
\]</span></p>
<p>ki <span class="math inline">\(s\)</span> şok hızıdır. Ya da</p>
<p><span class="math display">\[
u(x,t) = 
\left\{ \begin{array}{ll}
u_l &amp; x/t &lt; s \\
u_r &amp; x/t &gt; s 
\end{array} \right.
\]</span></p>
<p>Kesinti noktası <span class="math inline">\(s\)</span> hızında sağa ilerler, <span class="math inline">\(t\)</span> anında olacağı yer <span class="math inline">\(st\)</span>'dir.</p>
<div class="figure">
<img src="compscieng_bpp50fv1_01.png" />

</div>
<p>Karakteristik Eğriler</p>
<p>Üstteki çözümü anlamak, hatta ona ulaşmak için karakteristik eğriler faydalı oluyor. Karakteristik eğrilerle <span class="math inline">\(x,t\)</span> ilişkisine odaklanıyoruz, <span class="math inline">\(u\)</span>'nun zamana göre değişmediği duruma bakıyoruz (yani <span class="math inline">\(\mathrm{d} u / \mathrm{d} t = 0\)</span>) ve bu başlangıçtan bir <span class="math inline">\(\mathrm{d} x / \mathrm{d} t\)</span> türevine erişmeye uğraşıyoruz, ve seçilen bazı başlangıç noktaları ve sabit bir eğim için ortaya çıkan grafiği inceliyoruz. Türev basit bir dalga denkleminde,</p>
<p><span class="math display">\[
x&#39;(t) = a, \quad x(0) = x_0
\]</span></p>
<p>olur daha çetrefil dalgalarda farklı. <span class="math inline">\(\mathrm{d} x / \mathrm{d} t\)</span> elde etmek için <span class="math inline">\(t\)</span> ve <span class="math inline">\(x\)</span> değişkenleri olduğunu ve <span class="math inline">\(x = x(t)\)</span> olduğunu hatırlayalım, yani <span class="math inline">\(u = u(x,t) = u(x(t),t)\)</span> olur. İki değişkenli fonksionlar üzerinde genel zincirleme kanununu [10]'da gördük, mesela <span class="math inline">\(g(x(t),y(t))\)</span> için <span class="math inline">\(\mathrm{d} g / \mathrm{d} t\)</span></p>
<p><span class="math display">\[
\frac{\mathrm{d} g}{\mathrm{d} t} =
\frac{\partial g}{\partial x} \cdot \frac{\mathrm{d} x}{\mathrm{d} t} +
\frac{\partial g}{\partial y} \cdot \frac{\mathrm{d} y}{\mathrm{d} t} 
\]</span></p>
<p>İki değişkenli <span class="math inline">\(u\)</span>'nun zamana göre türevi o zaman [9, sf. 17],</p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d} t} u (x(t),t)) =
\frac{\partial u}{\partial x} \frac{\mathrm{d} x}{\mathrm{d} t} +
\frac{\partial u}{\partial t} \cancelto{1}{\frac{\mathrm{d} t}{\mathrm{d} t}}
\]</span></p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d} t} u (x(t),t)) =
\frac{\partial u}{\partial x} \frac{\mathrm{d} x}{\mathrm{d} t} +
\frac{\partial u}{\partial t}
\]</span></p>
<p>Üsttekini sıfıra eşitlersek,</p>
<p><span class="math display">\[
u_t  + u_x x&#39;(t) = 0
\]</span></p>
<p>(2a)'yı hatırlayalım ve üstteki formülle eşleştirelim, Burgers denklemi için <span class="math inline">\(x&#39;(t) = u\)</span> elde ederdik. Karakteristik diferansiyel denklemi,</p>
<p><span class="math display">\[
x&#39;(t) = u(x(t),t), \qquad x(0) = x_0
\]</span></p>
<p>Not: İki üsttekini (5) ile eşleyerek</p>
<p><span class="math display">\[
f&#39;(u) = \frac{\mathrm{d} x(t)}{\mathrm{d} t}
\]</span></p>
<p>karakteristik diferansiyeli de doğru.</p>
<p>Bu denklemi grafiklemek için <span class="math inline">\(t,x\)</span> yerine <span class="math inline">\(x,t\)</span> bazlı düşünmek daha iyi (bir önceki grafikle alakayı görmek için, her iki grafikte <span class="math inline">\(x\)</span> değişkeni yatay kordinatta oluyor) altta bir başlangıç <span class="math inline">\(x_0\)</span> seçiyoruz, ve buradan yukarı doğru <span class="math inline">\(u(x_0)\)</span> eğiminde (çünkü <span class="math inline">\(&#39;x = u\)</span> demiştik) bir çizgi gidiyor. Ama dikkat hayal etmek için eğimi tersine çevirmek lazım, giriş Calculus'ta eğimler <span class="math inline">\(y/t\)</span>, <span class="math inline">\(z/t\)</span> bazında düşünülür burada <span class="math inline">\(t/x\)</span>.</p>
<p>Devam edelim, ayrıca Riemann problemi çözdüğümüzü unutmayalım, <span class="math inline">\(u\)</span> değerleri değişik <span class="math inline">\(x\)</span> noktalarında bir değerden diğerine geçiyor, bir <span class="math inline">\(u_L\)</span> var, bir de <span class="math inline">\(u_R\)</span> var, eğimler bu değerleri yansıtmalı. Grafikleme sonrası,</p>
<div class="figure">
<img src="compscieng_bpp50fv1_03.png" />

</div>
<p>O zihindeki ters çevirme işleminden önceki hali göstermek gerekirse, alttaki gibi</p>
<div class="figure">
<img src="compscieng_bpp50fv1_04.png" />

</div>
<p>Görüldüğü gibi sıfırdan küçük <span class="math inline">\(x\)</span>'ler için <span class="math inline">\(u_L\)</span> devrede orada bizim klasik bildiğimiz eğim daha fazla, sıfırdan yukarı çıkınca eğim azalıyor, çünkü orada <span class="math inline">\(u_R\)</span> daha küçük.</p>
<p>Şimdi iki üstteki ana grafiğe tekrar bakarsak, orada bir problem gözüküyor [11, 10:13]. Soldan gelen ve sağdan gelen karakteristikler kesişiyor. O zaman o noktada iki çözüm olurdu. Bu nasıl mümkün olabilir ki? Doğanın o noktada yaptığı şudur; oraya bir şok yerleştirmek, o bölgeyi bir şok bölgesi haline getirmek. O bölgede, çizgi üzerinde eğim <span class="math inline">\(s\)</span> olacak ve bu <span class="math inline">\(s\)</span> aslında <span class="math inline">\(u_L\)</span> ve <span class="math inline">\(u_R\)</span>'nin ortalaması.</p>
<p><span class="math inline">\(st\)</span> değeri nereden geliyor? <span class="math inline">\(x,u\)</span>, <span class="math inline">\(x,t\)</span> grafiklerini <span class="math inline">\(x\)</span>'ler çakışacak şekilde alt alta gösterelim, ve <span class="math inline">\(x,t\)</span> grafiğinde bir <span class="math inline">\(t\)</span> noktası işaretleyelim (yatay çizgi), O çizginin şok bölgesini kestiği yerden aşağı doğru <span class="math inline">\(x,u\)</span> grafiğine inelim, alttaki grafikte o noktadaki <span class="math inline">\(u\)</span> değeri <span class="math inline">\(t\)</span> anındaki çözüm <span class="math inline">\(u(x,t)\)</span>.</p>
<div class="figure">
<img src="compscieng_bpp50fv1_05.png" />

</div>
<p>O noktada katedilmiş mesafe <span class="math inline">\(st\)</span> çünkü o noktada <span class="math inline">\(x&#39;(t) = s\)</span>. Bu işlemi daha önceki <span class="math inline">\(t\)</span> zamanları için yaparsak, kesikli sarı çizgi ortaya çıkacaktır. Bu da dalganın sağa doğru akışını gösteriyor bir bakıma.</p>
<p>Şok hızını cebirsel bulalım. Daha önce tek boyutlu lineer taşınım akımı (convection) ile gördüğümüz durum burada da var, orada çözüm <span class="math inline">\(u(x,y) = u_0(x-ct)\)</span> idi, dalga hızı <span class="math inline">\(c\)</span>. Şimdi hız <span class="math inline">\(u\)</span> bu <span class="math inline">\(s\)</span> şok hızınını verir, Burgers için hesabı <span class="math inline">\(s = (u_l + u_r) / 2\)</span>. Şok hızının hesabı için kesinti bölgesinin yeterince uzağında <span class="math inline">\(M\)</span> ve <span class="math inline">\(-M\)</span> noktalarını seçelim, bu iki nokta arasındaki toplam kütlenin / dalganın değişiminin hızı şok hızı <span class="math inline">\(s\)</span> olacaktır.</p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d} t} \int_{-M}^{M} u(x,t) \mathrm{d} x = f(u_l) - f(u_r)
\qquad (8)
\]</span></p>
<p>Salt entegralin nasıl hesaplanacağına bakarsak [3, sf. 31],</p>
<p><span class="math display">\[
\int_{-M}^{M} u(x,t) \mathrm{d} x =
\int_{-M}^{st} u_l \mathrm{d} x + 
\int_{st}^{M} u_r \mathrm{d} x
\]</span></p>
<p><span class="math display">\[
= (M+st)u_l + (M-st)u_r
\]</span></p>
<p>Şimdi zaman türevini geri koyalım, bu sağ tarafta <span class="math inline">\(s(u_l-u_r)\)</span> verir, hepsi bir arada,</p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d} t} \int_{-M}^{M} u(x,t) \mathrm{d} x = s(u_l-u_r)
\]</span></p>
<p>(8)'in sağ tarafını üstteki formüle koyunca,</p>
<p><span class="math display">\[
f(u_l) - f(u_r) = s(u_l-u_r)
\]</span></p>
<p><span class="math display">\[
s = \frac{f(u_l) - f(u_r)}{u_l-u_r}
\]</span></p>
<p>Böylece genel bir ifade elde ettik. Burgers denklemi özelinde, <span class="math inline">\(f(u) = u^2 / 2\)</span> olduğuna göre,</p>
<p><span class="math display">\[
f(u_l) - f(u_r) = \frac{1}{2} u_l^2 -  \frac{1}{2} u_r^2
\]</span></p>
<p>O zaman</p>
<p><span class="math display">\[
\frac{1}{2} (u_l + u_r)(u_l - u_r) = s(u_l-u_r)
\]</span></p>
<p>diyebiliriz [5, sf. 46], basitleştirince,</p>
<p><span class="math display">\[
s = \frac{1}{2} (u_l + u_r)
\]</span></p>
<p>Seyreltilmiş Dalga</p>
<p>İkinci seçenek, seyreltilmiş dalga sonucu, bu zayıf çözüm başlangıçta <span class="math inline">\(u_l &lt; u_r\)</span> olduğu zaman ortaya çıkıyor.</p>
<div class="figure">
<img src="compscieng_bpp50fv1_02.png" />

</div>
<p>Daha önceki formu tekrarlarsak, karakteristik ve <span class="math inline">\(x,u\)</span> grafiği alt alta,</p>
<div class="figure">
<img src="compscieng_bpp50fv1_06.png" />

</div>
<p>Bu grafikte karakteristik çizgilerini bulmak kolay değil, <span class="math inline">\(u_L\)</span>, <span class="math inline">\(u_R\)</span> kısımları yapılabilir ama ortadaki kısmı anlamak için bu sefer <span class="math inline">\(x,u\)</span> grafiğinden dönerek <span class="math inline">\(x,t\)</span>'ye gitmek gerekiyor. Altta <span class="math inline">\(u_R \cdot t\)</span> ve <span class="math inline">\(u_L \cdot t\)</span> noktaları bulunduktan sonra doğal olan onların düz çizgi ile birleştirilmesidir, bu çizgi de karakteristiklerdeki o yayılma (fan) şeklini ortaya çıkartır, tam ortasnda da tabii ki şok cizgisi olacaktır.</p>
<p>Bir çözüm, ki zayıf çözümlerde (bu konu ileride işlenecek), alttaki gibi olabilir,</p>
<p><span class="math display">\[
u(x,t) =
\left\{ \begin{array}{ll}
u_l &amp; x &lt; u_l t  \\
x/t &amp; u_l t \le x \le u_r t \\
u_r &amp; x &gt; u_r t
\end{array} \right.
\]</span></p>
<p>Sağ taraf yine daha önce olduğu gibi şu hale çevirilebilir (ki birazdan görülecek kodu anlamak için de bu form faydalı)</p>
<p><span class="math display">\[
u(x,t) =
\left\{ \begin{array}{ll}
u_l &amp; x/t &lt; u_l \\
x/t &amp; u_l \le x/t \le u_r  \\
u_r &amp; x/t &gt; u_r 
\end{array} \right. 
\]</span></p>
<p>Çözümün Burgers denklemi için doğru olduğunun sağlamasını yapabiliriz, [9, sf. 34], mesela orta şart <span class="math inline">\(u_l \le x/t \le u_r\)</span> kısmına bakalım, bu çözümü (2a)'ya sokarsak,</p>
<p><span class="math display">\[
\frac{\partial u}{\partial t} + u \frac{\partial u}{\partial x} =
\frac{\partial }{\partial t} \left( \frac{x}{t}  \right) +
\frac{x}{t} \frac{\partial }{\partial x} \left( \frac{x}{t}  \right) =
-\frac{x}{t^2} + \frac{x}{t} \frac{1}{t} = 0
\]</span></p>
<p>İlk ve üçüncü şartın çözüm olduğu bariz çünkü sabit sayılar, ve türevleri alınırken sıfırlanacaklar.</p>
<p>Entropi</p>
<p>Aslında üstteki seyreltilmiş dalga çözümü tek mümkün çözüm değil. Bu çözüm bir zayıf çözüm (ileride göreceğiz) bu sebeple özgün değiller. Mesela <span class="math inline">\(u_L = 0\)</span>, <span class="math inline">\(u_R = 1\)</span> örnekleri üzerinden alttakiler de birer çözüm olabilirdi [4, sf. 27],</p>
<div class="figure">
<img src="compscieng_bpp50fv1_07.png" />

</div>
<p>Çözümler soldan sağa doğru,</p>
<p><span class="math display">\[
u(x,t) =
\left\{ \begin{array}{ll}
0 &amp; x &lt; \frac{1}{2} t  \\
1 &amp; x &gt; \frac{1}{2} t  \\
\end{array} \right.
\]</span></p>
<p>Hız <span class="math inline">\(s\)</span> tabii ki daha önceki formülden hesaplandı,</p>
<p><span class="math display">\[
s = \frac{u_R^2 / 2 - u_L^2 / 2 }{u_R - u_L} = 1/2
\]</span></p>
<p>Ve</p>
<p><span class="math display">\[
u(x,t) =
\left\{ \begin{array}{ll}
0 &amp; x &lt; \frac{1}{3} t  \\
\frac{2}{3} &amp; \frac{1}{3} t &lt; x &lt; \frac{5}{6} t  \\
1 &amp; x &gt; \frac{5}{6} t  
\end{array} \right.
\]</span></p>
<p>Fakat bu çözümler fiziksel değildir. Niye? Çünkü grafiklere dikkat edersek her iki durumda da bazı karakteristik çizgiler <em>şoktan</em> dışarı çıkıyorlar, kıyasla en başta ilk karakteristik grafiğinde karakteristikler şoka doğru gidiyorlar. Karakteristikler bir anlamda bilgi akışının temsil ediyorlar, deterministik bir denklemi baz alan bir evrimsel, dinamik denklem her zaman başlangıç verisinden başlayarak ileri gitmelidir. Fakat hemen üstteki iki çözümde şok noktasında yeni bilgi yaratılıyor. Bir diğer açıdan [6, sf. 35] belirtmek gerekirse, istediğimiz, bir karakteristiği zamanı geriye sararak başlangıç şartına bağlayabilmektir. Üstteki iki çözümde bunu yapmak mümkün değil.</p>
<p>Animasyon</p>
<p>Altta Burgers denkleminin şok ve seyreltilmiş dalga formu için çözümlerini animasyon olarak bulabiliriz.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> qf(q): <span class="cf">return</span> <span class="fl">0.5</span><span class="op">*</span>q<span class="op">*</span>q
    
<span class="kw">def</span> exact_riemann_solution(xi,u_l,u_r):
    <span class="co"># Shock wave</span>
    <span class="cf">if</span> u_l <span class="op">&gt;</span> u_r: 
        shock_speed <span class="op">=</span> (qf(u_l)<span class="op">-</span>qf(u_r))<span class="op">/</span>(u_l<span class="op">-</span>u_r)
        q <span class="op">=</span> (xi <span class="op">&lt;</span> shock_speed)<span class="op">*</span>u_l <span class="op">\</span>
          <span class="op">+</span> (xi <span class="op">&gt;=</span>shock_speed)<span class="op">*</span>u_r
        <span class="cf">return</span> q
    <span class="co"># Rarefaction wave</span>
    <span class="cf">else</span>:  
        q <span class="op">=</span> (xi<span class="op">&lt;=</span>u_l)<span class="op">*</span>u_l <span class="op">\</span>
          <span class="op">+</span> (xi<span class="op">&gt;=</span>u_r)<span class="op">*</span>u_r <span class="op">\</span>
          <span class="op">+</span> (u_l<span class="op">&lt;</span>xi)<span class="op">*</span>(xi<span class="op">&lt;</span>u_r)<span class="op">*</span>xi
        <span class="cf">return</span> q</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> shock():
    u_l, u_r <span class="op">=</span> <span class="fl">5.0</span>, <span class="fl">1.0</span>

    <span class="cf">for</span> i,t <span class="kw">in</span> <span class="bu">enumerate</span>(np.linspace(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">6</span>)):
        outfile <span class="op">=</span> <span class="st">&#39;rieout/shock-</span><span class="sc">%02d</span><span class="st">.png&#39;</span> <span class="op">%</span> i
        fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">3</span>))
                    
        x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">1000</span>)
        
        q <span class="op">=</span> np.array([exact_riemann_solution(xi<span class="op">/</span>(t<span class="fl">+1e-10</span>),u_l,u_r) <span class="cf">for</span> xi <span class="kw">in</span> x])

        ax.set_xlim(<span class="op">-</span><span class="dv">4</span>,<span class="dv">4</span>)

        ax.plot(x,q,<span class="st">&#39;-k&#39;</span>,lw<span class="op">=</span><span class="dv">2</span>)

        ax.set_title(<span class="st">&#39;t=</span><span class="sc">%f</span><span class="st">&#39;</span> <span class="op">%</span> t)
    
        plt.savefig(outfile)

shock() </code></pre></div>
<div class="figure">
<img src="rieout/shock-00.png" />

</div>
<div class="figure">
<img src="rieout/shock-04.png" />

</div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> rarefaction():
    u_l, u_r <span class="op">=</span> <span class="fl">2.0</span>, <span class="fl">4.0</span>
    
    <span class="cf">for</span> i,t <span class="kw">in</span> <span class="bu">enumerate</span>(np.linspace(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">6</span>)):
        outfile <span class="op">=</span> <span class="st">&#39;rieout/rarefaction-</span><span class="sc">%02d</span><span class="st">.png&#39;</span> <span class="op">%</span> (t<span class="op">*</span><span class="dv">10</span>)

        fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">3</span>))
                    
        x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">1000</span>)
        
        q <span class="op">=</span> np.array([exact_riemann_solution(xi<span class="op">/</span>(t<span class="fl">+1e-10</span>),u_l,u_r) <span class="cf">for</span> xi <span class="kw">in</span> x])

        ax.set_xlim(<span class="op">-</span><span class="dv">4</span>,<span class="dv">4</span>)

        ax.plot(x,q,<span class="st">&#39;-k&#39;</span>,lw<span class="op">=</span><span class="dv">2</span>)
    
        ax.set_title(<span class="st">&#39;t=</span><span class="sc">%f</span><span class="st">&#39;</span> <span class="op">%</span> t)

        plt.savefig(outfile)

rarefaction()</code></pre></div>
<div class="figure">
<img src="rieout/rarefaction-02.png" />

</div>
<div class="figure">
<img src="rieout/rarefaction-06.png" />

</div>
<p>Animasyon olarak</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">!</span> convert <span class="op">-</span>delay <span class="dv">20</span> <span class="op">-</span>loop <span class="dv">0</span> rieout<span class="op">/</span>shock<span class="op">*</span>.png shock.gif</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">!</span> convert <span class="op">-</span>delay <span class="dv">20</span> <span class="op">-</span>loop <span class="dv">0</span> rieout<span class="op">/</span>rare<span class="op">*</span>.png rarefaction.gif</code></pre></div>
<p>Animasyon sonuç dosyaları [7] ve [8]'de bulunabilir.</p>
<p>Amaç bir diferansiyel denklemi sayısal olarak çözmek. Metot olarak sonlu farklılık (finite difference -FD-) yöntemi daha önce işlendi, bu yöntemde bir sürekli fonksiyonun değerlerini ayrıksal noktalar üzerinden temsil etmeye uğraşıyorduk. Bu noktalar bir ekseni eşit aralıklara bölerek ortaya çıkartılıyordu, mesela altta görülen bir tepeyle başlayıp inen <span class="math inline">\(f\)</span> fonksiyonu <span class="math inline">\(i-2,i-1,i,..\)</span> noktalarında <span class="math inline">\(x_i\)</span> değerleri üzerinden <span class="math inline">\(u_i = u(x_i)\)</span> ile tanımlanıyordu.</p>
<div class="figure">
<img src="13-22-29.png" />

</div>
<p>Sonlu hacim (FV) yönteminde durum biraz farklı; bir fonksiyonu belli noktalarındaki noktasal değerlerle değil, belli aralıklar arasında kalan değerlerinin <em>averajı</em> olarak temsil ediyoruz.</p>
<div class="figure">
<img src="13-22-34.png" />

</div>
<p>Farklı bir grafik</p>
<div class="figure">
<img src="13-16-00.png" />

</div>
<p>İki üstte görülen grafikte mesela <span class="math inline">\(i\)</span> ile <span class="math inline">\(i+1\)</span> noktası ortasındaki <span class="math inline">\(i+1/2\)</span> noktası ve <span class="math inline">\(i\)</span> ile <span class="math inline">\(i-1\)</span> noktası ortasındaki <span class="math inline">\(i-1/2\)</span> arasında kalan fonksiyonun averajı alınacak, ona <span class="math inline">\(&lt; u_i &gt;\)</span> ya da <span class="math inline">\(\overline{u}_i\)</span> diyoruz.</p>
<p><span class="math display">\[
\overline{u}_i = \frac{1}{\Delta x} \int_{x_{i-1/2}}^{x_{i+1/2}} u(x) \mathrm{d} x
\]</span></p>
<p>Dikkat; <span class="math inline">\(i-1,i-2\)</span> değerleri <span class="math inline">\(i\)</span> referanslı olduğu için eksi içerikli, <span class="math inline">\(i=4\)</span> olsaydı onlar <span class="math inline">\(3,2,..\)</span> diye gidebilirdi. Ayrıca FD yönteminin aksine, indis değerlerine tekabül eden <span class="math inline">\(x_i,x_{i+1}\)</span> değerleri herhangi bir yerde olabilir, böylece eşit aralıklı olmayan ızgaralarla çalışmamız mümkün olur, bu FV yönteminin kuvvetlerinden biri.</p>
<p>Gerçi biz bu anlatımda ve kodda eşit aralık farz edeceğiz, <span class="math inline">\(\Delta x\)</span>, <span class="math inline">\(h_x\)</span> burada devreye girer.</p>
<div class="figure">
<img src="12-20-00.png" />

</div>
<p>Muhafaza Kanunu Hesaplamak</p>
<p>Notasyonda <span class="math inline">\(f\)</span> akış (flux) için kullanılır [14], <span class="math inline">\(\Delta x\)</span> için <span class="math inline">\(h_x\)</span>,</p>
<p><span class="math display">\[
\overline{u}_i =  \frac{1}{h_x} \int_{x_{i-1/2}}^{x_{i+1/2}} u(x) \mathrm{d} x
\qquad (1)
\]</span></p>
<p>[17] yazısında muhafaza kanununun entegral formunu görmüştük,</p>
<p><span class="math display">\[
\int_{x_1}^{x_2} \rho(x,t_2) \mathrm{d} x =
\int_{x_1}^{x_2} \rho(x,t_1) \mathrm{d} x  +
\int_{t_1}^{t_2} \rho(x_1,t) v(x_1,t) \mathrm{d} t -
\int_{t_1}^{t_2}  \rho(x_2,t) v(x_2,t) \mathrm{d} t
\]</span></p>
<p><span class="math inline">\(f(\rho) = \rho(x,t) v(x,t)\)</span> denebilir, ya da herhangi daha genel olarak <span class="math inline">\(\rho\)</span> yerine herhangi bir ölçüm <span class="math inline">\(u\)</span> için <span class="math inline">\(f(u) = u(x,t) v(x,t)\)</span>, o zaman, ve biraz yer değişim sonrası,</p>
<p><span class="math display">\[
\int_{x_1}^{x_2} u(x,t_2) \mathrm{d} x -
\int_{x_1}^{x_2} u(x,t_1) \mathrm{d} x  +
\int_{t_1}^{t_2} f(x_2,t) \mathrm{d} t  -
\int_{t_1}^{t_2} f(x_1,t) \mathrm{d} t = 0
\]</span></p>
<p>Bu formülü her sonlu hacim hücresi için kullanacağız. Zaman indisleri <span class="math inline">\(t,t+1\)</span> olacak, üstte <span class="math inline">\(t_1,t_2\)</span> yerine. Yer için <span class="math inline">\(x_1,x_2\)</span> yerine bir <span class="math inline">\(j\)</span> indisi merkezli <span class="math inline">\(x_{j-1/2}\)</span> ve <span class="math inline">\(x_{j+1/2}\)</span>. Devam edelim, <span class="math inline">\(u(x_1,t_1)\)</span> içinde <span class="math inline">\(x_{j-1/2}\)</span> ve <span class="math inline">\(t_l\)</span> oluyor, (zaman <span class="math inline">\(l\)</span> indisi) ona da <span class="math inline">\(u_{j-1}^l\)</span> diyelim. <span class="math inline">\(x_2\)</span> yerine <span class="math inline">\(x_{j+1/2}\)</span>, sonuncuda zamanın hala değişken olduğu durum <span class="math inline">\(u_{j+1}\)</span> olsun. Eğer <span class="math inline">\(x\)</span> değişken ise, zaman indisi <span class="math inline">\(t_2 = t_{l+1}\)</span> için <span class="math inline">\(u^{l}\)</span>. Üstteki formülü bu notasyonla değiştirip istenen zaman ve yer aralıklarına uygularsak,</p>
<p><span class="math display">\[
\int_{x_{j-1/2}}^{x_{j+1/2}} u^{l+1} \mathrm{d} x -
\int_{x_{j-1/2}}^{x_{j+1/2}} u^{l} \mathrm{d} x  +
\int_{t_l}^{t_{l+1}} f(u_{j+1/2}) \mathrm{d} t  -
\int_{t_l}^{t_{l+1}} f(u_{j-1/2}) \mathrm{d} t = 0
\]</span></p>
<p>Her şeyi <span class="math inline">\(h_x\)</span> ile bölelim,</p>
<p><span class="math display">\[
\frac{1}{h_x} \int_{x_{j-1/2}}^{x_{j+1/2}} u^{l+1} \mathrm{d} x -
\frac{1}{h_x} \int_{x_{j-1/2}}^{x_{j+1/2}} u^{l} \mathrm{d} x  +
\frac{1}{h_x} \int_{t_l}^{t_{l+1}} f(u_{j+1/2}) \mathrm{d} t  -
\frac{1}{h_x} \int_{t_l}^{t_{l+1}} f(u_{j-1/2}) \mathrm{d} t = 0
\]</span></p>
<p>Bu formülde (1)'de tanımlanan ortalama formunu görüyoruz, kısaltma amaçlı <span class="math inline">\(\overline{u}_{j,l}\)</span> notasyonu oralarda kullanabiliriz,</p>
<p><span class="math display">\[
\overline{u}_{j,l+1} - \overline{u}_{j,l} + 
\frac{1}{h_x} \int_{t_l}^{t_{l+1}} f(u_{j+1/2}) \mathrm{d} t  -
\frac{1}{h_x} \int_{t_l}^{t_{l+1}} f(u_{j-1/2}) \mathrm{d} t = 0
\]</span></p>
<p>Şimdi son iki terime dikkat edelim, bu iki entegral zaman üzerinden alınıyor, fakat Riemann problemini hatırlarsak çözüm <span class="math inline">\(u(x,t)\)</span> sadece <span class="math inline">\(x/t\)</span> değişkeni üzerinden düşünülebilir, ve eğer <span class="math inline">\(x\)</span> değişmiyorsa (ki öyle çünkü üstteki iki entegral <span class="math inline">\(t\)</span> üzerinden, <span class="math inline">\(x\)</span> aynı) o zaman <span class="math inline">\(\mathrm{d} t\)</span> üzerinden entegral yerine, sabit <span class="math inline">\(u\)</span> ile bir ayrıksal <span class="math inline">\(h_t\)</span> çarpımı yeterlidir. Öyle ya sabit <span class="math inline">\(u\)</span> üzerinden ve yine sabit / bilinen <span class="math inline">\(t\)</span> adımı <span class="math inline">\(h_t\)</span> üzerinden alan bir dikdörtgendir, bu alanın hesabı için çetrefil entegral yerine direk çarpım yeterli.. Mesela ilk entegral,</p>
<p><span class="math display">\[
\frac{1}{h_x} \int_{t_l}^{t_{l+1}} f(u_{j+1/2}) \mathrm{d} t =
\frac{h_t}{h_x} f(u_{j+1/2})
\]</span></p>
<p>olarak hesaplanabilir, çünkü <span class="math inline">\(u\)</span> değeri <span class="math inline">\(x = x_{j \pm 1/2}\)</span> üzerinde değişmiyor. Aynı durum ikinci entegral için de geçerli, o zaman iki üstteki formül</p>
<p><span class="math display">\[
\overline{u}_{j,l+1} = \overline{u}_{j,l} -
\frac{h_t}{h_x} ( f(u_{j+1/2}) - f(u_{j-1/2}) )
\qquad (2)
\]</span></p>
<p>olacak. Böylece <span class="math inline">\(l\)</span> anındaki <span class="math inline">\(j\)</span> hücresinin ortalamasını bir sonraki zaman adımı <span class="math inline">\(l+1\)</span>'e nasıl aktaracağımızı, oraya geçiş yapacağımızın formülünü bulmuş olduk.</p>
<p>Eğer <span class="math inline">\(\frac{1}{h_x} \int_{t_l}^{t_{l+1}} f(u_{j+1/2}) \mathrm{d} t\)</span> entegralini entegral içindekiler çarpı <span class="math inline">\(h_t\)</span> ile gösterebiliyorsak, tüm entegrali <span class="math inline">\(h_t\)</span> ile bölmek bize yaklaşık, &quot;sayısal'' bir <span class="math inline">\(f(u_{j+1/2})\)</span> verecektir, ona büyük harf ile <span class="math inline">\(F_{j+1/2}^l\)</span> diyelim, formülü [16, sf. 103]</p>
<p><span class="math display">\[
F_{j+1/2}^l = \frac{1}{h_t} \int_{t_l}^{t_{l+1}} f(u_{j+1/2,l}) \mathrm{d} t
\]</span></p>
<p><span class="math inline">\(F\)</span>'ye sayısal akış (numerical flux) ismi de veriliyor. O zaman (2) formülü &quot;akış diferansiyel formunda'' da yazılabilir,</p>
<p><span class="math display">\[
\overline{u}_{j,l+1} = \overline{u}_{j,l} -
\frac{h_t}{h_x} ( F_{j+1/2,l} - F_{j-1/2,l} )
\]</span></p>
<p>Sayısal akışı elde etmek için bize bir sayısal <span class="math inline">\(u\)</span> lazım, bunu FV ile bulacağız, sonra bu <span class="math inline">\(u\)</span>'ları bildiğimiz <span class="math inline">\(f()\)</span> akışına verince sayısal <span class="math inline">\(F\)</span> elde edilecek.</p>
<p>Bu kod alttaki gibidir,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> scipy.integrate <span class="im">as</span> integrate
<span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt
<span class="im">import</span> numpy <span class="im">as</span> np

alpha <span class="op">=</span> <span class="fl">0.0</span>
beta  <span class="op">=</span> <span class="fl">1.0</span>

<span class="kw">def</span> init(z, alpha, beta):
    <span class="cf">return</span> alpha <span class="op">+</span> beta<span class="op">*</span>np.sin(z)

<span class="co"># </span>
<span class="co">#  u_t + f(u)_x = 0 denklemi icin akis (flux) fonksiyonu </span>
<span class="co">#</span>
<span class="kw">def</span> flux(u):
    <span class="cf">return</span> <span class="fl">0.5</span><span class="op">*</span>u<span class="op">**</span><span class="dv">2</span>

<span class="kw">def</span> godunov_flux(uval):
    fhat <span class="op">=</span> np.zeros((<span class="bu">len</span>(uval),<span class="dv">1</span>))

    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="bu">len</span>(uval)<span class="op">-</span><span class="dv">1</span>):
        ul <span class="op">=</span> uval[i]<span class="op">;</span> ur <span class="op">=</span> uval[i<span class="op">+</span><span class="dv">1</span>]

        s<span class="op">=</span>(ul<span class="op">+</span>ur)<span class="op">/</span><span class="dv">2</span><span class="op">;</span>
        <span class="cf">if</span> ul <span class="op">&gt;</span> ur:
            <span class="cf">if</span> s <span class="op">&lt;</span> <span class="dv">0</span>:
                fhat[i] <span class="op">=</span> flux(ur)
            <span class="cf">else</span>:
                fhat[i] <span class="op">=</span> flux(ul)
        <span class="cf">elif</span> ul <span class="op">&lt;</span> ur:
            <span class="cf">if</span> ur <span class="op">&lt;</span> <span class="dv">0</span>:
                fhat[i] <span class="op">=</span> flux(ur)
            <span class="cf">elif</span> ul <span class="op">&gt;</span> <span class="fl">0.</span>:
                fhat[i] <span class="op">=</span> flux(ul)
            <span class="cf">else</span>:
                fhat[i] <span class="op">=</span> <span class="dv">0</span>
                
    <span class="cf">return</span> fhat

a <span class="op">=</span> <span class="dv">0</span>
b <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>np.pi
N  <span class="op">=</span> <span class="dv">80</span>
T <span class="op">=</span> <span class="fl">2.0</span>

x <span class="op">=</span> np.linspace(a,b,N)     
dx <span class="op">=</span> (b<span class="op">-</span>a)<span class="op">/</span>(N<span class="dv">-1</span>)<span class="op">;</span>  
u <span class="op">=</span> np.zeros((<span class="bu">len</span>(x)<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>))<span class="op">;</span> 

<span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,N<span class="dv">-1</span>):
    u[i] <span class="op">=</span> (<span class="fl">1.0</span><span class="op">/</span>dx)<span class="op">*</span>integrate.quad(init, x[i], x[i<span class="op">+</span><span class="dv">1</span>], args<span class="op">=</span>(alpha,beta))[<span class="dv">0</span>]

dt <span class="op">=</span> dx<span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>np.amax(np.amax(u)))

t <span class="op">=</span> <span class="fl">0.0</span>
i <span class="op">=</span> <span class="dv">0</span>
<span class="cf">while</span> t <span class="op">&lt;</span> T:
    fR <span class="op">=</span> godunov_flux(u) 
    fL <span class="op">=</span> np.roll(fR,<span class="dv">1</span>)
    u <span class="op">-=</span> dt<span class="op">/</span>dx<span class="op">*</span>(fR <span class="op">-</span> fL)
    t <span class="op">=</span> t<span class="op">+</span>dt
    i <span class="op">+=</span> <span class="dv">1</span>

    <span class="cf">if</span> i <span class="op">%</span> <span class="dv">5</span> <span class="op">==</span> <span class="dv">0</span>:
        plt.figure()
        plt.plot(u)
        plt.ylim(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>)
        plt.savefig(<span class="st">&#39;/tmp/out-</span><span class="sc">%03d</span><span class="st">.png&#39;</span> <span class="op">%</span> i)
        plt.close(<span class="st">&#39;all&#39;</span>)</code></pre></div>
<p>Kodda ilk önce başlangıç fonksiyonu tanımlandı, içinde sinüs olan <code>init</code> bu; Bu fonksiyonun hücre bazında <code>integrate.quad</code> ile entegrali alındı, böylece her hücreyi temsil eden o tek değeri elde ettik.</p>
<div class="figure">
<img src="12-19-02.png" />

</div>
<p>FV yöntemi bundan sonra o hücreler üzerinden hesabını yapacak, dinamik denklemi zamanda ilerletirken bunun hücrelerdeki o temsili değer üzerinden yapacak.</p>
<p>Hücrelerin FV matematiği şöyle; mesela yanyana iki hücreye bakarsak, üstteki resimde <span class="math inline">\(x_{i-2}\)</span> ve <span class="math inline">\(x_{i-1}\)</span> diyelim, soldan ilk iki hücre, bu iki değer sanki bir Riemann problemini andırmıyor mu? Evet; ve Godunov'un icat ettiği FV çözümü için kullanılan teknik te zaten budur. İki hücre ortasındaki <span class="math inline">\(x_{i-1/2}\)</span> noktası hücre sınırı kabul edilir ve önceki sonraki değerler <span class="math inline">\(u_L\)</span> ve <span class="math inline">\(u_R\)</span> imiş gibi Riemann çözümü işletilir. Bu işlem tüm yanyana hücreler için işletilince bir zaman dilimi çözümü elde edilir, sonraki zaman dilimi için bu işlem tekrar baştan hesaplanır.</p>
<p>Şimdi <span class="math inline">\(x_{i}\)</span> ile <span class="math inline">\(x_{i+1}\)</span> arasındaki <span class="math inline">\(x_{1+1/2}\)</span> sınırını baz alıp, önce gördüğümüz Riemann çözümünü baz alarak şunu yazalım [16, sf. 109],</p>
<p><span class="math inline">\(u_i^l \ge u_{i+1}^l\)</span> için,</p>
<p><span class="math display">\[
u^\star_{i+1/2} = 
\left\{ \begin{array}{lll}
u_i^l &amp; \textrm{eğer} &amp; s &gt; (x-x_{i+1/2}) / t  \\
u_{i+1}^l &amp; \textrm{eğer} &amp; s &lt; (x-x_{i+1/2}) / t
\end{array} \right.
\]</span></p>
<p>Daha önce gördük <span class="math inline">\(s\)</span> dalga hızı, bu örnekte <span class="math inline">\(s = (u_i^n + u_{i+1}^n)/2\)</span>.</p>
<p><span class="math inline">\(u_i^l &lt; u_{i+1}^l\)</span> için,</p>
<p><span class="math display">\[
u^\star_{i+1/2} = 
\left\{ \begin{array}{lll}
u_i^l &amp; \textrm{eğer} &amp; (x-x_{i+1/2})/t \le u_i^l   \\
(x-x_{i+1/2})/t &amp; \textrm{eğer} &amp; u_i^l &lt; (x-x_{i+1/2})/t &lt; u_{i+1}^l   \\
u_{i+1}^l &amp; \textrm{eğer} &amp; (x-x_{i+1/2})/t \ge u_{i+1}^l   \\
\end{array} \right.
\]</span></p>
<p>Bir kez Riemann çözümü elde edilince Godunov sayısal akışı <span class="math inline">\(u^\star_{i+1/2}\)</span> ile kolayca hesaplanabilir, akış fonksiyonu <span class="math inline">\(f()\)</span> üzerinden <span class="math inline">\(F = f(u^\star_{i+1/2})\)</span>.</p>
<p>Üstteki formülleri daha da kolaylaştırmak mümkün, Godunov akışlarını <span class="math inline">\(x = x_{i+1/2}\)</span> noktasında hesapladığımız için bunu formülde <span class="math inline">\(x\)</span> yerine koyunca,</p>
<p><span class="math inline">\(u_i^l \ge u_{i+1}^l\)</span> için,</p>
<p><span class="math display">\[
u^\star_{i+1/2} = 
\left\{ \begin{array}{lll}
u_i^l &amp; \textrm{eğer} &amp; s &gt; 0  \\
u_{i+1}^l &amp; \textrm{eğer} &amp; s &lt; 0
\end{array} \right.
\]</span></p>
<p><span class="math inline">\(u_i^l &lt; u_{i+1}^l\)</span> için,</p>
<p><span class="math display">\[
u^\star_{i+1/2} = 
\left\{ \begin{array}{lll}
u_i^l &amp; \textrm{eğer} &amp; 0 \le u_i^l   \\
(x-x_{i+1/2})/t &amp; \textrm{eğer} &amp; u_i^l &lt; 0 &lt; u_{i+1}^l   \\
u_{i+1}^l &amp; \textrm{eğer} &amp; 0 \ge u_{i+1}^l   \\
\end{array} \right.
\]</span></p>
<p>Kod içinde üstte görülen hesabı tüm hücreler için yaptık, <span class="math inline">\(i\)</span>,<span class="math inline">\(i+1\)</span>,<span class="math inline">\(i+2\)</span>.. ve <span class="math inline">\(F_{j+1/2,l}\)</span> hesabından bir önceki <span class="math inline">\(F_{j-1/2,l}\)</span>, kod içinde önceki <code>fL</code> sonraki <code>fR</code>, onun için <code>np.roll</code> ile vektör içindeki değerleri bir ilerleterek önceki ve sonraki hücrelerin aynı hizaya düşmesini sağlıyoruz böylece <span class="math inline">\(F_{j+1/2,l}-F_{j-1/2,l}\)</span> hesabı kolay bir şekilde <code>fR-fL</code> ile bulunabiliyor.</p>
<p>Belli <span class="math inline">\(t\)</span> anlarından alınmış görüntüler altta bulunabilir.</p>
<p><img src="out-005.png" /> <img src="out-010.png" /> <img src="out-020.png" /> <img src="out-030.png" /></p>
<p>Animasyon [13],</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">!</span> convert <span class="op">-</span>delay <span class="dv">20</span> <span class="op">-</span>loop <span class="dv">0</span> <span class="op">/</span>tmp<span class="op">/</span>out<span class="op">-*</span>.png wave.gif</code></pre></div>
<p>Kaynaklar</p>
<p>[1] Bayramlı, <em>Hesapsal Bilim, Hesapsal Sıvı Dinamiğine Giriş</em></p>
<p>[2] Bayramlı, <em>Fizik, Gazlar, Sıvılar 1</em></p>
<p>[3] Leveque, <em>Numerical Methods for Conservation Laws</em></p>
<p>[4] Mishra, <em>Numerical methods for conservation laws and related equations</em></p>
<p>[5] Cooper, <em>Introduction to PDEs with Matlab</em></p>
<p>[6] Hesthaven, <em>Numerical Methods for Conservation Laws</em></p>
<p>[7] Bayramlı, <em>Animasyon, Şok Dalgası</em>, <a href="https://github.com/burakbayramli/classnotes/raw/master/compscieng/compscieng_bpp50fv/shock.gif" class="uri">https://github.com/burakbayramli/classnotes/raw/master/compscieng/compscieng_bpp50fv/shock.gif</a></p>
<p>[8] Bayramlı, <em>Animasyon, Seyrelen (Rarefaction) Dalga</em> <a href="https://github.com/burakbayramli/classnotes/raw/master/compscieng/compscieng_bpp50fv/rarefaction.gif" class="uri">https://github.com/burakbayramli/classnotes/raw/master/compscieng/compscieng_bpp50fv/rarefaction.gif</a></p>
<p>[9] Lee, <em>AM 260, Computational Fluid Dynamics</em>, <a href="https://users.soe.ucsc.edu/~dongwook/wp-content/uploads/2021/am260/html/" class="uri">https://users.soe.ucsc.edu/~dongwook/wp-content/uploads/2021/am260/html/</a></p>
<p>[10] Bayramlı, <em>Cok Degiskenli Calculus, Ders 11</em></p>
<p>[11] Muller, {Learn CFD, Lecture 15 - Part b}, <a href="https://youtu.be/f8fuMRFZYwQ" class="uri">https://youtu.be/f8fuMRFZYwQ</a></p>
<p>[12] Bayramlı, <em>Fizik, Gazlar, Sıvılar 2</em></p>
<p>[13] Bayramlı, <em>Animasyon, Godunov Sonlu Hacim Yontemi ile Burgers Denklem Cozumu</em> <a href="https://github.com/burakbayramli/classnotes/raw/master/compscieng/compscieng_bpp50fv/wave.gif" class="uri">https://github.com/burakbayramli/classnotes/raw/master/compscieng/compscieng_bpp50fv/wave.gif</a></p>
<p>[14] Kloeckner, <em>Numerical Methods for Partial Differential Equations CS555 / MATH555 / CSE510</em> <a href="https://relate.cs.illinois.edu/course/cs555-s20/" class="uri">https://relate.cs.illinois.edu/course/cs555-s20/</a></p>
<p>[16] Lee, <em>Computational Fluid Dynamics</em></p>
<p>[17] Bayramlı, <em>Fizik, Gazlar, Sivilar - 2</em></p>
</body>
</html>
