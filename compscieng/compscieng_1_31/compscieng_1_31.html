<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Evrişim (Convolution)</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="evrişim-convolution">Evrişim (Convolution)</h1>
<p>Evrişim iki fonksiyon <span class="math inline">\(f,g\)</span>
üzerinde tanımlı bir operasyondur, bu operasyon iki fonksiyondan üçüncü
bir fonksiyon yaratır. Operasyon bir entegral üzerinden tanımlıdır,
<span class="math inline">\(g\)</span>’nin aynı görüntüsü / ters
çevrilmiş halinin alınıp, soldan (negatif sonsuzluk) sağa doğru
kaydırılırken <span class="math inline">\(f\)</span> ile üst üste gelen
bölgenin alanını her <span class="math inline">\(t\)</span> için
alınması durumudur, bu açıdan evrişim bir tür ağırlıklı ortalama olarak
görülebilir, <span class="math inline">\(f\)</span>’in ağırlıklı
ortalaması <span class="math inline">\(g\)</span> üzerinden
alınmaktadır. Matematiksel olarak,</p>
<p><span class="math display">\[f * g \equiv \int_{-\infty}^{\infty}
f(\tau)g(t-\tau) \mathrm{d}\tau \]</span></p>
<p>Evrişim sırabağımsızdır, yani <span class="math inline">\(f * g = g *
f\)</span>, o zaman</p>
<p><span class="math display">\[f * g \equiv \int_{-\infty}^{\infty}
f(t-\tau)g(\tau) \mathrm{d}\tau \]</span></p>
<p>ifadesi de doğrudur. Örnek <span class="math inline">\(f,g\)</span>
üzerine görelim,</p>
<p><img src="tser_conv_01.png" /></p>
<p>Her iki fonksiyonu bir geçici değişken <span
class="math inline">\(\tau\)</span> üzerinden tanımlayabiliriz, Sonra
<span class="math inline">\(g\)</span>’nin ayna görüntüsünü alırız,
<span class="math inline">\(g(\tau) \to g(-\tau)\)</span></p>
<p><img src="tser_conv_02.png" /></p>
<p>Şimdi bir zaman kaydırma faktörü <span
class="math inline">\(t\)</span> ekleyebiliriz, bir <span
class="math inline">\(g(t-\tau)\)</span> elde ederiz, bunun etkisi her
<span class="math inline">\(t\)</span> için <span
class="math inline">\(g\)</span>’yi istediğimiz noktaya
kaydırabilmektir. Bunu yaparken, mesela negatif sonsuzluktan pozitif
sonsuzluğa kaydırırken, her <span class="math inline">\(t\)</span>
anında alınan entegralin sonuçları bize evrişimi verir. Dikkat, kaydırma
entegralin sonucu değil, sadece “her <span
class="math inline">\(t\)</span> için’’ vurgusu amacıyla bu kaydırma
görüntüsü veriliyor, her <span class="math inline">\(t\)</span>
noktasında, kaydırma nereye olursa olsun, <span
class="math inline">\(-\infty,\infty\)</span> arasında entegral
alınmaktadır.</p>
<p><img src="tser_conv_03.png" /></p>
<p>Ayrıksal olarak,</p>
<p><span class="math display">\[ (f * g) [n] \equiv
\sum_{m=-\infty}^{\infty} f[m] g[n-m]  \]</span></p>
<p>Farklı fonksiyonlar üzerinde görelim, mesela kare fonksiyonunu
kendisiyle evrişimi, <span class="math inline">\(f\)</span> mavi, <span
class="math inline">\(g\)</span> kırmızı, sarı bölgeler çakışma olan
yerler, <span class="math inline">\(g\)</span>’nin her <span
class="math inline">\(t\)</span> için evrişim entegral sonucu ise siyah
çizgi ile gösteriliyor,</p>
<p><img src="box1.png" /> <img src="box2.png" /></p>
<p><img src="box3.png" /> <img src="box4.png" /></p>
<p>Şimdi <span class="math inline">\(f\)</span> kavisli bir fonksiyon,
<span class="math inline">\(g\)</span> hala kare,</p>
<p><img src="spiky0.png" /> <img src="spiky1.png" /></p>
<p><img src="spiky2.png" /> <img src="spiky3.png" /></p>
<p>Evrişim ile çapraz korelasyon (cross-correlation) arasında
bağlantılar var, <span class="math inline">\(t-\tau\)</span> yerine
<span class="math inline">\(t+\tau\)</span> kullanılırsa çapraz
korelasyon elde ediliyor.</p>
<p><img src="compar.png" /></p>
<p>Örnek</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.signal</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> [<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (scipy.signal.convolve(f,g))</span></code></pre></div>
<pre class="text"><code>[ 5 14 26 40 55 70 50 32 17  6]</code></pre>
<p><span class="math inline">\(X+Y\)</span> Dağılımı</p>
<p>Çoğu zaman <span class="math inline">\(X,Y\)</span>’in bağımsız
olduğu durumda bu rasgele değişkenlerin toplamının dağılımını hesaplamak
gerekir [2, sf 56]. Kümülatif fonksiyon <span
class="math inline">\(F\)</span> ile</p>
<p><span class="math display">\[ F_{Z+Y} = P(X+Y \le a) \]</span></p>
<p><span class="math display">\[ = \int \int_{x+y \le a}^{} f(x)g(y)
\mathrm{d} x \mathrm{d} y \]</span></p>
<p><span class="math inline">\(f(x)g(y)\)</span> kullanabildik çünkü
<span class="math inline">\(X,Y\)</span> bağımsız. Alt sınırda bir
değişiklik yapalım, <span class="math inline">\(x+y \le a\)</span>, o
zaman <span class="math inline">\(x \le a-y\)</span>. Demek ki</p>
<p><span class="math display">\[
= \int_{-\infty}^{\infty} \int_{-\infty}^{a-y} f(x)g(y) \mathrm{d} x
\mathrm{d} y
\]</span></p>
<p>Entegralleri gruplayabiliriz,</p>
<p><span class="math display">\[
= \int_{-\infty}^{\infty}
\bigg[ \int_{-\infty}^{a-y} f(x) \mathrm{d} x \bigg] g(y) \mathrm{d} y
\]</span></p>
<p><span class="math display">\[ = \int_{-\infty}^{\infty} F_X(a-y) g(y)
\mathrm{d} y \]</span></p>
<p>Yoğunluğu almak için kümülatif fonksiyonun türevini alırsak,</p>
<p><span class="math display">\[
f_{X+Y}(a) = \frac{d}{da} \int_{-\infty}^{\infty} F_X(a-y) g(y)
\mathrm{d} y
\]</span></p>
<p><span class="math display">\[  = \int_{-\infty}^{\infty} \frac{d}{da}
F_X(a-y) g(y) \mathrm{d} y \]</span></p>
<p><span class="math display">\[  = \int_{-\infty}^{\infty} f_X(a-y)
g(y) \mathrm{d} y \]</span></p>
<p>Üstteki ifade bir evrişim operasyonu! Yani iki bağımsız rasgele
değişkenin toplamının yoğunluğu, değişkenlerin yoğunluklarının
evrişimine eşittir!</p>
<p>[1, sf. 365]’de ayrıksal olarak üstteki hesaba değiniliyor, elde iki
zar var, zarın her yüzünün gelme ihtimali <span
class="math inline">\(p_i=1/6\)</span>, bu iki zarın mümkün her türlü
toplamının hesabı bir evrişim, <span class="math inline">\(p *
p\)</span>,</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.signal</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> <span class="dv">1</span><span class="op">/</span><span class="fl">6.</span> <span class="op">*</span> np.array([<span class="fl">1.0</span>,<span class="fl">1.0</span>,<span class="fl">1.0</span>,<span class="fl">1.0</span>,<span class="fl">1.0</span>,<span class="fl">1.0</span>])</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (scipy.signal.convolve(d,d) )</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (scipy.signal.convolve(d,d) <span class="op">*</span> <span class="fl">36.</span>)</span></code></pre></div>
<pre class="text"><code>[0.02777778 0.05555556 0.08333333 0.11111111 0.13888889 0.16666667
 0.13888889 0.11111111 0.08333333 0.05555556 0.02777778]
[1. 2. 3. 4. 5. 6. 5. 4. 3. 2. 1.]</code></pre>
<p>Sonuca göre toplam 12 gelme ihtimali 1/36 (en baştaki), 11 gelme
ihtimali 2/36, vs.</p>
<p>Ek bilgiler için bkz [4] notları.</p>
<p>Kaynaklar</p>
<p>[1] Strang, <em>Computational Science and Engineering</em></p>
<p>[2] Wikipedia, <em>Convolution</em>, <a
href="https://en.wikipedia.org/wiki/Convolution">https://en.wikipedia.org/wiki/Convolution</a></p>
<p>[3] Ross, <em>Introduction to Probability Models 10th
Edition</em></p>
<p>[4] Bayramlı, Diferansiyel Denklemler, <em>Ders 21</em></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
