<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Ayrıksal Fourier Transformu (Discrete Fourier Transform -DFT-)</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1
id="ayrıksal-fourier-transformu-discrete-fourier-transform--dft-">Ayrıksal
Fourier Transformu (Discrete Fourier Transform -DFT-)</h1>
<p>Frekans Analizi, Periyodik Sinyaller</p>
<p>Bir periyodik sinyali nasıl analiz ederiz? Kendimiz bir sinyal
oluşturmak istesek bunu nasıl yapacağımızı düşünelim; <span
class="math inline">\(\sin\)</span> ya da <span
class="math inline">\(\cos\)</span> fonksiyonlarının bir periyotu
vardır, <span class="math inline">\(0,2\pi\)</span> arasındaki değerler
<span class="math inline">\(2\pi,4\pi\)</span> arasında tekrar eder,
vs.. Bazı ek özellikler; mesela <span
class="math inline">\(\cos\)</span> sıfır noktasında 1 değerine sahip,
fakat elimizdeki zaman serisi sağa ya da sola “kaymış’’ olabilir, buna
faz kayması (phase shift) deniyor, yani sıfır noktasında değer 1
olmayabilir. Ayrıca -1,+1 arasında gidip gelmek yerine mesela -10,+10
arasında gidip gelinebilir, buna genlik deniyor (amplitude). Bir diğer
özellik <span class="math inline">\(0,2\pi\)</span> arasında tek bir
periyot yerine birden fazla periyot olabilmesi (frekans değişimi).</p>
<p>Frekans ile başlayalım, önce normal bir kosinüs sinyali,</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">10</span>,<span class="dv">100</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>plt.plot(t, np.cos(t))</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">0</span>,<span class="dv">10</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_1_30_04.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_1_30_04.png" /></p>
<p>Her <span class="math inline">\(\pi\)</span> noktasını
gösterelim,</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>plt.plot(t, np.cos(t))</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>plt.axvline(<span class="dv">0</span>,lw<span class="op">=</span><span class="st">&#39;1&#39;</span>,ls<span class="op">=</span><span class="st">&#39;dashed&#39;</span>,color<span class="op">=</span><span class="st">&#39;r&#39;</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>plt.axvline(np.pi,lw<span class="op">=</span><span class="st">&#39;1&#39;</span>,ls<span class="op">=</span><span class="st">&#39;dashed&#39;</span>,color<span class="op">=</span><span class="st">&#39;r&#39;</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>plt.axvline(<span class="dv">2</span><span class="op">*</span>np.pi,lw<span class="op">=</span><span class="st">&#39;1&#39;</span>,ls<span class="op">=</span><span class="st">&#39;dashed&#39;</span>,color<span class="op">=</span><span class="st">&#39;r&#39;</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>plt.axvline(<span class="dv">3</span><span class="op">*</span>np.pi,lw<span class="op">=</span><span class="st">&#39;1&#39;</span>,ls<span class="op">=</span><span class="st">&#39;dashed&#39;</span>,color<span class="op">=</span><span class="st">&#39;r&#39;</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">0</span>,<span class="dv">10</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_1_30_05.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_1_30_05.png" /></p>
<p>Bu sinyalde <span class="math inline">\(\cos\)</span>’a verilen <span
class="math inline">\(t\)</span> değerlerini iki ile çarpsam ne olur?
<span class="math inline">\(0,2\pi\)</span> arasında bir periyot için
daha önceki <span class="math inline">\(t\)</span>’lerin yarısı ile bu
iş yapılabilir, demek ki önceki tek periyot içinde şimdi sinyal iki kez
tur atacaktır. O zaman <span class="math inline">\(\cos\)</span> içinde
bir sabit ile çarpım yapmak ile frekansı o kadar arttırmış oldum,</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>plt.plot(t, np.cos(<span class="dv">2</span><span class="op">*</span>t))</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>plt.axvline(<span class="dv">0</span>,lw<span class="op">=</span><span class="st">&#39;1&#39;</span>,ls<span class="op">=</span><span class="st">&#39;dashed&#39;</span>,color<span class="op">=</span><span class="st">&#39;r&#39;</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>plt.axvline(np.pi,lw<span class="op">=</span><span class="st">&#39;1&#39;</span>,ls<span class="op">=</span><span class="st">&#39;dashed&#39;</span>,color<span class="op">=</span><span class="st">&#39;r&#39;</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>plt.axvline(<span class="dv">2</span><span class="op">*</span>np.pi,lw<span class="op">=</span><span class="st">&#39;1&#39;</span>,ls<span class="op">=</span><span class="st">&#39;dashed&#39;</span>,color<span class="op">=</span><span class="st">&#39;r&#39;</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>plt.axvline(<span class="dv">3</span><span class="op">*</span>np.pi,lw<span class="op">=</span><span class="st">&#39;1&#39;</span>,ls<span class="op">=</span><span class="st">&#39;dashed&#39;</span>,color<span class="op">=</span><span class="st">&#39;r&#39;</span>)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">0</span>,<span class="dv">10</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_1_30_06.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_1_30_06.png" /></p>
<p>-1/+1 arasında gidip gelmeyi arttırmak en kolayı, <span
class="math inline">\(\cos\)</span> hesabından elde edilen değeri mesela
10 ile çarparsam genlik o kadar artar. Faz kaydırma <span
class="math inline">\(\cos\)</span> içinde bir toplam olabilir. Tüm
resmi göstermek gerekirse, <span class="math inline">\(A\)</span>
genlik, <span class="math inline">\(f_0\)</span> frekans, faz kayması
<span class="math inline">\(\phi\)</span> olacak şekilde,</p>
<p><span class="math display">\[
x(t) = A \cos (2\pi f_0 t - \phi)
\]</span></p>
<p>Bu formülün grafiği,</p>
<p><img src="compscieng_1_30_07.png" /></p>
<p>Direk formüle bakarak <span class="math inline">\(A\)</span> hemen
anlaşılabiliyor. Frekans <span class="math inline">\(t\)</span>’yi
çarpan değerle orantılı, yanlız dikkat, bu değer her zaman <span
class="math inline">\(2\pi\)</span>’ye oranlı bir şey, yani formül <span
class="math inline">\(\cos(10 t)\)</span> gibi bir ifade içeriyorsa,
<span class="math inline">\(10 / 2\pi\)</span> ile <span
class="math inline">\(f_0\)</span>’yi çıkartmamız gerekir. Eğer <span
class="math inline">\(t\)</span> saniye birimine sahipse, bir periyot
<span class="math inline">\(T_0 = 1/f_0 = 0.5\)</span> saniyedir, ve
frekans 2 Hertz olacaktır. Eğer frekans <span class="math inline">\(w_0
= 2\pi f_o\)</span> formunda gösterilirse, o zaman birim radyan / saniye
olur.</p>
<p>Faz kayması <span class="math inline">\(\phi\)</span> sebebiyle tepe
noktanın nerede olduğu da direk formülden anlaşılamıyor, biraz ek hesap
lazım, üstteki örnekte 3/16, bunu bulmak için “kosinüse geçilen değerin
sıfır olduğu yer’’ gerekli,</p>
<p><span class="math display">\[ 0 = 2\pi \cdot 2 \cdot t  - 3\pi/4
\implies t = 3\pi / (4 \cdot 4\pi)  
\implies t = 3/16
\]</span></p>
<p>Fakat hala faz kayması <span class="math inline">\(3\pi/4\)</span>
diyebiliriz.</p>
<p>Örneklemek (Sampling)</p>
<p>Sayısal, yani bilgisayar ortamında bilgiler ayrıksaldır, kimse bize
üstteki sürekli formül formatıyla sinyal parametrelerini vermez. Diyelim
ki bir sinyalin saniyede 10 tane örneklemini alıyoruz. O zaman 3 saniye
sonra elimizde 30 veri noktası olacak. Fakat her örneklem frekansı
gerçek sinyali anlamak için yeterli değildir. Nyquist teorisine göre
örneklem gerçek frekansın en az iki katı olmalıdır. Altta bazı örnekler
görülüyor, en alttaki örneklem frekansı dalga frekansı ile aynı, ve bu
sinyali anlamak için yeterli değil. Veri noktalarına bakarak onların ilk
üç noktada bir düz çizgi oluşturduğunu zannedebilirdik.</p>
<p><img src="compscieng_1_30_10.png" /></p>
<p>Tabii sadece ayrıksal frekansa bakarak sinyalin frekansının ne
olduğunu anlamak ta mümkün degil. Eğer bir şekilde gercek sinyalin kaç
örneklemde bir tekrar ettiğini bulursak, o zaman yaklaşık bir frekans
bulabiliriz; mesela bir sinüssel sinyalin 20 ölçümde bir tekrar ettiğini
bulduk, ve örneklem periyotu 0.05 milisaniye / örneklem ise (her iki
örneklem arası geçen zaman), o zaman</p>
<p><span class="math display">\[
\textrm{sinüs dalgası periyotu} =  
\frac{20 \textrm{ örneklem}}{periyot}
\frac{0.05 \textrm{ milisaniye}}{\textrm{örneklem}} = 1 milisaniye
\]</span></p>
<p>Demek ki periyot 1 / 1 milisaniye = 1 Khz. Ya örneklem periyotu 2
milisaniye olsaydı? O zaman sinüs dalga periyotu 40 milisaniye olurdu,
ve gerçek frekans 25 Hz olurdu. Söylemek istediğimiz ayrıksal durumda
Hz. bazında gerçek frekansın hesabı her zaman örneklem frekansına <span
class="math inline">\(f_s\)</span>’e bağlıdır,</p>
<p><span class="math display">\[ f_s = 1 / t_s\]</span></p>
<p>Ayrıksal Fourier Transformu</p>
<p>[4]’te sürekli Fourier Transformunu gördük,</p>
<p><span class="math display">\[ X(f) = \int_{-\infty}^{\infty} x(t)
e^{j2\pi ft} \mathrm{d} t \]</span></p>
<p>ki <span class="math inline">\(x(t)\)</span> zaman bazlı sürekli bir
sinyaldir. Bilgisayarlar sayesinde üstteki işlemi ayrıksal olarak
yapabiliyoruz [2, sf. 46],</p>
<p><span class="math display">\[ X(m) = \sum_{n=0}^{N-1} x(n) e^{-j2\pi
nm / N} \]</span></p>
<p><span class="math inline">\(x(n)\)</span> her <span
class="math inline">\(n\)</span> anında, bir <span
class="math inline">\(n\)</span> indisiyle erişilen, bir anlamda <span
class="math inline">\(x(t)\)</span>’den “örneklenmiş’’ sinyal verisi
olacaktır, <span class="math inline">\(e\)</span> tabii ki doğal
logaritma bazı, <span class="math inline">\(j\)</span> ise hayali sayı
<span class="math inline">\(j = \sqrt{-1}\)</span>. Euler ilişkisi <span
class="math inline">\(e^{-j\phi} = \cos(\phi) - j\sin(\phi)\)</span>’den
hareketle üstteki ayrıksal denklem alttakine eşittir,</p>
<p><span class="math display">\[ X(m) = \sum_{n=0}^{N-1} x(n) [
\cos(2\pi nm / N) - j \sin(2\pi nm / N)]
\qquad (1)
\]</span></p>
<p><span class="math inline">\(X(m)\)</span>: <span
class="math inline">\(m\)</span>’inci DFT bileşeni / katsayısı - <span
class="math inline">\(X(0),X(1),..\)</span> diye gidiyor</p>
<p><span class="math inline">\(m\)</span>: Frekans yöresindeki (domain)
DFT çıktısının katsayı indisi</p>
<p><span class="math inline">\(x(n)\)</span>: Zaman yöresindeki bilginin
ayrıksal verisi</p>
<p><span class="math inline">\(n\)</span>: Zaman verisi indisi</p>
<p><span class="math inline">\(N\)</span>: Giriş verisinden ve çıktı
frekans noktalarından kaç tane olduğu</p>
<p>Örnek</p>
<p>Diyelim ki elimizde biri 1 kHz ve diğeri 2 kHz’lük frekanslardan
oluşan bir sinyal var, bu sinyalin sürekli hali şöyle,</p>
<p><span class="math display">\[ x(t) = \sin(2\pi \cdot 1000 \cdot t) +
0.5 \sin (2\pi \cdot t + 3\pi/4)\]</span></p>
<p>Sinyali örnekleme oranımız <span class="math inline">\(f_s =
8000\)</span>, her saniye <span class="math inline">\(f_s\)</span> kadar
örneklem alıyoruz, her veri nokta arasındaki zaman farkı <span
class="math inline">\(t_s = 1/f_s\)</span>. Elimizdeki bu hızda ardı
ardına alınmış 8 tane veri noktası olsun, yani <span
class="math inline">\(N=8\)</span>. Ayrıksal formül,</p>
<p><span class="math display">\[ x(n) = \sin(2\pi \cdot 1000 \cdot nt_s)
+ 0.5 \sin (2\pi \cdot nt_s + 3\pi/4) \]</span></p>
<p>Bu noktalarda <span class="math inline">\(x(n)\)</span> değerleri</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>fs <span class="op">=</span> <span class="fl">8000.</span><span class="op">;</span> ts <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>fs</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> x(n):</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.sin(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span><span class="dv">1000</span><span class="op">*</span>n<span class="op">*</span>ts) <span class="op">+</span> <span class="fl">0.5</span><span class="op">*</span>np.sin(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span><span class="dv">2000</span><span class="op">*</span>n<span class="op">*</span>ts <span class="op">+</span> <span class="dv">3</span><span class="op">*</span>np.pi <span class="op">/</span> <span class="dv">4</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">8</span>): <span class="bu">print</span> (np.<span class="bu">round</span>(x(n),<span class="dv">4</span>),)</span></code></pre></div>
<pre><code>0.3536 0.3536 0.6464 1.0607 0.3536 -1.0607 -1.3536 -0.3536</code></pre>
<p>Şimdi <span class="math inline">\(x(n)\)</span> girdisine DFT
uygulayacağız. Eğer 1 kHz’un Fourier katsayılarını merak ediyorsak,
<span class="math inline">\(X(1)\)</span> hesaplarız, yani (1) formülü
kullanılacak, ki formül şuna benzer,</p>
<p><span class="math display">\[ X(1) = \sum_{n=0}^{7}  x(n)\cos(2\pi n
/ 8) - jx(n)\sin(2\pi n / 8) \]</span></p>
<p>Genel kodla gösterelim,</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> X(m):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    real <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span> imag <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">8</span>): </span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        real <span class="op">+=</span> x(n)<span class="op">*</span>np.cos(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>m<span class="op">*</span>n<span class="op">/</span><span class="fl">8.</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        imag <span class="op">-=</span> x(n)<span class="op">*</span>np.sin(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>m<span class="op">*</span>n<span class="op">/</span><span class="fl">8.</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.<span class="bu">round</span>(real,<span class="dv">4</span>), imag</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (X(<span class="dv">1</span>))</span></code></pre></div>
<pre><code>(-0.0, -4.0)</code></pre>
<p>2 kHz için ne olur?</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (X(<span class="dv">2</span>))</span></code></pre></div>
<pre><code>(1.4141999999999999, 1.4142135623730947)</code></pre>
<p>Bu sonuçlarda 1. kısım sayının reel tarafı, 2. kısmı pür kompleks
tarafı. Çoğunlukla bu elde edilen <span
class="math inline">\(X(m)\)</span> sayısının büyüklüğü (magnitude) ile
ilgileniriz, bu hesap</p>
<p><span class="math display">\[ X_{\textrm{büyüklük}} = |X(m)| =
\sqrt{X_{reel}(m)^2 + X_{kompleks}(m)^2}\]</span></p>
<p>olarak yapılıyor. <code>numpy.abs</code> çağrısı bu hesabı hayali
sayılar üzerinde otomatik olarak yapar.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>r,i <span class="op">=</span> X(<span class="dv">2</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (r,i, <span class="st">u&#39;büyüklük&#39;</span>, np.<span class="bu">abs</span>(<span class="bu">complex</span>(r,i)))</span></code></pre></div>
<pre><code>-5.55111512313e-17j büyüklük 1.99999040998</code></pre>
<p>Büyüklüğe bakılırsa 2 Khz frekansının katsayısı ufak değil, demek ki
bu frekans sinyal içinde var / önemli. 3 Khz’e bakalım,</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>r,i <span class="op">=</span> X(<span class="dv">3</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (r,i, <span class="st">u&#39;büyüklük&#39;</span>, np.<span class="bu">abs</span>(<span class="bu">complex</span>(r,i)))</span></code></pre></div>
<pre><code>-5.55111512313e-17j büyüklük 5.55111512313e-17</code></pre>
<p>Çok ufak, demek ki bu frekans sinyal içinde mevcut değil.</p>
<p>Örnekte sürekli bir formül kullanarak <span
class="math inline">\(x(n)\)</span> hesabı yapılmış olması ayrıksallığın
nerede başlayıp bittiği hakkında kafa karışıklığı yaratmasın; analitik
formül iki yöre arasında gidiş / geliş nasıl oluyor bunu göstermek için
verildi. Çoğunlukla elimizde sadece bir tek boyutlu bir dizi içinde bir
veri serisi olur, bu verinin hangi analitik formülden geldiğini bilmeyiz
(Fourier analizini onun için yapıyoruz zaten!), veri hakkında eldeki
diğer tek bilgi onun örneklem frekansı olur.</p>
<p>Bir örnek üzerinde daha görelim [3, sf. 152], bu sefer kütüphane
çağrısı <code>scipy.fft</code> ile analiz yapalım,</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>plt.figure()</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">64</span><span class="op">;</span> n <span class="op">=</span> np.arange(N) <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> T <span class="op">=</span> <span class="fl">0.05</span><span class="op">;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>w1 <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> w2 <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> n<span class="op">*</span>T<span class="op">;</span> xbn <span class="op">=</span> np.sin(w1<span class="op">*</span>t)<span class="op">+</span> <span class="fl">0.5</span><span class="op">*</span>np.sin(w2<span class="op">*</span>t)<span class="op">;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>plt.stem(t,xbn)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_1_30_08.png&#39;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb15"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>plt.figure()</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> np.arange(N) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>Xb <span class="op">=</span> scipy.fft.fft(xbn)<span class="op">;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>plt.stem(k,<span class="bu">abs</span>(Xb))</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_1_30_09.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_1_30_08.png" /></p>
<p><img src="compscieng_1_30_09.png" /></p>
<p>Üst sağdaki frekans analizine göre <span
class="math inline">\(k=2\)</span> ve <span
class="math inline">\(5\)</span>’te büyüklük var, bu değerler <span
class="math inline">\(k\omega_0 = 2\pi k / NT\)</span> ile <span
class="math inline">\(\pi\)</span> bazına çevirilebilir, <span
class="math inline">\(k=2\)</span> için <span class="math inline">\(2\pi
k / 3.2 = 1.25 \pi\)</span> olur, <span
class="math inline">\(k=5\)</span> için <span
class="math inline">\(3.125 \pi\)</span> elde ederiz.</p>
<p>Ders 15</p>
<p>[Strang hocanın notlarından. Üstteki DFT yöntemi toplamlar, döngüler,
belli indisler kullanarak yapılıyor. Altta Strang’in anlattığı
yaklaşımla, bir sinyalin belli frekansların katsayılarla ağırlıklanmış
toplamı olduğu temel Fourier formülüyle başlarız, fakat diğer yöne
gitmek için pür lineer cebir kullanırız, böylece katsayı hesabı bir
matris tersi alma işlemi haline gelir].</p>
<p>Ayrıksal (discrete) olarak Fourier modellemesi yapmak istiyorsak,
elimizde devamlı (continuous) f(x) fonksiyonu olmayacak, bir f(x)
fonksiyonun belli noktalarındaki değerleri (olduğunu farzettiğimiz)
verileri içeren bir {} olacak. Bu vektörün N elemanı var diyelim.
Fonksiyon periyodik olduğuna göre, x için <span
class="math inline">\(2\pi\)</span>’i N eşit parçaya böleriz (tahtadan
alınan resim altta). Bunu söylemekle fonksiyonun periyotunun <span
class="math inline">\(N\)</span> olduğunu farz etmiş oluyoruz, bir
anlamda diyoruz ki eğer elimizde <span class="math inline">\(N\)</span>
tane daha nokta olsaydı, onlar elimizde olan değerlerle tıpatıp aynı
olacaktı. Örneğimizde N=4 olsun.</p>
<p><img src="compscieng_1_30_01.png" /></p>
<p>Ayrıca <span class="math inline">\(F(x)\)</span> formülü biraz
değişecek. Elimizde sonsuz tane nokta olmadığına göre</p>
<p><span class="math display">\[ F(x) = \sum_{n=0}^{N} c_ne^{inx}
\]</span></p>
<p>olması lazım. Şimdi, eğer bütün <span
class="math inline">\(c_k\)</span> değerlerini biliyor olsaydık, bu
fonksiyon, x=0 noktasında hangi değere sahip olurdu?</p>
<p><span class="math display">\[ f(0) = c_0 + c_1 + c_2 + c_3 + c_4 =
Y_0 \]</span></p>
<p>Sonraki <span class="math inline">\(x\)</span> değerleri <span
class="math inline">\(2\pi/N, 4\pi/N, ..\)</span> için (çünkü her parça
<span class="math inline">\(2\pi/N\)</span>, bir sonraki parça <span
class="math inline">\(2\pi/N + 2\pi/N\)</span>, bir kere topluyoruz,
yani parçayı <span class="math inline">\(2\)</span> ile çarpıyoruz,
sonra <span class="math inline">\(3\)</span> ile, vs) aşağıdaki gibi
devam edeceğiz, ama ondan önce bir <span
class="math inline">\(w\)</span> değişkeni tanımlayalım, bu değişkeni
<span class="math inline">\(w=e^{2\pi i/N}\)</span> olarak alalım.
Böylece <span class="math inline">\(w^2\)</span> dediğimizde üstel
işlemlerde çarpım işlemi toplama işlemine dönüşeceği için <span
class="math inline">\(e^{4i\pi/N}\)</span> değeri elde edilebilir, <span
class="math inline">\(w^3\)</span> ile <span
class="math inline">\(e^{6i\pi/N}\)</span> elde edilir, vs. Bu değerler
bize lazım olacak değerler, <span class="math inline">\(w\)</span>
sayesinde formüller daha temiz olacak. <span
class="math inline">\(F(2\pi/N)\)</span> içindeki 3. terim (<span
class="math inline">\(n=2\)</span>) nedir? <span
class="math inline">\(c_ne^{inx} = c_2e^{2i2\pi/N} = c_2e^{4i\pi/N} =
c_2w^2\)</span>. O zaman</p>
<p><span class="math display">\[ f(2\pi/N) = c_o + wc_1 + w^2c_2 +
w^3c_3 = Y_1 \]</span></p>
<p>Devam edelim:</p>
<p><span class="math display">\[ f(4\pi/N) = c_o + w^2c_1 + w^4c_2 +
w^6c_3 = Y_2  \]</span></p>
<p><span class="math display">\[ f(6\pi/N) = c_o + w^3c_1 + w^6c_2 +
w^9c_3 = Y_3  \]</span></p>
<p>Elimizdeki dört toplam işlemine bakınca, bu toplamlar ve çarpımların
aslında lineer cebir üzerinden matrisler ile gösterilebildiğini
farkedebiliriz.</p>
<p><span class="math display">\[  
\left[ \begin{array}{c}
    Y_0 \\
    Y_1 \\
    Y_2 \\
    Y_3
\end{array} \right]
=
\left[ \begin{array}{cccc}
    1 &amp; 1 &amp; 1 &amp; 1 \\
    1 &amp; w &amp; w^2 &amp; w^3  \\
    1 &amp; w^2 &amp; w^4 &amp; w^6  \\
    1 &amp; w^3 &amp; w^6 &amp; w^9  
\end{array} \right]
\left[ \begin{array}{c}
    c_0 \\
    c_1 \\
    c_2 \\
    c_3
\end{array} \right] \\
\]</span></p>
<p>Her matris için bir değişken kullanırsak</p>
<p><span class="math display">\[ Y = WC \]</span></p>
<p>F(x)’ten (yani Y’den) C’ye gitmek istersek, elimizde <span
class="math inline">\(Y_n\)</span> değerleri var, <span
class="math inline">\(w\)</span> değerleri zaten sabittir, W bu sabit
değere göre oluşturulur, o zaman, <span
class="math inline">\(c_n\)</span> sayılarını nasıl buluruz?</p>
<p><span class="math display">\[ Y = WC  \]</span></p>
<p><span class="math display">\[ W^{-1}Y = W^{-1}WC  \]</span></p>
<p><span class="math display">\[ W^{-1}Y = C \]</span></p>
<p>Yani <span class="math inline">\(W\)</span> matrisinin tersini
(inverse) alıp, onu <span class="math inline">\(Y\)</span> ile çarpınca
elimize <span class="math inline">\(C\)</span> değerleri geçecek [1, sf.
340-370].</p>
<p>Güneş Benekleri</p>
<p>Güneşte periyodik olarak olan benekler, aşağı yukarı 11 senede bir
ortaya çıkarlar. Bu benekler uzun süredir gözlenmekte ve ölçülmektedir,
şiddetlerine göre, <code>sunspots.dat</code> adlı dosyada
bulabiliriz.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>tempdata <span class="op">=</span> np.loadtxt(<span class="st">&#39;sunspots.dat&#39;</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>year<span class="op">=</span>tempdata[:,<span class="dv">0</span>]</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>sunspots<span class="op">=</span>tempdata[:,<span class="dv">1</span>]</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="co">#year=year[year&lt;2001]</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>sunspots<span class="op">=</span>sunspots[year<span class="op">&lt;</span><span class="dv">2001</span>]</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>plt.plot(year[year<span class="op">&lt;</span><span class="dv">2001</span>],sunspots)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">u&#39;Güneş Benekleri&#39;</span>)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_1_30_03.png&#39;</span>)</span></code></pre></div>
<p><img src="compscieng_1_30_03.png" /></p>
<p>Benek verisindeki periyodik oluşu Fourier transformu ile analiz
edelim. Alttaki kod <span class="math inline">\(w\)</span>, <span
class="math inline">\(W\)</span>’yi kullanarak üstteki çarpımlarla <span
class="math inline">\(C\)</span> vektörünü bulacak. Bu vektör içindeki
sayılar Fourier analizindeki belli frekanslara, harmoniklere tekabül
ediyor olacaklar. Bu <span class="math inline">\(C\)</span> değerlerinde
bazıları diğerlerinden daha güçlü bir etkidir, mesela 11 senelik periyot
C içinde daha belirgin olarak çıkmalı.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>tempdata <span class="op">=</span> np.loadtxt(<span class="st">&quot;sunspots.dat&quot;</span>)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>year<span class="op">=</span>tempdata[:,<span class="dv">0</span>]</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>Y<span class="op">=</span>tempdata[:,<span class="dv">1</span>]</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="bu">len</span>(Y)</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> np.exp((<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span><span class="ot">1j</span>)<span class="op">/</span>N)</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>W <span class="op">=</span> np.zeros((N,N), <span class="bu">complex</span>)</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>        W[i,k] <span class="op">=</span> w<span class="op">**</span>(i<span class="op">*</span>k)</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> np.dot(np.linalg.inv(W), Y) </span></code></pre></div>
<p>Periyotların grafiği,</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>n<span class="op">=</span><span class="bu">len</span>(Y)<span class="op">;</span> <span class="bu">print</span> (<span class="st">&#39;n=&#39;</span>,n)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>power <span class="op">=</span> np.<span class="bu">abs</span>(C[<span class="dv">0</span>:<span class="bu">int</span>(n<span class="op">/</span><span class="dv">2</span>)])<span class="op">**</span><span class="dv">2</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>nyquist <span class="op">=</span> <span class="fl">1.</span><span class="op">/</span><span class="dv">2</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>freq <span class="op">=</span> np.array(<span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">float</span>, np.array(<span class="bu">range</span>(<span class="dv">0</span>,<span class="bu">int</span>(n<span class="op">/</span><span class="dv">2</span>)))))) <span class="op">/</span> (n<span class="op">/</span><span class="dv">2</span>)<span class="op">*</span>nyquist</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;len(freq)=&#39;</span>,<span class="bu">len</span>(freq))</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>period<span class="op">=</span><span class="fl">1.</span><span class="op">/</span>freq<span class="op">;</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>plt.plot(period,power)</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">0</span>,<span class="dv">30</span>)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;compscieng_1_30_02.png&#39;</span>)</span></code></pre></div>
<pre><code>n= 305
len(freq)= 152</code></pre>
<p><img src="compscieng_1_30_02.png" /></p>
<p>11 sene civarında belirgin bir frekans olduğunu görebiliyoruz.</p>
<p>FFT</p>
<p>Bitirmeden önce FFT konusundan bahsedelim. <span
class="math inline">\(*D*\)</span>FT algoritması kodda görüldüğü gibi
bir W matrisi ortaya çıkarır ve önce tersini alma, sonra bu ters ile bir
çarpım işlemi yaparak C sonucunu üretir. <span
class="math inline">\(O\)</span> notasyonunu kullanırsak DFT’nin
karmaşıklığı <span class="math inline">\(O(N^2)\)</span>’dir. Bu iyi bir
hızdır.</p>
<p>FFT algoritması üstteki çarpımın bazı özelliklerini kullanarak DFT’yi
daha da hızlandırır ve <span
class="math inline">\(O(\frac{1}{2}Nlog_2N)\)</span> hızına getirir.
FFT’den bu makalede bahsetmeyeceğiz, aklımızda olsun,
<code>scipy.fft.fft</code> çağrısı bu algoritmayı kullanır, örnek:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> scipy.fft.fft(Y)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (C[:<span class="dv">3</span>])</span></code></pre></div>
<pre><code>[ 15318.00000000   +0.j           1153.09522938 +866.74784921j
    -72.35158374+1347.22954505j]</code></pre>
<p>Soru</p>
<p>FFT yaklaşıksal bir algoritma mıdır? Yani DFT’nin elde değerlere
“yakın’’ değerler daha hızlı mı hesaplanıyor?</p>
<p>Cevap</p>
<p>FFT ile DFT tıpatıp aynı katsayıları hesaplıyorlar, FFT sadece bu
hesabı daha hızlı yapıyor.</p>
<p>Lomb-Scargle</p>
<p>Daha önceki bir yazida güneş beneklerinin ortaya çıkışı verisinde
periyotlar bulmak için Fourier analizi kullanmıştık. Bu analizin eksik
bir tarafı istatistiki önemlilik (significance) hesabını göstermemesi.
Daha iyi bir yöntem Lomb-Scargle yöntemi, ki bu yönteme göre periyot
bulmak pek çok sinüs eğrisinin hangilerinin veriye daha iyi uyduğunu
bulma problemine çeviriliyor, problem bir tür en az kareler çözümü
haline geliyor, arka planda FFT kullanılıyor fakat problemin ana modeli
artık FFT değil. Güneş benekleri,</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>tempdata <span class="op">=</span> np.loadtxt(<span class="st">&#39;sunspots.dat&#39;</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>year<span class="op">=</span>tempdata[:,<span class="dv">0</span>]<span class="op">;</span> sunspots<span class="op">=</span>tempdata[:,<span class="dv">1</span>]</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co">#year=year[year&lt;2001]</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>sunspots<span class="op">=</span>sunspots[year<span class="op">&lt;</span><span class="dv">2001</span>]</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>plt.plot(year[year<span class="op">&lt;</span><span class="dv">2001</span>],sunspots)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">u&#39;Güneş Benekleri&#39;</span>)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_ar_06.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_ar_06.png" /></p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> astroML.time_series <span class="im">import</span> lomb_scargle</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>omega <span class="op">=</span> np.linspace(<span class="dv">1</span>, <span class="dv">40</span>, <span class="dv">200</span>)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>dy <span class="op">=</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> np.random.random(<span class="bu">len</span>(sunspots))</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>sig <span class="op">=</span> np.array([<span class="fl">0.1</span>, <span class="fl">0.01</span>, <span class="fl">0.001</span>])</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>PS, z <span class="op">=</span> lomb_scargle(year[year<span class="op">&lt;</span><span class="dv">2001</span>], sunspots, dy, omega, generalized<span class="op">=</span><span class="va">True</span>, significance<span class="op">=</span>sig)</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>plt.plot(omega,PS)</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>xlim <span class="op">=</span> (omega[<span class="dv">0</span>], omega[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> zi, pi <span class="kw">in</span> <span class="bu">zip</span>(z, sig):</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    plt.plot(xlim, (zi, zi), <span class="st">&#39;:k&#39;</span>, lw<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>    plt.text(xlim[<span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> <span class="fl">0.001</span>, zi <span class="op">-</span> <span class="fl">0.02</span>, <span class="st">&quot;$</span><span class="sc">%.1g</span><span class="st">$&quot;</span> <span class="op">%</span> pi, ha<span class="op">=</span><span class="st">&#39;right&#39;</span>, va<span class="op">=</span><span class="st">&#39;top&#39;</span>)</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">u&#39;Güneş Benekleri Periyotları&#39;</span>)</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_ar_07.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_ar_07.png" /></p>
<p>Grafikte 0.1, 0.01, 0.001 önemliliğini yatay çizgiler olarak
görüyoruz; bu çizgilerin üzerindeki her tepe noktası önemli bir
periyottur.</p>
<p>Bir diğer örnek: Altta dünyada 500 kusur milyon yıl geriye giden
canlı tükenme yüzde grafiği görülüyor [7]. Mesela yaklaşık 66 milyon
sene önce bir göktaşı çarpmasıyla müthiş bir tükeniş yaşandı, zaten
dinazorların yokolması bu olay ile oldu. Bu olay grafikte açık bir
şekilde görülüyor.</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>ext <span class="op">=</span> pd.DataFrame(pd.read_csv(<span class="st">&#39;../../tser/tser_020_ar/extinct.csv&#39;</span>,header<span class="op">=</span><span class="va">None</span>))</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>ext2 <span class="op">=</span> ext.set_index(np.linspace(<span class="dv">542</span>,<span class="dv">1</span>,<span class="bu">len</span>(ext)))</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>ext2[<span class="dv">0</span>].plot()</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>ext <span class="op">=</span> ext[<span class="dv">0</span>]</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_ar_09.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_ar_09.png" /></p>
<p>Soru şu: acaba bu verideki periyotlar hangileri? Tükenişte belli
periyotlar var mı?</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> astroML.time_series <span class="im">import</span> lomb_scargle</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>dy <span class="op">=</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> np.random.random(<span class="bu">len</span>(ext))</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>omega <span class="op">=</span> np.linspace(<span class="dv">10</span>, <span class="dv">100</span>, <span class="dv">1000</span>)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>sig <span class="op">=</span> np.array([<span class="fl">0.1</span>, <span class="fl">0.01</span>, <span class="fl">0.001</span>])</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>PS, z <span class="op">=</span> lomb_scargle(ext.index, ext, dy, omega, generalized<span class="op">=</span><span class="va">True</span>, significance<span class="op">=</span>sig)</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>plt.plot(omega,PS)</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>xlim <span class="op">=</span> (omega[<span class="dv">0</span>], omega[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> zi, pi <span class="kw">in</span> <span class="bu">zip</span>(z, sig):</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    plt.plot(xlim, (zi, zi), <span class="st">&#39;:k&#39;</span>, lw<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    plt.text(xlim[<span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> <span class="fl">0.001</span>, zi <span class="op">-</span> <span class="fl">0.02</span>, <span class="st">&quot;$</span><span class="sc">%.1g</span><span class="st">$&quot;</span> <span class="op">%</span> pi, ha<span class="op">=</span><span class="st">&#39;right&#39;</span>, va<span class="op">=</span><span class="st">&#39;top&#39;</span>)</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">u&#39;Canlıların Tükenme Periyotları&#39;</span>)</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;tser_ar_08.png&#39;</span>)</span></code></pre></div>
<p><img src="tser_ar_08.png" /></p>
<p>Grafiğe göre yaklaşık 25 milyon, 70 milyon yılda bir rutin tükenişler
görülüyor.</p>
<p>Kaynaklar</p>
<p>[1] Strang, <em>Computational Science and Engineering</em></p>
<p>[2] Lyons, <em>Understanding Digital Signal Processing, 2nd
Edition</em></p>
<p>[3] Wang, <em>Applied Numerical Methods Using Matlab</em></p>
<p>[4] Bayramlı, Diferansiyel Denklemler, <em>Ders 15</em></p>
<p>[7] Bayramlı, <em>Grafikten Veri Çıkartmak</em>, <a
href="https://burakbayramli.github.io/dersblog/sk/2017/01/grafikten-veri-cikartmak.html">https://burakbayramli.github.io/dersblog/sk/2017/01/grafikten-veri-cikartmak.html</a></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
