<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  
  
  
  
</head>
<body>
<h1 id="ders-1">Ders 1</h1>
<p>Bir vektör, yön ve büyüklük (magnitude) bilgisi taşıyan bir ölçümdür.</p>
<div class="figure">
<img src="1_1.png" />

</div>
<p>Üç boyutlu bir ortamda x,y,z eksenleri üzerinden üstteki gibi bir vektör çizebiliriz. Bu vektör (ok istikametinde) bir yönü gösteriyor, ayrıca bir büyüklüğü de var. Vektörü bu eksenler içinde çizince, o vektörü her eksendeki yansımasına göre temsil edebilirim demektir; x yönünde ne kadar değişim var, y yönünde ne kadar var, vs. gibi.</p>
<p>Bir vektörün temsili için, <span class="math inline">\(\vec{A}\)</span> gibi üzerinde ok işareti bulunan bir büyük harf kullanacağız. Bazı kitaplarda üzerinde ok bulunan bir harf yerine koyu puntoyla yazılmış harfler kullanılıyor olabilir. Bunun tarihi sebepleri vardır, eski zamanlarda matbaalarda basım yaparken koyu harf (bold) yapmak üzerine ok çizmekten çok daha kolaydı.</p>
<p>Biraz önce de bahsettiğimiz gibi, bir vektörü bir uzayın eksenleri üzerindeki yansı-maları yardımıyla ifade edebiliriz. Mesela aşağıda gösterildiği gibi, üç boyutlu uzayda tanımlanmış bir vektörü bu şekilde uzayın eksenleri üzerine yaptığı yansı-maların büyüklüğü ve uzayın eksenlerinin yönünü belirten bir birimlik birim vektörler yardımıyla gösterebiliriz.</p>
<p><span class="math display">\[
\vec{A} = a_1 \hat{i} + a_2 \hat{j} + a_3 \hat{k}
\]</span></p>
<p>Burada dikkat etmemiz gereken şey, birim vektörler sadece kendi eksenlerinin yönünü göstermek üzere tasarlanmıştır. Bu yüzden diğer eksenler üzerinde hiç bir değişime (büyüklüğe) sahip değillerdir. Mesela <span class="math inline">\(\hat{i}\)</span>, x ekseni üzerinde 1 adımlık bir büyüklüktür, diğerlerinde değişim sıfırdır, gelin <span class="math inline">\(\hat{i} = &lt; 1,0,0 &gt;\)</span> ifadesinin gerçekten doğru olup olmadığına bakalım. Eğer <span class="math inline">\(&lt; 2,3,5 &gt;\)</span> vektörünü eksenlerine ayırıp göstermek isteseydik, bunu <span class="math inline">\(2\cdot&lt; 1,0,0 &gt; + 3\cdot&lt; 0,1,0 &gt; + 5\cdot&lt; 0,0,5 &gt;\)</span> ile yapabilirdik. Toplam <span class="math inline">\(&lt; 2,3,5 &gt;\)</span> olacaktır.</p>
<p>Hazır bahsetmişken, diğer vektör notasyonu şu şekildedir</p>
<p><span class="math display">\[
\vec{A} = &lt; a_1, a_2, a_3 &gt;
\]</span></p>
<p>Farketmiş olacağınız gibi <span class="math inline">\(a_1\)</span>, <span class="math inline">\(a_2\)</span> ve <span class="math inline">\(a_3\)</span>, sırasıyla <span class="math inline">\(\vec{A}\)</span> vektörünün <span class="math inline">\(\hat{i}\)</span>, <span class="math inline">\(\hat{j}\)</span>, <span class="math inline">\(\hat{k}\)</span> eksenleri üzerindeki yansımalarının büyüklüğüdür. Bir vektörün büyüklüğü <span class="math inline">\(|\vec{A}|\)</span> ifadesi ile gösterilir, ki <span class="math inline">\(|\cdot|\)</span> işareti mutlak değer gösterimi (absolute value) ile aynıdır. Bir vektörün büyüklüğü skaler (scalar) bir sayı ile ifade edilir. Bir vektörün yönü, ki bu bazen <span class="math inline">\(dir(\vec{A})\)</span> ile gösterilir, vektörün birim vektör haline getirilmesi ile elde edilir, yani vektörün tüm öğelerinin vektörün büyüklüğüne bölünmesi ile. Bu yapılınca vektör büyüklük bilgisi kaybolmuş olur tabii, geriye sadece yön bilgisi kalır.</p>
<p>Herhangi bir uzayda <span class="math inline">\(P\)</span> ve <span class="math inline">\(Q\)</span> gibi iki nokta arasındaki bir vektörü <span class="math inline">\(\vec{PQ}\)</span> olarak gösterebilirim. Fakat bu illa ki <span class="math inline">\(P\)</span>'den başlayıp <span class="math inline">\(Q\)</span>'ye gelmem gerektiği anlamına gelmez, aynı yönde aynı uzunlukta paralel bir başka vektör de <span class="math inline">\(\vec{PQ}\)</span> vektörü olabilir. Bu derste pek çok vektörü orijin (başlangıç) noktasından (0,0,0) başlayarak çizeceğiz, fakat aslında bunu yapmak zorunda değiliz. Fakat görsel ifadenin basit olması açısından öyle yapacağız.</p>
<div class="figure">
<img src="1_2.png" />

</div>
<p>Şimdi alttaki grafiğe bakalım. Uzunluk nedir?</p>
<div class="figure">
<img src="1_3.png" />

</div>
<p>Yani <span class="math inline">\(\vec{A} = &lt;3,2,1&gt;\)</span>'in uzunluğu nedir? Bu uzunluğu bulmak için ikinci bir resme bakalım:</p>
<div class="figure">
<img src="1_4.png" />

</div>
<p>Burada <span class="math inline">\(\vec{A}\)</span>'nin xy düzlemine olan yansımasını <span class="math inline">\(\vec{B}\)</span> olarak düşünelim, <span class="math inline">\(\vec{A}\)</span>'nın sadece xy değerlerini taşıyan hali yani <span class="math inline">\(\vec{B} = &lt;3,2&gt;\)</span>. Şimdi <span class="math inline">\(\vec{A}\)</span> ve <span class="math inline">\(\vec{B}\)</span>'nin ikisinin de üzerinde olduğu ve bir tarafı z ekseni olan bir kesiti hayal edelim. Bu kesiti ayırıp alttaki gibi çizebiliriz:</p>
<div class="figure">
<img src="1_5.png" />

</div>
<p>Görüldüğü gibi <span class="math inline">\(\vec{A}\)</span> ve <span class="math inline">\(\vec{B}\)</span> arasında z bağlamında 1 birimlik bir fark var, bu da <span class="math inline">\(\vec{A} = &lt;3,2,1&gt;\)</span> vektörünü <span class="math inline">\(\vec{B}=&lt;3,2&gt;\)</span> olarak alırken dahil etmediğimiz 1 değeri.</p>
<p>Üstteki grafiğe bakarsak Pisagor teoremini kullanarak <span class="math inline">\(|\vec{A}|\)</span>'yi bulabiliriz. Pisagor teoremine göre <span class="math inline">\(|\vec{A}|^2 = |\vec{B}|^2 + 1^2\)</span>'dir. Demek ki problem <span class="math inline">\(|\vec{B}|\)</span>'nin hesaplanmasına indirgendi,çünkü onu bulursak üstteki formülden <span class="math inline">\(|\vec{A}|\)</span>'yi da bulabiliriz. Peki <span class="math inline">\(|\vec{B}|\)</span> nedir? Onu da xy düzleminde / kesitinde Pitagor kullanarak bulabiliriz, <span class="math inline">\(|\vec{B}|\)</span>, x ekseninde 3 birimlik, y ekseninde ise 2 birimlik adımlar içeriyor.</p>
<p>Pisagor Teoremi'ni kullanarak</p>
<p><span class="math display">\[
|\vec{B}| = \sqrt{3^2 + 2^2} = \sqrt{13}
\]</span></p>
<p><span class="math display">\[
|\vec{A}| = \sqrt{|\vec{B}|^2 + 1^2} = \sqrt{13 + 1} = \sqrt{14}
\]</span></p>
<p>Genel formülü ise</p>
<p><span class="math display">\[
|\vec{A}| = \sqrt{a_1 ^2 + a_2^2 + a_3^2}
\]</span></p>
<p>olarak ifade edebiliriz.Vektörlerle başka ne yapabiliriz? Onları ekleyebiliriz, veya ölçeklendirebiliriz.</p>
<p>Ekleme işlemi</p>
<p>Elimizde <span class="math inline">\(\vec{A}\)</span> ve <span class="math inline">\(\vec{B}\)</span> var ise, <span class="math inline">\(\vec{A} + \vec{B}\)</span> işlemini gerçekleştirebiliriz.</p>
<p>Bu noktada şu yorumu eklemek gerekir, vektörler iki farklı dünyada yaşarlar, bir tanesi geometrik dünya, diğeri cebirsel dünya. Bu sebeple vektörler hakkındaki her sorunun iki cevabı vardır, geometrik ve cebirsel cevap.</p>
<p>Geometrik cevap ile başlayalım:</p>
<p>Diyelim ki iki vektörü aynı noktadan çıkacak şekilde çizmiştim</p>
<div class="figure">
<img src="1_6.png" />

</div>
<p>Toplamı almak için <span class="math inline">\(\vec{B}\)</span>'yi alıp hareket ettiririm (başlangıç bitiş noktalarının önemli olmadığını söylemiştik), ve <span class="math inline">\(\vec{A}\)</span>'nin bittiği noktadan başlamasını sağlarım.</p>
<div class="figure">
<img src="1_7.png" />

</div>
<p>Bunun bir paralelogram ortaya çıkardığını görüyoruz.</p>
<div class="figure">
<img src="1_8.png" />

</div>
<p>Eğer bu paralelogramın köşegenini hesaplarsak / çizersek, işte bu köşegen <span class="math inline">\(\vec{A} + \vec{B}\)</span> olarak nitelenebilir.</p>
<div class="figure">
<img src="1_9.png" />

</div>
<p>Yani bu iki vektörün birbiriyle toplanması için öteleme işlemini ister <span class="math inline">\(\vec{A}\)</span> vektörü için, isterse de <span class="math inline">\(\vec{B}\)</span> vektörü için yapayım sonuç farketmeyecektir. Böylece, <span class="math inline">\(\vec{A} + \vec{B} = \vec{B} + \vec{A}\)</span> eşitliğini grafiksel olarak böylece doğrulamış olduk.</p>
<p>Sayısal olarak düşünürsek:</p>
<p><span class="math display">\[ \vec{A} = &lt; a_1, a_2, a_3 &gt; \]</span></p>
<p><span class="math display">\[ \vec{B} = &lt; b_1, b_2, b_3 &gt; \]</span></p>
<p><span class="math display">\[ \vec{A} + \vec{B} = &lt; a_1+b_1, a_2+b_2, a_3+b_3 &gt; \]</span></p>
<p>Ölçeklendirme(sayı ile çarpım) işlemi</p>
<p>Eğer elimizde <span class="math inline">\(\vec{A}\)</span> var ise, <span class="math inline">\(2 \cdot \vec{A}\)</span> işlemi ile vektörün aynı yöndeki büyüklüğünü iki katına çıkarabiliriz. Ya da <span class="math inline">\(0.5\)</span> ile çarparak büyüklüğünü yarıya düşürebiliriz veya negatif bir sayı ile çarparak vektörün yönünü tersine çevirip büyüklüğünü de negatif sayının büyüklüğü kadar değiştirebiliriz.</p>
<div class="figure">
<img src="1_10.png" />

</div>
<p>Şimdi vektörler hakkında birkaç yeni operasyon daha öğreneceğiz. Bu operasyonlar geometriye daha detaylı şekilde başlayınca işimize yarayacak. İleride göreceğimiz gibi, geometri vektörler üzerinden yapılabilir, hatta pek çok açıdan, geometri ile çalışmak için vektörlerin &quot;en uygun dil'' olduğu söylenebilir. Özellikle fonksiyonlar konusuna gelince vektörler kullanmak, diğer tür geometrik işlemleri kullanmaktan daha faydalı olacak.</p>
<p>Tüm bunlar bir tür &quot;dil'', bir şeyin farklı bir şekillerde temsilinden ibaret, vektörler, fonksiyonlar, vs. gibi temsili objeler. Fakat farklı gösterimler, bazı şeyleri kolaylaştırmak açısından kolaylık sağlayabiliyor.</p>
<p>Nokta çarpım (Skalar çarpım)</p>
<p>Nokta çarpım, iki veya daha fazla vektörün bileşenlerinin çarpılıp toplanması ile bulunur. Burada dikkat edilmesi gereken nokta, bu işlemin sonucunun bir vektör değil, skaler bir sayı olmasıdır. Nokta çarpımın matematiksel gösterimi ise</p>
<p><span class="math display">\[
\vec{A} \cdot \vec{B} = \sum a_ib_i = a_1b_1 + a_2b_2 + a_3b_3 
\qquad (1)
\]</span></p>
<p>şeklindedir.</p>
<p>Peki bu operasyon niye kullanılır? Neye yarar? Aslında biraz garip bir operasyon. Bu sorunun cevabını vermeden önce belki de geometrik olarak ne yaptığını göstermek daha iyi olur. Aşağıdaki eşitlik nokta çarpımın geometrik bir özelliğidir.</p>
<p><span class="math inline">\(\theta\)</span> iki vektör arasındaki açı olmak üzere;</p>
<p><span class="math display">\[
\vec{A} \cdot \vec{B} = |\vec{A}||\vec{B}| \cos \theta 
\qquad (2)
\]</span></p>
<p>gibi bir eşitlik sağlanabilir.</p>
<p>Fakat dediğimiz gibi, bu operasyon çok suni bir şey gibi duruyor. Niye bu çetrefilli operasyonu yapalım ki? Şu sebepten ki, elde ettiğimiz sonuç, <span class="math inline">\(\vert\vec{A}\vert \vert\vec{B}\vert \cos \theta\)</span> eşitliği üzerinden bize hem büyüklükler anlamında, hem de açısal anlamda bilgi veriyor. Ekstra bir bonus ise bu hesabın çok kolay yapılabilmesi, iki vektörün öğelerini teker teker birbiriyle çarpınca noktasal çarpım sonucunu elde ediyoruz.</p>
<p>Fakat noktasal çarpım ve büyüklük, açı içeren formül arasında ne bağlantı var? Matematikte bu tür bağlantıların ispatlanması gerekir. Üstteki eşitlik bir teoridir (bu dersin ilk teorisi!). Hadi bunu ispatlayalım. İçinde büyüklük ve açı içeren geometrik tanım ne anlama geliyor? Alttaki ifade üzerinden kontrol edelim. Eğer <span class="math inline">\(\vec{A}\)</span>'nin kendisi ile noktasal çarpımını alsak ne olurdu?</p>
<p><span class="math display">\[\vec{A} \cdot \vec{A} = |A|^2\cos(0) = |A|^2\]</span></p>
<p><span class="math inline">\(\cos(0)\)</span> çünkü, vektörün kendisi ile arasındaki açı sıfırdır. Sıfırın <span class="math inline">\(\cos\)</span> değeri 1'dir. Peki diğer formu kullansaydık ne olacaktı? O zaman</p>
<p><span class="math display">\[ a_1^2 + a_2^2 + a_3^2 \]</span></p>
<p>ifadesini elde edecektik, ki bu ifade <span class="math inline">\(|A|^2\)</span>'ye eşittir çünkü büyüklüğün tanımını hatırlarsak</p>
<p><span class="math display">\[ |\vec{A}| = \sqrt{a_1 ^2 + a_2^2 + a_3^2} \]</span></p>
<p>iki tarafın da karesini alırsak</p>
<p><span class="math display">\[ |\vec{A}|^2 = a_1 ^2 + a_2^2 + a_3^2\]</span></p>
<p>bu ifadenin sağ tarafı noktasal çarpımdan elde ettiğimizle aynı.</p>
<p>Peki ya elimizde iki farklı vektör varsa?</p>
<p>İddiam şu ki formül (1) ve (2) arasındaki ilişkiyi Kosinüs Kanunu ile kurabilirim. Bu kanunu yazalım</p>
<div class="figure">
<img src="1_11.png" />

</div>
<p><span class="math display">\[ |\vec{C}|^2 = |\vec{A}|^2 + |\vec{B}|^2 - 2|\vec{A}||\vec{B}|\cos(\theta) \]</span></p>
<p>Bu arada, eğer bu formülü</p>
<p><span class="math display">\[ |\vec{C}|^2 = |\vec{A}|^2 + |\vec{B}|^2  \]</span></p>
<p>şeklinde yazsaydım Pisagor Formülü olurdu, fakat burada Pisagor kullanamayız çünkü arada dik açı yok, o yüzden üçüncü terimi eklemek gerekti.</p>
<p>İspata gelirsek,</p>
<p>Şöyle başlayalım</p>
<p><span class="math display">\[ |\vec{C}|^2 = \vec{C} \cdot \vec{C} \]</span></p>
<p>Bunun doğru olduğunu biliyoruz, daha önce ispatladık. <span class="math inline">\(\vec{C}\)</span>'nin üstteki tanımını yerine koyarsak</p>
<p><span class="math display">\[ = (\vec{A} - \vec{B}) \cdot (\vec{A} - \vec{B})  \]</span></p>
<p>Şimdi bu çarpımı açarak 4 terimin toplamı haline getirmek isterdik, ama bunu yapabilir miyiz? Daha bilmiyoruz, noktasal çarpım operasyonunu daha yeni gördük, gizemli yeni bir operasyon bizim için şu anda. Fakat cevap evet, çünkü formül (1)'deki tanıma bakarsak, açılım yapmak için bize gerekli şekilde davranacağını görebiliriz. O zaman</p>
<p><span class="math display">\[  =
\vec{A}\cdot\vec{A} - 
\vec{A}\cdot\vec{B} -
\vec{B}\cdot\vec{A} +
\vec{B}\cdot\vec{B} 
\]</span></p>
<p>İlk ve son terimin karşılığını hemen yazabiliriz, alttaki ilk iki terim onlar zaten</p>
<p><span class="math display">\[ = |\vec{A}|^2 + |\vec{B}|^2 - 2\vec{A} \cdot \vec{B} \]</span></p>
<p>Geride kalan en son terimi, son formül içindeki <span class="math inline">\(\cos\)</span> içeren formül ile karşılaştıralım, aralarındaki tek fark, bir tarafta <span class="math inline">\(2\vec{A} \cdot \vec{B}\)</span> diger tarafta <span class="math inline">\(2|\vec{A}||\vec{B}|\cos(\theta)\)</span> olması.. Ve formül (2)'deki eşitlikten bu iki terimin de aslında birbirine eşit olduğunu biliyoruz.</p>
<p>Uygulamalar</p>
<ol style="list-style-type: decimal">
<li>Uzunlukları ve açıları (özellikle açıları) hesaplamak.</li>
</ol>
<div class="figure">
<img src="1_12.png" />

</div>
<p>Diyelim ki sol alt köşedeki <span class="math inline">\(\theta\)</span> açısını hesaplamak istiyoruz.</p>
<p><span class="math display">\[ \vec{PQ} \cdot \vec{PR} = |\vec{PQ}||\vec{PR}|\cos(\theta)  \]</span></p>
<p>Bu formülde bilinmeyen <span class="math inline">\(\theta\)</span>, özellikle de <span class="math inline">\(\cos(\theta)\)</span>. Uzunlukları hesaplayabiliriz, formülünü biliyoruz. Noktasal çarpımları da hesaplayabiliriz, onun da basit bir formülü var.</p>
<p><span class="math display">\[ \cos\theta = \frac{\vec{PQ} \cdot \vec{PR}}{|\vec{PQ}||\vec{PR}|}\]</span></p>
<p><span class="math display">\[ = \frac{&lt;-1,1,0&gt;\cdot&lt;-1,0,2&gt;}
{  \sqrt{(-1)^2+1^2+0^2 }\sqrt{(-1)^2+0^2+2^2 }   } 
\]</span></p>
<p><span class="math display">\[ = \frac{1+0+0}{\sqrt{2}\sqrt{5}}  \]</span></p>
<p><span class="math display">\[ = \frac{1}{\sqrt{10}} \]</span></p>
<p><span class="math display">\[ \theta = \cos^{-1}(\frac{1}{\sqrt{10}}) \approx 71.5^o \]</span></p>
<p>Burada <span class="math inline">\(\vec{A}\cdot\vec{B}\)</span>'nin işaretine (artı mı eksi mi) dikkat çekelim.</p>
<div class="figure">
<img src="1_13.png" />

</div>
<p>Eğer işaret <span class="math inline">\(&gt;0\)</span> ise, o zaman <span class="math inline">\(\theta &lt; 90^o\)</span> (üstteki resimdeki 1. figür).</p>
<p>Eğer işaret <span class="math inline">\(=0\)</span> ise, o zaman <span class="math inline">\(\theta = 90^o\)</span> (üstteki resimdeki 2. figür).</p>
<p>Eğer işaret <span class="math inline">\(&lt;0\)</span> ise, o zaman <span class="math inline">\(\theta &gt; 90^o\)</span> (üstteki resimdeki 3. figür).</p>
<p>Yani noktasal çarpım bir nevi iki vektörün ne kadar &quot;üst üste bindiğini'' ölçüyor. Üstte 1. şekilde birinci vektör ikinci vektör üzerine az da olsa binmiş bir şekilde görünüyor, bu yüzden de işaret pozitif. 2. şekilde ise birinci vektör ikincisine tam dik konumda bu yüzden üzerine binme gibi bir durum söz konusu değil. 3. şekilde ise birinci vektör ikinci vektörün negatif yönü üzeri binmiş görünüyor, bu yüzden de işareti negatif.</p>
<ol start="2" style="list-style-type: decimal">
<li>Diklik Kontrolu</li>
</ol>
<p>Diyelim ki size</p>
<p><span class="math display">\[ x + 2y + 3z = 0 \]</span></p>
<p>şeklinde bir formül verildi. Sizce bu formül nasıl bir şekli ortaya çıkartır? Cevaplar:</p>
<ul>
<li>Boş küme (çözüm yok)</li>
<li>Tek bir nokta</li>
<li>Bir çizgi</li>
<li>Bir düzlem</li>
<li>Bir küre (sphere)</li>
<li>Üsttekilerin hiçbiri</li>
<li>Bilmiyorum</li>
</ul>
<p>Düşünün..</p>
<p>Doğru cevap: Bir düzlem.</p>
<p>Bunun bir düzlem olduğunu nasıl görebiliriz? Vektörler burada yardımımıza yetişiyor. Bir <span class="math inline">\(\vec{OP}\)</span> vektörü olduğunu düşünelim, ki bu vektörün öğeleri <span class="math inline">\(x,y,z\)</span> olsun.</p>
<div class="figure">
<img src="1_14.png" />

</div>
<p><span class="math inline">\(x + 2y + 3z = 0\)</span> ifadesine bakarsak, onu bir noktasal çarpım olarak temsil edebiliriz, bu çarpım <span class="math inline">\(\vec{OP}\)</span> ile &quot;bir başka vektörün'' çarpımı olabilir. Bu diğer vektör <span class="math inline">\(\vec{A} = &lt;1,2,3&gt;\)</span> vektörü olabilir. O zaman şu koşul</p>
<p><span class="math display">\[ x + 2y + 3z = 0 \]</span></p>
<p>Aslında</p>
<p><span class="math display">\[ \vec{OP} \cdot \vec{A} = 0 \]</span></p>
<p>olarak ta temsil edilebilir.</p>
<p>Peki üstteki noktasal çarpımın sıfıra eşit olması ne demektir? Vektörler hakkındaki bilgilerimizi kullanırsak, sıfıra eşitlik bu iki vektörün birbirine dik olması anlamına gelir. O zaman düzlemin ne olduğu hakkında bir ek bilinç daha geliştirmiş olduk. Elde ettiğimiz orijin noktasından geçen bir düzlem ve <span class="math inline">\(\vec{A}\)</span>'ya dik.</p>
<p>Fakat elimize geçen özgün (unique) bir düzlem mi yoksa seçeneklerden sadece biri mi? Çünkü şu akla gelebilir: eğer bir vektör başlangıç olarak herhangi bir yere konulabiliyorsa, o zaman herhangi bir yerden başlayabilecek <span class="math inline">\(&lt; 1,2,3 &gt;\)</span>'ye dik olmak ne demektir?</p>
<p>İyi bir soru fakat şunu hatırlayalım: Başlangıç değişse de yön değişmiyor, yani farklı düzlemler olsa bile birbirlerine paralel olurlar. Ayrıca <span class="math inline">\(x + 2y + 3z = 0\)</span> formülüne iyi bakalım, bu formülü sağlayan pek çok <span class="math inline">\(x,y,z\)</span> değerlerinden birisi <span class="math inline">\(0,0,0\)</span> değeridir, yani orijin noktasıdır. O zaman bu düzlem orijinden kesinlikle geçmeli, ki bu mümkün düzlemleri tek bir seçeneğe indiriyor.</p>
<p>Düzlem formülü <span class="math inline">\(ax + by + cz + d= 0\)</span> diye gider, bizim formülde <span class="math inline">\(d=0\)</span>. Bu form orijinden geçme zorundadır.</p>
<p>Bu düzlemi grafiklemek için alttaki programı kullanalım</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># plotting ax + by + cz = 0, or (ax + by)/-c  = z </span>
<span class="co"># ax + by + cz = 0 formulu grafikliyoruz ya da, (ax + by)/-c  = z </span>

<span class="im">from</span> mpl_toolkits.mplot3d <span class="im">import</span> Axes3D

fig <span class="op">=</span> plt.figure()
ax <span class="op">=</span> Axes3D(fig)
X <span class="op">=</span> np.arange(<span class="op">-</span><span class="dv">10</span>, <span class="dv">10</span>, <span class="fl">0.5</span>)
Y <span class="op">=</span> np.arange(<span class="op">-</span><span class="dv">10</span>, <span class="dv">10</span>, <span class="fl">0.5</span>)
X, Y <span class="op">=</span> np.meshgrid(X, Y)

Z <span class="op">=</span> (X <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>Y ) <span class="op">/</span> <span class="dv">-3</span>

surf <span class="op">=</span> ax.plot_surface(X, Y, Z,rstride<span class="op">=</span><span class="dv">1</span>, cstride<span class="op">=</span><span class="dv">1</span>, alpha<span class="op">=</span><span class="fl">0.3</span>, color<span class="op">=</span><span class="st">&#39;yellow&#39;</span>)

ax.set_xlim3d(<span class="op">-</span><span class="dv">10</span>, <span class="dv">10</span>)
ax.set_ylim3d(<span class="op">-</span><span class="dv">10</span>, <span class="dv">10</span>)
ax.set_zlim3d(<span class="dv">0</span>, <span class="dv">30</span>)

x, y, z <span class="op">=</span> np.array([[<span class="op">-</span><span class="dv">10</span>,<span class="dv">0</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="op">-</span><span class="dv">10</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]])
u, v, w <span class="op">=</span> np.array([[<span class="dv">10</span>,<span class="dv">0</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">10</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">10</span>]])
ax.quiver(x,y,z,u,v,w,arrow_length_ratio<span class="op">=</span><span class="fl">0.1</span>, color<span class="op">=</span><span class="st">&quot;black&quot;</span>)

plt.savefig(<span class="st">&#39;plane.jpg&#39;</span>)</code></pre></div>
<div class="figure">
<img src="plane.jpg" />

</div>
</body>
</html>
