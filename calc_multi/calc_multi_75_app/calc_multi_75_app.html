<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>

  <title>Green'in Teorisi, Düzlem Kesişmeleri, Eğriler</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  
  
  
  
</head>
<body>
<h1 id="greenin-teorisi-düzlem-kesişmeleri-eğriler">Green'in Teorisi, Düzlem Kesişmeleri, Eğriler</h1>
<p>Çizgi Parçası ve bir 3D Üçgenin Kesişmesi</p>
<p>Bir çizgi parçasını temsil etmek için <span class="math inline">\(s\)</span> başlangıç noktasından <span class="math inline">\(t\)</span> varış noktasına giden bir ışın (ray) hayal edelim, bu çizgi parçası üzerindeki herhangi bir <span class="math inline">\(x\)</span> noktası [9, sf. 84]</p>
<p><span class="math display">\[
x = s + \lambda (t-s) \quad 0 \le \lambda \le 1
\qquad (1)
\]</span></p>
<p>ile temsil edilebilir, ki <span class="math inline">\(x,s,t\)</span> üç boyutlu vektörler olmak üzere, yani <span class="math inline">\(\vec{x},\vec{s},\vec{t}\)</span>.</p>
<p>Bir üçgenin tüm yüzeyini, yani üç noktası arasında kalan tüm alanı üç boyutta temsil etmek gerekli, çünkü kesişim bu alanda bir yerde olacak, bunun için ağırlık merkezli (barycentric) kordinat sistemi kullanabiliriz, üçgen içindeki herhangi bir <span class="math inline">\(x\)</span> noktasını üç köşe noktasının farklı ağırlıklarla çarpılıp toplanmış hali olarak görebiliriz, yani üç köşe <span class="math inline">\(p_0,p_1,p_2\)</span> için</p>
<p><span class="math display">\[
x = \mu_0 p_0 + \mu_1 p_1 + \mu_2 p_2,
\quad \mu_0 + \mu_1 + \mu_2 = 1, \mu_i \ge 0
\]</span></p>
<p>Formülden <span class="math inline">\(\mu_0\)</span>'i atmak mümkün, onu diğerleri bazında gösterebiliriz, <span class="math inline">\(\mu_0 = 1-\mu_1-\mu_2\)</span>, üstteki formülü tekrar düzenleyince,</p>
<p><span class="math display">\[
x = p_0 + \mu_1 (p_1 - p_0) + \mu_2 (p_2 - p_0)
\qquad (2)
\]</span></p>
<p>Böylece, (1),(2) ile, bizi çizgi parçası biri üçgen sathi ile ilgili iki formül elde ettik. Kesişme noktası bu iki formülün <span class="math inline">\(x\)</span>'leri aynı olduğu yerdedir değil mi? <span class="math inline">\(r=t-s\)</span>, <span class="math inline">\(d_1=p_1-p_0\)</span>, <span class="math inline">\(d_2 = p_2-p_0\)</span> diyelim, ve (1) ile (2)'yi <span class="math inline">\(x\)</span> üzerinden birbirine eşitleyelim,</p>
<p><span class="math display">\[
s + r\lambda = p_0 + \mu_1 d_1 + \mu_2 d_2
\]</span></p>
<p>formülü bulunabilir. Üstteki formülü matris notasyonunda tekrar düzenlemek mümkündür,</p>
<p><span class="math display">\[
[\begin{array}{ccc} -r &amp; d_1 &amp; d_2 \end{array}]
\left[\begin{array}{ccc}
\lambda \\ \mu_1 \\ \mu_2 
\end{array}\right] = s - p_0
\]</span></p>
<p>Dikkat, <span class="math inline">\(-r,d_1,d_2\)</span> vektör oluşturmuş gibi gözüküyor ama böyle değil, bu değişkenlerin her birinin kendisi vektör, onların değerlerinin asağı doğru açılmış hali solda bir matris yaratıyor, o matrise <span class="math inline">\(A\)</span> diyelim, yani</p>
<p><span class="math display">\[
\left[\begin{array}{ccc}
\uparrow &amp; \uparrow &amp; \uparrow  \\
 -r &amp; d_1 &amp; d_2 \\
\downarrow &amp; \downarrow &amp; \downarrow 
\end{array}\right]
\left[\begin{array}{ccc}
\lambda \\ \mu_1 \\ \mu_2 
\end{array}\right] = s - p_0
\]</span></p>
<p><span class="math display">\[
A
\left[\begin{array}{ccc}
\lambda \\ \mu_1 \\ \mu_2 
\end{array}\right] = s - p_0
\]</span></p>
<p>Sistemi çözmek için</p>
<p><span class="math display">\[
\left[\begin{array}{ccc}
\lambda \\ \mu_1 \\ \mu_2 
\end{array}\right] = A^{-1} (s - p_0)
\]</span></p>
<p>Yani <span class="math inline">\(A\)</span>'nin tersini alıp eşitliğin sağ tarafını soldan çarpınca kesişme noktasındaki <span class="math inline">\(\lambda,\mu_1,\mu_2\)</span> elde ediliyor.</p>
<p>Bu değerleri kullanarak kesişme noktasının kordinat yerini artık bulabiliriz, mesela çizgi parçası formülünden yola çıkarsak <span class="math inline">\(x = s + \lambda (t-s)\)</span> formülüne bulunan <span class="math inline">\(\lambda\)</span> değerini sokunca, ki <span class="math inline">\(t,s\)</span> zaten biliniyor, kesişim noktası <span class="math inline">\(x\)</span> elde edilebilir.</p>
<p>Önemli bir nokta eğer kesişme <em>yoksa</em> üstteki çözümün ne vereceği. Bu durumda <span class="math inline">\(A\)</span> matrisi özgün (singular) olur, yani tersi alınamaz. O zaman eğer bir lineer cebir paketi kullanıyorsak bir hata mesajı alırız. Tabii özgünlüğün basit bir kontrol yöntemi var, <span class="math inline">\(A\)</span>'nin determinantını alırız, eğer sıfır ise matris özgündür, çözüm / kesişme yoktur.</p>
<p>Bu hesabın farklı bazı ekleri için <code>raytri.c</code> koduna bakılabilir.</p>
<p>Not: Üstteki kod ve [9] lineer cebir sistemini Cramer'in Kuralı ile çözüyor, o cebirsel açılım sırasında ortaya çıkan determinantlar kullanılıyor. Detaylar için koda ve kaynağa başvurulabilir.</p>
<p>Örnek</p>
<p>Gerekli grafik rutinleri,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> mpl_toolkits.mplot3d <span class="im">as</span> a3
<span class="im">import</span> matplotlib.colors <span class="im">as</span> colors
<span class="im">import</span> pylab <span class="im">as</span> pl
<span class="im">import</span> numpy <span class="im">as</span> np

<span class="kw">def</span> plot_tri3d(corners, axx):
   tri <span class="op">=</span> a3.art3d.Poly3DCollection([corners])   
   tri.set_edgecolor(<span class="st">&#39;k&#39;</span>)
   tri.set_color(<span class="st">&#39;red&#39;</span>)
   tri.set_alpha(<span class="fl">0.2</span>)
   axx.add_collection3d(tri)
   axx.view_init(elev<span class="op">=</span><span class="dv">20</span>, azim<span class="op">=</span><span class="dv">250</span>)
   axx.set_xlim(<span class="op">-</span><span class="dv">5</span>,<span class="dv">8</span>)
   axx.set_ylim(<span class="op">-</span><span class="dv">5</span>,<span class="dv">8</span>)
   axx.set_zlim(<span class="op">-</span><span class="dv">5</span>,<span class="dv">8</span>)

<span class="kw">def</span> plot_line(p0,p1,axx):
   axx.plot([p0[<span class="dv">0</span>],p1[<span class="dv">0</span>]],[p0[<span class="dv">1</span>],p1[<span class="dv">1</span>]],[p0[<span class="dv">2</span>],p1[<span class="dv">2</span>]])
   </code></pre></div>
<p>Bir çizgi parçası ve bir üçgen yaratalım,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">vtx1 <span class="op">=</span> np.array([[<span class="dv">0</span>,<span class="dv">5</span>,<span class="dv">0</span>],[<span class="dv">8</span>,<span class="dv">4</span>,<span class="dv">0</span> ],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]])

ax <span class="op">=</span> a3.Axes3D(pl.figure())
plot_tri3d(vtx1,ax)
s <span class="op">=</span> np.array([<span class="dv">2</span>,<span class="dv">3</span>,<span class="op">-</span><span class="dv">2</span>])
t <span class="op">=</span> np.array([<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">2</span>])
plot_line(s,t,ax)
plt.savefig(<span class="st">&#39;calc_multi_75_app_14.jpg&#39;</span>)</code></pre></div>
<div class="figure">
<img src="calc_multi_75_app_14.jpg" />

</div>
<p>Kesişmeyi bulmak için,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy.linalg <span class="im">as</span> lin
r <span class="op">=</span> t <span class="op">-</span> s
d1 <span class="op">=</span> vtx1[<span class="dv">1</span>,:]<span class="op">-</span>vtx1[<span class="dv">0</span>,:]
d2 <span class="op">=</span> vtx1[<span class="dv">2</span>,:]<span class="op">-</span>vtx1[<span class="dv">0</span>,:]
A <span class="op">=</span> np.zeros((<span class="dv">3</span>,<span class="dv">3</span>))
A[:,<span class="dv">0</span>] <span class="op">=</span> <span class="op">-</span>r
A[:,<span class="dv">1</span>] <span class="op">=</span> d1
A[:,<span class="dv">2</span>] <span class="op">=</span> d2
<span class="bu">print</span> (<span class="st">&#39;A&#39;</span>,A)
<span class="bu">print</span> (<span class="st">u&#39;A determinantı&#39;</span>, lin.det(A))
res <span class="op">=</span> np.dot(lin.inv(A),(s<span class="op">-</span>vtx1[<span class="dv">0</span>,:]))
lam,mu1,mu2 <span class="op">=</span> <span class="bu">list</span>(res)</code></pre></div>
<pre><code>A [[-3.  8.  0.]
 [ 0. -1. -5.]
 [-4.  0.  0.]]
A determinantı 159.99999999999994</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> (mu1,mu2,mu1<span class="op">+</span>mu2)
xintersect <span class="op">=</span> s <span class="op">+</span> lam <span class="op">*</span> (t<span class="op">-</span>s)
<span class="bu">print</span> (<span class="st">u&#39;kesişme noktası&#39;</span>,xintersect)</code></pre></div>
<pre><code>0.4375 0.3125 0.75
kesişme noktası [3.5 3.  0. ]</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">ax <span class="op">=</span> a3.Axes3D(pl.figure())
plot_tri3d(vtx1,ax)
plot_line(s,t,ax)
ax.plot(xintersect[<span class="dv">0</span>],xintersect[<span class="dv">1</span>],xintersect[<span class="dv">2</span>],<span class="st">&#39;rd&#39;</span>)
plt.savefig(<span class="st">&#39;calc_multi_75_app_15.jpg&#39;</span>)</code></pre></div>
<div class="figure">
<img src="calc_multi_75_app_15.jpg" />

</div>
<p>Örnek</p>
<p>Kesişmenin olmadığı bir örneğe bakalım,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">ax <span class="op">=</span> a3.Axes3D(pl.figure())
plot_tri3d(vtx1,ax)
s <span class="op">=</span> np.array([<span class="op">-</span><span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">3</span>])
t <span class="op">=</span> np.array([<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">3</span>])
r <span class="op">=</span> t <span class="op">-</span> s
A <span class="op">=</span> np.zeros((<span class="dv">3</span>,<span class="dv">3</span>))
A[:,<span class="dv">0</span>] <span class="op">=</span> <span class="op">-</span>r
A[:,<span class="dv">1</span>] <span class="op">=</span> d1
A[:,<span class="dv">2</span>] <span class="op">=</span> d2
<span class="bu">print</span> (<span class="st">&#39;A&#39;</span>,A)
<span class="bu">print</span> (<span class="st">&#39;A determinant&#39;</span>, lin.det(A))
plot_line(s,t,ax)
plt.savefig(<span class="st">&#39;calc_multi_75_app_16.jpg&#39;</span>)</code></pre></div>
<pre><code>A [[-3.  8.  0.]
 [ 4. -1. -5.]
 [ 0.  0.  0.]]
A determinant 0.0</code></pre>
<div class="figure">
<img src="calc_multi_75_app_16.jpg" />

</div>
<p>İki 3D Üçgenin Hızlı Kesişme Kontrolü</p>
<p>Üç boyutta iki üçgenin hızlı bir kesişme kontrolü için, ya da <em>kesişmeme</em> durumunda kesişme ihtimalini hızlı bir şekilde eleyebilmek için [7] bir yöntem nokta / düzlem [8] mesafe mantığını kullanmak. Bu yöntemde verili iki üçgen var diyelim, <span class="math inline">\(T_1\)</span>, ki <span class="math inline">\((u_0,u_1,u_2)\)</span> köşelerinden oluşuyor, ve <span class="math inline">\(T_2\)</span>, ki <span class="math inline">\((v_0,v_1,v_2)\)</span> köşelerinden oluşuyor, ikinci üçgen için önce üç noktanın ima ettiği düzlemi oluştururuz.</p>
<p><span class="math display">\[
n_2 = (v_1-v_0) \times (v_2 - v_1)
\]</span></p>
<p><span class="math display">\[
d_2 = -n_2 \cdot v_0
\]</span></p>
<p>Sonra <span class="math inline">\(T_1\)</span>'in tüm köşelerinden bu düzleme olan işaretli mesafeyi hesaplarız.</p>
<p><span class="math display">\[
m_i = n_2 \cdot u_i + d_2
\]</span></p>
<p>Eğer tüm <span class="math inline">\(m_i &lt; 0\)</span> ya da tüm <span class="math inline">\(m_i &gt; 0\)</span> ise, bu üçgen / üçgen kesişmesinin olmadığı sonucuna varabiliriz. Bu hızlı, kabaca yapılan bir ilk test olarak faydalı olabilir.</p>
<p>Yöntem direk üçgen / üçgen bazında bir test değildir, üçgen noktaları ve diğer üçgenin olduğu <em>düzlem</em> bazında bir testtir fakat kesişme olmadığı durumda muhakkak kesişme olmadığı sonucuna hızlıca varabildiği için tercih edilen bir ilk test olabilir. Anlatımda biraz karışıklık olduysa açmaya uğraşalım, üstteki test kesişme olmadığı her zaman negatif sonuç verir. Fakat negatif sonuç alınmadıysa bu illa kesişme olduğu anlamına gelmez. Metot negatif sonuçlarda yüzde yüz başarılı, bu sebeple kesişme eleme fazında yardımcı olur, kesin kesişme sonucuna varmak için farklı yöntemler gerekir, mesela daha önce paylaşılan çizgi / üçgen kesişme yaklaşımı gibi.</p>
<p>Örnek</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">vtx1 <span class="op">=</span> np.array([[<span class="dv">0</span>,<span class="dv">5</span>,<span class="dv">0</span>],[<span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">0</span> ],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]])
vtx2 <span class="op">=</span> np.array([[<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">3</span>],[<span class="dv">6</span>,<span class="dv">8</span>,<span class="op">-</span><span class="dv">2</span>],[<span class="dv">6</span>,<span class="op">-</span><span class="dv">4</span>,<span class="op">-</span><span class="dv">2</span>]])

ax <span class="op">=</span> a3.Axes3D(pl.figure())
plot_tri3d(vtx1,ax)
plot_tri3d(vtx2,ax)
plt.savefig(<span class="st">&#39;calc_multi_75_app_12.jpg&#39;</span>)</code></pre></div>
<div class="figure">
<img src="calc_multi_75_app_12.jpg" />

</div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># ikinci ucgen ile duzlem yarat</span>
n2 <span class="op">=</span> np.cross( vtx2[<span class="dv">1</span>,:]<span class="op">-</span>vtx2[<span class="dv">0</span>,:], vtx2[<span class="dv">2</span>,:]<span class="op">-</span>vtx2[<span class="dv">0</span>,:]  )
d2 <span class="op">=</span> <span class="op">-</span>np.dot(n2,vtx2[<span class="dv">0</span>,:])
<span class="bu">print</span> (n2,d2)</code></pre></div>
<pre><code>[-60   0   0] 360</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):
    sdi <span class="op">=</span> np.dot(n2,vtx1[i,:])<span class="op">+</span>d2
    <span class="bu">print</span> (<span class="st">&#39;</span><span class="sc">%d</span><span class="st">. noktaya uzaklik = </span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span> (i,sdi))</code></pre></div>
<pre><code>0. noktaya uzaklik = 360
1. noktaya uzaklik = -120
2. noktaya uzaklik = 360</code></pre>
<p>Örnek</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">ax <span class="op">=</span> a3.Axes3D(pl.figure())
vtx3 <span class="op">=</span> vtx2 <span class="op">+</span> <span class="dv">3</span>
plot_tri3d(vtx1,ax)
plot_tri3d(vtx3,ax)
plt.savefig(<span class="st">&#39;calc_multi_75_app_13.jpg&#39;</span>)</code></pre></div>
<div class="figure">
<img src="calc_multi_75_app_13.jpg" />

</div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># ucuncu ucgen ile duzlem yarat</span>
n3 <span class="op">=</span> np.cross( vtx3[<span class="dv">1</span>,:]<span class="op">-</span>vtx3[<span class="dv">0</span>,:], vtx3[<span class="dv">2</span>,:]<span class="op">-</span>vtx3[<span class="dv">0</span>,:]  )
d3 <span class="op">=</span> <span class="op">-</span>np.dot(n3,vtx3[<span class="dv">0</span>,:])
<span class="bu">print</span> (n3,d3)</code></pre></div>
<pre><code>[-60   0   0] 540</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):
    sdi <span class="op">=</span> np.dot(n2,vtx1[i,:])<span class="op">+</span>d3
    <span class="bu">print</span> (<span class="st">&#39;</span><span class="sc">%d</span><span class="st">. noktaya uzaklik = </span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span> (i,sdi))</code></pre></div>
<pre><code>0. noktaya uzaklik = 540
1. noktaya uzaklik = 60
2. noktaya uzaklik = 540</code></pre>
<p>Daha detaylı kod <code>muller.c</code> ve <code>muller.py</code> dosyalarında bulunabilir.</p>
<p>Çizgi Düzlem Kesişmesini Vektörler ile Hesaplamak</p>
<p>Üstteki yöntem cebirsel manipülasyon gerektiriyor, fakat sayısal hesap için sembolik cebir işlemlerine girmeden vektör matematiği ile direk bir sonuç bulamaz mıyız? [3,4]'ü temel alalım: alttaki durumu düşünelim,</p>
<div class="figure">
<img src="calc_multi_75_app_06.jpg" />

</div>
<p>Grafiğe göre <span class="math inline">\(P(s)\)</span> <span class="math inline">\(P_1\)</span> ve <span class="math inline">\(P_0\)</span> arasındaki birim vektörün <span class="math inline">\(s\)</span> kadar uzatılmış hali olsun, o aralığı <span class="math inline">\(u\)</span> kabul edersek <span class="math inline">\(P(s)-V_0 = w + su\)</span> olur. Düzlem ile kesişmenin olduğu noktayı <span class="math inline">\(P(s_I)\)</span> diye tanımlayalım, aradığımız nokta burası. O noktada <span class="math inline">\(n\)</span> ile <span class="math inline">\(P(s_I)\)</span> dikgen olacaktır, yani <span class="math inline">\(P(s) - V_0 = w + su\)</span> vektörü <span class="math inline">\(n\)</span>'e dikgen olacaktır, ki <span class="math inline">\(w=P_0-V_0\)</span>. Bu durumda <span class="math inline">\(n \cdot (w+su) = 0\)</span> olur. Bunu kullanarak,</p>
<p><span class="math display">\[ s_I = \frac{-n \cdot w}{n \cdot u} = 
\frac{n \cdot (V_0 - P_0)}{n \cdot (P_1-P_0)} = 
\frac{-(ax_0 + by_0 + cz_0 + d)}{n \cdot u}
\]</span></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">n <span class="op">=</span> np.array([<span class="fl">1.</span>, <span class="fl">1.</span>, <span class="fl">1.</span>])
V0 <span class="op">=</span> np.array([<span class="fl">1.</span>, <span class="fl">1.</span>, <span class="fl">-5.</span>])
P0 <span class="op">=</span> np.array([<span class="op">-</span><span class="fl">5.</span>, <span class="fl">1.</span>, <span class="fl">-1.</span>])
P1 <span class="op">=</span> np.array([<span class="fl">1.</span>, <span class="fl">2.</span>, <span class="fl">3.</span>])

w <span class="op">=</span> P0 <span class="op">-</span> V0<span class="op">;</span>
u <span class="op">=</span> P1<span class="op">-</span>P0<span class="op">;</span>
N <span class="op">=</span> <span class="op">-</span>np.dot(n,w)<span class="op">;</span>
D <span class="op">=</span> np.dot(n,u)
sI <span class="op">=</span> N <span class="op">/</span> D
I <span class="op">=</span> P0<span class="op">+</span> sI<span class="op">*</span>u
<span class="bu">print</span> I</code></pre></div>
<pre><code>[-3.90909091  1.18181818 -0.27272727]</code></pre>
<p>Grafiklersek</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> sys<span class="op">;</span> sys.path.append(<span class="st">&#39;../../vision/vision_02&#39;</span>)
<span class="im">import</span> plot3d

f <span class="op">=</span> plt.figure()
ax <span class="op">=</span> f.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)
w <span class="op">=</span> <span class="dv">10</span>
ax.set_xlim(<span class="op">-</span>w,w)<span class="op">;</span>ax.set_ylim(<span class="op">-</span>w,w)<span class="op">;</span>ax.set_zlim(<span class="op">-</span>w,w)
ax.set_xlabel(<span class="st">&quot;X&quot;</span>)
ax.set_ylabel(<span class="st">&quot;Y&quot;</span>)
ax.set_zlabel(<span class="st">&quot;Z&quot;</span>)
v <span class="op">=</span> P1<span class="op">-</span>P0
ax.quiver(P0[<span class="dv">0</span>], P0[<span class="dv">1</span>], P0[<span class="dv">2</span>], v[<span class="dv">0</span>], v[<span class="dv">1</span>], v[<span class="dv">2</span>], color<span class="op">=</span><span class="st">&#39;red&#39;</span>)
ax.scatter(V0[<span class="dv">0</span>], V0[<span class="dv">1</span>], V0[<span class="dv">2</span>], color<span class="op">=</span><span class="st">&#39;black&#39;</span>)
ax.scatter(V0[<span class="dv">0</span>]<span class="op">+</span>n[<span class="dv">0</span>], V0[<span class="dv">1</span>]<span class="op">+</span>n[<span class="dv">1</span>], V0[<span class="dv">2</span>]<span class="op">+</span>n[<span class="dv">2</span>], color<span class="op">=</span><span class="st">&#39;black&#39;</span>)
ax.scatter(I[<span class="dv">0</span>], I[<span class="dv">1</span>], I[<span class="dv">2</span>], color<span class="op">=</span><span class="st">&#39;black&#39;</span>)
ax.quiver(V0[<span class="dv">0</span>], V0[<span class="dv">1</span>], V0[<span class="dv">2</span>], n[<span class="dv">0</span>], n[<span class="dv">1</span>], n[<span class="dv">2</span>], color<span class="op">=</span><span class="st">&#39;blue&#39;</span>)
plot3d.plot_plane(ax, <span class="bu">list</span>(V0), <span class="bu">list</span>(n), color<span class="op">=</span><span class="st">&#39;y&#39;</span>)
plt.savefig(<span class="st">&#39;calc_multi_75_app_07.jpg&#39;</span>)</code></pre></div>
<div class="figure">
<img src="calc_multi_75_app_07.jpg" />

</div>
<p>Green'in Teorisi, Uzaklaşım, Stokes, Yol ve Çizgi Entegralleri</p>
<p>Yüzeyler (Surfaces)</p>
<p>Üç boyut içindeki iki boyut yüzeyler parametrize edilerek gösterilir, tek boyutlu eğri bir parametre <span class="math inline">\(t\)</span> ile parametrize ediliyordu, alan için iki değişken <span class="math inline">\(u,v\)</span> gerekir. Notasyonel olarak <span class="math inline">\(r\)</span>'nin taradığı bir yüzey</p>
<p><span class="math display">\[
r(u,v) = &lt; x(u,v), y(u,v), z(u,v) &gt;
\]</span></p>
<p>Mesela <span class="math inline">\(r(u,v) = &lt; u, u^2, v &gt;\)</span> bir yüzey olabilir.</p>
<p>Yüzey alan hesabı için tüm yüzeyi kenarları <span class="math inline">\(\Delta u\)</span>, <span class="math inline">\(\Delta v\)</span> olan hücreler yaratabiliriz. Her noktada iki tane teğet vektör bulunabilir, bunlar <span class="math inline">\(t_u\)</span> ve <span class="math inline">\(t_v\)</span> olsun,</p>
<p><span class="math display">\[
t_u = &lt; \frac{\partial x}{\partial u},
        \frac{\partial y}{\partial u},
        \frac{\partial z}{\partial u} &gt;, \quad
t_v = &lt; \frac{\partial x}{\partial v},
        \frac{\partial y}{\partial v},
        \frac{\partial z}{\partial v} &gt;        
\]</span></p>
<p>Yaklaşık olarak her hücrenin alanı <span class="math inline">\(\Delta S_{ij}\)</span> her hücredeki <span class="math inline">\(t_u\)</span> ve <span class="math inline">\(t_v\)</span> (ya da yeni notasyonla onlara <span class="math inline">\(t_u^{ij}\)</span> ve <span class="math inline">\(t_v^{ij}\)</span> diyelim) yönündeki <span class="math inline">\(\Delta u\)</span> ve <span class="math inline">\(\Delta v\)</span>'nin oluşturduğu paralelogram alanıdır, bu paralelogram bildiğimiz gibi iki vektörün çapraz çarpımından gelen üçüncü vektörün büyüklüğüdür, o zaman</p>
<p><span class="math display">\[
\Delta S_{ij} \approx || \Delta u t_u^{ij} \times \Delta v t_v^{ij} ||
\]</span></p>
<p><span class="math display">\[
= ||  t_u^{ij} \times t_v^{ij} || \Delta u \Delta v
\]</span></p>
<div class="figure">
<img src="calc_multi_75_app_01.jpg" />

</div>
<div class="figure">
<img src="calc_multi_75_app_02.jpg" />

</div>
<p>Tüm ufak hücre alanlarını toplarız, ve hücre sayısı sonsuza yaklaşırken toplam alan limitine bakabiliriz,</p>
<p><span class="math display">\[
\lim_{m,n \to \infty} \sum_{i=1}^{m} \sum_{j=1}^{n} || t_u^{ij} \times t_v^{ij} || \Delta u \Delta v
\]</span></p>
<p>Bu limit yüzey alan çift entegral hesabına yaklaşır / onu tanımlar, [2, sf. 769],</p>
<p><span class="math display">\[
= \iint_D || t_u \times t_v || \mathrm{d} u \mathrm{d} v = \iint_D || t_u \times t_v || \mathrm{d} A
\]</span></p>
<p>Yüzey Entegrali (Surface Integral)</p>
<p>Yukarıda gördüklerimiz parametrize edilmiş yüzeyin alanını hesaplamak içindir. Yüzey entegrali bir yüzey <em>üzerinden</em> alınan entegrallere verilen isimdir, mesela tek sayı / skalar değerli bir fonksiyon <span class="math inline">\(f\)</span>'nin pürüzsüz bir yüzey <span class="math inline">\(S\)</span> üzerinden alınan yüzey entegrali, o fonksiyonun her noktadaki alan büyüklüğü ile çarpılıp sonuçların toplanmasıdır, cebirsel olarak yine <span class="math inline">\(t_u,t_v\)</span> kavramlarını kullanırsak,</p>
<p><span class="math display">\[
\iint_S f(x,y,z) \mathrm{d} S 
= \lim_{m,n \to \infty} \sum_{i=1}^{m} \sum_{j=1}^{n} f(P_{ij}) || t_u^{ij} \times t_v^{ij} || \Delta u \Delta v
\]</span></p>
<p><span class="math display">\[
= \lim_{m,n \to \infty} \sum_{i=1}^{m} \sum_{j=1}^{n} f(P_{ij}) \Delta S_{ij} 
\]</span></p>
<p>O zaman yüzey entegralleri alttaki şekilde hesaplanabilir,</p>
<p><span class="math display">\[
\iint_S f(x,y,z) \mathrm{d} S =
\iint_D f(r(u,v)) || t_u \times t_v || \mathrm{d} A
\]</span></p>
<p>Çizgi entegrali (line integrals) daha düşük boyuttaki benzer bir kavram idi.</p>
<p>Vektör Alanları Üzerinden Yüzey Entegrali</p>
<p>Skalar fonksiyona benzer şekilde bir vektör alanı <span class="math inline">\(F\)</span> ve yüzey <span class="math inline">\(S\)</span> üzerinden de entegral hesaplanabilir. Yine bir ufak çarpımlar toplamından bahsediyoruz, bu tür bir hesap pek çok uygulama için faydalı olabilir. Mesela bir su akışı içindeki geçirgen bir yüzeyi düşünürsek, kütle akışını (mass flux) nasıl hesaplarız?</p>
<div class="figure">
<img src="calc_multi_75_app_04.jpg" />

</div>
<p>Her noktada yüzey <span class="math inline">\(S\)</span>'ye dik olan alan <span class="math inline">\(N\)</span> olsun, her noktadaki akış hızı <span class="math inline">\(v\)</span> diyelim, o zaman bir noktadaki birim zaman ve birim alandaki kütle akışı <span class="math inline">\(\rho v \cdot N\)</span>. Ölçüm birimlerini kontrol edelim, hız <span class="math inline">\(m/s\)</span>, yoğunluk <span class="math inline">\(\rho\)</span> <span class="math inline">\(g/m^3\)</span>, çarparsak <span class="math inline">\(g/s \cdot m^2\)</span> elde ederiz, yani birim alan ve zamandaki kütle akışı.</p>
<p>Şimdi <span class="math inline">\(\rho v \cdot N\)</span> değerini <span class="math inline">\(\Delta S_{ij}\)</span> ile çarparsak <span class="math inline">\(S\)</span> üzerindeki hayali ufak hücreden birim zamanda akan kütleyi buluruz, tüm bu akışları toplarız,</p>
<p><span class="math display">\[
\sum_{i=1}^{m} \sum_{j=1}^{n} (\rho v \cdot N) \Delta S_{ij}
\]</span></p>
<p>Tüm akışı elde etmiş oluruz. Izgara hücreleri <span class="math inline">\(S_{ij}\)</span> ufaldıkça üstteki toplam gerçek kütle akışına yaklaşır, yani</p>
<p><span class="math display">\[
\iint_S \rho v \cdot N \mathrm{d} S = \lim_{m,n \to \infty}
\sum_{i=1}^{m} \sum_{j=1}^{n} (\rho v \cdot N) \Delta S_{ij}
\]</span></p>
<p>Devam edelim <span class="math inline">\(\rho v\)</span> yerine herhangi bir vektör alanı <span class="math inline">\(F\)</span> kullanalım, o zaman şu genel tanımı artık yapabiliriz, <span class="math inline">\(F\)</span>'nin <span class="math inline">\(S\)</span> yüzeyi üzerinden entegrali</p>
<p><span class="math display">\[
\iint_S \vec{F} \cdot \mathrm{d} \vec{S} = \iint_S \vec{F} \cdot \vec{N} \mathrm{d} S
\]</span></p>
<p>olarak gösterilir.</p>
<div class="figure">
<img src="calc_multi_75_app_05.jpg" />

</div>
<p>Dikkat her yerde vektör notasyonu kullanmıyoruz, olmadığı yerde formül çerçevesine göre anlaşılabilir.</p>
<p><span class="math inline">\(N\)</span> yüzey normalı, öne dik olan birim vektör, hesabı için önceden gördüğümüz <span class="math inline">\(t_u,t_v\)</span> vektörlerini kullanabiliriz,</p>
<p><span class="math display">\[
N = \frac{t_u \times t_v}{ || t_u \times t_v || }
\]</span></p>
<p>Üstteki ifadeyi yüzey entegralinde kullanırsak [2, sf. 778],</p>
<p><span class="math display">\[
\iint_S \vec{F} \cdot \vec{N} \mathrm{d} S =
\iint_S \vec{F} \cdot \frac{t_u \times t_v}{ || t_u \times t_v || } \mathrm{d} S
\]</span></p>
<p>Daha önce gördük</p>
<p><span class="math display">\[
\mathrm{d} S = || t_u \times t_v || \mathrm{d} u \mathrm{d} v = || t_u \times t_v || \mathrm{d} A
\]</span></p>
<p>İki üste geçirince</p>
<p><span class="math display">\[
= \iint_D \vec{F}(r(u,v)) \cdot \frac{t_u \times t_v}{ || t_u \times t_v || }
|| t_u \times t_v || \mathrm{d} A
\]</span></p>
<p>Basitleştirme sonrası,</p>
<p><span class="math display">\[
= \iint_D \vec{F}(r(u,v)) \cdot (t_u \times t_v) || t_u \times t_v || \mathrm{d} A
\]</span></p>
<p>Soru</p>
<p><span class="math inline">\(F = &lt; -y, x, 0 &gt;\)</span> olarak veriliyor, <span class="math inline">\(S\)</span> yüzeyi <span class="math inline">\(r(u,v) = &lt; u, v^2 - u, u+v &gt;\)</span>.</p>
<p><span class="math inline">\(\iint_S F \cdot N \mathrm{d} S\)</span> yüzey entegralini hesaplayın.</p>
<p>Cevap</p>
<p>Teğet vektörler <span class="math inline">\(t_u = &lt; 1, -1, 1 &gt;\)</span>, ve <span class="math inline">\(t_v = &lt; 0, 2v, 1 &gt;\)</span>.</p>
<p><span class="math inline">\(t_u \times t_v\)</span> çapraz çarpımı</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> sympy

u,v <span class="op">=</span> sympy.symbols(<span class="st">&#39;u v&#39;</span>)
t_u <span class="op">=</span> sympy.Matrix([[<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>]])
t_v <span class="op">=</span> sympy.Matrix([[<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>v,<span class="dv">1</span>]])
<span class="bu">print</span> (t_u.cross(t_v))</code></pre></div>
<pre><code>Matrix([[-2*v - 1, -1, 2*v]])</code></pre>
<p>Yüzey entegral hesabı şöyle hesaplanabilir,</p>
<p><span class="math display">\[
\int _{0}^{4} \int _{0}^{3} F(r(u,v)) \cdot (t_u \times t_v) \mathrm{d} u \mathrm{d} v
\]</span></p>
<p>Verili <span class="math inline">\(F = &lt; -y, x, 0 &gt;\)</span>, ve yüzey <span class="math inline">\(r(u,v) = &lt; u, v^2 - u, u+v &gt;\)</span> demiştik, o zaman</p>
<p><span class="math display">\[
F(r(u,v)) = &lt; u-v^2, u, 0 &gt; 
\]</span></p>
<p>olur. Tüm entegral</p>
<p><span class="math display">\[
= \int _{0}^{4} \int _{0}^{3} &lt; u-v^2, u, 0 &gt;  \cdot &lt; -1-2v, -1, 2v &gt;
\mathrm{d} u \mathrm{d} v
\]</span></p>
<p><span class="math display">\[
= \int_{0}^{4} \int_{0}^{3} (2v^3 + v^2 -2uv -2u )
\mathrm{d} u \mathrm{d} v
\]</span></p>
<p><span class="math display">\[
= \int_{0}^{4} [ 2v^3u + v^2u - vu^2 - u^2 ]_{0}^{3} \mathrm{d} v
\]</span></p>
<p><span class="math display">\[
= \int_{0}^{4} (6v^3 + 3v^2 - 9v -9 ) \mathrm{d} v
\]</span></p>
<p><span class="math display">\[
= \left[ \frac{3v^4}{2} + v^3 - \frac{9v^2}{2} - 9v \right]_{0}^{4}
\]</span></p>
<p><span class="math display">\[
= 340
\]</span></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> mpl_toolkits.mplot3d <span class="im">import</span> Axes3D
<span class="im">from</span> matplotlib <span class="im">import</span> cm
<span class="im">import</span> numpy <span class="im">as</span> np
fig <span class="op">=</span> plt.figure()
ax <span class="op">=</span> fig.add_subplot(<span class="dv">111</span>, projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)
u <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">100</span>)
v <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">4</span>, <span class="dv">100</span>)
u,v <span class="op">=</span> np.meshgrid(u,v)

x <span class="op">=</span> u<span class="op">;</span> y <span class="op">=</span> v<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> u<span class="op">;</span> z <span class="op">=</span> u <span class="op">+</span> v

ax.plot_surface(x, y, z, rstride<span class="op">=</span><span class="dv">4</span>, cstride<span class="op">=</span><span class="dv">4</span>, cmap <span class="op">=</span> cm.copper)
x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">5</span>)
y <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">5</span>)
z <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">6</span>, <span class="dv">5</span>)

fu <span class="op">=</span> <span class="op">-</span>y<span class="op">;</span> fv <span class="op">=</span> x<span class="op">;</span> fw <span class="op">=</span> z<span class="op">*</span><span class="dv">0</span>

xx,yy,zz <span class="op">=</span> np.meshgrid(x,y,z)
ax.quiver(xx, yy, zz, fu, fv, fw, length<span class="op">=</span><span class="fl">0.2</span>, color <span class="op">=</span> <span class="st">&#39;red&#39;</span>)
ax.view_init(elev<span class="op">=</span><span class="dv">18</span>, azim<span class="op">=-</span><span class="dv">46</span>)
plt.savefig(<span class="st">&#39;calc_multi_75_app_03.jpg&#39;</span>,quality<span class="op">=</span><span class="dv">30</span>)</code></pre></div>
<div class="figure">
<img src="calc_multi_75_app_03.jpg" />

</div>
<p>Çizgi Düzlem Kesişmesi</p>
<p>Elimizde <span class="math inline">\(P = 2x + y - 4z = 4\)</span> düzlemi var. Bu düzlemin</p>
<p><span class="math display">\[ x = t \quad y = 2 + 3t \quad z = t\]</span></p>
<p>çizgisi ile kesiştiği yer neresidir?</p>
<p>Cevap kolay; çizgi denkleminde <span class="math inline">\(t\)</span> bazlı tanımlı <span class="math inline">\(x,y,z\)</span> değerleri <span class="math inline">\(P\)</span>'ye sokarsak, tek bilinmeyeni <span class="math inline">\(t\)</span> olan bir denklem çıkar,</p>
<p><span class="math display">\[ 2(t) + (2+3t)-4(t) = 4 \Rightarrow t = 2\]</span></p>
<p>İki Nokta Arasında Parametrize Edilmiş Eğri</p>
<p>Diyelim ki <span class="math inline">\((1,1)\)</span> ve <span class="math inline">\((4,4)\)</span> noktalarından geçen ve dışarıdan tanımlı parametrelerle yeterince eğilip, bükülebilecek bir eğri tanımlamamız lazım. Polinomlar üzerinden tanımlanan bir eğri ile bunu başarabiliriz,</p>
<p><span class="math display">\[
x(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3
\]</span></p>
<p><span class="math display">\[
y(t) = b_0 + b_1 t + b_2 t^2 + b_3 t^3
\]</span></p>
<p>Bu şekilde bir eğri yeterince eğilip bükülebilir, ve istenen şekle sokulabilir. Fakat baş ve sonun verili noktalardan geçmesini nasıl garanti ederiz? Bunun için bu noktaları üstteki denkleme sokalim, ve <span class="math inline">\(0 \le t \le 1\)</span> olacak sekilde kısıtlama yapalim, <span class="math inline">\(t=0\)</span>'da</p>
<p><span class="math display">\[
1 = a_0 + a_1 (0) + a_2 (0)^2 + a_3 (0)^3
\]</span></p>
<p><span class="math display">\[
1 = b_0 + b_1 (0) + b_2 (0)^2 + b_3 (0)^3
\]</span></p>
<p>Yani <span class="math inline">\(a_0=1\)</span> ve <span class="math inline">\(b_0=1\)</span>. Peki <span class="math inline">\(t=1\)</span> icin?</p>
<p><span class="math display">\[
4 = 1 + a_1 (1) + a_2 (1)^2 + a_3 (1)^3 
\]</span></p>
<p><span class="math display">\[
4 = 1 + b_1 (1) + b_2 (1)^2 + b_3 (1)^3 
\]</span></p>
<p><span class="math display">\[
3 = a_1 + a_2 + a_3, \quad 3 = b_1 + b_2 + b_3
\]</span></p>
<p>Demek ki üstteki iki formüle mutabık kaldığımız sürece <span class="math inline">\(a_1,a_2,a_3,b_1,b_2,b_3\)</span> ie istediğimiz şekilde oynayarak istediğimiz eğriyi ortaya çıkartabiliriz.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">t <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="fl">1.0</span>,<span class="dv">100</span>)

a1,a2 <span class="op">=</span> <span class="fl">-1.1</span>, <span class="fl">1.9</span>
b1,b2 <span class="op">=</span> <span class="fl">1.1</span>, <span class="fl">1.4</span>

sx,sy<span class="op">=</span>(<span class="fl">1.0</span>,<span class="fl">1.0</span>)
ex,ey<span class="op">=</span>(<span class="fl">4.0</span>,<span class="fl">4.0</span>)

a3 <span class="op">=</span> ex <span class="op">-</span> sx <span class="op">-</span> (a1<span class="op">+</span>a2)
b3 <span class="op">=</span> ey <span class="op">-</span> sy <span class="op">-</span> (b1<span class="op">+</span>b2)

x <span class="op">=</span> <span class="fl">1.0</span> <span class="op">+</span> a1<span class="op">*</span>t <span class="op">+</span> a2<span class="op">*</span>t<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> a3<span class="op">*</span>t<span class="op">**</span><span class="dv">3</span>
y <span class="op">=</span> <span class="fl">1.0</span> <span class="op">+</span> b1<span class="op">*</span>t <span class="op">+</span> b2<span class="op">*</span>t<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> b3<span class="op">*</span>t<span class="op">**</span><span class="dv">3</span>

plt.xlim(<span class="dv">0</span>,<span class="fl">5.0</span>)
plt.ylim(<span class="dv">0</span>,<span class="fl">5.0</span>)
plt.plot(x,y)
plt.savefig(<span class="st">&#39;calc_multi_75_app_08.jpg&#39;</span>)</code></pre></div>
<div class="figure">
<img src="calc_multi_75_app_08.jpg" />

</div>
<p>Max ve Sigmoid Bazlı Yaklaşım</p>
<p>Daha önce [6]'da görülen spline tekniğinin parametrik hali de olabilir. Mesela</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">a1,b1,c1,d1 <span class="op">=</span> (<span class="dv">1</span>, <span class="fl">-1.4</span>, <span class="dv">2</span>, <span class="fl">2.5</span>)
a2,b2,c2,d2 <span class="op">=</span> (<span class="dv">1</span>, <span class="fl">1.4</span>, <span class="dv">1</span>, <span class="fl">2.5</span>)
<span class="kw">def</span> f(t):
    x <span class="op">=</span> ax <span class="op">+</span> <span class="op">\</span>
        bx<span class="op">*</span>np.<span class="bu">max</span>([<span class="dv">0</span>,t<span class="dv">-2</span>]) <span class="op">+</span> <span class="op">\</span>
        cx<span class="op">*</span>np.<span class="bu">max</span>([<span class="dv">0</span>,t<span class="dv">-3</span>]) <span class="op">+</span> <span class="op">\</span>
        dx<span class="op">*</span>np.<span class="bu">max</span>([<span class="dv">0</span>,t<span class="dv">-4</span>])
       
    y <span class="op">=</span> ay <span class="op">+</span> <span class="op">\</span>
        by<span class="op">*</span>np.<span class="bu">max</span>([<span class="dv">0</span>,t<span class="dv">-2</span>]) <span class="op">+</span> <span class="op">\</span>
        cy<span class="op">*</span>np.<span class="bu">max</span>([<span class="dv">0</span>,t<span class="dv">-3</span>]) <span class="op">+</span> <span class="op">\</span>
        dy<span class="op">*</span>np.<span class="bu">max</span>([<span class="dv">0</span>,t<span class="dv">-4</span>])
    <span class="cf">return</span> x,y     
    
tmp <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">5</span>,<span class="dv">100</span>)
res <span class="op">=</span> np.array([f(tt) <span class="cf">for</span> tt <span class="kw">in</span> tmp])
plt.plot(res[:,<span class="dv">0</span>],res[:,<span class="dv">1</span>])
plt.savefig(<span class="st">&#39;calc_multi_75_app_09.jpg&#39;</span>)</code></pre></div>
<div class="figure">
<img src="calc_multi_75_app_09.jpg" />

</div>
<p>Başlangıcı <span class="math inline">\(a_x,a_y\)</span> olan kesik bir eğriyi görüyoruz. Bu tür eğrileri aynen [6]'da olduğu gibi sigmoid bazlı yapabiliriz,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">rho <span class="op">=</span> <span class="fl">7.0</span>
<span class="kw">def</span> sig(x,a):
   <span class="cf">return</span> (x<span class="op">-</span>a)<span class="op">*</span><span class="dv">1</span><span class="op">/</span>(<span class="dv">1</span><span class="op">+</span>np.exp(<span class="op">-</span>rho<span class="op">*</span>(x<span class="op">-</span>a)))

<span class="kw">def</span> maxk(x,a):
   <span class="cf">return</span> np.<span class="bu">max</span>([<span class="dv">0</span>,x<span class="op">-</span>a])

ax,bx,cx,dx,ex <span class="op">=</span> (<span class="dv">1</span>, <span class="fl">2.4</span>, <span class="dv">1</span>, <span class="fl">-3.5</span>, <span class="fl">-2.1</span>)
ay,by,cy,dy,ey <span class="op">=</span> (<span class="dv">1</span>, <span class="fl">0.4</span>, <span class="fl">-0.1</span>, <span class="fl">0.5</span>, <span class="dv">-3</span>)
<span class="kw">def</span> f(t):
    x <span class="op">=</span> ax <span class="op">+</span> <span class="op">\</span>
        bx<span class="op">*</span>maxk(t,<span class="dv">2</span>) <span class="op">+</span> <span class="op">\</span>
        cx<span class="op">*</span>maxk(t,<span class="dv">3</span>) <span class="op">+</span> <span class="op">\</span>
        dx<span class="op">*</span>maxk(t,<span class="fl">3.5</span>) <span class="op">+</span> <span class="op">\</span>
        ex<span class="op">*</span>maxk(t,<span class="fl">4.0</span>)
       
    y <span class="op">=</span> ay <span class="op">+</span> <span class="op">\</span>
        by<span class="op">*</span>maxk(t,<span class="dv">2</span>) <span class="op">+</span> <span class="op">\</span>
        cy<span class="op">*</span>maxk(t,<span class="dv">3</span>) <span class="op">+</span> <span class="op">\</span>
        dy<span class="op">*</span>maxk(t,<span class="fl">3.5</span>) <span class="op">+</span> <span class="op">\</span>
        ey<span class="op">*</span>maxk(t,<span class="fl">4.0</span>)
    <span class="cf">return</span> x,y     
    
<span class="kw">def</span> g(t):
    x <span class="op">=</span> ax <span class="op">+</span> <span class="op">\</span>
        bx<span class="op">*</span>sig(t,<span class="dv">2</span>) <span class="op">+</span> <span class="op">\</span>
        cx<span class="op">*</span>sig(t,<span class="dv">3</span>) <span class="op">+</span> <span class="op">\</span>
        dx<span class="op">*</span>sig(t,<span class="fl">3.5</span>) <span class="op">+</span> <span class="op">\</span>
        ex<span class="op">*</span>sig(t,<span class="fl">4.0</span>)
       
    y <span class="op">=</span> ay <span class="op">+</span> <span class="op">\</span>
        by<span class="op">*</span>sig(t,<span class="dv">2</span>) <span class="op">+</span> <span class="op">\</span>
        cy<span class="op">*</span>sig(t,<span class="dv">3</span>) <span class="op">+</span> <span class="op">\</span>
        dy<span class="op">*</span>sig(t,<span class="fl">3.5</span>) <span class="op">+</span> <span class="op">\</span>
        ey<span class="op">*</span>sig(t,<span class="fl">4.0</span>)
    <span class="cf">return</span> x,y     
    
tmp <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">5</span>,<span class="dv">100</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">res <span class="op">=</span> np.array([f(tt) <span class="cf">for</span> tt <span class="kw">in</span> tmp])
plt.plot(res[:,<span class="dv">0</span>],res[:,<span class="dv">1</span>])
plt.savefig(<span class="st">&#39;calc_multi_75_app_10.jpg&#39;</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">res <span class="op">=</span> np.array([g(tt) <span class="cf">for</span> tt <span class="kw">in</span> tmp])
plt.plot(res[:,<span class="dv">0</span>],res[:,<span class="dv">1</span>])
plt.savefig(<span class="st">&#39;calc_multi_75_app_11.jpg&#39;</span>)</code></pre></div>
<p><img src="calc_multi_75_app_10.jpg" /> <img src="calc_multi_75_app_11.jpg" /></p>
<p>Herhangi bir şekli katsayılarla yaratmak mümkün.</p>
<p>Bitiş noktalasını nasıl ayarlarız? Burada yine polinom örnekteki gibi cebirsel bir yöntem seçebilirdik, fakat çoğunlukla başlangıç ve bitiş arasındaki eğriler bir optimizasyon bağlamında kullanılır. Bu durumda bitiş noktaları ile katsayılar arasında bir optimizasyon kısıtlaması yaratmak ve bitiş noktalarını böyle ayarlamak daha iyidir.</p>
<p>Çünkü biliyoruz parametrize ortamda mesela önceki örnekte <span class="math inline">\(0 \ge t \ge 5\)</span>. O zaman egrinin bitisinde <span class="math inline">\(t=5\)</span> olacağını biliyoruz. Bu durumda mesela</p>
<p><span class="math display">\[
    x = a_x + \
        b_x \sigma(t,2) + \
        c_x \sigma(t,3) + \
        d_x \sigma(t,3.5) +
        e_x \sigma(t,4.0)
\]</span></p>
<p>ifadesine <span class="math inline">\(t\)</span> tüm ilmik noktalarının ötesinde olduğu için artık tüm <span class="math inline">\(\sigma\)</span> ifadeleri 1 veriyor. Eğer 1 veriyorsa, yani tüm sigmoid'ler aktif ise, eğri bitişinde bilinen <span class="math inline">\(t\)</span> üzerinden elimizdeki <span class="math inline">\(x\)</span> <span class="math inline">\(x = a_x + b_x(5-2) + c_x(5-3) + d_x(5-3.5) + e_x(5-4.0)\)</span> olmalı. Optimizasyonda bu eşitliğin belli bir değer (istediğimiz bitiş noktası kordinatı) olmasını şart tutarak amacımız erişebiliriz.</p>
<p>Kaynaklar</p>
<p>[1] Marsden, <em>Vector Calculus</em></p>
<p>[2] Strang, <em>Calculus Volume 3, OpenStaxa</em></p>
<p>[3] Sunday, <em>Intersection of Lines and Planes</em>, <a href="http://geomalgorithms.com/a05-_intersect-1.html" class="uri">http://geomalgorithms.com/a05-_intersect-1.html</a></p>
<p>[4] Khaled, <em>Straight Line and Plane Intersection Matlab Code</em>, <a href="https://uk.mathworks.com/matlabcentral/fileexchange/17751-straight-line-and-plane-intersection" class="uri">https://uk.mathworks.com/matlabcentral/fileexchange/17751-straight-line-and-plane-intersection</a></p>
<p>[5] <em>Distance between Point and Line</em>, <a href="https://brilliant.org/wiki/distance-between-point-and-line/" class="uri">https://brilliant.org/wiki/distance-between-point-and-line/</a></p>
<p>[6] Bayramlı, <em>Hesapsal Bilim, Spline Eğrileri ve Baz Fonksiyonlar</em></p>
<p>[7] Rotenberg, <em>CSE169: Computer Animation</em>, <a href="https://cseweb.ucsd.edu/classes/wi19/cse169-a/slides/" class="uri">https://cseweb.ucsd.edu/classes/wi19/cse169-a/slides/</a></p>
<p>[8] Bayramlı, <em>Çok Değişkenli Calculus - Ders 4</em></p>
<p>[9] Bergen, <em>Collision Detection</em></p>
</body>
</html>
