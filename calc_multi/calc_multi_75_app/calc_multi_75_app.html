<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Green'in Teorisi, Düzlem Kesişmeleri, Eğriler</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="greenin-teorisi-düzlem-kesişmeleri-eğriler">Green’in Teorisi,
Düzlem Kesişmeleri, Eğriler</h1>
<p>Çizgi Parçası ve bir 3D Üçgenin Kesişmesi</p>
<p>Bir çizgi parçasını temsil etmek için <span
class="math inline">\(s\)</span> başlangıç noktasından <span
class="math inline">\(t\)</span> varış noktasına giden bir ışın (ray)
hayal edelim, bu çizgi parçası üzerindeki herhangi bir <span
class="math inline">\(x\)</span> noktası [9, sf. 84]</p>
<p><span class="math display">\[
x = s + \lambda (t-s) \quad 0 \le \lambda \le 1
\qquad (1)
\]</span></p>
<p>ile temsil edilebilir, ki <span class="math inline">\(x,s,t\)</span>
üç boyutlu vektörler olmak üzere, yani <span
class="math inline">\(\vec{x},\vec{s},\vec{t}\)</span>.</p>
<p>Bir üçgenin tüm yüzeyini, yani üç noktası arasında kalan tüm alanı üç
boyutta temsil etmek gerekli, çünkü kesişim bu alanda bir yerde olacak,
bunun için ağırlık merkezli (barycentric) kordinat sistemi
kullanabiliriz, üçgen içindeki herhangi bir <span
class="math inline">\(x\)</span> noktasını üç köşe noktasının farklı
ağırlıklarla çarpılıp toplanmış hali olarak görebiliriz, yani üç köşe
<span class="math inline">\(p_0,p_1,p_2\)</span> için</p>
<p><span class="math display">\[
x = \mu_0 p_0 + \mu_1 p_1 + \mu_2 p_2,
\quad \mu_0 + \mu_1 + \mu_2 = 1, \mu_i \ge 0
\]</span></p>
<p>Formülden <span class="math inline">\(\mu_0\)</span>’i atmak mümkün,
onu diğerleri bazında gösterebiliriz, <span class="math inline">\(\mu_0
= 1-\mu_1-\mu_2\)</span>, üstteki formülü tekrar düzenleyince,</p>
<p><span class="math display">\[
x = p_0 + \mu_1 (p_1 - p_0) + \mu_2 (p_2 - p_0)
\qquad (2)
\]</span></p>
<p>Böylece, (1),(2) ile, bizi çizgi parçası biri üçgen sathi ile ilgili
iki formül elde ettik. Kesişme noktası bu iki formülün <span
class="math inline">\(x\)</span>’leri aynı olduğu yerdedir değil mi?
<span class="math inline">\(r=t-s\)</span>, <span
class="math inline">\(d_1=p_1-p_0\)</span>, <span
class="math inline">\(d_2 = p_2-p_0\)</span> diyelim, ve (1) ile (2)’yi
<span class="math inline">\(x\)</span> üzerinden birbirine
eşitleyelim,</p>
<p><span class="math display">\[
s + r\lambda = p_0 + \mu_1 d_1 + \mu_2 d_2
\]</span></p>
<p>formülü bulunabilir. Üstteki formülü matris notasyonunda tekrar
düzenlemek mümkündür,</p>
<p><span class="math display">\[
[\begin{array}{ccc} -r &amp; d_1 &amp; d_2 \end{array}]
\left[\begin{array}{ccc}
\lambda \\ \mu_1 \\ \mu_2
\end{array}\right] = s - p_0
\]</span></p>
<p>Dikkat, <span class="math inline">\(-r,d_1,d_2\)</span> vektör
oluşturmuş gibi gözüküyor ama böyle değil, bu değişkenlerin her birinin
kendisi vektör, onların değerlerinin asağı doğru açılmış hali solda bir
matris yaratıyor, o matrise <span class="math inline">\(A\)</span>
diyelim, yani</p>
<p><span class="math display">\[
\left[\begin{array}{ccc}
\uparrow &amp; \uparrow &amp; \uparrow  \\
-r &amp; d_1 &amp; d_2 \\
\downarrow &amp; \downarrow &amp; \downarrow
\end{array}\right]
\left[\begin{array}{ccc}
\lambda \\ \mu_1 \\ \mu_2
\end{array}\right] = s - p_0
\]</span></p>
<p><span class="math display">\[
A
\left[\begin{array}{ccc}
\lambda \\ \mu_1 \\ \mu_2
\end{array}\right] = s - p_0
\]</span></p>
<p>Sistemi çözmek için</p>
<p><span class="math display">\[
\left[\begin{array}{ccc}
\lambda \\ \mu_1 \\ \mu_2
\end{array}\right] = A^{-1} (s - p_0)
\]</span></p>
<p>Yani <span class="math inline">\(A\)</span>’nin tersini alıp
eşitliğin sağ tarafını soldan çarpınca kesişme noktasındaki <span
class="math inline">\(\lambda,\mu_1,\mu_2\)</span> elde ediliyor.</p>
<p>Bu değerleri kullanarak kesişme noktasının kordinat yerini artık
bulabiliriz, mesela çizgi parçası formülünden yola çıkarsak <span
class="math inline">\(x = s + \lambda (t-s)\)</span> formülüne bulunan
<span class="math inline">\(\lambda\)</span> değerini sokunca, ki <span
class="math inline">\(t,s\)</span> zaten biliniyor, kesişim noktası
<span class="math inline">\(x\)</span> elde edilebilir.</p>
<p>Önemli bir nokta eğer kesişme <em>yoksa</em> üstteki çözümün ne
vereceği. Bu durumda <span class="math inline">\(A\)</span> matrisi
özgün (singular) olur, yani tersi alınamaz. O zaman eğer bir lineer
cebir paketi kullanıyorsak bir hata mesajı alırız. Tabii özgünlüğün
basit bir kontrol yöntemi var, <span
class="math inline">\(A\)</span>’nin determinantını alırız, eğer sıfır
ise matris özgündür, çözüm / kesişme yoktur.</p>
<p>Bu hesabın farklı bazı ekleri için <code>raytri.c</code> koduna
bakılabilir.</p>
<p>Not: Üstteki kod ve [9] lineer cebir sistemini Cramer’in Kuralı ile
çözüyor, o cebirsel açılım sırasında ortaya çıkan determinantlar
kullanılıyor. Detaylar için koda ve kaynağa başvurulabilir.</p>
<p>Örnek</p>
<p>Gerekli grafik rutinleri,</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> mpl_toolkits.mplot3d <span class="im">as</span> a3</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.colors <span class="im">as</span> colors</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pylab <span class="im">as</span> pl</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_tri3d(corners, axx):</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>   tri <span class="op">=</span> a3.art3d.Poly3DCollection([corners])   </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>   tri.set_edgecolor(<span class="st">&#39;k&#39;</span>)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>   tri.set_color(<span class="st">&#39;red&#39;</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>   tri.set_alpha(<span class="fl">0.2</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>   axx.add_collection3d(tri)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>   axx.view_init(elev<span class="op">=</span><span class="dv">20</span>, azim<span class="op">=</span><span class="dv">250</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>   axx.set_xlim(<span class="op">-</span><span class="dv">5</span>,<span class="dv">8</span>)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>   axx.set_ylim(<span class="op">-</span><span class="dv">5</span>,<span class="dv">8</span>)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>   axx.set_zlim(<span class="op">-</span><span class="dv">5</span>,<span class="dv">8</span>)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_line(p0,p1,axx):</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>   axx.plot([p0[<span class="dv">0</span>],p1[<span class="dv">0</span>]],[p0[<span class="dv">1</span>],p1[<span class="dv">1</span>]],[p0[<span class="dv">2</span>],p1[<span class="dv">2</span>]])</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>   </span></code></pre></div>
<p>Bir çizgi parçası ve bir üçgen yaratalım,</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>vtx1 <span class="op">=</span> np.array([[<span class="dv">0</span>,<span class="dv">5</span>,<span class="dv">0</span>],[<span class="dv">8</span>,<span class="dv">4</span>,<span class="dv">0</span> ],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]])</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> a3.Axes3D(pl.figure())</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>plot_tri3d(vtx1,ax)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> np.array([<span class="dv">2</span>,<span class="dv">3</span>,<span class="op">-</span><span class="dv">2</span>])</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.array([<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">2</span>])</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>plot_line(s,t,ax)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;calc_multi_75_app_14.jpg&#39;</span>)</span></code></pre></div>
<p><img src="calc_multi_75_app_14.jpg" /></p>
<p>Kesişmeyi bulmak için,</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy.linalg <span class="im">as</span> lin</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> t <span class="op">-</span> s</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>d1 <span class="op">=</span> vtx1[<span class="dv">1</span>,:]<span class="op">-</span>vtx1[<span class="dv">0</span>,:]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>d2 <span class="op">=</span> vtx1[<span class="dv">2</span>,:]<span class="op">-</span>vtx1[<span class="dv">0</span>,:]</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.zeros((<span class="dv">3</span>,<span class="dv">3</span>))</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>A[:,<span class="dv">0</span>] <span class="op">=</span> <span class="op">-</span>r</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>A[:,<span class="dv">1</span>] <span class="op">=</span> d1</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>A[:,<span class="dv">2</span>] <span class="op">=</span> d2</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;A&#39;</span>,A)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">u&#39;A determinantı&#39;</span>, lin.det(A))</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> np.dot(lin.inv(A),(s<span class="op">-</span>vtx1[<span class="dv">0</span>,:]))</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>lam,mu1,mu2 <span class="op">=</span> <span class="bu">list</span>(res)</span></code></pre></div>
<pre><code>A [[-3.  8.  0.]
 [ 0. -1. -5.]
 [-4.  0.  0.]]
A determinantı 159.99999999999994</code></pre>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (mu1,mu2,mu1<span class="op">+</span>mu2)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>xintersect <span class="op">=</span> s <span class="op">+</span> lam <span class="op">*</span> (t<span class="op">-</span>s)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">u&#39;kesişme noktası&#39;</span>,xintersect)</span></code></pre></div>
<pre><code>0.4375 0.3125 0.75
kesişme noktası [3.5 3.  0. ]</code></pre>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> a3.Axes3D(pl.figure())</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>plot_tri3d(vtx1,ax)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>plot_line(s,t,ax)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>ax.plot(xintersect[<span class="dv">0</span>],xintersect[<span class="dv">1</span>],xintersect[<span class="dv">2</span>],<span class="st">&#39;rd&#39;</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;calc_multi_75_app_15.jpg&#39;</span>)</span></code></pre></div>
<p><img src="calc_multi_75_app_15.jpg" /></p>
<p>Örnek</p>
<p>Kesişmenin olmadığı bir örneğe bakalım,</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> a3.Axes3D(pl.figure())</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>plot_tri3d(vtx1,ax)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> np.array([<span class="op">-</span><span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">3</span>])</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.array([<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">3</span>])</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> t <span class="op">-</span> s</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.zeros((<span class="dv">3</span>,<span class="dv">3</span>))</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>A[:,<span class="dv">0</span>] <span class="op">=</span> <span class="op">-</span>r</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>A[:,<span class="dv">1</span>] <span class="op">=</span> d1</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>A[:,<span class="dv">2</span>] <span class="op">=</span> d2</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;A&#39;</span>,A)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;A determinant&#39;</span>, lin.det(A))</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>plot_line(s,t,ax)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;calc_multi_75_app_16.jpg&#39;</span>)</span></code></pre></div>
<pre><code>A [[-3.  8.  0.]
 [ 4. -1. -5.]
 [ 0.  0.  0.]]
A determinant 0.0</code></pre>
<p><img src="calc_multi_75_app_16.jpg" /></p>
<p>İki 3D Üçgenin Hızlı Kesişme Kontrolü</p>
<p>Üç boyutta iki üçgenin hızlı bir kesişme kontrolü için, ya da
<em>kesişmeme</em> durumunda kesişme ihtimalini hızlı bir şekilde
eleyebilmek için [7] bir yöntem nokta / düzlem [8] mesafe mantığını
kullanmak. Bu yöntemde verili iki üçgen var diyelim, <span
class="math inline">\(T_1\)</span>, ki <span
class="math inline">\((u_0,u_1,u_2)\)</span> köşelerinden oluşuyor, ve
<span class="math inline">\(T_2\)</span>, ki <span
class="math inline">\((v_0,v_1,v_2)\)</span> köşelerinden oluşuyor,
ikinci üçgen için önce üç noktanın ima ettiği düzlemi oluştururuz.</p>
<p><span class="math display">\[
n_2 = (v_1-v_0) \times (v_2 - v_1)
\]</span></p>
<p><span class="math display">\[
d_2 = -n_2 \cdot v_0
\]</span></p>
<p>Sonra <span class="math inline">\(T_1\)</span>’in tüm köşelerinden bu
düzleme olan işaretli mesafeyi hesaplarız.</p>
<p><span class="math display">\[
m_i = n_2 \cdot u_i + d_2
\]</span></p>
<p>Eğer tüm <span class="math inline">\(m_i &lt; 0\)</span> ya da tüm
<span class="math inline">\(m_i &gt; 0\)</span> ise, bu üçgen / üçgen
kesişmesinin olmadığı sonucuna varabiliriz. Bu hızlı, kabaca yapılan bir
ilk test olarak faydalı olabilir.</p>
<p>Yöntem direk üçgen / üçgen bazında bir test değildir, üçgen noktaları
ve diğer üçgenin olduğu <em>düzlem</em> bazında bir testtir fakat
kesişme olmadığı durumda muhakkak kesişme olmadığı sonucuna hızlıca
varabildiği için tercih edilen bir ilk test olabilir. Anlatımda biraz
karışıklık olduysa açmaya uğraşalım, üstteki test kesişme olmadığı her
zaman negatif sonuç verir. Fakat negatif sonuç alınmadıysa bu illa
kesişme olduğu anlamına gelmez. Metot negatif sonuçlarda yüzde yüz
başarılı, bu sebeple kesişme eleme fazında yardımcı olur, kesin kesişme
sonucuna varmak için farklı yöntemler gerekir, mesela daha önce
paylaşılan çizgi / üçgen kesişme yaklaşımı gibi.</p>
<p>Örnek</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>vtx1 <span class="op">=</span> np.array([[<span class="dv">0</span>,<span class="dv">5</span>,<span class="dv">0</span>],[<span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">0</span> ],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]])</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>vtx2 <span class="op">=</span> np.array([[<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">3</span>],[<span class="dv">6</span>,<span class="dv">8</span>,<span class="op">-</span><span class="dv">2</span>],[<span class="dv">6</span>,<span class="op">-</span><span class="dv">4</span>,<span class="op">-</span><span class="dv">2</span>]])</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> a3.Axes3D(pl.figure())</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>plot_tri3d(vtx1,ax)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>plot_tri3d(vtx2,ax)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;calc_multi_75_app_12.jpg&#39;</span>)</span></code></pre></div>
<p><img src="calc_multi_75_app_12.jpg" /></p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ikinci ucgen ile duzlem yarat</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>n2 <span class="op">=</span> np.cross( vtx2[<span class="dv">1</span>,:]<span class="op">-</span>vtx2[<span class="dv">0</span>,:], vtx2[<span class="dv">2</span>,:]<span class="op">-</span>vtx2[<span class="dv">0</span>,:]  )</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>d2 <span class="op">=</span> <span class="op">-</span>np.dot(n2,vtx2[<span class="dv">0</span>,:])</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (n2,d2)</span></code></pre></div>
<pre><code>[-60   0   0] 360</code></pre>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    sdi <span class="op">=</span> np.dot(n2,vtx1[i,:])<span class="op">+</span>d2</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span> (<span class="st">&#39;</span><span class="sc">%d</span><span class="st">. noktaya uzaklik = </span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span> (i,sdi))</span></code></pre></div>
<pre><code>0. noktaya uzaklik = 360
1. noktaya uzaklik = -120
2. noktaya uzaklik = 360</code></pre>
<p>Örnek</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> a3.Axes3D(pl.figure())</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>vtx3 <span class="op">=</span> vtx2 <span class="op">+</span> <span class="dv">3</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>plot_tri3d(vtx1,ax)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>plot_tri3d(vtx3,ax)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;calc_multi_75_app_13.jpg&#39;</span>)</span></code></pre></div>
<p><img src="calc_multi_75_app_13.jpg" /></p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ucuncu ucgen ile duzlem yarat</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>n3 <span class="op">=</span> np.cross( vtx3[<span class="dv">1</span>,:]<span class="op">-</span>vtx3[<span class="dv">0</span>,:], vtx3[<span class="dv">2</span>,:]<span class="op">-</span>vtx3[<span class="dv">0</span>,:]  )</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>d3 <span class="op">=</span> <span class="op">-</span>np.dot(n3,vtx3[<span class="dv">0</span>,:])</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (n3,d3)</span></code></pre></div>
<pre><code>[-60   0   0] 540</code></pre>
<div class="sourceCode" id="cb18"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    sdi <span class="op">=</span> np.dot(n2,vtx1[i,:])<span class="op">+</span>d3</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span> (<span class="st">&#39;</span><span class="sc">%d</span><span class="st">. noktaya uzaklik = </span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span> (i,sdi))</span></code></pre></div>
<pre><code>0. noktaya uzaklik = 540
1. noktaya uzaklik = 60
2. noktaya uzaklik = 540</code></pre>
<p>Daha detaylı kod <code>muller.c</code> ve <code>muller.py</code>
dosyalarında bulunabilir.</p>
<p>Çizgi Düzlem Kesişmesini Vektörler ile Hesaplamak</p>
<p>Üstteki yöntem cebirsel manipülasyon gerektiriyor, fakat sayısal
hesap için sembolik cebir işlemlerine girmeden vektör matematiği ile
direk bir sonuç bulamaz mıyız? [3,4]’ü temel alalım: alttaki durumu
düşünelim,</p>
<p><img src="calc_multi_75_app_06.jpg" /></p>
<p>Grafiğe göre <span class="math inline">\(P(s)\)</span> <span
class="math inline">\(P_1\)</span> ve <span
class="math inline">\(P_0\)</span> arasındaki birim vektörün <span
class="math inline">\(s\)</span> kadar uzatılmış hali olsun, o aralığı
<span class="math inline">\(u\)</span> kabul edersek <span
class="math inline">\(P(s)-V_0 = w + su\)</span> olur. Düzlem ile
kesişmenin olduğu noktayı <span class="math inline">\(P(s_I)\)</span>
diye tanımlayalım, aradığımız nokta burası. O noktada <span
class="math inline">\(n\)</span> ile <span
class="math inline">\(P(s_I)\)</span> dikgen olacaktır, yani <span
class="math inline">\(P(s) - V_0 = w + su\)</span> vektörü <span
class="math inline">\(n\)</span>’e dikgen olacaktır, ki <span
class="math inline">\(w=P_0-V_0\)</span>. Bu durumda <span
class="math inline">\(n \cdot (w+su) = 0\)</span> olur. Bunu
kullanarak,</p>
<p><span class="math display">\[ s_I = \frac{-n \cdot w}{n \cdot u} =
\frac{n \cdot (V_0 - P_0)}{n \cdot (P_1-P_0)} =
\frac{-(ax_0 + by_0 + cz_0 + d)}{n \cdot u}
\]</span></p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> np.array([<span class="fl">1.</span>, <span class="fl">1.</span>, <span class="fl">1.</span>])</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>V0 <span class="op">=</span> np.array([<span class="fl">1.</span>, <span class="fl">1.</span>, <span class="op">-</span><span class="fl">5.</span>])</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>P0 <span class="op">=</span> np.array([<span class="op">-</span><span class="fl">5.</span>, <span class="fl">1.</span>, <span class="op">-</span><span class="fl">1.</span>])</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>P1 <span class="op">=</span> np.array([<span class="fl">1.</span>, <span class="fl">2.</span>, <span class="fl">3.</span>])</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> P0 <span class="op">-</span> V0<span class="op">;</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> P1<span class="op">-</span>P0<span class="op">;</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="op">-</span>np.dot(n,w)<span class="op">;</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> np.dot(n,u)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>sI <span class="op">=</span> N <span class="op">/</span> D</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>I <span class="op">=</span> P0<span class="op">+</span> sI<span class="op">*</span>u</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> I</span></code></pre></div>
<pre><code>[-3.90909091  1.18181818 -0.27272727]</code></pre>
<p>Grafiklersek</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys<span class="op">;</span> sys.path.append(<span class="st">&#39;../../vision/vision_02&#39;</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> plot3d</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> plt.figure()</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> f.gca(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>ax.set_xlim(<span class="op">-</span>w,w)<span class="op">;</span>ax.set_ylim(<span class="op">-</span>w,w)<span class="op">;</span>ax.set_zlim(<span class="op">-</span>w,w)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">&quot;X&quot;</span>)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">&quot;Y&quot;</span>)</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>ax.set_zlabel(<span class="st">&quot;Z&quot;</span>)</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> P1<span class="op">-</span>P0</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>ax.quiver(P0[<span class="dv">0</span>], P0[<span class="dv">1</span>], P0[<span class="dv">2</span>], v[<span class="dv">0</span>], v[<span class="dv">1</span>], v[<span class="dv">2</span>], color<span class="op">=</span><span class="st">&#39;red&#39;</span>)</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>ax.scatter(V0[<span class="dv">0</span>], V0[<span class="dv">1</span>], V0[<span class="dv">2</span>], color<span class="op">=</span><span class="st">&#39;black&#39;</span>)</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>ax.scatter(V0[<span class="dv">0</span>]<span class="op">+</span>n[<span class="dv">0</span>], V0[<span class="dv">1</span>]<span class="op">+</span>n[<span class="dv">1</span>], V0[<span class="dv">2</span>]<span class="op">+</span>n[<span class="dv">2</span>], color<span class="op">=</span><span class="st">&#39;black&#39;</span>)</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>ax.scatter(I[<span class="dv">0</span>], I[<span class="dv">1</span>], I[<span class="dv">2</span>], color<span class="op">=</span><span class="st">&#39;black&#39;</span>)</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>ax.quiver(V0[<span class="dv">0</span>], V0[<span class="dv">1</span>], V0[<span class="dv">2</span>], n[<span class="dv">0</span>], n[<span class="dv">1</span>], n[<span class="dv">2</span>], color<span class="op">=</span><span class="st">&#39;blue&#39;</span>)</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>plot3d.plot_plane(ax, <span class="bu">list</span>(V0), <span class="bu">list</span>(n), color<span class="op">=</span><span class="st">&#39;y&#39;</span>)</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;calc_multi_75_app_07.jpg&#39;</span>)</span></code></pre></div>
<p><img src="calc_multi_75_app_07.jpg" /></p>
<p>Green’in Teorisi, Uzaklaşım, Stokes, Yol ve Çizgi Entegralleri</p>
<p>Yüzeyler (Surfaces)</p>
<p>Üç boyut içindeki iki boyut yüzeyler parametrize edilerek gösterilir,
tek boyutlu eğri bir parametre <span class="math inline">\(t\)</span>
ile parametrize ediliyordu, alan için iki değişken <span
class="math inline">\(u,v\)</span> gerekir. Notasyonel olarak <span
class="math inline">\(r\)</span>’nin taradığı bir yüzey</p>
<p><span class="math display">\[
r(u,v) = &lt; x(u,v), y(u,v), z(u,v) &gt;
\]</span></p>
<p>Mesela <span class="math inline">\(r(u,v) = &lt; u, u^2, v
&gt;\)</span> bir yüzey olabilir.</p>
<p>Yüzey alan hesabı için tüm yüzeyi kenarları <span
class="math inline">\(\Delta u\)</span>, <span
class="math inline">\(\Delta v\)</span> olan hücreler yaratabiliriz. Her
noktada iki tane teğet vektör bulunabilir, bunlar <span
class="math inline">\(t_u\)</span> ve <span
class="math inline">\(t_v\)</span> olsun,</p>
<p><span class="math display">\[
t_u = &lt; \frac{\partial x}{\partial u},
        \frac{\partial y}{\partial u},
        \frac{\partial z}{\partial u} &gt;, \quad
t_v = &lt; \frac{\partial x}{\partial v},
        \frac{\partial y}{\partial v},
        \frac{\partial z}{\partial v} &gt;        
\]</span></p>
<p>Yaklaşık olarak her hücrenin alanı <span class="math inline">\(\Delta
S_{ij}\)</span> her hücredeki <span class="math inline">\(t_u\)</span>
ve <span class="math inline">\(t_v\)</span> (ya da yeni notasyonla
onlara <span class="math inline">\(t_u^{ij}\)</span> ve <span
class="math inline">\(t_v^{ij}\)</span> diyelim) yönündeki <span
class="math inline">\(\Delta u\)</span> ve <span
class="math inline">\(\Delta v\)</span>’nin oluşturduğu paralelogram
alanıdır, bu paralelogram bildiğimiz gibi iki vektörün çapraz
çarpımından gelen üçüncü vektörün büyüklüğüdür, o zaman</p>
<p><span class="math display">\[
\Delta S_{ij} \approx || \Delta u t_u^{ij} \times \Delta v t_v^{ij} ||
\]</span></p>
<p><span class="math display">\[
= ||  t_u^{ij} \times t_v^{ij} || \Delta u \Delta v
\]</span></p>
<p><img src="calc_multi_75_app_01.jpg" /></p>
<p><img src="calc_multi_75_app_02.jpg" /></p>
<p>Tüm ufak hücre alanlarını toplarız, ve hücre sayısı sonsuza
yaklaşırken toplam alan limitine bakabiliriz,</p>
<p><span class="math display">\[
\lim_{m,n \to \infty} \sum_{i=1}^{m} \sum_{j=1}^{n} || t_u^{ij} \times
t_v^{ij} || \Delta u \Delta v
\]</span></p>
<p>Bu limit yüzey alan çift entegral hesabına yaklaşır / onu tanımlar,
[2, sf. 769],</p>
<p><span class="math display">\[
= \iint_D || t_u \times t_v || \mathrm{d} u \mathrm{d} v = \iint_D ||
t_u \times t_v || \mathrm{d} A
\]</span></p>
<p>Yüzey Entegrali (Surface Integral)</p>
<p>Yukarıda gördüklerimiz parametrize edilmiş yüzeyin alanını hesaplamak
içindir. Yüzey entegrali bir yüzey <em>üzerinden</em> alınan
entegrallere verilen isimdir, mesela tek sayı / skalar değerli bir
fonksiyon <span class="math inline">\(f\)</span>’nin pürüzsüz bir yüzey
<span class="math inline">\(S\)</span> üzerinden alınan yüzey entegrali,
o fonksiyonun her noktadaki alan büyüklüğü ile çarpılıp sonuçların
toplanmasıdır, cebirsel olarak yine <span
class="math inline">\(t_u,t_v\)</span> kavramlarını kullanırsak,</p>
<p><span class="math display">\[
\iint_S f(x,y,z) \mathrm{d} S
= \lim_{m,n \to \infty} \sum_{i=1}^{m} \sum_{j=1}^{n} f(P_{ij}) ||
t_u^{ij} \times t_v^{ij} || \Delta u \Delta v
\]</span></p>
<p><span class="math display">\[
= \lim_{m,n \to \infty} \sum_{i=1}^{m} \sum_{j=1}^{n} f(P_{ij}) \Delta
S_{ij}
\]</span></p>
<p>O zaman yüzey entegralleri alttaki şekilde hesaplanabilir,</p>
<p><span class="math display">\[
\iint_S f(x,y,z) \mathrm{d} S =
\iint_D f(r(u,v)) || t_u \times t_v || \mathrm{d} A
\]</span></p>
<p>Çizgi entegrali (line integrals) daha düşük boyuttaki benzer bir
kavram idi.</p>
<p>Vektör Alanları Üzerinden Yüzey Entegrali</p>
<p>Skalar fonksiyona benzer şekilde bir vektör alanı <span
class="math inline">\(F\)</span> ve yüzey <span
class="math inline">\(S\)</span> üzerinden de entegral hesaplanabilir.
Yine bir ufak çarpımlar toplamından bahsediyoruz, bu tür bir hesap pek
çok uygulama için faydalı olabilir. Mesela bir su akışı içindeki
geçirgen bir yüzeyi düşünürsek, kütle akışını (mass flux) nasıl
hesaplarız?</p>
<p><img src="calc_multi_75_app_04.jpg" /></p>
<p>Her noktada yüzey <span class="math inline">\(S\)</span>’ye dik olan
alan <span class="math inline">\(N\)</span> olsun, her noktadaki akış
hızı <span class="math inline">\(v\)</span> diyelim, o zaman bir
noktadaki birim zaman ve birim alandaki kütle akışı <span
class="math inline">\(\rho v \cdot N\)</span>. Ölçüm birimlerini kontrol
edelim, hız <span class="math inline">\(m/s\)</span>, yoğunluk <span
class="math inline">\(\rho\)</span> <span
class="math inline">\(g/m^3\)</span>, çarparsak <span
class="math inline">\(g/s \cdot m^2\)</span> elde ederiz, yani birim
alan ve zamandaki kütle akışı.</p>
<p>Şimdi <span class="math inline">\(\rho v \cdot N\)</span> değerini
<span class="math inline">\(\Delta S_{ij}\)</span> ile çarparsak <span
class="math inline">\(S\)</span> üzerindeki hayali ufak hücreden birim
zamanda akan kütleyi buluruz, tüm bu akışları toplarız,</p>
<p><span class="math display">\[
\sum_{i=1}^{m} \sum_{j=1}^{n} (\rho v \cdot N) \Delta S_{ij}
\]</span></p>
<p>Tüm akışı elde etmiş oluruz. Izgara hücreleri <span
class="math inline">\(S_{ij}\)</span> ufaldıkça üstteki toplam gerçek
kütle akışına yaklaşır, yani</p>
<p><span class="math display">\[
\iint_S \rho v \cdot N \mathrm{d} S = \lim_{m,n \to \infty}
\sum_{i=1}^{m} \sum_{j=1}^{n} (\rho v \cdot N) \Delta S_{ij}
\]</span></p>
<p>Devam edelim <span class="math inline">\(\rho v\)</span> yerine
herhangi bir vektör alanı <span class="math inline">\(F\)</span>
kullanalım, o zaman şu genel tanımı artık yapabiliriz, <span
class="math inline">\(F\)</span>’nin <span
class="math inline">\(S\)</span> yüzeyi üzerinden entegrali</p>
<p><span class="math display">\[
\iint_S \vec{F} \cdot \mathrm{d} \vec{S} = \iint_S \vec{F} \cdot \vec{N}
\mathrm{d} S
\]</span></p>
<p>olarak gösterilir.</p>
<p><img src="calc_multi_75_app_05.jpg" /></p>
<p>Dikkat her yerde vektör notasyonu kullanmıyoruz, olmadığı yerde
formül çerçevesine göre anlaşılabilir.</p>
<p><span class="math inline">\(N\)</span> yüzey normalı, öne dik olan
birim vektör, hesabı için önceden gördüğümüz <span
class="math inline">\(t_u,t_v\)</span> vektörlerini kullanabiliriz,</p>
<p><span class="math display">\[
N = \frac{t_u \times t_v}{ || t_u \times t_v || }
\]</span></p>
<p>Üstteki ifadeyi yüzey entegralinde kullanırsak [2, sf. 778],</p>
<p><span class="math display">\[
\iint_S \vec{F} \cdot \vec{N} \mathrm{d} S =
\iint_S \vec{F} \cdot \frac{t_u \times t_v}{ || t_u \times t_v || }
\mathrm{d} S
\]</span></p>
<p>Daha önce gördük</p>
<p><span class="math display">\[
\mathrm{d} S = || t_u \times t_v || \mathrm{d} u \mathrm{d} v = || t_u
\times t_v || \mathrm{d} A
\]</span></p>
<p>İki üste geçirince</p>
<p><span class="math display">\[
= \iint_D \vec{F}(r(u,v)) \cdot \frac{t_u \times t_v}{ || t_u \times t_v
|| }
|| t_u \times t_v || \mathrm{d} A
\]</span></p>
<p>Basitleştirme sonrası,</p>
<p><span class="math display">\[
= \iint_D \vec{F}(r(u,v)) \cdot (t_u \times t_v) || t_u \times t_v ||
\mathrm{d} A
\]</span></p>
<p>Soru</p>
<p><span class="math inline">\(F = &lt; -y, x, 0 &gt;\)</span> olarak
veriliyor, <span class="math inline">\(S\)</span> yüzeyi <span
class="math inline">\(r(u,v) = &lt; u, v^2 - u, u+v &gt;\)</span>.</p>
<p><span class="math inline">\(\iint_S F \cdot N \mathrm{d} S\)</span>
yüzey entegralini hesaplayın.</p>
<p>Cevap</p>
<p>Teğet vektörler <span class="math inline">\(t_u = &lt; 1, -1, 1
&gt;\)</span>, ve <span class="math inline">\(t_v = &lt; 0, 2v, 1
&gt;\)</span>.</p>
<p><span class="math inline">\(t_u \times t_v\)</span> çapraz
çarpımı</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sympy</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>u,v <span class="op">=</span> sympy.symbols(<span class="st">&#39;u v&#39;</span>)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>t_u <span class="op">=</span> sympy.Matrix([[<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>]])</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>t_v <span class="op">=</span> sympy.Matrix([[<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>v,<span class="dv">1</span>]])</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (t_u.cross(t_v))</span></code></pre></div>
<pre><code>Matrix([[-2*v - 1, -1, 2*v]])</code></pre>
<p>Yüzey entegral hesabı şöyle hesaplanabilir,</p>
<p><span class="math display">\[
\int _{0}^{4} \int _{0}^{3} F(r(u,v)) \cdot (t_u \times t_v) \mathrm{d}
u \mathrm{d} v
\]</span></p>
<p>Verili <span class="math inline">\(F = &lt; -y, x, 0 &gt;\)</span>,
ve yüzey <span class="math inline">\(r(u,v) = &lt; u, v^2 - u, u+v
&gt;\)</span> demiştik, o zaman</p>
<p><span class="math display">\[
F(r(u,v)) = &lt; u-v^2, u, 0 &gt;
\]</span></p>
<p>olur. Tüm entegral</p>
<p><span class="math display">\[
= \int _{0}^{4} \int _{0}^{3} &lt; u-v^2, u, 0 &gt;  \cdot &lt; -1-2v,
-1, 2v &gt;
\mathrm{d} u \mathrm{d} v
\]</span></p>
<p><span class="math display">\[
= \int_{0}^{4} \int_{0}^{3} (2v^3 + v^2 -2uv -2u )
\mathrm{d} u \mathrm{d} v
\]</span></p>
<p><span class="math display">\[
= \int_{0}^{4} [ 2v^3u + v^2u - vu^2 - u^2 ]_{0}^{3} \mathrm{d} v
\]</span></p>
<p><span class="math display">\[
= \int_{0}^{4} (6v^3 + 3v^2 - 9v -9 ) \mathrm{d} v
\]</span></p>
<p><span class="math display">\[
= \left[ \frac{3v^4}{2} + v^3 - \frac{9v^2}{2} - 9v \right]_{0}^{4}
\]</span></p>
<p><span class="math display">\[
= 340
\]</span></p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpl_toolkits.mplot3d <span class="im">import</span> Axes3D</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> cm</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">111</span>, projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">100</span>)</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">4</span>, <span class="dv">100</span>)</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>u,v <span class="op">=</span> np.meshgrid(u,v)</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> u<span class="op">;</span> y <span class="op">=</span> v<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> u<span class="op">;</span> z <span class="op">=</span> u <span class="op">+</span> v</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>ax.plot_surface(x, y, z, rstride<span class="op">=</span><span class="dv">4</span>, cstride<span class="op">=</span><span class="dv">4</span>, cmap <span class="op">=</span> cm.copper)</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">5</span>)</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">5</span>)</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">6</span>, <span class="dv">5</span>)</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>fu <span class="op">=</span> <span class="op">-</span>y<span class="op">;</span> fv <span class="op">=</span> x<span class="op">;</span> fw <span class="op">=</span> z<span class="op">*</span><span class="dv">0</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>xx,yy,zz <span class="op">=</span> np.meshgrid(x,y,z)</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>ax.quiver(xx, yy, zz, fu, fv, fw, length<span class="op">=</span><span class="fl">0.2</span>, color <span class="op">=</span> <span class="st">&#39;red&#39;</span>)</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>ax.view_init(elev<span class="op">=</span><span class="dv">18</span>, azim<span class="op">=-</span><span class="dv">46</span>)</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;calc_multi_75_app_03.jpg&#39;</span>,quality<span class="op">=</span><span class="dv">30</span>)</span></code></pre></div>
<p><img src="calc_multi_75_app_03.jpg" /></p>
<p>Çizgi Düzlem Kesişmesi</p>
<p>Elimizde <span class="math inline">\(P = 2x + y - 4z = 4\)</span>
düzlemi var. Bu düzlemin</p>
<p><span class="math display">\[ x = t \quad y = 2 + 3t \quad z =
t\]</span></p>
<p>çizgisi ile kesiştiği yer neresidir?</p>
<p>Cevap kolay; çizgi denkleminde <span class="math inline">\(t\)</span>
bazlı tanımlı <span class="math inline">\(x,y,z\)</span> değerleri <span
class="math inline">\(P\)</span>’ye sokarsak, tek bilinmeyeni <span
class="math inline">\(t\)</span> olan bir denklem çıkar,</p>
<p><span class="math display">\[ 2(t) + (2+3t)-4(t) = 4 \Rightarrow t =
2\]</span></p>
<p>İki Nokta Arasında Parametrize Edilmiş Eğri</p>
<p>Diyelim ki <span class="math inline">\((1,1)\)</span> ve <span
class="math inline">\((4,4)\)</span> noktalarından geçen ve dışarıdan
tanımlı parametrelerle yeterince eğilip, bükülebilecek bir eğri
tanımlamamız lazım. Polinomlar üzerinden tanımlanan bir eğri ile bunu
başarabiliriz,</p>
<p><span class="math display">\[
x(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3
\]</span></p>
<p><span class="math display">\[
y(t) = b_0 + b_1 t + b_2 t^2 + b_3 t^3
\]</span></p>
<p>Bu şekilde bir eğri yeterince eğilip bükülebilir, ve istenen şekle
sokulabilir. Fakat baş ve sonun verili noktalardan geçmesini nasıl
garanti ederiz? Bunun için bu noktaları üstteki denkleme sokalim, ve
<span class="math inline">\(0 \le t \le 1\)</span> olacak sekilde
kısıtlama yapalim, <span class="math inline">\(t=0\)</span>’da</p>
<p><span class="math display">\[
1 = a_0 + a_1 (0) + a_2 (0)^2 + a_3 (0)^3
\]</span></p>
<p><span class="math display">\[
1 = b_0 + b_1 (0) + b_2 (0)^2 + b_3 (0)^3
\]</span></p>
<p>Yani <span class="math inline">\(a_0=1\)</span> ve <span
class="math inline">\(b_0=1\)</span>. Peki <span
class="math inline">\(t=1\)</span> icin?</p>
<p><span class="math display">\[
4 = 1 + a_1 (1) + a_2 (1)^2 + a_3 (1)^3
\]</span></p>
<p><span class="math display">\[
4 = 1 + b_1 (1) + b_2 (1)^2 + b_3 (1)^3
\]</span></p>
<p><span class="math display">\[
3 = a_1 + a_2 + a_3, \quad 3 = b_1 + b_2 + b_3
\]</span></p>
<p>Demek ki üstteki iki formüle mutabık kaldığımız sürece <span
class="math inline">\(a_1,a_2,a_3,b_1,b_2,b_3\)</span> ie istediğimiz
şekilde oynayarak istediğimiz eğriyi ortaya çıkartabiliriz.</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="fl">1.0</span>,<span class="dv">100</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>a1,a2 <span class="op">=</span> <span class="op">-</span><span class="fl">1.1</span>, <span class="fl">1.9</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>b1,b2 <span class="op">=</span> <span class="fl">1.1</span>, <span class="fl">1.4</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>sx,sy<span class="op">=</span>(<span class="fl">1.0</span>,<span class="fl">1.0</span>)</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>ex,ey<span class="op">=</span>(<span class="fl">4.0</span>,<span class="fl">4.0</span>)</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>a3 <span class="op">=</span> ex <span class="op">-</span> sx <span class="op">-</span> (a1<span class="op">+</span>a2)</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>b3 <span class="op">=</span> ey <span class="op">-</span> sy <span class="op">-</span> (b1<span class="op">+</span>b2)</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="fl">1.0</span> <span class="op">+</span> a1<span class="op">*</span>t <span class="op">+</span> a2<span class="op">*</span>t<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> a3<span class="op">*</span>t<span class="op">**</span><span class="dv">3</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="fl">1.0</span> <span class="op">+</span> b1<span class="op">*</span>t <span class="op">+</span> b2<span class="op">*</span>t<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> b3<span class="op">*</span>t<span class="op">**</span><span class="dv">3</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">0</span>,<span class="fl">5.0</span>)</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="dv">0</span>,<span class="fl">5.0</span>)</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>plt.plot(x,y)</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;calc_multi_75_app_08.jpg&#39;</span>)</span></code></pre></div>
<p><img src="calc_multi_75_app_08.jpg" /></p>
<p>Max ve Sigmoid Bazlı Yaklaşım</p>
<p>Daha önce [6]’da görülen spline tekniğinin parametrik hali de
olabilir. Mesela</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>a1,b1,c1,d1 <span class="op">=</span> (<span class="dv">1</span>, <span class="op">-</span><span class="fl">1.4</span>, <span class="dv">2</span>, <span class="fl">2.5</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>a2,b2,c2,d2 <span class="op">=</span> (<span class="dv">1</span>, <span class="fl">1.4</span>, <span class="dv">1</span>, <span class="fl">2.5</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(t):</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> ax <span class="op">+</span> <span class="op">\</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>        bx<span class="op">*</span>np.<span class="bu">max</span>([<span class="dv">0</span>,t<span class="op">-</span><span class="dv">2</span>]) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>        cx<span class="op">*</span>np.<span class="bu">max</span>([<span class="dv">0</span>,t<span class="op">-</span><span class="dv">3</span>]) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>        dx<span class="op">*</span>np.<span class="bu">max</span>([<span class="dv">0</span>,t<span class="op">-</span><span class="dv">4</span>])</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>       </span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> ay <span class="op">+</span> <span class="op">\</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>        by<span class="op">*</span>np.<span class="bu">max</span>([<span class="dv">0</span>,t<span class="op">-</span><span class="dv">2</span>]) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>        cy<span class="op">*</span>np.<span class="bu">max</span>([<span class="dv">0</span>,t<span class="op">-</span><span class="dv">3</span>]) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>        dy<span class="op">*</span>np.<span class="bu">max</span>([<span class="dv">0</span>,t<span class="op">-</span><span class="dv">4</span>])</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x,y     </span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>tmp <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">5</span>,<span class="dv">100</span>)</span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> np.array([f(tt) <span class="cf">for</span> tt <span class="kw">in</span> tmp])</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>plt.plot(res[:,<span class="dv">0</span>],res[:,<span class="dv">1</span>])</span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;calc_multi_75_app_09.jpg&#39;</span>)</span></code></pre></div>
<p><img src="calc_multi_75_app_09.jpg" /></p>
<p>Başlangıcı <span class="math inline">\(a_x,a_y\)</span> olan kesik
bir eğriyi görüyoruz. Bu tür eğrileri aynen [6]’da olduğu gibi sigmoid
bazlı yapabiliriz,</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>rho <span class="op">=</span> <span class="fl">7.0</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sig(x,a):</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> (x<span class="op">-</span>a)<span class="op">*</span><span class="dv">1</span><span class="op">/</span>(<span class="dv">1</span><span class="op">+</span>np.exp(<span class="op">-</span>rho<span class="op">*</span>(x<span class="op">-</span>a)))</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maxk(x,a):</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> np.<span class="bu">max</span>([<span class="dv">0</span>,x<span class="op">-</span>a])</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>ax,bx,cx,dx,ex <span class="op">=</span> (<span class="dv">1</span>, <span class="fl">2.4</span>, <span class="dv">1</span>, <span class="op">-</span><span class="fl">3.5</span>, <span class="op">-</span><span class="fl">2.1</span>)</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>ay,by,cy,dy,ey <span class="op">=</span> (<span class="dv">1</span>, <span class="fl">0.4</span>, <span class="op">-</span><span class="fl">0.1</span>, <span class="fl">0.5</span>, <span class="op">-</span><span class="dv">3</span>)</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(t):</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> ax <span class="op">+</span> <span class="op">\</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>        bx<span class="op">*</span>maxk(t,<span class="dv">2</span>) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>        cx<span class="op">*</span>maxk(t,<span class="dv">3</span>) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>        dx<span class="op">*</span>maxk(t,<span class="fl">3.5</span>) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>        ex<span class="op">*</span>maxk(t,<span class="fl">4.0</span>)</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>       </span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> ay <span class="op">+</span> <span class="op">\</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>        by<span class="op">*</span>maxk(t,<span class="dv">2</span>) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>        cy<span class="op">*</span>maxk(t,<span class="dv">3</span>) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>        dy<span class="op">*</span>maxk(t,<span class="fl">3.5</span>) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>        ey<span class="op">*</span>maxk(t,<span class="fl">4.0</span>)</span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x,y     </span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> g(t):</span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> ax <span class="op">+</span> <span class="op">\</span></span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a>        bx<span class="op">*</span>sig(t,<span class="dv">2</span>) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a>        cx<span class="op">*</span>sig(t,<span class="dv">3</span>) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a>        dx<span class="op">*</span>sig(t,<span class="fl">3.5</span>) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a>        ex<span class="op">*</span>sig(t,<span class="fl">4.0</span>)</span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a>       </span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> ay <span class="op">+</span> <span class="op">\</span></span>
<span id="cb28-32"><a href="#cb28-32" aria-hidden="true" tabindex="-1"></a>        by<span class="op">*</span>sig(t,<span class="dv">2</span>) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb28-33"><a href="#cb28-33" aria-hidden="true" tabindex="-1"></a>        cy<span class="op">*</span>sig(t,<span class="dv">3</span>) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb28-34"><a href="#cb28-34" aria-hidden="true" tabindex="-1"></a>        dy<span class="op">*</span>sig(t,<span class="fl">3.5</span>) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb28-35"><a href="#cb28-35" aria-hidden="true" tabindex="-1"></a>        ey<span class="op">*</span>sig(t,<span class="fl">4.0</span>)</span>
<span id="cb28-36"><a href="#cb28-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x,y     </span>
<span id="cb28-37"><a href="#cb28-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-38"><a href="#cb28-38" aria-hidden="true" tabindex="-1"></a>tmp <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">5</span>,<span class="dv">100</span>)</span></code></pre></div>
<div class="sourceCode" id="cb29"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> np.array([f(tt) <span class="cf">for</span> tt <span class="kw">in</span> tmp])</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>plt.plot(res[:,<span class="dv">0</span>],res[:,<span class="dv">1</span>])</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;calc_multi_75_app_10.jpg&#39;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb30"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> np.array([g(tt) <span class="cf">for</span> tt <span class="kw">in</span> tmp])</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>plt.plot(res[:,<span class="dv">0</span>],res[:,<span class="dv">1</span>])</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;calc_multi_75_app_11.jpg&#39;</span>)</span></code></pre></div>
<p><img src="calc_multi_75_app_10.jpg" /> <img
src="calc_multi_75_app_11.jpg" /></p>
<p>Herhangi bir şekli katsayılarla yaratmak mümkün.</p>
<p>Bitiş noktalasını nasıl ayarlarız? Burada yine polinom örnekteki gibi
cebirsel bir yöntem seçebilirdik, fakat çoğunlukla başlangıç ve bitiş
arasındaki eğriler bir optimizasyon bağlamında kullanılır. Bu durumda
bitiş noktaları ile katsayılar arasında bir optimizasyon kısıtlaması
yaratmak ve bitiş noktalarını böyle ayarlamak daha iyidir.</p>
<p>Çünkü biliyoruz parametrize ortamda mesela önceki örnekte <span
class="math inline">\(0 \ge t \ge 5\)</span>. O zaman egrinin bitisinde
<span class="math inline">\(t=5\)</span> olacağını biliyoruz. Bu durumda
mesela</p>
<p><span class="math display">\[
    x = a_x + \
        b_x \sigma(t,2) + \
        c_x \sigma(t,3) + \
        d_x \sigma(t,3.5) +
        e_x \sigma(t,4.0)
\]</span></p>
<p>ifadesine <span class="math inline">\(t\)</span> tüm ilmik
noktalarının ötesinde olduğu için artık tüm <span
class="math inline">\(\sigma\)</span> ifadeleri 1 veriyor. Eğer 1
veriyorsa, yani tüm sigmoid’ler aktif ise, eğri bitişinde bilinen <span
class="math inline">\(t\)</span> üzerinden elimizdeki <span
class="math inline">\(x\)</span> <span class="math inline">\(x = a_x +
b_x(5-2) + c_x(5-3) + d_x(5-3.5) + e_x(5-4.0)\)</span> olmalı.
Optimizasyonda bu eşitliğin belli bir değer (istediğimiz bitiş noktası
kordinatı) olmasını şart tutarak amacımız erişebiliriz.</p>
<p>Kaynaklar</p>
<p>[1] Marsden, <em>Vector Calculus</em></p>
<p>[2] Strang, <em>Calculus Volume 3, OpenStaxa</em></p>
<p>[3] Sunday, <em>Intersection of Lines and Planes</em>, <a
href="http://geomalgorithms.com/a05-_intersect-1.html">http://geomalgorithms.com/a05-_intersect-1.html</a></p>
<p>[4] Khaled, <em>Straight Line and Plane Intersection Matlab
Code</em>, <a
href="https://uk.mathworks.com/matlabcentral/fileexchange/17751-straight-line-and-plane-intersection">https://uk.mathworks.com/matlabcentral/fileexchange/17751-straight-line-and-plane-intersection</a></p>
<p>[5] <em>Distance between Point and Line</em>, <a
href="https://brilliant.org/wiki/distance-between-point-and-line/">https://brilliant.org/wiki/distance-between-point-and-line/</a></p>
<p>[6] Bayramlı, <em>Hesapsal Bilim, Spline Eğrileri ve Baz
Fonksiyonlar</em></p>
<p>[7] Rotenberg, <em>CSE169: Computer Animation</em>, <a
href="https://cseweb.ucsd.edu/classes/wi19/cse169-a/slides/">https://cseweb.ucsd.edu/classes/wi19/cse169-a/slides/</a></p>
<p>[8] Bayramlı, <em>Çok Değişkenli Calculus - Ders 4</em></p>
<p>[9] Bergen, <em>Collision Detection</em></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
