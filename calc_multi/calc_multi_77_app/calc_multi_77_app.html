<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Poligon Alanı, Nokta Bulutları, Noktaları Çevreleyen Bölgeler</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="poligon-alanı-nokta-bulutları-noktaları-çevreleyen-bölgeler">Poligon Alanı, Nokta Bulutları, Noktaları Çevreleyen Bölgeler</h1>
<p>Poligon, Üçgen Alanı</p>
<p>[8] notlarından iki vektörün temsil ettiği bir üçgenin alanının bu iki vektörün çapraz çarpmından gelen vektörün uzunluğu olduğunu biliyoruz.</p>
<div class="figure">
<img src="triar4.png" />

</div>
<p>O iki vektörün temsil ettiği üçgenin alanı ise paralelogramın yarısıdır,</p>
<div class="figure">
<img src="triar3.png" />

</div>
<p>Bir üçgenin alanını içindeki üç tane alt üçgen üzerinden de hesaplayabilirdik, elimizde üç nokta var ise, mesela <span class="math inline">\((x_1,y_1)\)</span>, <span class="math inline">\((x_2,y_2)\)</span>, <span class="math inline">\((x_3,y_3)\)</span>, üçgenin ortasında orijin olduğunu kabul edersek, orijinden o noktalara giden üç vektör üzerinden 3 tane üçgen ile büyük üçgenin alanını hesaplayabiliriz [9, sf. 272],</p>
<div class="figure">
<img src="triar5.jpg" />

</div>
<p><span class="math display">\[
Alan = 1/2 \left( 
\left|\begin{array}{cc}
x_1 &amp; y_1 \\ x_2 &amp; y_2 
\end{array}\right| + 
\left|\begin{array}{cc}
x_2 &amp; y_2 \\ x_3 &amp; y_3 
\end{array}\right| + 
\left|\begin{array}{cc}
x_3 &amp; y_3 \\ x_1 &amp; y_1
\end{array}\right| \right)
\]</span></p>
<p>Üç tane determinant hesabı gösteriliyor, açılımı</p>
<p><span class="math display">\[
\frac{1}{2} (x_1 y_2  - x_2 y_1) + 
\frac{1}{2} (x_2 y_3  - x_3 y_2) + 
\frac{1}{2} (x_3 y_1  - x_1 y_3) 
\]</span></p>
<p>Benzer şekilde herhangi bir poligon alanı da hesaplanabilir,</p>
<div class="figure">
<img src="triar1.png" />

</div>
<p>Bu poligon içinde üçgenleri toplayarak tüm poligon alanı hesaplanır,</p>
<div class="figure">
<img src="triar2.png" />

</div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy.linalg <span class="im">as</span> lin
pts <span class="op">=</span> [[<span class="op">-</span><span class="dv">2</span>, <span class="dv">-2</span>],[<span class="dv">0</span>, <span class="dv">4</span>],[<span class="dv">3</span>, <span class="dv">-1</span>],[<span class="dv">1</span>, <span class="dv">-1</span>]]
s <span class="op">=</span> <span class="op">\</span>
lin.det(np.vstack((pts[<span class="dv">0</span>],pts[<span class="dv">1</span>]))) <span class="op">+</span> <span class="op">\</span>
lin.det(np .vstack((pts[<span class="dv">1</span>],pts[<span class="dv">2</span>]))) <span class="op">+</span> <span class="op">\</span>
lin.det(np.vstack((pts[<span class="dv">2</span>],pts[<span class="dv">3</span>]))) <span class="op">+</span> <span class="op">\</span>
lin.det(np.vstack((pts[<span class="dv">3</span>],pts[<span class="dv">0</span>])))
<span class="bu">print</span> (np.<span class="bu">abs</span>(s) <span class="op">/</span> <span class="dv">2</span>)</code></pre></div>
<pre><code>13.0</code></pre>
<p>Vektörlerin illa ki bir orijinden çıktığı varsayımı da şart değil, üstteki hesabı orijin merkezli olmayan noktalar için yaparsak yine aynı sonucu elde ediyoruz, bunun ispatını vermiyoruz fakat düşünürsek her türlü üçgeni alanını değiştirmeden sadece kaydırıp orijin merkezli hale getirebilirdik, ve yakın orantılı sayılarla yapılan benzer hesaplar hala geçerli olurdu.</p>
<p>Bu konu hakkında karşımıza çıkabilecek bir isim Ayakkabı Bağı (Shoelace) tekniği, bu teknik üstteki yaklaşımın cebirsel olarak açılımıdır sadece, değişkenler belli şekilde yanyana dizilince bir çapraz ayakkabı bağı şekli çıktığı için bu isim verilmiş, tabii bu çaprazlığın üstteki determinantın gerektirdiği çapraz çarpımla yakın ilişkisi olduğu da görülebilir.</p>
<p>Dışbükey Zarf (Convex Hull)</p>
<p>Yaklaşık olarak işleyen yaklaşımlardan biri [3, sf. 154]'de. Bu yaklaşıma göre veri noktalarında önce minimum <span class="math inline">\(x\)</span> ve maksimum <span class="math inline">\(x\)</span> değerleri bulunur (yani en sol ve en sağ uç noktalar), ardından bu noktalar arası dikey şeritlere bölünür.</p>
<div class="figure">
<img src="enc_03.png" />

</div>
<p>Sonra algoritma solda sağa giderek her şerit içinde dikey en maksimum ve minimum iki noktayı bulur. Bu noktalar sırasıyla üst ve alt zarf noktaları olacaktır. Algoritma tamamlanınca bu minimal, maksimal noktalarının hepsini alıp üzerinde standart dışbükey zarf algoritmalarından birini işletiriz. Fakat eldeki noktaların sayısı artık oldukça azaldığı için algoritmanın tamamı çok hızlı çalışacaktır. Algoritmanın karmaşıklığı <span class="math inline">\(O(N)\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">xmin <span class="op">=</span> np.<span class="bu">min</span>(points[:,<span class="dv">0</span>])
xmax <span class="op">=</span> np.<span class="bu">max</span>(points[:,<span class="dv">1</span>])
<span class="bu">print</span> xmin, xmax
bins <span class="op">=</span> np.linspace(xmin,xmax,<span class="dv">10</span>)
bidx <span class="op">=</span> np.digitize(points[:,<span class="dv">0</span>], bins)
mins <span class="op">=</span> []<span class="op">;</span> maxs <span class="op">=</span> []
<span class="cf">for</span> idx <span class="kw">in</span> np.unique(bidx):
    tmp<span class="op">=</span>points[bidx<span class="op">==</span>idx]
    mins.append(tmp[np.argmin(points[bidx<span class="op">==</span>idx,<span class="dv">1</span>])])
    maxs.append(tmp[np.argmax(points[bidx<span class="op">==</span>idx,<span class="dv">1</span>])])
mins<span class="op">=</span>np.array(mins)
maxs<span class="op">=</span>np.array(maxs)</code></pre></div>
<pre><code>6.85483870968 13.2291666667</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">plt.plot(points[:,<span class="dv">0</span>], points[:,<span class="dv">1</span>], <span class="st">&#39;o&#39;</span>)
plt.plot(mins[:,<span class="dv">0</span>], mins[:,<span class="dv">1</span>], <span class="st">&#39;dr&#39;</span>)
plt.plot(maxs[:,<span class="dv">0</span>], maxs[:,<span class="dv">1</span>], <span class="st">&#39;dr&#39;</span>)
plt.xlim(<span class="dv">6</span>,<span class="dv">12</span>)<span class="op">;</span> plt.ylim(<span class="dv">8</span>,<span class="dv">15</span>)
plt.savefig(<span class="st">&#39;enc_02.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="enc_02.png" />

</div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">approx <span class="op">=</span> np.vstack((mins,maxs))
hull <span class="op">=</span> ConvexHull(approx)
plt.plot(approx[:,<span class="dv">0</span>], approx[:,<span class="dv">1</span>], <span class="st">&#39;o&#39;</span>)
<span class="cf">for</span> simplex <span class="kw">in</span> hull.simplices:
    plt.plot(approx[simplex, <span class="dv">0</span>], approx[simplex, <span class="dv">1</span>], <span class="st">&#39;k-&#39;</span>)
plt.xlim(<span class="dv">6</span>,<span class="dv">12</span>)<span class="op">;</span> plt.ylim(<span class="dv">8</span>,<span class="dv">15</span>)
plt.savefig(<span class="st">&#39;enc_10.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="enc_10.png" />

</div>
<p>Nokta, Bölge İçinde mi Dışında mı?</p>
<p>Diyelim ki 2 boyutta olmak üzere, elimizde dışbükey bir bölgeyi temsil eden noktalar var, ve elimizdeki bir başka noktanın bu bölge içinde mi dışında mı olduğunu merak ediyoruz. Bölgeyi tanımlayan analitik bir fonksiyon yok, mesela bir elips formülü gibi bir tanım olsaydı, direk herhangi bir kordinatı geçip <span class="math inline">\(&lt;1\)</span>, ya da <span class="math inline">\(&gt;1\)</span> cevabını alabilirdik. Burada noktalar var, ama araları birleşik değil.</p>
<div class="figure">
<img src="enc_05.png" />

</div>
<p>Çapraz çarpımla bu sorunu çözebiliriz [4]. Bir nokta bir vektörün sağında mı solunda mı sorusunun cevabını çapraz çarpımdan alabiliriz, tabii nokta vektör olarak gösterilebildiğine göre, bir vektör diğerinin sağında mı solunda mı sorusu.. Ama bunu da açalım, sağda olmak demek, &quot;saat yönüne 180 dereceden az gitmek'' demek. Neyse, sağda solda olmanın fark ettiğini biliyoruz, bir, sağ el kuralından, iki, <span class="math inline">\(A \times B = -B \times A\)</span>. Tüm bu tanımlar tabii ki temelde gidip determinant kullanan hesaba bağlanıyor. Söylediklerimizin hepsi o tanım üzerinde test edilebilir, bkz [5].</p>
<p>O zaman çapraz çarpım bize sağda, solda olmayı söylüyorsa, şu hesabı yaparsak ne olur? Verili bir <span class="math inline">\(x\)</span> noktası ve bir kapalı bölge oluşturan <span class="math inline">\(p_1,..,p_N\)</span> var, biz her <span class="math inline">\(i = 1,..,N\)</span> için</p>
<p><span class="math display">\[ (x-p_i) \times (p_{i+1}-p_i) \]</span></p>
<p>hesabını yaparız (not bu hesap dışbükey bölgeler için işler). Bu hesap şu vektörleri baz alıyor,</p>
<div class="figure">
<img src="enc_04.png" />

</div>
<p><span class="math inline">\(p_{i+1}-p_i\)</span> kapalı bölgeyi çevreleyen vektörler, <span class="math inline">\(x-p_i\)</span> ise bölge noktasından içeride (ya da dışarıda) olan noktaya giden vektör. Eğer bir nokta bölge içindeyse 1-a, 2-b çapraz çarpımları hep aynı işaretli olmalı, yani <span class="math inline">\(x\)</span> her zaman 1'ın 2'nin, vs. sağında. Ama nokta dışarıda olsaydı,</p>
<div class="figure">
<img src="enc_06.png" />

</div>
<p>1-a ile 2-b çapraz çarpımlarının işareti farklı mesela. Bunu kullanabiliriz, tüm çapraz çarpımları alıp sonuç vektöründeki tüm öğelerin aynı işarette olup olmadığını kontrol ederiz. Eğer öyle ise nokta içeridedir, yoksa dışarıda. Örnek kod ve bazı veriler üzerinde görelim.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pandas <span class="im">as</span> pd
<span class="im">from</span> math <span class="im">import</span> sqrt, fabs

<span class="kw">def</span> plot_line(pt1,pt2,color):
    plt.plot(np.array([pt1[<span class="dv">0</span>],pt2[<span class="dv">0</span>]]),np.array([pt1[<span class="dv">1</span>],pt2[<span class="dv">1</span>]]),color<span class="op">=</span>color)
    
<span class="kw">def</span> plot_quad(c,color<span class="op">=</span><span class="st">&#39;r&#39;</span>):
    plot_line(c[<span class="dv">1</span>],c[<span class="dv">0</span>],color)
    plot_line(c[<span class="dv">2</span>],c[<span class="dv">1</span>],color)
    plot_line(c[<span class="dv">3</span>],c[<span class="dv">2</span>],color)
    plot_line(c[<span class="dv">0</span>],c[<span class="dv">3</span>],color)

rect1 <span class="op">=</span> [[<span class="dv">6</span>,<span class="dv">8</span>],[<span class="dv">12</span>,<span class="dv">10</span>],[<span class="dv">13</span>,<span class="dv">15</span>],[<span class="dv">6</span>,<span class="dv">14</span>]]
plot_quad(rect1)
plt.xlim(<span class="dv">0</span>,<span class="dv">20</span>)<span class="op">;</span> plt.ylim(<span class="dv">0</span>,<span class="dv">20</span>)

pt1 <span class="op">=</span> np.array([<span class="dv">10</span>,<span class="dv">10</span>])
pt2 <span class="op">=</span> np.array([<span class="dv">15</span>,<span class="dv">5</span>])

plt.plot(pt1[<span class="dv">0</span>],pt1[<span class="dv">1</span>],<span class="st">&#39;gd&#39;</span>)
plt.plot(pt2[<span class="dv">0</span>],pt2[<span class="dv">1</span>],<span class="st">&#39;gd&#39;</span>)

plt.savefig(<span class="st">&#39;enc_07.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="enc_07.png" />

</div>
<p>İki nokta seçtik, biri kapalı 4 nokta içinde, diğeri dışında.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> same_sign(arr): <span class="cf">return</span> np.<span class="bu">all</span>(arr <span class="op">&gt;</span> <span class="dv">0</span>) <span class="cf">if</span> arr[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> np.<span class="bu">all</span>(arr <span class="op">&lt;</span> <span class="dv">0</span>)

<span class="kw">def</span> inside_quad(rect, pt):
    pts <span class="op">=</span> np.array(rect)
    a <span class="op">=</span>  pts <span class="op">-</span> pt
    d <span class="op">=</span> np.zeros((<span class="dv">4</span>,<span class="dv">2</span>))
    d[<span class="dv">0</span>,:] <span class="op">=</span> pts[<span class="dv">1</span>,:]<span class="op">-</span>pts[<span class="dv">0</span>,:]
    d[<span class="dv">1</span>,:] <span class="op">=</span> pts[<span class="dv">2</span>,:]<span class="op">-</span>pts[<span class="dv">1</span>,:]
    d[<span class="dv">2</span>,:] <span class="op">=</span> pts[<span class="dv">3</span>,:]<span class="op">-</span>pts[<span class="dv">2</span>,:]
    d[<span class="dv">3</span>,:] <span class="op">=</span> pts[<span class="dv">0</span>,:]<span class="op">-</span>pts[<span class="dv">3</span>,:]
    res <span class="op">=</span> np.cross(a,d)
    <span class="cf">return</span> same_sign(res), res

<span class="bu">print</span> inside_quad(rect1, pt1)
<span class="bu">print</span> inside_quad(rect1, pt2)</code></pre></div>
<pre><code>(True, array([  4.,  10.,  32.,  24.]))
(False, array([-36., -20.,  72.,  54.]))</code></pre>
<p>Sonuç beklenen şekilde geldi.</p>
<p>Sargılanan Sayı Algoritması (Winding Number Algoritm)</p>
<p>Eğer bir nokta bir polygon içinde ise o noktadan her köşe noktasına birer çizgi çeksek ve ortaya çıkan açılara baksak, bu açılar 360'a toplanacaktır. Fakat nokta dışarıda ise bu doğru olmazdı,</p>
<div class="figure">
<img src="winding.jpg" />

</div>
<p>Sargılanan sayı algoritması bunu temel alıyor, bkz [6], örnek kod alttadır,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> math

<span class="kw">def</span> offsetCoords(polygon, newOrigin):
    offsetPolygon <span class="op">=</span> []
    <span class="cf">for</span> v <span class="kw">in</span> polygon:
        offsetPolygon.append((v[<span class="dv">0</span>]<span class="op">-</span>newOrigin[<span class="dv">0</span>], v[<span class="dv">1</span>]<span class="op">-</span>newOrigin[<span class="dv">1</span>]))
    <span class="cf">return</span> offsetPolygon

<span class="kw">def</span> dotProduct(v1, v2):
    <span class="cf">return</span> v1[<span class="dv">0</span>]<span class="op">*</span>v2[<span class="dv">0</span>]<span class="op">+</span>v1[<span class="dv">1</span>]<span class="op">*</span>v2[<span class="dv">1</span>]

<span class="kw">def</span> vectorLen(v):
    <span class="cf">return</span> (v[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span><span class="op">+</span>v[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span>)<span class="op">**</span>.<span class="dv">5</span>

<span class="kw">def</span> angleBetweenVectors(v1, v2):
    cosine <span class="op">=</span> dotProduct(v1, v2) <span class="op">/</span> (vectorLen(v1) <span class="op">*</span> vectorLen(v2))
    <span class="cf">return</span> math.acos(cosine)

<span class="kw">def</span> isWithin(point, polygon):
    <span class="cf">if</span> point <span class="kw">in</span> polygon:
        <span class="cf">return</span> <span class="va">False</span>
    sumAngles <span class="op">=</span> <span class="dv">0</span>
    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(polygon) <span class="op">-</span> <span class="dv">1</span>):
        sumAngles <span class="op">+=</span> angleBetweenVectors(polygon[i], polygon[i<span class="op">+</span><span class="dv">1</span>])
    <span class="cf">if</span> math.isclose(sumAngles, math.pi<span class="op">*</span><span class="dv">2</span>):
        <span class="cf">return</span> <span class="va">True</span>
    <span class="cf">else</span>:
        <span class="cf">return</span> <span class="va">False</span>

polygon <span class="op">=</span> [(<span class="dv">2</span>,<span class="dv">0</span>), (<span class="dv">4</span>,<span class="dv">1</span>), (<span class="dv">4</span>,<span class="dv">4</span>), (<span class="dv">2</span>,<span class="dv">5</span>), (<span class="dv">1</span>,<span class="dv">2</span>), (<span class="dv">2</span>,<span class="dv">0</span>)]

coords <span class="op">=</span> (<span class="dv">3</span>,<span class="dv">3</span>)

point <span class="op">=</span> (<span class="bu">float</span>(coords[<span class="dv">0</span>]), <span class="bu">float</span>(coords[<span class="dv">1</span>]))

offsetPolygon <span class="op">=</span> offsetCoords(polygon, point)
offsetPoint <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">0</span>)

result <span class="op">=</span> <span class="st">&#39;Is POINT </span><span class="sc">{}</span><span class="st"> within POLYGON </span><span class="sc">{}</span><span class="st">? </span><span class="sc">{}</span><span class="st">.&#39;</span>.<span class="bu">format</span>(point, polygon, isWithin(offsetPoint, offsetPolygon))

<span class="bu">print</span>(result) </code></pre></div>
<pre><code>Is POINT (3.0, 3.0) within POLYGON [(2, 0), (4, 1), (4, 4), (2, 5), (1, 2), (2, 0)]? True.</code></pre>
<p>Dış Geometrik Objenin İç Noktalara Uyum Skoru</p>
<p>Bazen önceden bilinen bir çokgenin (dörtgen, beşgen, vs.) onun içinde olan noktaları ne kadar iyi &quot;kapsadığını'' bir skor ile belirtmek gerekebilir. Mesela gürültülü bir nokta bulutundan yaklaşık dışbükey zarf çıkarttık, ve şimdi eldeki bir hipotez dörtgenin bu veriye ne kadar iyi uyduğunu bulmak istiyoruz.</p>
<p>Şöyle bir yaklaşım düşünülebilir. Her nokta için o noktanın kapsayan tüm kenarlara ne kadar uzak olduğunu ölçeriz, bunlar arasında minimum olan uzaklığı alırız. Eğer bir kenar bir noktanın yanındaysa onu kapsıyor demektir, ayrıca bir noktanın en yakınındaki kenar uzakta ise kapsama iyi değil demektir. Kenarlar dışına düşmek ne olacak? Bu durum noktanın içeride olup olmadığı sorusu ile halledilir, dışarı düşen noktalara cezalandırma amaçlı yapay yüksek bir uzaklık atanabilir. Ardından tüm bu minimum uzaklıklar toplanır ve genel bir skor ortaya çıkartılır.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> pdis(a, b, c):
    t <span class="op">=</span> b[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>], b[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>]           <span class="co"># Vektor ab</span>
    dd <span class="op">=</span> sqrt(t[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span><span class="op">+</span>t[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span>)         <span class="co"># ab uzunlugu</span>
    t <span class="op">=</span> t[<span class="dv">0</span>]<span class="op">/</span>dd, t[<span class="dv">1</span>]<span class="op">/</span>dd               <span class="co"># ab birim vektoru</span>
    n <span class="op">=</span> <span class="op">-</span>t[<span class="dv">1</span>], t[<span class="dv">0</span>]                    <span class="co"># ab&#39;ye normal birim vektor</span>
    ac <span class="op">=</span> c[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>], c[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>]          <span class="co"># vector ac</span>
    <span class="cf">return</span> fabs(ac[<span class="dv">0</span>]<span class="op">*</span>n[<span class="dv">0</span>]<span class="op">+</span>ac[<span class="dv">1</span>]<span class="op">*</span>n[<span class="dv">1</span>]) <span class="co"># ac&#39;nin n&#39;e yansimasi (minimum uzaklik)</span>

<span class="kw">def</span> score_quad_fit(c, pt):
    arr <span class="op">=</span> np.array([pdis(c[<span class="dv">1</span>],c[<span class="dv">0</span>],pt), pdis(c[<span class="dv">2</span>],c[<span class="dv">1</span>],pt), <span class="op">\</span>
                    pdis(c[<span class="dv">3</span>],c[<span class="dv">2</span>],pt), pdis(c[<span class="dv">0</span>],c[<span class="dv">3</span>],pt) ])
    i,tmp <span class="op">=</span> inside_quad(c, pt)
    <span class="cf">if</span> i<span class="op">==</span><span class="va">False</span>: i<span class="op">=</span><span class="fl">10.</span>
    <span class="cf">return</span> np.<span class="bu">min</span>(arr) <span class="op">*</span> i

plt.plot(approx[:,<span class="dv">0</span>], approx[:,<span class="dv">1</span>], <span class="st">&#39;o&#39;</span>)

rect1 <span class="op">=</span> [[<span class="dv">6</span>,<span class="dv">8</span>],[<span class="dv">12</span>,<span class="dv">10</span>],[<span class="dv">13</span>,<span class="dv">15</span>],[<span class="dv">6</span>,<span class="dv">14</span>]]
plot_quad(rect1,<span class="st">&#39;b&#39;</span>)
r1total <span class="op">=</span> np.array([score_quad_fit(rect1,p) <span class="cf">for</span> p <span class="kw">in</span> points]).<span class="bu">sum</span>()

rect2 <span class="op">=</span> [[<span class="dv">7</span>,<span class="dv">9</span>],[<span class="dv">12</span>,<span class="dv">10</span>],[<span class="dv">11</span>,<span class="dv">14</span>],[<span class="dv">6</span>,<span class="dv">12</span>]]
plot_quad(rect2,<span class="st">&#39;r&#39;</span>)
r2total <span class="op">=</span> np.array([score_quad_fit(rect2,p) <span class="cf">for</span> p <span class="kw">in</span> points]).<span class="bu">sum</span>()

rect3 <span class="op">=</span> [[<span class="dv">7</span>,<span class="dv">9</span>],[<span class="dv">11</span>,<span class="dv">10</span>],[<span class="dv">10</span>,<span class="dv">14</span>],[<span class="dv">6</span>,<span class="dv">12</span>]]
plot_quad(rect3,<span class="st">&#39;k&#39;</span>)
r3total <span class="op">=</span> np.array([score_quad_fit(rect3,p) <span class="cf">for</span> p <span class="kw">in</span> points]).<span class="bu">sum</span>()

<span class="bu">print</span> <span class="st">&#39;mavi&#39;</span>,r1total
<span class="bu">print</span> <span class="st">&#39;kirmizi&#39;</span>,r2total
<span class="bu">print</span> <span class="st">&#39;siyah&#39;</span>,r3total

plt.xlim(<span class="dv">4</span>,<span class="dv">14</span>)<span class="op">;</span> plt.ylim(<span class="dv">6</span>,<span class="dv">17</span>)
plt.savefig(<span class="st">&#39;enc_11.png&#39;</span>)</code></pre></div>
<pre><code>mavi 65.8765373106
kirmizi 36.3649774766
siyah 53.192955306</code></pre>
<div class="figure">
<img src="enc_11.png" />

</div>
<p>Üstteki çıktılara göre mavi renkli dörtgenin kapsaması en kötü, en iyisi kırmızı olan. Daha küçük siyah dörtgen de fena kapsamıyor fakat bu dörtgen sağdaki bazı noktaları dışarıda bırakmış. Bu noktalar rutinimiz tarafından 10 skor ile cezalandırılıyor.</p>
<p>Kaynaklar</p>
<p>[3] Preparata, <em>Computational Geometry An Introduction</em></p>
<p>[4] Mathematics Stack Exchange, <em>Determine If 2D Pixel Inside a Region Without Formula</em>,<a href="http://math.stackexchange.com/questions/1956626/determine-if-2d-pixel-inside-a-region-without-formula" class="uri">http://math.stackexchange.com/questions/1956626/determine-if-2d-pixel-inside-a-region-without-formula</a></p>
<p>[5] Bayramlı, <em>Çok Değişkenli Calculus, Ders 3</em></p>
<p>[6] Stackoverflow, <a href="https://stackoverflow.com/a/43822141/423805" class="uri">https://stackoverflow.com/a/43822141/423805</a></p>
<p>[8] Bayramlı, <em>Çok Değişkenli Calculus, Ders 2</em></p>
<p>[9] Strang, <em>Introduction to Linear Algebra, 4th Ed</em></p>
<p>[10] Math Doctors, <em>Polygon Coordinates and Areas</em>, <a href="https://www.themathdoctors.org/polygon-coordinates-and-areas/" class="uri">https://www.themathdoctors.org/polygon-coordinates-and-areas/</a></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
