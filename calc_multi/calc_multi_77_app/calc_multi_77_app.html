<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Poligon Alanı, Nokta Bulutları, Noktaları Çevreleyen Bölgeler</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1
id="poligon-alanı-nokta-bulutları-noktaları-çevreleyen-bölgeler">Poligon
Alanı, Nokta Bulutları, Noktaları Çevreleyen Bölgeler</h1>
<p>Poligon, Üçgen Alanı</p>
<p>[8] notlarından iki vektörün temsil ettiği bir üçgenin alanının bu
iki vektörün çapraz çarpmından gelen vektörün uzunluğu olduğunu
biliyoruz.</p>
<p><img src="triar4.png" /></p>
<p>O iki vektörün temsil ettiği üçgenin alanı ise paralelogramın
yarısıdır,</p>
<p><img src="triar3.png" /></p>
<p>Bir üçgenin alanını içindeki üç tane alt üçgen üzerinden de
hesaplayabilirdik, elimizde üç nokta var ise, mesela <span
class="math inline">\((x_1,y_1)\)</span>, <span
class="math inline">\((x_2,y_2)\)</span>, <span
class="math inline">\((x_3,y_3)\)</span>, üçgenin ortasında orijin
olduğunu kabul edersek, orijinden o noktalara giden üç vektör üzerinden
3 tane üçgen ile büyük üçgenin alanını hesaplayabiliriz [9, sf.
272],</p>
<p><img src="triar5.jpg" /></p>
<p><span class="math display">\[
Alan = 1/2 \left(
\left|\begin{array}{cc}
x_1 &amp; y_1 \\ x_2 &amp; y_2
\end{array}\right| +
\left|\begin{array}{cc}
x_2 &amp; y_2 \\ x_3 &amp; y_3
\end{array}\right| +
\left|\begin{array}{cc}
x_3 &amp; y_3 \\ x_1 &amp; y_1
\end{array}\right| \right)
\]</span></p>
<p>Üç tane determinant hesabı gösteriliyor, açılımı</p>
<p><span class="math display">\[
\frac{1}{2} (x_1 y_2  - x_2 y_1) +
\frac{1}{2} (x_2 y_3  - x_3 y_2) +
\frac{1}{2} (x_3 y_1  - x_1 y_3)
\]</span></p>
<p>Benzer şekilde herhangi bir poligon alanı da hesaplanabilir,</p>
<p><img src="triar1.png" /></p>
<p>Bu poligon içinde üçgenleri toplayarak tüm poligon alanı
hesaplanır,</p>
<p><img src="triar2.png" /></p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy.linalg <span class="im">as</span> lin</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>pts <span class="op">=</span> [[<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">2</span>],[<span class="dv">0</span>, <span class="dv">4</span>],[<span class="dv">3</span>, <span class="op">-</span><span class="dv">1</span>],[<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>]]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="op">\</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>lin.det(np.vstack((pts[<span class="dv">0</span>],pts[<span class="dv">1</span>]))) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>lin.det(np .vstack((pts[<span class="dv">1</span>],pts[<span class="dv">2</span>]))) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>lin.det(np.vstack((pts[<span class="dv">2</span>],pts[<span class="dv">3</span>]))) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>lin.det(np.vstack((pts[<span class="dv">3</span>],pts[<span class="dv">0</span>])))</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> ((np.<span class="bu">abs</span>(s) <span class="op">/</span> <span class="dv">2</span>))</span></code></pre></div>
<pre><code>13.0</code></pre>
<p>Vektörlerin illa ki bir orijinden çıktığı varsayımı da şart değil,
üstteki hesabı orijin merkezli olmayan noktalar için yaparsak yine aynı
sonucu elde ediyoruz, bunun ispatını vermiyoruz fakat düşünürsek her
türlü üçgeni alanını değiştirmeden sadece kaydırıp orijin merkezli hale
getirebilirdik, ve yakın orantılı sayılarla yapılan benzer hesaplar hala
geçerli olurdu.</p>
<p>Bu konu hakkında karşımıza çıkabilecek bir isim Ayakkabı Bağı
(Shoelace) tekniği, bu teknik üstteki yaklaşımın cebirsel olarak
açılımıdır sadece, değişkenler belli şekilde yanyana dizilince bir
çapraz ayakkabı bağı şekli çıktığı için bu isim verilmiş, tabii bu
çaprazlığın üstteki determinantın gerektirdiği çapraz çarpımla yakın
ilişkisi olduğu da görülebilir.</p>
<p>Dışbükey Zarf (Convex Hull)</p>
<p>Yaklaşık olarak işleyen yaklaşımlardan biri [3, sf. 154]’de. Bu
yaklaşıma göre veri noktalarında önce minimum <span
class="math inline">\(x\)</span> ve maksimum <span
class="math inline">\(x\)</span> değerleri bulunur (yani en sol ve en
sağ uç noktalar), ardından bu noktalar arası dikey şeritlere
bölünür.</p>
<p><img src="enc_03.png" /></p>
<p>Sonra algoritma solda sağa giderek her şerit içinde dikey en maksimum
ve minimum iki noktayı bulur. Bu noktalar sırasıyla üst ve alt zarf
noktaları olacaktır. Algoritma tamamlanınca bu minimal, maksimal
noktalarının hepsini alıp üzerinde standart dışbükey zarf
algoritmalarından birini işletiriz. Fakat eldeki noktaların sayısı artık
oldukça azaldığı için algoritmanın tamamı çok hızlı çalışacaktır.
Algoritmanın karmaşıklığı <span class="math inline">\(O(N)\)</span>.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>pts <span class="op">=</span> np.array(pts)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>xmin <span class="op">=</span> np.<span class="bu">min</span>(pts[:,<span class="dv">0</span>])</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>xmax <span class="op">=</span> np.<span class="bu">max</span>(pts[:,<span class="dv">1</span>])</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (xmin, xmax)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>bins <span class="op">=</span> np.linspace(xmin,xmax,<span class="dv">10</span>)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>bidx <span class="op">=</span> np.digitize(pts[:,<span class="dv">0</span>], bins)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>mins <span class="op">=</span> []<span class="op">;</span> maxs <span class="op">=</span> []</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> idx <span class="kw">in</span> np.unique(bidx):</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    tmp<span class="op">=</span>pts[bidx<span class="op">==</span>idx]</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    mins.append(tmp[np.argmin(pts[bidx<span class="op">==</span>idx,<span class="dv">1</span>])])</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    maxs.append(tmp[np.argmax(pts[bidx<span class="op">==</span>idx,<span class="dv">1</span>])])</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>mins<span class="op">=</span>np.array(mins)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>maxs<span class="op">=</span>np.array(maxs)</span></code></pre></div>
<pre><code>6.85483870968 13.2291666667</code></pre>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>plt.plot(pts[:,<span class="dv">0</span>], pts[:,<span class="dv">1</span>], <span class="st">&#39;o&#39;</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>plt.plot(mins[:,<span class="dv">0</span>], mins[:,<span class="dv">1</span>], <span class="st">&#39;dr&#39;</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>plt.plot(maxs[:,<span class="dv">0</span>], maxs[:,<span class="dv">1</span>], <span class="st">&#39;dr&#39;</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">6</span>,<span class="dv">12</span>)<span class="op">;</span> plt.ylim(<span class="dv">8</span>,<span class="dv">15</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;enc_02.png&#39;</span>)</span></code></pre></div>
<p><img src="enc_02.png" /></p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.spatial <span class="im">import</span> ConvexHull</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>approx <span class="op">=</span> np.vstack((mins,maxs))</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>hull <span class="op">=</span> ConvexHull(approx)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>plt.plot(approx[:,<span class="dv">0</span>], approx[:,<span class="dv">1</span>], <span class="st">&#39;o&#39;</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> simplex <span class="kw">in</span> hull.simplices:</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    plt.plot(approx[simplex, <span class="dv">0</span>], approx[simplex, <span class="dv">1</span>], <span class="st">&#39;k-&#39;</span>)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">6</span>,<span class="dv">12</span>)<span class="op">;</span> plt.ylim(<span class="dv">8</span>,<span class="dv">15</span>)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;enc_10.png&#39;</span>)</span></code></pre></div>
<p><img src="enc_10.png" /></p>
<p>Nokta, Bölge İçinde mi Dışında mı?</p>
<p>Diyelim ki 2 boyutta olmak üzere, elimizde dışbükey bir bölgeyi
temsil eden noktalar var, ve elimizdeki bir başka noktanın bu bölge
içinde mi dışında mı olduğunu merak ediyoruz. Bölgeyi tanımlayan
analitik bir fonksiyon yok, mesela bir elips formülü gibi bir tanım
olsaydı, direk herhangi bir kordinatı geçip <span
class="math inline">\(&lt;1\)</span>, ya da <span
class="math inline">\(&gt;1\)</span> cevabını alabilirdik. Burada
noktalar var, ama araları birleşik değil.</p>
<p><img src="enc_05.png" /></p>
<p>Çapraz çarpımla bu sorunu çözebiliriz [4]. Bir nokta bir vektörün
sağında mı solunda mı sorusunun cevabını çapraz çarpımdan alabiliriz,
tabii nokta vektör olarak gösterilebildiğine göre, bir vektör diğerinin
sağında mı solunda mı sorusu.. Ama bunu da açalım, sağda olmak demek,
“saat yönüne 180 dereceden az gitmek’’ demek. Neyse, sağda solda olmanın
fark ettiğini biliyoruz, bir, sağ el kuralından, iki, <span
class="math inline">\(A \times B = -B \times A\)</span>. Tüm bu tanımlar
tabii ki temelde gidip determinant kullanan hesaba bağlanıyor.
Söylediklerimizin hepsi o tanım üzerinde test edilebilir, bkz [5].</p>
<p>O zaman çapraz çarpım bize sağda, solda olmayı söylüyorsa, şu hesabı
yaparsak ne olur? Verili bir <span class="math inline">\(x\)</span>
noktası ve bir kapalı bölge oluşturan <span
class="math inline">\(p_1,..,p_N\)</span> var, biz her <span
class="math inline">\(i = 1,..,N\)</span> için</p>
<p><span class="math display">\[ (x-p_i) \times (p_{i+1}-p_i)
\]</span></p>
<p>hesabını yaparız (not bu hesap dışbükey bölgeler için işler). Bu
hesap şu vektörleri baz alıyor,</p>
<p><img src="enc_04.png" /></p>
<p><span class="math inline">\(p_{i+1}-p_i\)</span> kapalı bölgeyi
çevreleyen vektörler, <span class="math inline">\(x-p_i\)</span> ise
bölge noktasından içeride (ya da dışarıda) olan noktaya giden vektör.
Eğer bir nokta bölge içindeyse 1-a, 2-b çapraz çarpımları hep aynı
işaretli olmalı, yani <span class="math inline">\(x\)</span> her zaman
1’ın 2’nin, vs. sağında. Ama nokta dışarıda olsaydı,</p>
<p><img src="enc_06.png" /></p>
<p>1-a ile 2-b çapraz çarpımlarının işareti farklı mesela. Bunu
kullanabiliriz, tüm çapraz çarpımları alıp sonuç vektöründeki tüm
öğelerin aynı işarette olup olmadığını kontrol ederiz. Eğer öyle ise
nokta içeridedir, yoksa dışarıda. Örnek kod ve bazı veriler üzerinde
görelim.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> math <span class="im">import</span> sqrt, fabs</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_line(pt1,pt2,color):</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    plt.plot(np.array([pt1[<span class="dv">0</span>],pt2[<span class="dv">0</span>]]),np.array([pt1[<span class="dv">1</span>],pt2[<span class="dv">1</span>]]),color<span class="op">=</span>color)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_quad(c,color<span class="op">=</span><span class="st">&#39;r&#39;</span>):</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    plot_line(c[<span class="dv">1</span>],c[<span class="dv">0</span>],color)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    plot_line(c[<span class="dv">2</span>],c[<span class="dv">1</span>],color)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    plot_line(c[<span class="dv">3</span>],c[<span class="dv">2</span>],color)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    plot_line(c[<span class="dv">0</span>],c[<span class="dv">3</span>],color)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>rect1 <span class="op">=</span> [[<span class="dv">6</span>,<span class="dv">8</span>],[<span class="dv">12</span>,<span class="dv">10</span>],[<span class="dv">13</span>,<span class="dv">15</span>],[<span class="dv">6</span>,<span class="dv">14</span>]]</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>plot_quad(rect1)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">0</span>,<span class="dv">20</span>)<span class="op">;</span> plt.ylim(<span class="dv">0</span>,<span class="dv">20</span>)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>pt1 <span class="op">=</span> np.array([<span class="dv">10</span>,<span class="dv">10</span>])</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>pt2 <span class="op">=</span> np.array([<span class="dv">15</span>,<span class="dv">5</span>])</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>plt.plot(pt1[<span class="dv">0</span>],pt1[<span class="dv">1</span>],<span class="st">&#39;gd&#39;</span>)</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>plt.plot(pt2[<span class="dv">0</span>],pt2[<span class="dv">1</span>],<span class="st">&#39;gd&#39;</span>)</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;enc_07.png&#39;</span>)</span></code></pre></div>
<p><img src="enc_07.png" /></p>
<p>İki nokta seçtik, biri kapalı 4 nokta içinde, diğeri dışında.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> same_sign(arr): <span class="cf">return</span> np.<span class="bu">all</span>(arr <span class="op">&gt;</span> <span class="dv">0</span>) <span class="cf">if</span> arr[<span class="dv">0</span>] <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> np.<span class="bu">all</span>(arr <span class="op">&lt;</span> <span class="dv">0</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> inside_quad(rect, pt):</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    pts <span class="op">=</span> np.array(rect)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span>  pts <span class="op">-</span> pt</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> np.zeros((<span class="dv">4</span>,<span class="dv">2</span>))</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    d[<span class="dv">0</span>,:] <span class="op">=</span> pts[<span class="dv">1</span>,:]<span class="op">-</span>pts[<span class="dv">0</span>,:]</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    d[<span class="dv">1</span>,:] <span class="op">=</span> pts[<span class="dv">2</span>,:]<span class="op">-</span>pts[<span class="dv">1</span>,:]</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    d[<span class="dv">2</span>,:] <span class="op">=</span> pts[<span class="dv">3</span>,:]<span class="op">-</span>pts[<span class="dv">2</span>,:]</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    d[<span class="dv">3</span>,:] <span class="op">=</span> pts[<span class="dv">0</span>,:]<span class="op">-</span>pts[<span class="dv">3</span>,:]</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> np.cross(a,d)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> same_sign(res), res</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (inside_quad(rect1, pt1))</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (inside_quad(rect1, pt2))</span></code></pre></div>
<pre><code>(True, array([  4.,  10.,  32.,  24.]))
(False, array([-36., -20.,  72.,  54.]))</code></pre>
<p>Sonuç beklenen şekilde geldi.</p>
<p>Sargılanan Sayı Algoritması (Winding Number Algoritm)</p>
<p>Eğer bir nokta bir polygon içinde ise o noktadan her köşe noktasına
birer çizgi çeksek ve ortaya çıkan açılara baksak, bu açılar 360’a
toplanacaktır. Fakat nokta dışarıda ise bu doğru olmazdı,</p>
<p><img src="winding.jpg" /></p>
<p>Sargılanan sayı algoritması bunu temel alıyor, bkz [6], örnek kod
alttadır,</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> offsetCoords(polygon, newOrigin):</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    offsetPolygon <span class="op">=</span> []</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> polygon:</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        offsetPolygon.append((v[<span class="dv">0</span>]<span class="op">-</span>newOrigin[<span class="dv">0</span>], v[<span class="dv">1</span>]<span class="op">-</span>newOrigin[<span class="dv">1</span>]))</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> offsetPolygon</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dotProduct(v1, v2):</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> v1[<span class="dv">0</span>]<span class="op">*</span>v2[<span class="dv">0</span>]<span class="op">+</span>v1[<span class="dv">1</span>]<span class="op">*</span>v2[<span class="dv">1</span>]</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> vectorLen(v):</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (v[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span><span class="op">+</span>v[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span>)<span class="op">**</span><span class="fl">.5</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> angleBetweenVectors(v1, v2):</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    cosine <span class="op">=</span> dotProduct(v1, v2) <span class="op">/</span> (vectorLen(v1) <span class="op">*</span> vectorLen(v2))</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> math.acos(cosine)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> isWithin(point, polygon):</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> point <span class="kw">in</span> polygon:</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>    sumAngles <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(polygon) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>        sumAngles <span class="op">+=</span> angleBetweenVectors(polygon[i], polygon[i<span class="op">+</span><span class="dv">1</span>])</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> math.isclose(sumAngles, math.pi<span class="op">*</span><span class="dv">2</span>):</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>polygon <span class="op">=</span> [(<span class="dv">2</span>,<span class="dv">0</span>), (<span class="dv">4</span>,<span class="dv">1</span>), (<span class="dv">4</span>,<span class="dv">4</span>), (<span class="dv">2</span>,<span class="dv">5</span>), (<span class="dv">1</span>,<span class="dv">2</span>), (<span class="dv">2</span>,<span class="dv">0</span>)]</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>coords <span class="op">=</span> (<span class="dv">3</span>,<span class="dv">3</span>)</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>point <span class="op">=</span> (<span class="bu">float</span>(coords[<span class="dv">0</span>]), <span class="bu">float</span>(coords[<span class="dv">1</span>]))</span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>offsetPolygon <span class="op">=</span> offsetCoords(polygon, point)</span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>offsetPoint <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> <span class="st">&#39;Is POINT </span><span class="sc">{}</span><span class="st"> within POLYGON </span><span class="sc">{}</span><span class="st">? </span><span class="sc">{}</span><span class="st">.&#39;</span>.<span class="bu">format</span>(point, polygon, isWithin(offsetPoint, offsetPolygon))</span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result) </span></code></pre></div>
<pre><code>Is POINT (3.0, 3.0) within POLYGON [(2, 0), (4, 1), (4, 4), (2, 5), (1, 2), (2, 0)]? True.</code></pre>
<p>Dış Geometrik Objenin İç Noktalara Uyum Skoru</p>
<p>Bazen önceden bilinen bir çokgenin (dörtgen, beşgen, vs.) onun içinde
olan noktaları ne kadar iyi “kapsadığını’’ bir skor ile belirtmek
gerekebilir. Mesela gürültülü bir nokta bulutundan yaklaşık dışbükey
zarf çıkarttık, ve şimdi eldeki bir hipotez dörtgenin bu veriye ne kadar
iyi uyduğunu bulmak istiyoruz.</p>
<p>Şöyle bir yaklaşım düşünülebilir. Her nokta için o noktanın kapsayan
tüm kenarlara ne kadar uzak olduğunu ölçeriz, bunlar arasında minimum
olan uzaklığı alırız. Eğer bir kenar bir noktanın yanındaysa onu
kapsıyor demektir, ayrıca bir noktanın en yakınındaki kenar uzakta ise
kapsama iyi değil demektir. Kenarlar dışına düşmek ne olacak? Bu durum
noktanın içeride olup olmadığı sorusu ile halledilir, dışarı düşen
noktalara cezalandırma amaçlı yapay yüksek bir uzaklık atanabilir.
Ardından tüm bu minimum uzaklıklar toplanır ve genel bir skor ortaya
çıkartılır.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pdis(a, b, c):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> b[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>], b[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>]           <span class="co"># Vektor ab</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    dd <span class="op">=</span> sqrt(t[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span><span class="op">+</span>t[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span>)         <span class="co"># ab uzunlugu</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> t[<span class="dv">0</span>]<span class="op">/</span>dd, t[<span class="dv">1</span>]<span class="op">/</span>dd               <span class="co"># ab birim vektoru</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="op">-</span>t[<span class="dv">1</span>], t[<span class="dv">0</span>]                    <span class="co"># ab&#39;ye normal birim vektor</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    ac <span class="op">=</span> c[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>], c[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>]          <span class="co"># vector ac</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fabs(ac[<span class="dv">0</span>]<span class="op">*</span>n[<span class="dv">0</span>]<span class="op">+</span>ac[<span class="dv">1</span>]<span class="op">*</span>n[<span class="dv">1</span>]) <span class="co"># ac&#39;nin n&#39;e yansimasi (minimum uzaklik)</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> score_quad_fit(c, pt):</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    arr <span class="op">=</span> np.array([pdis(c[<span class="dv">1</span>],c[<span class="dv">0</span>],pt), pdis(c[<span class="dv">2</span>],c[<span class="dv">1</span>],pt), <span class="op">\</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>                    pdis(c[<span class="dv">3</span>],c[<span class="dv">2</span>],pt), pdis(c[<span class="dv">0</span>],c[<span class="dv">3</span>],pt) ])</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    i,tmp <span class="op">=</span> inside_quad(c, pt)</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i<span class="op">==</span><span class="va">False</span>: i<span class="op">=</span><span class="fl">10.</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.<span class="bu">min</span>(arr) <span class="op">*</span> i</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>plt.plot(approx[:,<span class="dv">0</span>], approx[:,<span class="dv">1</span>], <span class="st">&#39;o&#39;</span>)</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>rect1 <span class="op">=</span> [[<span class="dv">6</span>,<span class="dv">8</span>],[<span class="dv">12</span>,<span class="dv">10</span>],[<span class="dv">13</span>,<span class="dv">15</span>],[<span class="dv">6</span>,<span class="dv">14</span>]]</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>plot_quad(rect1,<span class="st">&#39;b&#39;</span>)</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>r1total <span class="op">=</span> np.array([score_quad_fit(rect1,p) <span class="cf">for</span> p <span class="kw">in</span> pts]).<span class="bu">sum</span>()</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>rect2 <span class="op">=</span> [[<span class="dv">7</span>,<span class="dv">9</span>],[<span class="dv">12</span>,<span class="dv">10</span>],[<span class="dv">11</span>,<span class="dv">14</span>],[<span class="dv">6</span>,<span class="dv">12</span>]]</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>plot_quad(rect2,<span class="st">&#39;r&#39;</span>)</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>r2total <span class="op">=</span> np.array([score_quad_fit(rect2,p) <span class="cf">for</span> p <span class="kw">in</span> pts]).<span class="bu">sum</span>()</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>rect3 <span class="op">=</span> [[<span class="dv">7</span>,<span class="dv">9</span>],[<span class="dv">11</span>,<span class="dv">10</span>],[<span class="dv">10</span>,<span class="dv">14</span>],[<span class="dv">6</span>,<span class="dv">12</span>]]</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>plot_quad(rect3,<span class="st">&#39;k&#39;</span>)</span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>r3total <span class="op">=</span> np.array([score_quad_fit(rect3,p) <span class="cf">for</span> p <span class="kw">in</span> pts]).<span class="bu">sum</span>()</span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;mavi&#39;</span>,r1total)</span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;kirmizi&#39;</span>,r2total)</span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&#39;siyah&#39;</span>,r3total)</span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">4</span>,<span class="dv">14</span>)<span class="op">;</span> plt.ylim(<span class="dv">6</span>,<span class="dv">17</span>)</span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;enc_11.png&#39;</span>)</span></code></pre></div>
<pre><code>mavi 65.8765373106
kirmizi 36.3649774766
siyah 53.192955306</code></pre>
<p><img src="enc_11.png" /></p>
<p>Üstteki çıktılara göre mavi renkli dörtgenin kapsaması en kötü, en
iyisi kırmızı olan. Daha küçük siyah dörtgen de fena kapsamıyor fakat bu
dörtgen sağdaki bazı noktaları dışarıda bırakmış. Bu noktalar rutinimiz
tarafından 10 skor ile cezalandırılıyor.</p>
<p>Kaynaklar</p>
<p>[3] Preparata, <em>Computational Geometry An Introduction</em></p>
<p>[4] Mathematics Stack Exchange, <em>Determine If 2D Pixel Inside a
Region Without Formula</em>,<a
href="http://math.stackexchange.com/questions/1956626/determine-if-2d-pixel-inside-a-region-without-formula">http://math.stackexchange.com/questions/1956626/determine-if-2d-pixel-inside-a-region-without-formula</a></p>
<p>[5] Bayramlı, <em>Çok Değişkenli Calculus, Ders 3</em></p>
<p>[6] Stackoverflow, <a
href="https://stackoverflow.com/a/43822141/423805">https://stackoverflow.com/a/43822141/423805</a></p>
<p>[8] Bayramlı, <em>Çok Değişkenli Calculus, Ders 2</em></p>
<p>[9] Strang, <em>Introduction to Linear Algebra, 4th Ed</em></p>
<p>[10] Math Doctors, <em>Polygon Coordinates and Areas</em>, <a
href="https://www.themathdoctors.org/polygon-coordinates-and-areas/">https://www.themathdoctors.org/polygon-coordinates-and-areas/</a></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
