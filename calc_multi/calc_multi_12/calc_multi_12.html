<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Ders 12</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"
  type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="ders-12">Ders 12</h1>
<p>Zincirleme Kanunu hatırlayalım</p>
<p><span class="math display">\[ \frac{dw}{dt}  = w_x \frac{dx}{dt} +
w_y \frac{dy}{dt} +
w_z \frac{dz}{dt}  \]</span></p>
<p>Bu formül, kısmi türevler üzerinden, <span
class="math inline">\(w\)</span>’daki değişimin <span
class="math inline">\(x,y,z\)</span>’deki değişime ne kadar “hassas’’ ne
kadar”bağlı’’ olduğnu gösteriyor.</p>
<p>Şimdi üsttekini daha azaltılmış, özetli (compact, concise) bir formda
şöyle yazacağım.</p>
<p><span class="math display">\[
= \nabla w \cdot  \frac{d\vec{r}}{dt}
\]</span></p>
<p>Gradyan vektörü tüm kısmi türevlerin bir araya konmuş halidir.</p>
<p><span class="math display">\[ \nabla w = &lt; w_x, w_y, w_z &gt;
\]</span></p>
<p>Tabii ki bunu söyleyince üstteki gradyan’ın <span
class="math inline">\(x,y,z\)</span>’ye bağlı olduğunu da söylüyoruz,
mesela <span class="math inline">\(w\)</span>’nun belli bir nokta <span
class="math inline">\(x,y,z\)</span>’da gradyanını alabilirsiniz, o
zaman her değişik <span class="math inline">\(x,y,z\)</span> noktasında
farklı bir vektör elde edersiniz, ki bu vektörlerin tamamına ileride
“vektör alanı (vector field)’’ ismini vereceğiz. Devam edelim,</p>
<p><span class="math display">\[ \frac{d\vec{r}}{dt} = &lt;
\frac{dx}{dt}, \frac{dy}{dt}, \frac{dz}{dt} &gt; \]</span></p>
<p>Yani hız vektörü (velocity vector) <span
class="math inline">\(d\vec{r}/{dt}\)</span> yukarıdaki gibi
tanımlıdır.</p>
<p>Bugünkü amacımız gradyan vektörünü anlamak, ve nerelerde
kullanabileceğimizi incelemek. Gradyanları yaklaşıksal formüllerde
kullanmak mümkündür, vs. Üstte gördüğümüz onun notasyonu.</p>
<p>Gradyanların belki de en “havalı’’ özellikleri şudur.</p>
<p>Teori</p>
<p>İddia ediyorum ki <span class="math inline">\(\nabla w\)</span>
vektörü, <span class="math inline">\(w = \textrm{ bir sabit
}\)</span>ile elde edilecek kesit yüzeyine (level surface) her zaman
diktir.</p>
<p>Eğer fonksiyonumun bir kontur grafiğini çizersem</p>
<p><img src="12_1.png" /></p>
<p>gösterilen noktada hesaplanacak gradyan vektörü o noktadaki kontura
diktir.</p>
<p>Örnek 1</p>
<p>Lineer bir <span class="math inline">\(w\)</span> kullanalım.</p>
<p><span class="math display">\[ w = a_1 x + a_2 y + a_3 z \]</span></p>
<p>Gradyan nedir? Kısmi türevleri alalım:</p>
<p><span class="math display">\[
\nabla w = &lt; a_1, a_2, a_3 &gt;
\]</span></p>
<p>Konturları nasıl elde ederim? <span class="math inline">\(a_1 x + a_2
y + a_3 z = c\)</span> ki <span class="math inline">\(c\)</span> bir
sabittir, bu formülü tatmin eden tüm <span
class="math inline">\(x,y,z\)</span> değerleri bir düzlem
oluştururlar.</p>
<p>Bu düzlemin normalinin nasıl alınacağını biliyoruz, katsayılara
bakarız, <span class="math inline">\(&lt; a_1,a_2,a_3 &gt;\)</span>. Bu
vektörün gradyanla aynı çıktığına dikkat, ki normal vektör de düzleme
diktir zaten. Aynı çıkmaları mantıklı.</p>
<p>Aslında bu örnek gradyanın dikliğini bir anlamda ispatlıyor, çünkü
düzlem olmasa bile herhangi bir fonksiyonun birinci yaklaşıksallığı bir
düzlem yaratır, o düzlemin normalı, gradyanı eşitliği bizi yine
gradyanın dikliğine götürür. Ama bu yeterince ikna edici olmadıysa başka
bir örneğe bakabiliriz.</p>
<p>Örnek 2</p>
<p><span class="math display">\[ w = x^2 + y^2 \]</span></p>
<p>Bu fonksiyonun kesit seviyeleri, değişik yarıçaplara sahip
dairelerdir, <span class="math inline">\(x^2 + y^2 = c\)</span>
formülündeki değişik <span class="math inline">\(c\)</span> değerleri bu
daireleri tanımlar.</p>
<p>Gradyan vektörü</p>
<p><span class="math display">\[ \nabla w = &lt;2x, 2y&gt; \]</span></p>
<p><img src="12_2.png" /></p>
<p>Seçilen <span class="math inline">\(x,y\)</span> noktasında <span
class="math inline">\(\nabla w\)</span> gösterilmiş. Bu vektörün <span
class="math inline">\(x\)</span> ve <span
class="math inline">\(y\)</span> eksenlerinde boyunun, başladığı noktaya
göre olan <span class="math inline">\(x,y\)</span> değerlerinin yaklaşık
iki katı olduğuna dikkat, ki bu da <span class="math inline">\(&lt;
2x,2y &gt;\)</span> vektörü ile uyumlu.</p>
<p>Şimdi gradyanın niye kesit eğrilerine hep dik olduğunu
ispatlayalım.</p>
<p>İspat</p>
<p>Önce kesit eğrileri “üzerinde’’ hareket eden bir nokta hayal
edeceğiz. Bu nokta fonksiyonun sabit olduğu yerlerden geçiyor demektir,
çünkü kontur üzerinde fonksiyon değeri hep aynıdır.</p>
<p>Eğri <span class="math inline">\(\vec{r} = \vec{r}(t)\)</span> hep
<span class="math inline">\(w = c\)</span> üzerinde olacak. Resme
bakalım, hayali bir kesit yüzeyi üzerinde bir eğri bu (kırmızı renkli)
ve bu eğrinin üzerinde giden noktanın bir hızı olacak. Bu arada <span
class="math inline">\(w\)</span> mesela <span class="math inline">\(w =
x^2 + y^2\)</span> belki, herhangi bir üç boyutlu fonksiyon. <span
class="math inline">\(\vec{r}\)</span>’nin <span
class="math inline">\(w\)</span> üstünde gitmesi demek, <span
class="math inline">\(\vec{r}\)</span> ile <span
class="math inline">\(w\)</span> parametrize edilebilir demek, <span
class="math inline">\(\vec{r}(t) = &lt; x(t),y(t),z(t) &gt;\)</span> ve
onu kullanarak <span class="math inline">\(w(\vec{r}(t)) =
c\)</span>.</p>
<p><img src="12_3.jpg" /></p>
<p>İddia o ki,</p>
<p><span class="math display">\[ \vec{v} = \frac{d\vec{r}}{dt}
\]</span></p>
<p>vektörü, kesit <span class="math inline">\(w = c\)</span>’ye muhakkak
teğet olmalı, çünkü hız eğriye teğet, ve eğri kesit içinde. Bu arada
<span class="math inline">\(w\)</span>’nin aslında <span
class="math inline">\(w(\vec{r}(t))\)</span> olduğunu belirttik.</p>
<p>Bu sayede Zincirleme Kanununu kullanarak</p>
<p><span class="math display">\[ \frac{dw(\vec{r})}{dt} = \nabla w \cdot
\frac{d\vec{r}}{dt} = \frac{dc}{dt}\]</span></p>
<p>eşitliğini kurabiliriz. Noktasal çarpım nereden geldi? Bu ifade <span
class="math inline">\(w\)</span>’nin her kısmi türevinin alıp, ona
tekabül eden <span class="math inline">\(\vec{r}(t)\)</span> öğesinin
türevi ile çarpıp sonuçların toplanması demek. Sonuç Zincirleme
Kanunu’ndaki görüntü olacaktır. Ayrıca</p>
<p><span class="math display">\[  = \nabla w \cdot \vec{v} =
0\]</span></p>
<p>Sıfıra eşitliğin sebebi <span class="math inline">\(w = c\)</span>
olması ve sabitin türevi <span class="math inline">\(dc/dt\)</span>
sıfır oldu.</p>
<p>Şimdi sıfır sonucundan ters yöne gidelim: iki vektörün noktasal
çarpımı ne zaman sıfır sonucu verir? Eğer vektörler birbirine dik ise.
Demek ki <span class="math inline">\(\nabla w \perp
\vec{v}\)</span>.</p>
<p>Hatta iddia ediyorum ki bu diklik <span
class="math inline">\(w=c\)</span> üzerindeki her hareket (motion) için
geçerlidir. Yani <span class="math inline">\(\vec{v}\)</span>, kesit
yüzeyine teğet olan herhangi bir vektör olabilir, üstteki diklik hep
doğru olacaktır.</p>
<p><img src="12_4.png" /></p>
<p>Bunun güzel bir uygulaması şu, artık istediğimiz her şeyin teğet
düzlemini bulabiliriz.</p>
<p>Örnek</p>
<p>Yüzey <span class="math inline">\(x^2 + y^2 - z^2 = 4\)</span>’un
<span class="math inline">\((2,1,1)\)</span> noktasındaki teğet
düzlemini bul. Alttaki şekil bir hiperboloid (hyperboloid) ve bu dersin
altında grafiklemek için gereken kodlar var.</p>
<p><img src="12_5.jpg" /></p>
<p>Resimde teğet düzlem pek teğet gibi değil, diğer grafiğin içine
girmiş gibi duruyor, fakat problemin verdiği noktada düzlem teğet.</p>
<p>Bu düzlemi nasıl bulacağız? Gradyanı hesaplayarak.</p>
<p>Kesit seviyesi <span class="math inline">\(w=4\)</span> ve Yüzey
<span class="math inline">\(w = x^2 + y^2 - z^2\)</span>.</p>
<p><span class="math display">\[ \nabla w = &lt;2x, 2y, -2z&gt;
\]</span></p>
<p>Verilen nokta değerlerini bu gradyan vektörüne verirsek, sonuç <span
class="math inline">\(&lt; 4,2,-2 &gt;\)</span>. Bu sonuç yüzeye ya da
teğet düzleme normal (dik) olan vektörü verecek.</p>
<p>Bu normal vektörü kullanarak düzlemin formülünü bulabiliriz.</p>
<p><span class="math display">\[ 4x + 2y - 2z = ? \]</span></p>
<p>Soru işareti ne olur? <span class="math inline">\((2,1,1)\)</span>
noktasını formüle koyarsak, sonuç 8 çıkar.</p>
<p><span class="math display">\[ 4x + 2y - 2z = 8 \]</span></p>
<p>Alternatif Yöntem</p>
<p>Aslında tüm bunları gradyan olmadan da yapabilirdik, bir diferansiyel
ile ise başlayabilirdik</p>
<p><span class="math display">\[ dw = 2x dx + 2y dy -2z dz \]</span></p>
<p><span class="math inline">\((2,1,1)\)</span> noktasında</p>
<p><span class="math display">\[ = 4dx + 4dy - 2dz \]</span></p>
<p>Yaklaşıksal olarak</p>
<p><span class="math display">\[ \Delta w \approx 4 \Delta x + 2\Delta y
- 2\Delta z  \]</span></p>
<p>Ne zaman kesit yüzeyi, kontur üzerindeyiz? Eğer <span
class="math inline">\(w\)</span>’de hiç değişim yok ise, yani <span
class="math inline">\(\Delta w = 0\)</span> ise. Bu arada üstteki
yaklaşıksallığın bir lineer yaklaşıksallık olduğunu unutmayalım. <span
class="math inline">\([\begin{array}{ccc} 2&amp;1&amp;1
\end{array}]\)</span> noktasında bu teğeti kullanmak istersek, <span
class="math inline">\(\Delta w = 0\)</span> eşitliği bize <span
class="math inline">\(4 \Delta x + 2 \Delta y - 2 \Delta z\)</span>
teğet düzlemini verecektir. Nasıl? <span class="math inline">\(\Delta
x\)</span> değişimdir, teğet düzlem üzerinde değişimi tanımlamak
istiyorsak, <span class="math inline">\([\begin{array}{ccc}
2&amp;1&amp;1 \end{array}]\)</span>’den başlayarak bir yere gittiğimizi
düşünmemiz gerekir, ki mesela <span class="math inline">\(x-2\)</span>
değişimini yapabiliriz, vs. Tam formül</p>
<p><span class="math display">\[ 4(x-2) + 2(y-1) - 2(z-1) = 0
\]</span></p>
<p>Yönsel Türevler (Directional Derivatives)</p>
<p>Elimdeki bir <span class="math inline">\(w = w(x,y)\)</span>
formülünün kısmi türevini aldığım zaman <span
class="math inline">\(\partial w/\partial x\)</span>, <span
class="math inline">\(\partial w/\partial y\)</span> ile mesela, bu
türevler x-ekseni ya da y-ekseni yönünde değişim olduğu zaman <span
class="math inline">\(w\)</span>’nun nasıl değiştini ölçerler. Peki
başka yönlere göre, mesela bir birim vektör <span
class="math inline">\(\hat{u}\)</span> yönünde türev alınamaz mı? Cevap
evet. Yönsel türevler bu ise yarıyorlar.</p>
<p><img src="12_6.jpg" /></p>
<p>Yani <span class="math inline">\(\hat{u}\)</span> üzerinden geçen
yolda ilerlerken <span class="math inline">\(z\)</span>’nin nasıl
değişeceğini merak ediyorum. Düz çizgi üzerindeki gidişata (straight
line trajectory) bakıyoruz.</p>
<p><span class="math inline">\(s\)</span> adlı bir parametreye bağlı bir
pozisyon vektörü <span class="math inline">\(\vec{r(s)}\)</span> hayal
edelim, öyle ki,</p>
<p><span class="math display">\[ d\vec{r}/ds = \hat{u} \]</span></p>
<p>sonucunu versin.</p>
<p>Niye üstte <span class="math inline">\(t\)</span> yerine <span
class="math inline">\(s\)</span> kullandım? Çünkü çizgi boyunca birim
hızda ilerliyorum, o zaman parametrize ettiğim şey katedilen yol. <span
class="math inline">\(s\)</span> bir anlamda eğri uzunluğu (arc length),
tabii tam eğri denemez çünkü çizgi düz, ama yine mesafe kavramını
kullanıyoruz.</p>
<p>O zaman <span class="math inline">\(dw/ds\)</span> nedir? Bunu
hesaplamak için Zincirleme Kanunu’nun özel bir durumunu
kullanacağız.</p>
<p>Eğer <span class="math inline">\(\hat{u} = &lt;a,b&gt;\)</span>
ise</p>
<p><span class="math display">\[ x(s) = x_0 + as \]</span></p>
<p><span class="math display">\[ y(s) = y_0 + bs \]</span></p>
<p>Bu formülleri <span class="math inline">\(w\)</span>’ye sokarız,
sonra <span class="math inline">\(dw/ds\)</span>’i hesaplarız.</p>
<p>Tanım: Yönsel Türev</p>
<p><span class="math display">\[ \frac{dw}{ds}_{|\hat{u}} \]</span></p>
<p>Daha önce kısmi türevleri incelerken onları geometrik olarak, x ve y
eksenine paralel düzlemlerin fonksiyonu kesmesi olarak görmüştük. Yönsel
türevler ise herhangi bir yöndeki (daha doğrusu <span
class="math inline">\(\hat{u}\)</span> yönündeki) bir düzlemin
fonksiyonu kesmesi olarak görülebilir.</p>
<p><img src="12_7.png" /></p>
<p>Tanım</p>
<p><span class="math inline">\(dw / ds_{|\hat{u}}\)</span> = Bir
grafiğin (fonksiyonun) <span class="math inline">\(\hat{u}\)</span>
vektörünü içeren / ona paralel olan, ve dikey düzlem (vertical plane)
kesilmesi ile elde edilen, o düzlemdeki yansımasının oluşturduğu eğrinin
değişimi / eğimi (slope).</p>
<p>Zincirleme Kanunu uygulanırsa</p>
<p><span class="math display">\[ \frac{dw}{ds} = \nabla w \cdot
\frac{d\vec{r}}{ds}
= \nabla w \cdot \hat{u}
\]</span></p>
<p>Hatırlamamız gereken formül o zaman</p>
<p><span class="math display">\[ \frac{dw}{ds}_{|\hat{u}} =  \nabla w
\cdot \hat{u} \]</span></p>
<p>Eşitliğin sağ tarafı “gradyanın <span
class="math inline">\(\hat{u}\)</span> yönünde giden bileşeni, kısmı’’
olarak ta nitelenebilir.</p>
<p>Kavramların birbiriyle alakasını iyice görmek için suna bakalım</p>
<p>Örnek</p>
<p><span class="math display">\[
\frac{dw}{ds}_{|\hat{i}} =  \nabla w \cdot \hat{i} =
\frac{\partial w}{\partial x} \]</span></p>
<p>Geometrik olarak</p>
<p><span class="math display">\[ \frac{dw}{ds}_{|\hat{u}} =  \nabla w
\cdot \hat{u} \]</span></p>
<p><span class="math display">\[ =  |\nabla
w||\hat{u}|\cos(\theta)  \]</span></p>
<p><span class="math inline">\(\hat{u}\)</span> birim vektör olduğuna
göre <span class="math inline">\(|\hat{u}| = 1\)</span>, formülden
atılır</p>
<p><span class="math display">\[ =  |\nabla
w||\cos(\theta)  \]</span></p>
<p><img src="12_8.png" /></p>
<p>Bu ifade “gradyanın <span class="math inline">\(\hat{u}\)</span>
yönündeki bileşeni’’ hesabının bir diğer versiyonudur aslında.</p>
<p>Şu soruyu soralım: hangi yöndeki değişim en büyüktür? <span
class="math inline">\(|\nabla w||\cos(\theta)\)</span> ifadesinin en
buyuk olduğu yer <span class="math inline">\(\cos(\theta)=1\)</span>
olduğu zamandır, yani <span class="math inline">\(\theta = 0\)</span>,
ki bu durum <span class="math inline">\(\hat{u} = dir(\nabla
w)\)</span>, yani <span class="math inline">\(\hat{u}\)</span>’nun
gradyan ile aynı yönde olduğu zamandır.</p>
<p>O zaman şu yorumu da yapabiliriz, gradyan belli bir noktada
fonksiyonun en çok artacağı yönü gösterir.</p>
<p>Peki <span class="math inline">\(|\nabla w|\)</span>, yani <span
class="math inline">\(\nabla w\)</span>’nun büyüklüğü neye eşittir?</p>
<p><span class="math display">\[ |\nabla w|
=   \frac{dw}{ds}_{|\hat{u}=dir(\nabla w)}  \]</span></p>
<p>En hızlı düşüş (azalış) hangi yöndedir? En fazla artışın tam tersi
yönünde.</p>
<p>Yani min <span class="math inline">\(dw/ds_{|\hat{u}}\)</span> için
<span class="math inline">\(\cos(\theta) = -1\)</span> olmalıdır, yani
<span class="math inline">\(\theta = 180^o\)</span>, <span
class="math inline">\(\hat{u}\)</span>, <span
class="math inline">\(-\nabla w\)</span> yönünde olduğu zaman.</p>
<p>Peki şu ne zaman doğrudur?</p>
<p><span class="math display">\[ \frac{dw}{ds}_{|\hat{u}} = 0
\]</span></p>
<p>Yani fonksiyon hangi yönde değişmez?</p>
<p>Bunun için <span class="math inline">\(\cos(\theta) = 0\)</span>
olmalıdır, ki bu <span class="math inline">\(\theta = 90^0\)</span>
olduğu zamandır. Yani <span class="math inline">\(\hat{u} \perp \nabla
w\)</span> ise. Bunu anlamanın bir diğer yolu, hiç değişimin olmadığı
yönün kesit yüzeyine teğet olduğudur, bu yüzeyde <span
class="math inline">\(w\)</span> hiç değişmediğine göre değişim olmaz,
değişim yoksa, biz de teğet hareket ediyoruz demektir.</p>
<p>Soru <img src="2d9.png" /> P noktasında <span
class="math inline">\(\partial w/ \partial x\)</span> ve <span
class="math inline">\(\partial w/\partial y\)</span>’yi kabaca
hesapla.</p>
<p><span class="math display">\[ \frac{\partial w}{\partial x} =
\frac{dw}{ds} \bigg|_{\hat{i}} \approx
\frac{\Delta w}{\Delta s} \approx
\frac{-1}{5/3} = -0.6
\]</span></p>
<p><span class="math display">\[ \frac{\partial w}{\partial y} =
\frac{dw}{ds} \bigg|_{\hat{j}} \approx
\frac{\Delta w}{\Delta s} \approx
\frac{-1}{1} = -1
\]</span></p>
<p><span class="math inline">\(\Delta = -1\)</span> çünkü dik giderken
kesit seviye 2’den 1’e geliyoruz, <span class="math inline">\(w\)</span>
1 azalıyor. Bu gidişat <span class="math inline">\(s\)</span>’in kendi
değişimi <span class="math inline">\(\Delta s\)</span>, bunu da kabaca,
sol alt köşedeki skalaya bakarak tahmin ediyoruz, sağa doğru yatay gidiş
1’den büyük gibi duruyor, ona 5/3 demişiz, yukarı doğru gidişat tam 1
gibi duruyor, ona 1 demişiz.</p>
<p><span class="math inline">\(\partial w / \partial y\)</span>
hesabında niye aşağı değil yukarı gitmişiz? Çünkü <span
class="math inline">\(\hat{i}\)</span>’nin yönü yukarıdır, aşağı
değil.</p>
<p>Hiperboloid</p>
<p>Parametrizasyonu türetelim. Diyelim ki <span
class="math inline">\(x^2 + y^2 - z^2 = 1\)</span> gibi bir
paraboloid’imiz var. <span class="math inline">\(x,y\)</span>’yi şöyle
alalım</p>
<p><span class="math display">\[ x = r \cos u \]</span></p>
<p><span class="math display">\[ y = r \sin u \]</span></p>
<p>Yerine koyarsak</p>
<p><span class="math display">\[ r^2 - z^2 = 1 \]</span></p>
<p>elde ederiz. Şimdi kareleri birbirinden çıkartılınca 1 veren bir
şeyler bulmak lazım. Hiperbol <span class="math inline">\(\sin\)</span>
ve <span class="math inline">\(\cos\)</span> (hyperbolic sine, cosine)
böyle fonksiyonlardır.</p>
<p><span class="math display">\[ \cosh^2x - \sinh^2x = 1 \]</span></p>
<p>Bu eşitliği kullanarak</p>
<p><span class="math display">\[ r = \cosh v \]</span></p>
<p><span class="math display">\[ z = \sinh(v) \]</span></p>
<p>Yine yerine koyalım</p>
<p><span class="math display">\[ x = \cos u \cosh v \]</span></p>
<p><span class="math display">\[ y = \sin u \cosh v \]</span></p>
<p><span class="math display">\[ z = \sinh v \]</span></p>
<p>Son formüllerimiz bunlar.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpl_toolkits.mplot3d <span class="im">import</span> Axes3D</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>plt.figaspect(<span class="dv">1</span>))  <span class="co"># Square figure</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">111</span>, projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>r<span class="op">=</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>u<span class="op">=</span>np.linspace(<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">200</span>)<span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>v<span class="op">=</span>np.linspace(<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>np.pi,<span class="dv">60</span>)<span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>[u,v]<span class="op">=</span>np.meshgrid(u,v)<span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> a<span class="op">*</span>np.cosh(u)<span class="op">*</span>np.cos(v)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> b<span class="op">*</span>np.cosh(u)<span class="op">*</span>np.sin(v)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> c<span class="op">*</span>np.sinh(u)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>ax.plot_surface(x, y, z,  rstride<span class="op">=</span><span class="dv">4</span>, cstride<span class="op">=</span><span class="dv">4</span>, color<span class="op">=</span><span class="st">&#39;b&#39;</span>)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;hyperboloid.jpg&#39;</span>)</span></code></pre></div>
<p><img src="hyperboloid.jpg" /></p>
<p>Bir diğer kod <span class="math inline">\(a \cos,b \sin\)</span>
ifadelerinin toplamını gösteriyor</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>xmax <span class="op">=</span> <span class="fl">6.</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>xmin <span class="op">=</span> <span class="op">-</span><span class="fl">6.</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> linspace(xmin, xmax, D)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>plot(x, (a<span class="op">*</span>cos(x) <span class="op">+</span> b<span class="op">*</span>sin(x)))</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>plot(x, (a<span class="op">*</span>cos(x)))</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>plot(x, (b<span class="op">*</span>sin(x)))</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>grid()</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>legend([<span class="st">&#39;sum&#39;</span>, <span class="st">&#39;cos&#39;</span>,<span class="st">&#39;sin&#39;</span>])</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;1h7.png&#39;</span>)</span></code></pre></div>
<p><img src="1h7.png" /></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
