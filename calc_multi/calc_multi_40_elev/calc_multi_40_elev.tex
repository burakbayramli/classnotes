\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Yükseklik Fonksiyonu (Tepeler) Arasýndan En Düz, Optimal Yürüyüþ Yolunu Bulmak

Elimizde bir alan içindeki yükseklikleri veren bir fonksiyon $f(x,y)$
olduðunu düþünelim. Acaba verili bir baþlangýç ve bitiþ noktasý arasýndaki
en ``rahat'' gidiþ yolunu nasýl buluruz? 

Bu problem bir çizgi entegral hesabýna çevirilebilir. Bir skalar alan
üzerinden giden herhangi bir parametrize eðrinin altýndaki alaný
hesaplamayý biliyoruz [2]. Ayrýca istediðimiz derecede polinom parametrize
eðrileri nasýl yaratacaðýmýzý biliyoruz [3]. Bu fikirleri bir araya koyarsak,
geriye kalan bir optimizasyon problemidir. Çünkü en rahat yol, ``toplam
yüksekliði en az olan yol'' olarak görülebilir, ve burada çizgi entegrali
faydalý olur.

Önce yükseklikleri ve eðrileri iki örnek üzerinde görelim. Bir rasgele
tepe, ve bir rasgele yol çiziyoruz,

\begin{minted}[fontsize=\footnotesize]{python}
from mpl_toolkits.mplot3d import Axes3D
from scipy.spatial.distance import cdist
from matplotlib import cm

def gfunc(x, y):
    s1 = 2.2; x1 = 2.0; y1 = 2.0
    g1 = np.exp( -4 *np.log(2) * ((x-x1)**2+(y-y1)**2) / s1**2)
    return g1 

def plot_surf_path(a0,a1,a2,a3,a4,b0,b1,b2,b3,b4):

    D = 50
    x = np.linspace(0,5,D)
    y = np.linspace(0,5,D)
    xx,yy = np.meshgrid(x,y)
    zz = gfunc(xx,yy)

    fig = plt.figure()
    ax = fig.gca(projection='3d')
    ax.set_xlim(0,5)
    ax.set_ylim(0,5)
    surf = ax.plot_wireframe(xx, yy, zz,rstride=10, cstride=10)

    t = np.linspace(0,1.0,100)

    x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
    y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4

    ax.plot3D(x, y, gfunc(x,y),'r.')

# 1. gidis yolunun tanimi, uzun yoldan dolanarak gidiyor
a1,a2,a3 = 1.5, 8.1, 4.0
b1,b2,b3 = 0.3, 0.4, 23.3
a0,b0=(1.0,1.0)
ex,ey=(0.3,4.0)
a4 = ex - a0 - (a1+a2+a3)
b4 = ey - b0 - (b1+b2+b3)
test_coefs1 = (a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plot_surf_path(a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)

plt.savefig('calc_multi_40_elev_01.png')
\end{minted}

\includegraphics[width=20em]{calc_multi_40_elev_01.png}

Eðer üstteki gidiþ yoluna kuþbakýþý, iki boyutlu ortamda bakmak istersek,

\begin{minted}[fontsize=\footnotesize]{python}
t = np.linspace(0,1.0,100)
x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4
plt.xlim(0,5.0)
plt.ylim(0,5.0)
plt.plot(x,y)
plt.savefig('calc_multi_40_elev_02.png')
\end{minted}

\includegraphics[width=20em]{calc_multi_40_elev_02.png}

Þimdi ikinci bir gidiþ yoluna bakalým, baþlangýç noktasý ayný ama bitiþ farklý,

\begin{minted}[fontsize=\footnotesize]{python}
# 2. gidis yolunun tanimi, dik cikip iniyor
a1,a2,a3 = 1.5, 3.0, 1.0
b1,b2,b3 = 0.0, 1.0, 1.0
a0,b0=(1.0,1.0)
ex,ey=(0.3,4.0)
a4 = ex - a0 - (a1+a2+a3)
b4 = ey - b0 - (b1+b2+b3)
test_coefs2 = (a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plot_surf_path(a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plt.savefig('calc_multi_40_elev_03.png')
\end{minted}

\includegraphics[width=20em]{calc_multi_40_elev_03.png}

Bu yollarý tabii ki rasgele parametreler üzerinden yarattýk, bunlar optimal
yollar deðiller.

Optimallik için gereken çizgi entegralinin hesabýna gelelim. Bu hesap için
formül,

$$
\int_{t=0}^{t=1} f(x(t),y(t)) \sqrt{(\ud x/\ud t)^2 + (\ud y/\ud t)^2} \ud t
$$

Formülde görülen $\ud x/\ud t$ ve $\ud y/\ud t$ ve bunlarýn karesi,
toplamlarýn karekökü, vs. hesaplarýný sembolik olarak altta yapalým,

\begin{minted}[fontsize=\footnotesize]{python}
import sympy

vars = 't a0 a1 a2 a3 b0 b1 b2 b3 gamma x y'
t, a0, a1, a2, a3, b0, b1, b2, b3, gamma, x, y = sympy.symbols(vars)

xdef = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4
ydef = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4

dxdt = sympy.diff(xdef,t)
print (dxdt)
dydt = sympy.diff(ydef,t)
print (dydt)
sqrtdef = sympy.sqrt(sympy.diff(xdef,t)**2 + sympy.diff(ydef,t))
print (sqrtdef)
\end{minted}

\begin{verbatim}
a1 + 2*a2*t + 3*a3*t**2 - 57.2*t**3
b1 + 2*b2*t + 3*b3*t**2 - 84.0*t**3
sqrt(b1 + 2*b2*t + 3*b3*t**2 - 84.0*t**3 + (a1 + 2*a2*t + 3*a3*t**2 - 57.2*t**3)**2)
\end{verbatim}


Þimdi entegralin kendisine gelelim. Bu noktada üstteki sembolik programý
daha da ilerletip sembolik entegrali almayý deneyebilirdik. Fakat bu iþlem
oldukca uzun zaman alýyor. Zaten daha ileride daha çetrefil yükseklik
fonksiyonlarý ile çalýþmak istersek, o durumda da kullanabilecek bir metota
ihtiyacýmýz var. Burada sayýsal entegral almak [1] bir seçenektir. Ama o
zaman optimizasyon için gereken gradyan hesabý nasýl olacak diye merak
edenler olabilir.. Bazi optimizasyon rutinleri gradyan olmadan da
isleyebiliyor. 

Altta entegral hesabýný üstteki örnek yollar için görelim,

\begin{minted}[fontsize=\footnotesize]{python}
def trapz(y, dx):
    vals = np.nan_to_num(y[1:-1],0)
    tmp = np.sum(vals*2.0)    
    return (y[0]+tmp+y[-1])*(dx/2.0)

def intval(t,a0,a1,a2,a3,a4,b0,b1,b2,b3,b4):
   sq = np.sqrt(b1 + 2*b2*t + 3*b3*t**2 - 112.0*t**3 + (a1 + 2*a2*t + 3*a3*t**2 - 65.2*t**3)**2)
   x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
   y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4
   x = np.array(x)
   y = np.array(y)   
   z = gfunc(x,y)   
   res = z * sq
   T = trapz(res, 1.0/len(t))
   return T

t = np.linspace(0,1,100)

a0,a1,a2,a3,a4,b0,b1,b2,b3,b4 = test_coefs1
T = intval(t,a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
print (T)
a0,a1,a2,a3,a4,b0,b1,b2,b3,b4 = test_coefs2
T = intval(t,a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
print (T)
\end{minted}

\begin{verbatim}
1.624956808796678
5.534245013919315
\end{verbatim}

Daha dik yolun entegrali daha yüksek çýktý, bu normal.

Þimdi optimal yolu bulalým,

\inputminted[fontsize=\footnotesize]{python}{paths.py}

\includegraphics[width=20em]{calc_multi_40_elev_04.png}

\includegraphics[width=20em]{calc_multi_40_elev_05.png}

Ayrýca bir \verb!offset! parametresiyle yükseklik fonksiyonunun döndürdüðü
her yükseklik hesabýna bir \verb!offset! kadar yüksekliði suni olarak
eklediðimize dikkat. Bunun sebebi yer seviyesinin 0 yükseklikte olmasý
sebebiyle sürekli tercih edilebilmesi, yani upuzun bir yol yer seviyesinden
gidebilir, çünkü orada gitmenin hiçbir bedeli yoktur. Biz de her yüksekliði
suni bir yükseklik ekleyerek yerdeki çok uzun yollarýn tercih edilmemesini
saðladýk.

RBF Tepeleri

Ýþleri biraz daha zorlaþtýralým. Gerçek dünya þartlarýnda bir bölgenin
yükseklik verisinden örneklem toplayýp, bu verileri RBF ile modelleyip [4],
o modeli yükseklik için kullanmak isteyebiliriz. Eðer herhangi bir $x,y$
noktasýnýn yüksekliðinin verecek RBF toplam fonksiyonunu temiz bir þekilde
iþletmenin yolunu bulabilirsek, bunun üzerinden çizgi entegrali, ve bu
entegral fonksiyonun `autoðrad` türevi üzerinden minimizasyonunu
yapabiliriz. 

Hatta daha da zorlaþtýralým, gerçek dünya þartlarýnda coðrafik kordinatlarý
da parçalara bölüp her parça üzerinde RBF modellemesi yapmak
gerekebilir. Diyelim ki kordinatlarý tam sayý bazýnda bölüyoruz, mesela tüm
enlem/boylam (36,32) kordinatlarý bir blok (Alanya çevresi), (36,33) bir
baþka blok. Her tam sayýlý alan yaklaþýk 9,300 $km^2$'ye tekabül eder. Bu
yeterince büyük bir alan, oradaki tepeleri modellemek ise yarar. Her neyse,
diyelim ki bir hesap için (36,32), ve (36,33) RBF'lerini bir sözlük içine
alýyoruz, ve bu iki RBF bloðu üzerinden optimizasyonun olmasýný
saðlayalým. 

Test amaçlý bir blok içinde iki tepe yaratalým, sonra ayný tepeleri bir
baþka blok içinde yaratacaðýz, ve ikisini yanyana koyacaðýz. 

\begin{minted}[fontsize=\footnotesize]{python}
from scipy import optimize
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm

np.random.seed(0)
S = 50
D = 100

def func1(x, y):
    s1 = 0.2; x1 = 36.5; y1 = 32.5
    s2 = 0.4; x2 = 36.1; y2 = 32.8
    g1 = np.exp( -4 *np.log(2) * ((x-x1)**2+(y-y1)**2) / s1**2)
    g2 = np.exp( -2 *np.log(2) * ((x-x2)**2+(y-y2)**2) / s2**2)	   
    return g1 + g2 

def func2(x, y):
    s1 = 0.2; x1 = 36.5; y1 = 33.5
    s2 = 0.4; x2 = 36.1; y2 = 33.8
    g1 = np.exp( -4 *np.log(2) * ((x-x1)**2+(y-y1)**2) / s1**2)
    g2 = np.exp( -2 *np.log(2) * ((x-x2)**2+(y-y2)**2) / s2**2)	   
    return g1 + g2 

def create_rbfi_hills(latint,lonint):
    x = np.linspace(latint,latint+1,D)
    y = np.linspace(lonint,lonint+1,D)

    xx,yy = np.meshgrid(x,y)
    from scipy.interpolate import Rbf

    xx = xx.reshape(D,D)
    yy = yy.reshape(D,D)
    if lonint==32:
       zz = func1(xx,yy)
    if lonint==33:
       zz = func2(xx,yy)

    idx = np.random.choice(range(D*D),S)
    xr = xx.reshape(D*D)[idx].reshape(S,1)
    yr = yy.reshape(D*D)[idx].reshape(S,1)
    zr = zz.reshape(D*D)[idx].reshape(S,1)

    rbfi = Rbf(xr,yr,zr,function='gaussian',epsilon=0.15)
    return rbfi

edict = {}

edict[(36,32)] = create_rbfi_hills(36,32)
edict[(36,33)] = create_rbfi_hills(36,33)

def dist_matrix(X, Y):
    sx = np.sum(X**2, 1)
    sy = np.sum(Y**2, 1)
    D2 =  sx[:, np.newaxis] - 2.0*X.dot(Y.T) + sy[np.newaxis, :] 
    D2[D2 < 0] = 0
    D = np.sqrt(D2)
    return D

def gaussian(r,eps): return np.exp(-(r/eps)**2)

def f_interp(x,y,rbfi,offset=0):
    newp = np.array([[x,y]])
    nodes = rbfi.nodes.reshape(1,len(rbfi.nodes))
    newp_dist = dist_matrix(newp, rbfi.xi.T)
    res = np.dot(gaussian(newp_dist, rbfi.epsilon), nodes.T)
    res = np.float(res[[0]])
    return res+offset

def rbfi_combo(x,y,offset=0):
    xint = int(x)
    yint = int(y)
    rbfi = edict.get((xint,yint))
    if not rbfi: return 0.0
    return f_interp(x,y,rbfi,offset)

x = np.linspace(36,37,D)
y = np.linspace(32,34,D)
xx,yy = np.meshgrid(x,y)
zz = [rbfi_combo(xxx,yyy)  for xxx,yyy in zip(xx.flatten(),yy.flatten())]
zz = np.array(zz).reshape(D,D)

fig = plt.figure()
ax = fig.gca(projection='3d')
ax.view_init(elev=60, azim=30)
surf = ax.plot_surface(xx, yy, zz, cmap=cm.coolwarm)

plt.savefig('calc_multi_40_elev_06.png')
\end{minted}

\includegraphics[width=25em]{calc_multi_40_elev_06.png}

Þimdi çizgi entegrali hesabý ve optimizasyon için gerekli rutinleri
yazalým, ve bir baþlangýç noktasý \verb!(36.0,32.0)!'dan
\verb!(36.4,34.0)!'a giden optimal yolu bulmaya çalýþalým.

\begin{minted}[fontsize=\footnotesize]{python}
def trapz(y, dx):
    vals = np.nan_to_num(y[1:-1],0)
    tmp = np.sum(vals*2.0)    
    return (y[0]+tmp+y[-1])*(dx/2.0)

def intval(t,a0,a1,a2,a3,a4,b0,b1,b2,b3,b4):
   sq = np.sqrt(b1 + 2*b2*t + 3*b3*t**2 - 112.0*t**3 + \
        (a1 + 2*a2*t + 3*a3*t**2 - 65.2*t**3)**2)
   x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
   y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4
   x = np.array(x)
   y = np.array(y)   
   z = [rbfi_combo(xxx,yyy)  for xxx,yyy in zip(x,y)]
   res = z * sq
   T = trapz(res, 1.0/len(t))
   return T

def find_path(ex,ey,a0,b0):
    
    cons=({'type': 'ineq','fun': lambda x: 4.0-x[0]}, # y<30
	  {'type': 'ineq','fun': lambda x: 4.0-x[1]},
	  {'type': 'ineq','fun': lambda x: 4.0-x[2]},
	  {'type': 'ineq','fun': lambda x: 4.0-x[3]},
	  {'type': 'ineq','fun': lambda x: 4.0-x[4]},
	  {'type': 'ineq','fun': lambda x: 4.0-x[5]},
	  {'type': 'ineq','fun': lambda x: x[0]}, # y>0
	  {'type': 'ineq','fun': lambda x: x[1]},
	  {'type': 'ineq','fun': lambda x: x[2]},
	  {'type': 'ineq','fun': lambda x: x[3]},
	  {'type': 'ineq','fun': lambda x: x[4]},
	  {'type': 'ineq','fun': lambda x: x[5]},
    )

    # baslangic degerleri
    a1,a2,a3 = 3,2,1
    b1,b2,b3 = 1,2,3
    x0 = a1,a2,a3,b1,b2,b3

    def pintval(p):
        a1,a2,a3,b1,b2,b3 = p
        t = np.linspace(0,1,100)
        a4 = ex - a0 - (a1+a2+a3)
        b4 = ey - b0 - (b1+b2+b3)   
        sq = np.sqrt(b1 + 2*b2*t + 3*b3*t**2 - 112.0*t**3 + (a1 + 2*a2*t + 3*a3*t**2 - 65.2*t**3)**2)
        x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
        y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4
        x = np.array(x)
        y = np.array(y)   
        z = np.array([rbfi_combo(xxx,yyy,offset=2.0) for xxx,yyy in zip(x,y)])
        res = z * sq
        T = trapz(res, 1.0/len(t))
        return T
    
    sol = optimize.minimize(pintval,
			    x0,
			    method = 'COBYLA',
			    tol=0.00001,
			    constraints=cons)

    return sol.x

a0,b0=(36.0,32.0)
ex,ey=(36.4,34.0)
res = find_path(ex,ey,a0,b0)
print (res)
\end{minted}

\begin{verbatim}
[1.93790581 1.18886277 2.05012843 0.73404354 1.79221447 2.97475768]
\end{verbatim}

Bir yol bulundu. Grafikleyelim,

\begin{minted}[fontsize=\footnotesize]{python}
a1,a2,a3,b1,b2,b3 = res

a4 = ex - a0 - (a1+a2+a3)
b4 = ey - b0 - (b1+b2+b3)

t = np.linspace(0,1.0,100)
xl = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
yl = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4
zl = [rbfi_combo(xxx,yyy)  for xxx,yyy in zip(xl,yl)]

fig = plt.figure()
ax = fig.gca(projection='3d')
ax.view_init(elev=60, azim=30)
strides = 10
surf = ax.plot_wireframe(xx, yy, zz,rstride=strides, cstride=strides)
ax.plot3D(xl, yl, zl,'r.')	

plt.savefig('calc_multi_40_elev_07.png')
\end{minted}

\includegraphics[width=25em]{calc_multi_40_elev_07.png}

Autograd, Otomatik Türev

Þimdiye kadar gördüðümüz yöntem gradyan /türev bilgisinin sayýsal olarak
hesaplayan bir yöntem kullandý, COBYLA. Fakat gradyan bilgisini `autograd`
otomatik türev olarak aldýrýp (sembolik türev ile ayný kuvvette),
minimizasyon adýmýný kendimiz de atabilirdik.

Ýki tepeli örnek üzerinde görelim. Tepeleri yaratýp, örneklem alýp, RBF
modelleme yapiyoruz. Fakat bir fark var, RBF ile yükseklik hesaplayan
metot, ve onun içinde çaðýrdýðý tüm metotlar ``autograd-perver'' olmalý,
çünkü autograd perde arkasýnda Python kodu üzerinde bazý temelden
deðiþimler yapýyor, ve bu sebeple metotlarýn autoðrad üzerinden, ve
autograd dýþýndan çaðrýlmalarýnda farklýlýklar olabiliyor. Kodlamadaki
deðiþimleri açýk þekilde göstermek amaciyla 
\verb!import numpy as anp! ile dahil edilen \verb!numpy! versiyoununu farklý isimlendirdik.

Gradyan iniþi için gereken gradyan her parametre için
\verb!autograd.grad(intval,...)! ile alinir [5], ve 0,1,2,.. diye giden
parametreler sýrasýyla egrinin katsayilari $a_1,a_2,..$'ye tekabül ediyor.

\inputminted[fontsize=\footnotesize]{python}{pathsauto.py}

\includegraphics[width=18em]{linear_app88rbf_08-0.png}
\includegraphics[width=18em]{linear_app88rbf_08-1.png}
\includegraphics[width=18em]{linear_app88rbf_08-2.png}

Sonuçlara bakarsak rasgele katsayýlarla baþladýk, ve tek bir gradyan iniþi
adýmý ile optimal bir yola oldukca yaklaþtýk. Bir adým daha daha da iyi
sonuç verdi. 

Ýþte görüldüðü gibi son derece çetrefil bir fonksiyon olsa da türevi rahat
bir þekilde hesaplamýþ oluyoruz. 

Kaynaklar 

[1] Bayramlý, Sayýsal Bilim, {\em Sayýsal Entegrasyon (Numerical Integration)}

[2] Bayramlý, Cok Boyutlu Calculus, {\em Ders 19, Skalar Alanlar Uzerinden Cizgi Entegral}

[3] Bayramlý, Cok Boyutlu Calculus, {\em Ders 5, Ýki Nokta Arasýnda Parametrize Edilmiþ Eðri}

[4] Bayramlý, Ýstatistik ve Veri Analizi, {\em Dairesel Baz Fonksiyonlarý (Radial Basis Functions -RBF-)}

[5] Bayramlý, Fonksiyonel Analiz ve Optimizasyon, {\em Autograd ile Optimizasyon}

\end{document}



