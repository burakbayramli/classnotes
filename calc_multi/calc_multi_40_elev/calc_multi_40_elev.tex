\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Yükseklik Fonksiyonu (Tepeler) Arasýndan En Düz, Optimal Yürüyüþ Yolunu Bulmak

Elimizde bir alan içindeki yükseklikleri veren bir fonksiyon $f(x,y)$
olduðunu düþünelim. Acaba verili bir baþlangýç ve bitiþ noktasý arasýndaki
en ``rahat'' gidiþ yolunu nasýl buluruz? 

Bu problem bir çizgi entegral hesabýna çevirilebilir. Bir skalar alan
üzerinden giden herhangi bir parametrize eðrinin altýndaki alaný
hesaplamayý biliyoruz [2]. Ayrýca istediðimiz derecede polinom parametrize
eðrileri nasýl yaratacaðýmýzý biliyoruz [3]. Bu fikirleri bir araya koyarsak,
geriye kalan bir optimizasyon problemidir. Çünkü en rahat yol, ``toplam
yüksekliði en az olan yol'' olarak görülebilir, ve burada çizgi entegrali
faydalý olur.

Önce yükseklikleri ve eðrileri iki örnek üzerinde görelim. Bir rasgele
tepe, ve bir rasgele yol çiziyoruz,

\begin{minted}[fontsize=\footnotesize]{python}
from mpl_toolkits.mplot3d import Axes3D
from scipy.spatial.distance import cdist
from matplotlib import cm

def gfunc(x, y):
    s1 = 2.2; x1 = 2.0; y1 = 2.0
    g1 = np.exp( -4 *np.log(2) * ((x-x1)**2+(y-y1)**2) / s1**2)
    return g1 

def plot_surf_path(a0,a1,a2,a3,a4,b0,b1,b2,b3,b4):

    D = 50
    x = np.linspace(0,5,D)
    y = np.linspace(0,5,D)
    xx,yy = np.meshgrid(x,y)
    zz = gfunc(xx,yy)

    fig = plt.figure()
    ax = fig.gca(projection='3d')
    ax.set_xlim(0,5)
    ax.set_ylim(0,5)
    surf = ax.plot_wireframe(xx, yy, zz,rstride=10, cstride=10)

    t = np.linspace(0,1.0,100)

    x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
    y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4

    ax.plot3D(x, y, gfunc(x,y),'r.')

# 1. gidis yolunun tanimi, uzun yoldan dolanarak gidiyor
a1,a2,a3 = 1.5, 8.1, 4.0
b1,b2,b3 = 0.3, 0.4, 23.3
a0,b0=(1.0,1.0)
ex,ey=(0.3,4.0)
a4 = ex - a0 - (a1+a2+a3)
b4 = ey - b0 - (b1+b2+b3)
test_coefs1 = (a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plot_surf_path(a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)

plt.savefig('calc_multi_40_elev_01.png')
\end{minted}

\includegraphics[width=20em]{calc_multi_40_elev_01.png}

Eðer üstteki gidiþ yoluna kuþbakýþý, iki boyutlu ortamda bakmak istersek,

\begin{minted}[fontsize=\footnotesize]{python}
t = np.linspace(0,1.0,100)
x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4
plt.xlim(0,5.0)
plt.ylim(0,5.0)
plt.plot(x,y)
plt.savefig('calc_multi_40_elev_02.png')
\end{minted}

\includegraphics[width=20em]{calc_multi_40_elev_02.png}

Þimdi ikinci bir gidiþ yoluna bakalým, baþlangýç noktasý ayný ama bitiþ farklý,

\begin{minted}[fontsize=\footnotesize]{python}
# 2. gidis yolunun tanimi, dik cikip iniyor
a1,a2,a3 = 1.5, 3.0, 1.0
b1,b2,b3 = 0.0, 1.0, 1.0
a0,b0=(1.0,1.0)
ex,ey=(0.3,4.0)
a4 = ex - a0 - (a1+a2+a3)
b4 = ey - b0 - (b1+b2+b3)
test_coefs2 = (a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plot_surf_path(a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plt.savefig('calc_multi_40_elev_03.png')
\end{minted}

\includegraphics[width=20em]{calc_multi_40_elev_03.png}

Bu yollarý tabii ki rasgele parametreler üzerinden yarattýk, bunlar optimal
yollar deðiller.

Optimallik için gereken çizgi entegralinin hesabýna gelelim. Bu hesap için
gereken formül,

$$
\int_{t=0}^{t=1} f(x(t),y(t)) \sqrt{(\ud x/\ud t)^2 + (\ud y/\ud t)^2} \ud t
$$

Formülde görülen $\ud x/\ud t$ ve $\ud y/\ud t$ ve bunlarýn karesi,
toplamarýn kareköku, vs. hesaplarýný sembolik olarak altta yapalým,

\begin{minted}[fontsize=\footnotesize]{python}
import sympy

vars = 't a0 a1 a2 a3 b0 b1 b2 b3 gamma x y'
t, a0, a1, a2, a3, b0, b1, b2, b3, gamma, x, y = sympy.symbols(vars)

xdef = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4
ydef = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4

dxdt = sympy.diff(xdef,t)
print (dxdt)
dydt = sympy.diff(ydef,t)
print (dydt)
sqrtdef = sympy.sqrt(sympy.diff(xdef,t)**2 + sympy.diff(ydef,t))
print (sqrtdef)
\end{minted}

\begin{verbatim}
a1 + 2*a2*t + 3*a3*t**2 - 57.2*t**3
b1 + 2*b2*t + 3*b3*t**2 - 84.0*t**3
sqrt(b1 + 2*b2*t + 3*b3*t**2 - 84.0*t**3 + (a1 + 2*a2*t + 3*a3*t**2 - 57.2*t**3)**2)
\end{verbatim}


Þimdi entegralin kendisine gelelim. Bu noktada üstteki sembolik programý
daha da ilerletip sembolik entegrali almayý deneyebilirdik. Fakat bu iþlem
oldukca uzun zaman alýyor. Zaten daha ileride daha çetrefil yükseklik
fonksiyonlarý ile çalýþmak istersek, o durumda da kullanabilecek bir metota
ihtiyacýmýz var. Burada sayýsal entegral almak [1] bir seçenektir. Ama o
zaman optimizasyon için gereken gradyan hesabý nasýl olacak diye merak
edenler olabilir.. Cevap basit. Otomatik türev yöntemi ile! 

Otomatik türev ile herhangi bir fonksiyonun türevini alabileceðimizi
biliyoruz [4], eh sayýsal entegrasyon da herhangi bir metot olduðuna göre
onun türevini alabiliriz. Altta bu hesabý üstteki örnek yollar için
görelim,

\begin{minted}[fontsize=\footnotesize]{python}
def trapz(y, dx):
    vals = np.nan_to_num(y[1:-1],0)
    tmp = np.sum(vals*2.0)    
    return (y[0]+tmp+y[-1])*(dx/2.0)

def intval(t,a0,a1,a2,a3,a4,b0,b1,b2,b3,b4):
   sq = np.sqrt(b1 + 2*b2*t + 3*b3*t**2 - 112.0*t**3 + (a1 + 2*a2*t + 3*a3*t**2 - 65.2*t**3)**2)
   x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
   y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4
   x = np.array(x)
   y = np.array(y)   
   z = gfunc(x,y)   
   res = z * sq
   T = trapz(res, 1.0/len(t))
   return T

t = np.linspace(0,1,100)

a0,a1,a2,a3,a4,b0,b1,b2,b3,b4 = test_coefs1
T = intval(t,a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
print (T)
a0,a1,a2,a3,a4,b0,b1,b2,b3,b4 = test_coefs2
T = intval(t,a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
print (T)
\end{minted}

\begin{verbatim}
1.624956808796678
5.534245013919315
\end{verbatim}

Daha dik yolun entegrali daha yüksek çýktý, bu normal.

Þimdi optimal yolu bulalým,

\inputminted[fontsize=\footnotesize]{python}{paths.py}

\includegraphics[width=20em]{calc_multi_40_elev_04.png}

\includegraphics[width=20em]{calc_multi_40_elev_05.png}

Dikkat edersek son kod içinde bazý fonksiyonlarý tekrar yazmamýz
gerekti. Bunun sebebi otomatik türev kütüphanesi \verb!autograd!'ýn kendi
içinde olan \verb!numpy! kodlarýný kullanmamýz gerekmesi. Yani dýþarýdan
\verb!numpy! deðil \verb!autograd! içindeki \verb!numpy!'i kullanmak lazým;
sebep o \verb!numpy!'in ``türevi alýnabilir'' bir hale getirilmiþ
olmasý. OT bir sihirli deðnek deðil, pek çok iyi yapýyor, daha önceden
hazýrlanmýþ öðeleri kullanmak þartýyla. 

Ayrýca bir \verb!OFFSET! parametresiyle yükseklik fonksiyonunun döndürdüðü
her yükseklik hesabýna bir \verb!OFFSET! kadar yüksekliði suni olarak
eklediðimize dikkat. Bunun sebebi yer seviyesinin 0 yükseklikte olmasý
sebebiyle sürekli tercih edilebilmesi, yani upuzun bir yol yer seviyesinden
gidebilir, çünkü orada gitmenin hiçbir bedeli yoktur. Biz de her yüksekliði
suni bir yükseklik ekleyerek yerdeki çok uzun yollarýn tercih edilmemesini
saðladýk.

RBF Tepeleri

Ýþleri biraz daha zorlaþtýralým. Gerçek dünya þartlarýnda bir bölgenin
yükseklik verisinden örneklem toplayýp, bu verileri RBF ile modelleyip [6],
o modeli yükseklik için kullanmak isteyebiliriz. Eðer herhangi bir $x,y$
noktasýnýn yüksekliðinin verecek RBF toplam fonksiyonunu temiz bir þekilde
iþletmenin yolunu bulabilirsek, bunun üzerinden çizgi entegrali, ve bu
entegral fonksiyonun `autoðrad` türevi üzerinden minimizasyonunu
yapabiliriz. 

Hatta daha da zorlaþtýralým, gerçek dünya þartlarýnda coðrafik kordinatlarý
da parçalara bölüp her parça üzerinde RBF modellemesi yapmak
gerekebilir. Diyelim ki kordinatlarý tam sayý bazýnda bölüyoruz, mesela tüm
enlem/boylam (36,32) kordinatlarý bir blok (Alanya çevresi), (36,33) bir
baþka blok. Her tam sayýlý alan yaklaþýk 9,300 $km^2$'ye tekabül eder. Bu
yeterince büyük bir alan, oradaki tepeleri modellemek ise yarar. Her neyse,
diyelim ki bir hesap için (36,32), ve (36,33) RBF'lerini bir sözlük içine
alýyoruz, ve bu iki RBF bloðu üzerinden entegralin otomatik türevini
alacaðýz. Olur mu? Autograd ile oluyor.

Test amaçlý bir blok içinde iki tepe yaratalým, sonra ayný tepeleri bir
baþka blok içinde yaratacaðýz, ve ikisini yanyana koyacaðýz. 

\begin{minted}[fontsize=\footnotesize]{python}
from autograd import numpy as anp
from scipy import optimize
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm
import autograd

np.random.seed(0)
S = 50
D = 100

def func1(x, y):
    s1 = 0.2; x1 = 36.5; y1 = 32.5
    s2 = 0.4; x2 = 36.1; y2 = 32.8
    g1 = np.exp( -4 *np.log(2) * ((x-x1)**2+(y-y1)**2) / s1**2)
    g2 = np.exp( -2 *np.log(2) * ((x-x2)**2+(y-y2)**2) / s2**2)	   
    return g1 + g2 

def func2(x, y):
    s1 = 0.2; x1 = 36.5; y1 = 33.5
    s2 = 0.4; x2 = 36.1; y2 = 33.8
    g1 = np.exp( -4 *np.log(2) * ((x-x1)**2+(y-y1)**2) / s1**2)
    g2 = np.exp( -2 *np.log(2) * ((x-x2)**2+(y-y2)**2) / s2**2)	   
    return g1 + g2 

def create_rbfi_hills(latint,lonint):
    x = np.linspace(latint,latint+1,D)
    y = np.linspace(lonint,lonint+1,D)

    xx,yy = np.meshgrid(x,y)
    from scipy.interpolate import Rbf

    xx = xx.reshape(D,D)
    yy = yy.reshape(D,D)
    if lonint==32:
       zz = func1(xx,yy)
    if lonint==33:
       zz = func2(xx,yy)

    idx = np.random.choice(range(D*D),S)
    xr = xx.reshape(D*D)[idx].reshape(S,1)
    yr = yy.reshape(D*D)[idx].reshape(S,1)
    zr = zz.reshape(D*D)[idx].reshape(S,1)

    rbfi = Rbf(xr,yr,zr,function='gaussian',epsilon=0.15)
    return rbfi

edict = {}

edict[(36,32)] = create_rbfi_hills(36,32)
edict[(36,33)] = create_rbfi_hills(36,33)

def dist_matrix(X, Y):
    sx = np.sum(X**2, 1)
    sy = np.sum(Y**2, 1)
    D2 =  sx[:, np.newaxis] - 2.0*X.dot(Y.T) + sy[np.newaxis, :] 
    D2[D2 < 0] = 0
    D = np.sqrt(D2)
    return D

def gaussian(r,eps): return np.exp(-(r/eps)**2)

def f_interp(x,y,rbfi,offset=0):
    newp = np.array([[x,y]])
    nodes = rbfi.nodes.reshape(1,len(rbfi.nodes))
    newp_dist = dist_matrix(newp, rbfi.xi.T)
    res = np.dot(gaussian(newp_dist, rbfi.epsilon), nodes.T)
    res = np.float(res[[0]])
    return res+offset

def rbfi_combo(x,y,offset=0):
    xint = int(x)
    yint = int(y)
    rbfi = edict.get((xint,yint))
    if not rbfi: return 0.0
    return f_interp(x,y,rbfi,offset)

x = np.linspace(36,37,D)
y = np.linspace(32,34,D)
xx,yy = np.meshgrid(x,y)
zz = [rbfi_combo(xxx,yyy)  for xxx,yyy in zip(xx.flatten(),yy.flatten())]
zz = np.array(zz).reshape(D,D)

fig = plt.figure()
ax = fig.gca(projection='3d')
ax.view_init(elev=60, azim=30)
surf = ax.plot_surface(xx, yy, zz, cmap=cm.coolwarm)

plt.savefig('calc_multi_40_elev_06.png')
\end{minted}

\includegraphics[width=25em]{calc_multi_40_elev_06.png}

Þimdi çizgi entegrali hesabý ve optimizasyon için gerekli rutinleri
yazalým, ve bir baþlangýç noktasý \verb!(36.0,32.0)!'dan
\verb!(36.4,34.0)!'a giden optimal yolu bulmaya çalýþalým.

\begin{minted}[fontsize=\footnotesize]{python}
def trapz(y, dx):
    vals = np.nan_to_num(y[1:-1],0)
    tmp = np.sum(vals*2.0)    
    return (y[0]+tmp+y[-1])*(dx/2.0)

def intval(t,a0,a1,a2,a3,a4,b0,b1,b2,b3,b4):
   sq = np.sqrt(b1 + 2*b2*t + 3*b3*t**2 - 112.0*t**3 + (a1 + 2*a2*t + 3*a3*t**2 - 65.2*t**3)**2)
   x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
   y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4
   x = np.array(x)
   y = np.array(y)   
   z = [rbfi_combo(xxx,yyy)  for xxx,yyy in zip(x,y)]
   res = z * sq
   T = trapz(res, 1.0/len(t))
   return T

def find_path(ex,ey,a0,b0):
    
    cons=({'type': 'ineq','fun': lambda x: 30.0-x[0]}, # y<30
	  {'type': 'ineq','fun': lambda x: 30.0-x[1]},
	  {'type': 'ineq','fun': lambda x: 30.0-x[2]},
	  {'type': 'ineq','fun': lambda x: 30.0-x[3]},
	  {'type': 'ineq','fun': lambda x: 30.0-x[4]},
	  {'type': 'ineq','fun': lambda x: 30.0-x[5]},
	  {'type': 'ineq','fun': lambda x: x[0]}, # y>0
	  {'type': 'ineq','fun': lambda x: x[1]},
	  {'type': 'ineq','fun': lambda x: x[2]},
	  {'type': 'ineq','fun': lambda x: x[3]},
	  {'type': 'ineq','fun': lambda x: x[4]},
	  {'type': 'ineq','fun': lambda x: x[5]},
    )

    # baslangic degerleri
    a1,a2,a3 = 0.5,1.0,2.0
    b1,b2,b3 = 0.5,1.0,2.0
    x0 = a1,a2,a3,b1,b2,b3

    def pintval(p):
        a1,a2,a3,b1,b2,b3 = p
        a4 = ex - a0 - (a1+a2+a3)
        b4 = ey - b0 - (b1+b2+b3)   
        t = anp.linspace(0,1,100)
        tmp = b1 + 2.0*b2*t + 3.0*b3*t**2.0 - 112.0*t**3.0 + \
              (a1 + 2.0*a2*t + 3.0*a3*t**2.0 - 65.2*t**3.0)**2.0
        sq = [anp.sqrt(_) if _ != anp.nan else 0.0 for _ in tmp]
        x = a0 + a1*t + a2*t**2.0 + a3*t**3.0 + a4*t**4.0
        y = b0 + b1*t + b2*t**2.0 + b3*t**3.0 + b4*t**4.0
        x = np.array(x)
        y = np.array(y)
        z = np.array([rbfi_combo(xxx,yyy,offset=1.0) for xxx,yyy in zip(x,y)])
        res = z * sq
        T = trapz(res, 1.0/len(t))
        return T

    pintval_grad = autograd.grad(pintval)
    
    sol = optimize.minimize(pintval,
			    x0,
			    jac = pintval_grad,
			    method = 'COBYLA',
			    callback=print,
			    tol=0.05,
			    constraints=cons)

    return sol.x

a0,b0=(36.0,32.0)
ex,ey=(36.4,34.0)
res = find_path(ex,ey,a0,b0)
print (res)
\end{minted}

\begin{verbatim}
[1.043711   1.69200854 2.8494874  1.75138445 1.77491621 1.73660466]
\end{verbatim}

\begin{minted}[fontsize=\footnotesize]{python}
a1,a2,a3,b1,b2,b3 = res

a4 = ex - a0 - (a1+a2+a3)
b4 = ey - b0 - (b1+b2+b3)

t = np.linspace(0,1.0,300)
xl = 36.0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
yl = 32.0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4
zl = [rbfi_combo(xxx,yyy)  for xxx,yyy in zip(xl,yl)]

fig = plt.figure()
ax = fig.gca(projection='3d')
ax.view_init(elev=60, azim=30)
strides = 10
surf = ax.plot_wireframe(xx, yy, zz,rstride=strides, cstride=strides)
ax.plot3D(xl, yl, zl,'r.')	

plt.savefig('calc_multi_40_elev_07.png')
\end{minted}

\includegraphics[width=25em]{calc_multi_40_elev_07.png}


Kaynaklar 

[1] Bayramlý, Sayýsal Bilim, {\em Sayýsal Entegrasyon (Numerical Integration)}

[2] Bayramlý, Cok Boyutlu Calculus, {\em Ders 19, Skalar Alanlar Uzerinden Cizgi Entegral}

[3] Bayramlý, Cok Boyutlu Calculus, {\em Ders 5, Ýki Nokta Arasýnda Parametrize Edilmiþ Eðri}

[4] Bayramlý, Bilgisayar Bilim, Yapay Zeka, {\em Otomatik Türev Almak}

[5] Bayramlý, Fonksiyonel Analiz ve Optimizasyon, {\em Autograd ile Optimizasyon}

[6] Bayramlý, Ýstatistik ve Veri Analizi, {\em Dairesel Baz Fonksiyonlarý (Radial Basis Functions -RBF-)}

\end{document}
