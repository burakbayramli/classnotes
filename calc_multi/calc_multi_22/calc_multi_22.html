<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]
      });
    });
    </script>  
   
  <title>Ders 22</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<div id="header">
</div>
<h1 id="ders-22">Ders 22</h1>
<p>Diyelim ki genel bir vektör alanımız var, ve bu alan muhafazakar değil, biz kapalı bir eğri içinde çizgi entegrali hesaplamak istiyoruz, bu entegral sıfır olmayacak. Bu hesabı iki metotla yapabiliriz. Ya direk entegral hesabı yaparız, ya da Green'in Teoremi adlı bir tekniği kullanırız.</p>
<p>Green'in Teorisi</p>
<p>Eğer <span class="math inline">\(C\)</span> eğrisi <span class="math inline">\(R\)</span> alanını tanımlayan kapalı bir eğriyse, bu eğri üzerindeki hareket saat yönünün tersi ise, ve elimde eğrinin ve içindeki alanın her noktasında tanımlı ve türevi alınabilir bir vektör alanı <span class="math inline">\(\vec{F}\)</span> var ise, o zaman</p>
<p><span class="math display">\[ \oint_C \vec{F} \cdot \mathrm{d}\vec{r} = \int \int_R \mathrm{curl} \vec{F} \mathrm{d} A \]</span></p>
<p>Diğer bir formda</p>
<p><span class="math display">\[ \oint_C M \mathrm{d} x + N \mathrm{d} y = \int \int_R (N_x - M_y) \mathrm{d} A \]</span></p>
<p>Üstteki her iki formülde de eşitliğin iki tarafının birbirinden ne kadar farklı hesaplar olduğuna dikkat edelim. Mesela bir üstteki formülün sol tarafı bir çizgi entegrali, bir (mesela) <span class="math inline">\(t\)</span> üzerinden birbirine bağlı iki <span class="math inline">\(x,y\)</span> değişkeninin, bir şekilde birbirine bağlı şekilde değişen <span class="math inline">\(x,y\)</span> değişkenleri üzerinden bir entegral hesabı bu. Ama aynı formülde eşitliğin sağ tarafı eğrinin &quot;içindeki'' bölgede, bu bölgedeki her nokta için geçerli. Bu bölgede <span class="math inline">\(x,y\)</span> birbirinden bağımsız.</p>
<p>Peki niye saat yönü tersi dedik? Bu aslında herhangi bir yön olabilir, ama bu yön <span class="math inline">\(N_x-M_y\)</span> ile uyumlu, eğer saat yönü olursa, ona göre bir <span class="math inline">\(M_x,N_y\)</span> ifadesinin kullanılması gerekir.</p>
<p>Örnek</p>
<p><span class="math inline">\(C\)</span> eğrisi <span class="math inline">\((2,0)\)</span> noktasında çizilmiş 1 yarıçaplı bir çember olsun. Gidişat saat yönü tersinde.</p>
<div class="figure">
<img src="22_1.png" />

</div>
<p><span class="math display">\[ \oint_C ye^{-x} \mathrm{d} x + (\frac{1}{2}x^2 - e^{-x}) \mathrm{d} y \]</span></p>
<p>Direk olarak</p>
<p><span class="math display">\[ x = 2 + \cos\theta, dx = -\sin\theta \mathrm{d}\theta \]</span></p>
<p><span class="math display">\[ y = \sin\theta, dy = \cos\theta \mathrm{d}\theta \]</span></p>
<p>Sonra üstteki iki satırdaki formülleri alıp entegrale koyardım, ve 0 ile <span class="math inline">\(\pi\)</span> sınırları arasında entegrali hesaplardım.</p>
<p>Tüm bu işlemler yerine Green'in Teorisini kullanalım. Yani çift entegral hesabını yapalım. <span class="math inline">\(M,N\)</span> nedir?</p>
<p><span class="math display">\[ \oint_C 
\underbrace{ye^{-x}}_{M} dx + 
\underbrace{(\frac{1}{2}x^2 - e^{-x})}_{N}dy
\]</span></p>
<p>Çift entegral o zaman şöyle</p>
<p><span class="math display">\[ \int \int_R (N_x - N_y) \mathrm{d} A = \]</span></p>
<p><span class="math inline">\(R\)</span> nedir? Çemberin içindeki her şeydir (çizgili alan).</p>
<div class="figure">
<img src="22_2.png" />

</div>
<p><span class="math display">\[= \int \int_R \bigg( x+ e^{-x} \bigg) - e^{-x} \mathrm{d} A \]</span></p>
<p><span class="math display">\[=  \int \int_R  x \mathrm{d} A \]</span></p>
<p>Peki bu çift entegrali nasıl hesaplayacağız? Tüm cebirsel işlemi yapabiliriz, ya da, bir kısayol düşünelim.</p>
<p><span class="math display">\[ = Alan(R) \ \bar{x} \]</span></p>
<p>Çünkü çift entegral bir alan hesabı yapıyor. <span class="math inline">\(\bar{x}\)</span> ise <span class="math inline">\(R\)</span> alanının yatay ekşendeki kütle merkezi, ki örneğimiz için bu merkez 2 noktasında. Alan zaten <span class="math inline">\(\pi\)</span>, sonuç</p>
<p><span class="math display">\[ = 2\pi \]</span></p>
<p>Bu arada <span class="math inline">\(\bar{x}\)</span>'in tanımı</p>
<p><span class="math display">\[ \bar{x} = \frac{1}{Alan} \int \int x \mathrm{d} A \]</span></p>
<p>Şimdi Green Teorisinin niye işlediğini, yani ispatını görelim.</p>
<p>Özel Durum</p>
<p><span class="math inline">\(\mathrm{curl} \vec{F} = 0\)</span></p>
<p>Bu durumda <span class="math inline">\(\vec{F}\)</span> muhafazakar.</p>
<p><span class="math display">\[ \oint_C \vec{F} \cdot \mathrm{d}\vec{r} = \int \int_R \mathrm{curl} \vec{F} \mathrm{d} A \]</span></p>
<p>Ama curl sıfır ise, o zaman sıfırın entegrali alınır, bu da sıfırdır.</p>
<p><span class="math display">\[ = 0 \]</span></p>
<p>Bu aynı zamanda eğer kapalı eğri içindeki her noktada <span class="math inline">\(\mathrm{curl} \vec{F} = 0\)</span> ise, o zaman <span class="math inline">\(\oint_C \vec{F} \cdot \mathrm{d}\vec{r} = 0\)</span> olduğunun ispatıdır, bu da <span class="math inline">\(\vec{F}\)</span>'in muhafazakar olduğunun ispatıdır.</p>
<p>Problem Set 8 Problem 2 için Green Teorisi uygulanamıyor, çünkü <span class="math inline">\(C\)</span> içinde orijin var.</p>
<p>İspat</p>
<p>Şunu ispatlamaya uğraşıyoruz</p>
<p><span class="math display">\[ \oint_C M \mathrm{d} x + N \mathrm{d} y = \int \int_R (N_x - M_y) \mathrm{d} A \]</span></p>
<p>İşimizi kolaylaştırmak için daha basit bir ifadeyi ispat edelim. Üstteki formülün özel bir hali</p>
<p><span class="math display">\[ \oint_C M \mathrm{d} x  = \int \int_R -M_y \mathrm{d} A \]</span></p>
<p>bu durumda <span class="math inline">\(N=0\)</span>, ve vektör alanında sadece <span class="math inline">\(x\)</span> bileşeni var.</p>
<p>Peki bu özel şart niye yeterli? İddia o ki eğer bu daha basit ifadeyi ispat edebilirsem, sadece <span class="math inline">\(y\)</span> bileşenin olduğu diğer şartı da ispat edebilirim, sonra bu iki özel şartı toplarsam genel şartı elde ederim.</p>
<p>Diğer özel şart</p>
<p><span class="math display">\[ \oint_C N \mathrm{d} y  = \int \int_R N_x \mathrm{d} A \]</span></p>
<p>Bir problem daha var, eğer eğri çetrefil ise çift entegrali oluşturmak zor olabilir.</p>
<div class="figure">
<img src="22_3.png" />

</div>
<p>O zaman daha basit eğrilerle ise başlamak daha iyi.</p>
<p>Bir diğer gözlem daha, <span class="math inline">\(R\)</span>'i daha basit bölgelere ayırabiliriz.</p>
<p><img src="22_4.png" /> <img src="22_5.png" /></p>
<p>Eğer</p>
<p><span class="math display">\[ \oint_{c_1} M \mathrm{d} x  = \int \int_{R_1} -M_y \mathrm{d} A \]</span></p>
<p><span class="math display">\[ \oint_{c_2} M \mathrm{d} x  = \int \int_{R_2} -M_y \mathrm{d} A \]</span></p>
<p>ifadelerinin doğru olduğunu ispatlarsam, o zaman <span class="math inline">\(C\)</span> için olan ifadenin doğruluğunu ispatlayabilirim, çünkü üstteki iki formülü toplayabilirim.</p>
<p>Peki üstteki iki formülde sol taraf toplandığında <span class="math inline">\(R\)</span> bölgesini kabaca ortadan bölen eğriyi iki kere toplamış olmaz mıyım? Aslında evet, ama o eğri üzerindeki gidişata dikkat, biri yukarı, diğeri aşağı yönde. O zaman o parça iki kere toplanınca birbirlerini iptal edecekler ve sonuç sıfır olacak.</p>
<p>O zaman</p>
<p><span class="math display">\[
\oint_C M \mathrm{d} x = \oint_{C_1} + \oint_{C_2} =
\int \int_{R_1} + \int \int_{R_2} = \int \int_R -M_y \mathrm{d} A
\]</span></p>
<p>Örnek olarak şöyle bir şekli alalım. Bu şekli dikey ve &quot;basit'' olarak ve 5 parçaya bölüyoruz.</p>
<div class="figure">
<img src="22_6.png" />

</div>
<p>Bu ne demek?</p>
<p><span class="math display">\[ a &lt; x &lt; b, \ f_1(x) &lt; y &lt; f_2(x) \]</span></p>
<p>Kesik çizgilerin x bileşenini <span class="math inline">\(a,b\)</span> olarak alırsak, bu noktaların <span class="math inline">\(y\)</span> değerleri de dikey (kesik) çizgiler arasında kalıyor.</p>
<p>Ana İşlem</p>
<p>Eğer <span class="math inline">\(R\)</span> dikey ve basit ise, ve <span class="math inline">\(C\)</span>, saat yönü tersi olmak üzere <span class="math inline">\(R\)</span>'nin sınırını oluşturuyorsa,</p>
<p><span class="math display">\[ \oint_C M \mathrm{d} x  = \int \int_R -M_y \mathrm{d} A \]</span></p>
<p>ifadesini ispatla.</p>
<div class="figure">
<img src="22_7.png" />

</div>
<p>Üstteki de basit olarak bölünmüş bir bölgeyi gösteriyor. Çizgili bölümü nasıl hesaplarız?</p>
<div class="figure">
<img src="22_8.png" />

</div>
<p>Eğriyi 4 parçaya ayırırız.</p>
<p><span class="math inline">\(C_1\)</span></p>
<p><span class="math display">\[ y = f_1(x) \]</span></p>
<p><span class="math inline">\(x\)</span> değeri <span class="math inline">\(a\)</span>'dan <span class="math inline">\(b\)</span>'ye gidiyor.</p>
<p><span class="math display">\[ \int_{c_1}M(x,y) \mathrm{d} x = \int_a^b M(x,f_1(x)) \mathrm{d} x\]</span></p>
<p>Burada tek değişken üzerinden entegral alabilirim. Tabii bu ispatta <span class="math inline">\(M\)</span> ifadesini bilmediğim için bunu yapamam, tanımı burada bırakırım.</p>
<p><span class="math inline">\(C_2\)</span></p>
<p><span class="math inline">\(x\)</span> değeri <span class="math inline">\(b\)</span>, <span class="math inline">\(dx = 0\)</span></p>
<p><span class="math display">\[ \int_{c_2}M(x,y) \mathrm{d} x = 0\]</span></p>
<p>Aynı şekilde <span class="math inline">\(C_4\)</span> sıfır olur.</p>
<p><span class="math inline">\(C_3\)</span></p>
<p><span class="math display">\[ y = f_2(x) \]</span></p>
<p><span class="math inline">\(x\)</span> değeri <span class="math inline">\(b\)</span>'dan <span class="math inline">\(a\)</span>'ya gidiyor.</p>
<p><span class="math display">\[
\int_{c_2}M(x,y) \mathrm{d} x = \int_b^a M(x,f_2(x)) \mathrm{d} x = - \int_a^b M(x,f_2(x)) \mathrm{d} 
x 
\]</span></p>
<p>Hepsini toplarsak</p>
<p><span class="math display">\[
\oint_C M \mathrm{d} x  =
\int_a^b M(x,f_1(x)) \mathrm{d} x - \int_a^b M(x,f_2(x)) \mathrm{d} x 
\qquad (1)
\]</span></p>
<p>Şimdi çift entegrale bakıyorum, ve bakalım bu çift entegrali üstteki ifadeye eşitleyebilecek miyim.</p>
<p><span class="math display">\[
\int \int_R -M_y \mathrm{d} A
= - \int_a^b \int_{f_1(x)}^{f_2(x)} \frac{\partial M}{\partial y} \mathrm{d} y \mathrm{d} x
\]</span></p>
<p>Daha önce söylemiştik, bölgeyi belli basit, belli bir şekilde seçmemizin sebebi <span class="math inline">\(dy,dx\)</span>'i ayarlamamızın kolay olması içindi. Yani çift entegral için kesitler hazırlarken bu kesitlerin kolay olması için bölgeyi böyle seçtik.</p>
<p>İçteki entegral</p>
<p><span class="math display">\[ \int_{f_1(x)}^{f_2(x)} \frac{\partial M}{\partial y} \mathrm{d} y =
M(x,f_2(x)) - M(x,f_1(x))
 \]</span></p>
<p>Geri koyarsak</p>
<p><span class="math display">\[
\int \int_R -M_y \mathrm{d} A
= - \int_a^b M(x,f_2(x)) - M(x,f_1(x)) \mathrm{d} x
\]</span></p>
<p>Bu ifade (1) ifadesi ile aynı. İspat tamamlandı. Çünkü özel şart dikeysel basit bölgelerde ispat geçerli, bu faraziyeyi ortadan kaldırırsak, tüm bölgeler için ispat geçerli. <span class="math inline">\(y\)</span> bileşeni için de aynı şey geçerli, o zaman genel teori ispatlanmış oldu.</p>
<p>Güzel Bir Örnek</p>
<p>Green'in Teorisi için bir örnek şudur. Bilgisayarlar bu kadar yaygın olmadan önce deneysel fizikçiler deneylerden sonra bir kağıt, düzey üzerinde deneylerinin sonuçlarını baskı halinde alırlardı. Bu noktalar belli bölgede, bir eğri içinde olurdu. Fakat bu bölgenin alanı lazımdı, bu hesap nasıl yapılacaktı?</p>
<div class="figure">
<img src="22_9.png" />

</div>
<p>Üstteki planımeter denen alet buna yarıyordu. Kollardan birini alttaki gibi bir çıktı üzerinde, onun eğrileri üzerinde gezdirip, başladığınız noktaya dönünce, alet pat diye size hemen sonucu söylüyordu. Nasıl ?</p>
<div class="figure">
<img src="22_10.png" />

</div>
<p>Bunu çizgisel entegrali hesaplayarak yapıyordu. Green'in Teorisine göre çizgisel entegral, alanı içeren entegrale eşit olduğu için doğru sonucu veriyordu.</p>
<p><span class="math display">\[ \oint_C x \mathrm{d} y  = \int \int_R 1 \mathrm{d} A = Alan(R) \]</span></p>
<p>Alet eşitliğin solundaki hesabı yapıyor, bize aradığımız sağdaki sonucu veriyordu yani.</p>
<p>Eğer aletin nasıl işlediği hakkında bir spekülasyon yapmak gerekirse, vektör alanı <span class="math inline">\(x\)</span>'i ele alalım (çizmek için gerekli kod ile)</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">x <span class="op">=</span> linspace(<span class="dv">0</span>,<span class="fl">10.</span>,<span class="dv">10</span>)
y <span class="op">=</span> linspace(<span class="dv">0</span>,<span class="fl">10.</span>,<span class="dv">10</span>)
x,y <span class="op">=</span> meshgrid(x,y)
u <span class="op">=</span> x<span class="op">*</span><span class="dv">10</span>
v <span class="op">=</span> np.zeros(y.shape)
q <span class="op">=</span> plt.quiver(x,y,u,v,angles<span class="op">=</span><span class="st">&#39;xy&#39;</span>,scale<span class="op">=</span><span class="dv">1000</span>,color<span class="op">=</span><span class="st">&#39;r&#39;</span>)
p <span class="op">=</span> plt.quiverkey(q,<span class="dv">1</span>,<span class="fl">16.5</span>,<span class="dv">50</span>,<span class="st">&quot;50 m/s&quot;</span>,coordinates<span class="op">=</span><span class="st">&#39;data&#39;</span>,color<span class="op">=</span><span class="st">&#39;r&#39;</span>)
plt.savefig(<span class="st">&#39;field_x.png&#39;</span>)</code></pre></div>
<div class="figure">
<img src="field_x.png" />

</div>
<p>Bu vektörler mekanik alet içinde belki teller, ya da demir çubuklar olarak gösteriliyor olabilir. Hareket ettirilen kol, kadran gezdirilirken &quot;dikey hareket farkı'' yani <span class="math inline">\(dy\)</span> bir şekilde alınıyor (belki de işi basitleştirmek için önceden tanımlı bir sabit olarak kabul edildi), sonra gezdirilme sırasında hangi tele (vektöre) &quot;çarpıldıysa'' dikey fark bu vektörün değeri ile bir şekilde çarpılıp, başka bir mekanik bileşende toplanıyor. Başa dönülünce eldeki toplam aranan alan değeri olacaktır.</p>
<p>Not: En basit ok çizimi için alttaki kod kullanılabilir</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">u <span class="op">=</span> <span class="dv">200</span>
v <span class="op">=</span> <span class="dv">200</span>
q <span class="op">=</span> plt.quiver(<span class="dv">10</span>,<span class="dv">10</span>,u,v,angles<span class="op">=</span><span class="st">&#39;xy&#39;</span>,scale<span class="op">=</span><span class="dv">1000</span>,color<span class="op">=</span><span class="st">&#39;r&#39;</span>)
p <span class="op">=</span> plt.quiverkey(q,<span class="dv">1</span>,<span class="fl">16.5</span>,<span class="dv">50</span>,<span class="st">&quot;50 m/s&quot;</span>,coordinates<span class="op">=</span><span class="st">&#39;data&#39;</span>,color<span class="op">=</span><span class="st">&#39;r&#39;</span>)
xl <span class="op">=</span> plt.xlabel(<span class="st">&quot;x (km)&quot;</span>)
yl <span class="op">=</span> plt.ylabel(<span class="st">&quot;y (km)&quot;</span>)</code></pre></div>
<p>Ekler</p>
<p>Green'in Teorisi, Uzaklaşım, Stokes</p>
<p>Green'in Teorisi</p>
<p>Bu teorinin detayları, ispatı [2]'de bulunabilir. Tekrar üzerinden geçmek gerekirse, [4, sf. 429] bazlı anlatalım, iki boyutta elimizde bir <span class="math inline">\(D\)</span> bölgesi etrafındaki <span class="math inline">\(C\)</span> eğrisi var, ve <span class="math inline">\(F(x,y) = M(x,y) *i* + N(x,y) *j*\)</span> <span class="math inline">\(D\)</span> içinde vektör alanı olsun, o zaman alttaki ifade doğrudur,</p>
<p><span class="math display">\[
\int_C M \mathrm{d} x + N \mathrm{d} Y =
\int \int_D \left(
  \frac{\partial N}{\partial x} - \frac{\partial M}{\partial y}
  \mathrm{d} x \mathrm{d} y
\right)
\]</span></p>
<p><span class="math inline">\(\int_C\)</span> ki bazen <span class="math inline">\(\oint_C\)</span> ile gösterilir, bir eğri üzerinden alınan bir entegraldır. Eşitliğin sol tarafı bazen bir <span class="math inline">\(\mathrm{d}\vec{s}\)</span> üzerinden de sunulabilir,</p>
<p><span class="math display">\[
\int_C \vec{F} \cdot \mathrm{d}\vec{s} = \int_C M \mathrm{d} x + N \mathrm{d} Y 
\]</span></p>
<p>Bu cebirsel bir özet sadece, <span class="math inline">\(\mathrm{d}{\vec{s}} = [\begin{array}{cc} \mathrm{d} x &amp; \mathrm{d} y \end{array}]^T\)</span> sonuçta ve noktasal çarpım bize iki üstteki ifadeyi verecektir.</p>
<p>Örnek</p>
<p>Bir vektör alanı <span class="math inline">\(\vec{F} = xy *i* + y^2 *j*\)</span> olsun, ve bu alanda birinci dörtlük içinde <span class="math inline">\(y = x\)</span> çizgisi ve <span class="math inline">\(y=x^2\)</span> parabolu arasındaki bölgeyi düşünelim. Bu bölge ve alan üzerinden Green'in Teorisini doğrulamaya uğraşalım.</p>
<p>Grafik şu şekilde,</p>
<div class="figure">
<img src="calc_multi_75_green_02.jpg" />

</div>
<p>Vektör alanı (100 ile çarpıp vektörleri büyüttük gözüksün diye),</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">x <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="fl">1.</span>,<span class="dv">10</span>)
y <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="fl">1.</span>,<span class="dv">10</span>)
x,y <span class="op">=</span> np.meshgrid(x,y)
SCALE <span class="op">=</span> <span class="fl">100.0</span>
u <span class="op">=</span> x<span class="op">*</span>y<span class="op">*</span>SCALE<span class="op">;</span> v <span class="op">=</span> (y<span class="op">**</span><span class="dv">2</span>)<span class="op">*</span>SCALE
v <span class="op">=</span> np.zeros(y.shape)
q <span class="op">=</span> plt.quiver(x,y,u,v,angles<span class="op">=</span><span class="st">&#39;xy&#39;</span>,scale<span class="op">=</span><span class="dv">1000</span>,color<span class="op">=</span><span class="st">&#39;r&#39;</span>)
p <span class="op">=</span> plt.quiverkey(q,<span class="dv">1</span>,<span class="fl">16.5</span>,<span class="dv">50</span>,<span class="st">&quot;50 m/s&quot;</span>,coordinates<span class="op">=</span><span class="st">&#39;data&#39;</span>,color<span class="op">=</span><span class="st">&#39;r&#39;</span>)
plt.savefig(<span class="st">&#39;calc_multi_75_green_01.jpg&#39;</span>)</code></pre></div>
<div class="figure">
<img src="calc_multi_75_green_01.jpg" />

</div>
<p>Eğri iki parça olarak analiz edilecek, <span class="math inline">\(C_1\)</span> ve <span class="math inline">\(C_2\)</span>. Eğri üzerinden gereken tüm entegral,</p>
<p><span class="math display">\[
\int_C \vec{F} \cdot \mathrm{d}{\vec{s}} = \int_C xy \mathrm{d} x + y^2 \mathrm{d} y
\]</span></p>
<p>Bu entegral iki parça üzerinden alınmalı ve sonuç toplanmalı,</p>
<p><span class="math display">\[
= \int_{C_1} xy \mathrm{d} x + y^2 \mathrm{d} y + \int_{C_2} xy \mathrm{d} x + y^2 \mathrm{d} y
\label{2}
\]</span></p>
<p>Eğriyi parametrize edelim, böylece <span class="math inline">\(\mathrm{d} x\)</span>, <span class="math inline">\(\mathrm{d} y\)</span> üzerinden entegraller kolaylaşsın,</p>
<p><span class="math display">\[
C_1: x = t, y = t^2, \quad 0 \le t \le 1
\]</span></p>
<p><span class="math display">\[
C_2: x = 1-t, y = 1-t, \quad 0 \le t \le 1
\]</span></p>
<p><span class="math inline">\(C_1\)</span>,<span class="math inline">\(C_2\)</span> gidişat yönlerine dikkat, mesela eğri ile yukarı çıkış var, ama düz eğri ile aşağı iniyoruz, bu sebeple <span class="math inline">\(t\)</span> sıfırdan başlarken <span class="math inline">\(x,y\)</span> değerleri <span class="math inline">\((1,1)\)</span>, öyle ayarladık, ve en sonda <span class="math inline">\(t=1\)</span> olduğu anda <span class="math inline">\(x,y\)</span> değerleri <span class="math inline">\((0,0)\)</span> oluyor.</p>
<p>Şimdi parametrize edilmiş değişkenlerle (2) formülünü tekrar yazalım,</p>
<p><span class="math display">\[
= \int_{0}^{1} ( t \cdot t^2 + t^4 \cdot 2t ) \mathrm{d} t +
\int_{0}^{1} ((1-t)^2 + (1-t)^2) (-\mathrm{d} t)
\]</span></p>
<p><span class="math display">\[
= \int_{0}^{1} (t^3 + 2t^5) \mathrm{d} t + \int _{0}^{1} 2 (1-t)^2 (-\mathrm{d} t)
\]</span></p>
<p><span class="math display">\[
= (\frac{1}{4} t^4 + \frac{2}{6} t^6) \big\vert_{0}^{1} +
(\frac{2}{3} (1-t)^3 ) \big\vert_{0}^{1}
\]</span></p>
<p><span class="math display">\[
= \frac{1}{4} + \frac{2}{6} - \frac{2}{3} = -\frac{1}{12}
\]</span></p>
<p>Green'in Teorisinin sağ tarafına bakalım şimdi,</p>
<p><span class="math display">\[
\int \int_D \frac{\partial N}{\partial x} - \frac{\partial M}{\partial y} \mathrm{d} x \mathrm{d} y =
\int \int_D \left(
\frac{\partial }{\partial x}(y^2) - \frac{\partial }{\partial y}(xy) \mathrm{d} x \mathrm{d} y
\right)
\]</span></p>
<p><span class="math display">\[
= \int_{0}^{1} \int_{x^2}^{x} -x \mathrm{d} y \mathrm{d} x =
\int_{0}^{1} -x (x-x^2) \mathrm{d} x =
\int_{0}^{1} (x^3 - x^2) \mathrm{d} x = (\frac{1}{4} x^4 - \frac{1}{3} x^3 ) \bigg\vert_{0}^{1}
\]</span></p>
<p><span class="math display">\[
= \frac{1}{4} - \frac{1}{3} = -\frac{1}{12}
\]</span></p>
<p>Aynı sonuca eriştik.</p>
<p>[devam edecek]</p>
<p>Gauss-Green Eşitliği</p>
<p>Gauss-Green eşitliği iki boyutta şu şekilde gösterilebilir [1, sf. 262],</p>
<p><span class="math display">\[
\iint_R (\nabla u ) \cdot w \mathrm{d} x \mathrm{d} y =
\iint_R u (- \mathrm{div} w) \mathrm{d} x \mathrm{d} y + \int_C u w \cdot n \mathrm{d} s
\]</span></p>
<p>Türetmek için başlangıç noktası <span class="math inline">\(uv\)</span> üzerinde uzaklaşım almak. Aslında ileride göreceğimiz gibi çok boyutta parçalı entegral tekniği Gauss-Green'in uzantısı bir bakıma ve tek boyutta gördük ki [3] parçalı entegrale erişmek için de Calculus'un çarpım kuralından başlanmıştı.</p>
<p><span class="math display">\[
\mathrm{div} (uw) = \mathrm{div} (u w_1 + u w_2) =
\frac{\partial u}{\partial x} w_1 +
\frac{\partial w_1}{\partial x} u +
\frac{\partial u}{\partial y} w_2 +
\frac{\partial w_2}{\partial y} u 
\]</span></p>
<p>Gruplarsak,</p>
<p><span class="math display">\[
= \left( 
\frac{\partial u}{\partial x} w_1 +
\frac{\partial u}{\partial y} w_2 \right) +
\left( 
\frac{\partial w_1}{\partial x} u +
\frac{\partial w_2}{\partial y} u \right)
\]</span></p>
<p>Daha kısa şekilde,</p>
<p><span class="math display">\[
\mathrm{div} (uw) = \nabla u \cdot w + u \mathrm{div}(w)
\]</span></p>
<p>Üstteki ifade üzerinde Uzaklaşım Teorisi'ni uygulayalım. Önce <span class="math inline">\(\iint_R \mathrm{div} (uw)\)</span>,</p>
<p><span class="math display">\[
\iint_R \mathrm{div} (uw) \mathrm{d} x \mathrm{d} y= \iint_R \nabla u \cdot w + u \mathrm{div}(w) \mathrm{d} x \mathrm{d} y
\]</span></p>
<p><span class="math display">\[
= \iint_R \nabla u \cdot w  \mathrm{d} x \mathrm{d} y + \iint_R u \mathrm{div}(w) \mathrm{d} x \mathrm{d} y
\]</span></p>
<p>Uzaklaşım Teorisi'ne göre sağ taraf <span class="math inline">\(\int_C uw \cdot n \mathrm{d} s\)</span> olmalı, yani</p>
<p><span class="math display">\[
\iint_R \nabla u \cdot w  \mathrm{d} x \mathrm{d} y + \iint_R u \mathrm{div}(w) \mathrm{d} x \mathrm{d} y = \int_C uw \cdot n \mathrm{d} s
\]</span></p>
<p>Eşitliğin sol tarafındaki ikinci terimi sağa geçirirsek,</p>
<p><span class="math display">\[
\iint_R \nabla u \cdot w  \mathrm{d} x \mathrm{d} y =
\iint_R u (-\mathrm{div} w) \mathrm{d} x \mathrm{d} y + \int_C uw \cdot n \mathrm{d} s
\]</span></p>
<p>[1] notasyonu ile <span class="math inline">\(\nabla\)</span> yerine <span class="math inline">\(\mathrm{grad}\)</span>,</p>
<p><span class="math display">\[
\iint_R \mathrm{grad} u \cdot w  \mathrm{d} x \mathrm{d} y =
\iint_R u (-\mathrm{div} w) \mathrm{d} x \mathrm{d} y + \int_C uw \cdot n \mathrm{d} s
\qquad (3)
\]</span></p>
<p>Böylece Gauss-Green eşitliğine erişmiş olduk.</p>
<p>Green'in İlk Eşitliği</p>
<p>Eğer (3) içinde <span class="math inline">\(w\)</span> için <span class="math inline">\(\mathrm{grad} u\)</span> sokarsak, bu bize Green'in İlk Eşitliği (Green's First İdentity) denen formülü veriyor [1, sf. 281],</p>
<p><span class="math display">\[
\iint_R \mathrm{grad} u \cdot \mathrm{grad} u  \mathrm{d} x \mathrm{d} y =
\iint_R u (-\mathrm{div} \mathrm{grad} u) \mathrm{d} x \mathrm{d} y + \int_C u \mathrm{grad} u \cdot n \mathrm{d} s
\]</span></p>
<p>Gradyanın uzaklaşımı bazen <span class="math inline">\(\Delta\)</span> notasyonu ile gösterilir, öyle yapalım,</p>
<p><span class="math display">\[
\iint_R | \mathrm{grad} u |^2  \mathrm{d} x \mathrm{d} y = - \iint_R u (\Delta u) \mathrm{d} x \mathrm{d} y +
\int_C u \mathrm{grad} u \cdot n \mathrm{d} s
\]</span></p>
<p>Eşitliğin sağından, solundan birkaç yer değişim sonrası,</p>
<p><span class="math display">\[
\iint_R u (\Delta u) \mathrm{d} x \mathrm{d} y =
- \iint_R | \mathrm{grad} u |^2  \mathrm{d} x \mathrm{d} y
+ \int_C u \mathrm{grad} u \cdot n \mathrm{d} s
\]</span></p>
<p>Böylece [1, sf. 281]'daki forma erişmiş olduk. Bu Green'in İlk Eşitliği.</p>
<p>Kaynaklar</p>
<p>[1] Strang, <em>Computational Science and Engineering</em></p>
<p>[2] Bayramli, <em>Cok Degiskenli Calculus, Ders 23</em></p>
<p>[3] Bayramlı, <em>Diferansiyel Denklemler, Ekler</em></p>
<p>[4] Colley, <em>Vector Calculus</em></p>
<p>
  <a href="..">Yukarı</a>
</p>
</body>
</html>
