<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  
  
  
  
</head>
<body>
<h1 id="ders-3">Ders 3</h1>
<p>Çapraz çarpımlar hakkında bilinmesi gereken bazı şaşırtıcı gelebilecek kurallar var. Bunlardan bir tanesi <span class="math inline">\(\vec{A} \times \vec{B} \ne \vec{B} \times \vec{A}\)</span> işlemi. Peki neden böyle? Bunu incelemenin yollarından bir tanesi geometrik olarak düşünmek. Sağ el kuralını düşünürsek, yönün neden farklı olabileceğini anlarız. İşaretler tam terstir, yani</p>
<p><span class="math display">\[  \vec{A} \times \vec{B} = - \vec{B}\times \vec{A} \]</span></p>
<p>Determinant açılımını da düşünürsek, ikinci terim eksi işareti taşır, ama çarpım sırası değişince eksi işaretinin yeri değişir.</p>
<p>Peki <span class="math inline">\(\vec{A} \times \vec{A}\)</span> nedir? Çapraz çarpım alan hesabında önemli olduğuna göre ve <span class="math inline">\(\vec{A} \times \vec{A}\)</span> bir paralelkenar oluşturamayacağına göre (ya da sıfır alanlı bir paralelkenar oluşturacağına göre) cevap sıfır, daha doğrusu sıfır &quot;vektörü'' (o vektörün büyüklüğü de tabii ki sıfır).</p>
<p>Uygulamalar</p>
<p>Diyelim ki bize uzayda üç nokta verildi, ve bu noktaları içeren bir düzlemin formülünü bulmamız gerekiyor. Üç nokta, üç boyutlu uzayda bir düzlem yaratmak için yeterli, bunu biliyoruz. Bunun için bir dördüncü nokta <span class="math inline">\(P\)</span> hayal edelim ki bu noktanın öğeleri <span class="math inline">\(x,y,z\)</span> olsun.</p>
<div class="figure">
<img src="3_1.png" />

</div>
<p>Şimdi düzlemi tanımlayalım. Şu şekilde 3 tane vektör yaratalım</p>
<div class="figure">
<img src="3_2.png" />

</div>
<p>Bu vektörlerin aynı düzlem üzerinde olması, aynı zamanda bu vektörlerin tanımladığı paralelyüz'ün hacimsiz olması demektir. Yani birisi üzerinden bastırıp onu dümdüz etmiştir sanki, sadece alanı kalmıştır.</p>
<p>Bunu matematiksel olarak ifade etmenin yolu şudur:</p>
<p><span class="math display">\[ det(\vec{P_1P},\vec{P_2P},\vec{P_3P}) = 0 \]</span></p>
<p>Gerçek uygulama bağlamında problem bize <span class="math inline">\(P_1,P_2,P_3\)</span> sayılarını vermiş olurdu.Biz bu sayıları üstteki formüle yerleştirdiğimizde ise tanımsız olan sadece <span class="math inline">\(x,y,z\)</span> kalırdı ve bu <span class="math inline">\(x,y,z\)</span>'ler ile beraber elde edilecek formül bu noktaların tanımladığı alan olurdu.</p>
<p>Bu hesabı daha da hızlı yapmanın bir yolu var. Alttaki resmi düşünelim.</p>
<div class="figure">
<img src="3_3.png" />

</div>
<p>Düzlem üzerindeki iki vektöre dik bir <span class="math inline">\(\vec{N}\)</span>'i nasıl hesaplayacağımızı biliyoruz (çarpraz çarpım ile). Ayrıca, <span class="math inline">\(x,y,z\)</span> değişkenlerini içeren üçüncü bir vektör <span class="math inline">\(\vec{P_1P}\)</span>'in aynı düzlemde olması demek, bu <span class="math inline">\(\vec{N}\)</span> vektörüne dik olması demektir (<span class="math inline">\(\vec{N}\)</span> &quot;normal vektör'' olarak isimlendirilir). Bunu matematiksel olarak nasıl ifade ederiz? Dikliğin matematiksel karşılığını biliyoruz, noktasal çarpım sıfır olmalı.</p>
<p><span class="math display">\[ \vec{P_1P} \cdot \vec{N} = 0 \]</span></p>
<p><span class="math inline">\(\vec{N}\)</span> hesabı için</p>
<p><span class="math display">\[ \vec{N} = \vec{P_1P_2} \times \vec{P_1P_3}\]</span></p>
<p>Bu kadar.</p>
<p>Ek not, eğer çapraz çarpımın sırasını değiştirmiş olsaydım, o zaman üstteki hesabın ters yönünde bir başka dik vektör elde ederdim, düzlem yine aynı olurdu, sadece başka bir normal vektör olurdu. Bu problem değil, herhangi bir düzlemin sonsuz sayıda normal vektörü olabilir. Elde ettiğimiz bir normal vektörü herhangi bir sabit ile çarpınca yeni bir normal vektör elde etmiş olurum çünkü.</p>
<p><span class="math display">\[ \vec{P_1P} \cdot \vec{N} =
\vec{P_1P} \cdot (\vec{P_1P_2} \times \vec{P_1P_3})
\]</span></p>
<p>Eşitliğin sağındaki çarpıma üçlü çarpım (triple product) deniyor.</p>
<p>Eğer dikkat ettiyseniz, denklemin sağ tarafındaki çapraz çarpım işlemine tabi tutulan vektörler aynı düzlem içerisinde bulunduğu için, çapraz çarpımın sonucu bize bulundukları düzleme dik bir vektör verir. Bu vektör, denklemin sol tarafındaki <span class="math inline">\(\vec{N}\)</span> ile aynı doğrultuda olduğu için bu eşitlik her zaman sağlanır.</p>
<p>Matrisler</p>
<p><span class="math inline">\(AB\)</span> şeklindeki bir matris çarpımında herhangi bir hücrenin, hangi kolon hangi satırın noktasal çarpımının sonucu olduğunu hayal edebilmek için alttaki şekil faydalı olabilir. <span class="math inline">\(AB\)</span> çarpımını gerçekleştirdikten sonra ortaya çıkan matriste, herhangi bir hücreyi ele alalım. Mesela, beşinci satır, dördüncü kolon. Bu sayı, <span class="math inline">\(A\)</span> matrisinin beşinci satırı ile, <span class="math inline">\(B\)</span> matrisinin dordüncü kolonunun noktasal çarpımının sonucudur. İşte bu kadar basit.</p>
<div class="figure">
<img src="3_4.png" />

</div>
<p>Sezgisel olarak <span class="math inline">\(AB\)</span> çarpımı neyi temsil eder? Bu çarpımı şöyle düşünebiliriz, önce <span class="math inline">\(B\)</span> transformu yap, sonra <span class="math inline">\(A\)</span> transformu yap. Bu biraz acaip gelebilir, çünkü normalde işlemleri soldan sağa yapmaya alışığızdır. Fakat <span class="math inline">\(AB\)</span>'yi belki de sıralı fonksiyon işlemleri olarak görmek daha doğru olur, mesela <span class="math inline">\(f(g(x))\)</span> gibi. Burada önce <span class="math inline">\(g\)</span> uygulanır, sonra <span class="math inline">\(f\)</span> uygulanır.</p>
<p><span class="math display">\[ (AB)X = A(BX) \]</span></p>
<p>Üstteki özelliğe birleşim özelliği diyoruz. Bu arada, üstteki çarpımın noktasal değil, matris çarpımı olduğuna dikkat edelim.</p>
<p>Not: <span class="math inline">\(AB \ne BA\)</span>. En azından sağdaki çarpımın olabileceğini beklemememiz gerekir. <span class="math inline">\(AB\)</span> çarpımı boyutlar uyduğu için mümkün olmuştur, fakat bu uyumlu boyutlar yerler değişince belki mümkün olmaz. Boyutlar olsa bile sonuç farklı çıkabilir, o sebeple eşitlik farz edilemez. Ufak bir Python kodu ile test edelim:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">
a <span class="op">=</span> [[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>],[<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">5</span>],[<span class="dv">9</span>,<span class="dv">3</span>,<span class="dv">2</span>]]
b <span class="op">=</span> [[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">9</span>],[<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">5</span>],[<span class="dv">9</span>,<span class="dv">3</span>,<span class="dv">2</span>]]

<span class="bu">print</span> np.dot(a,b)

<span class="bu">print</span> np.dot(b,a)</code></pre></div>
<pre><code>[[ 52  24  41]
[ 69  35  66]
[ 48  39 100]]
[[97 45 41]
[61 35 36]
[48 45 55]]</code></pre>
<p>Sonuçlar farklı çıkacak.</p>
<p>Örnek</p>
<p>Çevirmek / Rotasyon</p>
<p>Bir düzlem üzerinde bir vektörü <span class="math inline">\(90^o\)</span>, saat yönü tersine çevirmek için</p>
<p><span class="math display">\[ R =
\left[\begin{array}{rr}
0 &amp; -1 \\
1 &amp; 0
\end{array}\right]
\]</span></p>
<p>İlginç bir durum</p>
<p><span class="math display">\[ R^2 =
\left[\begin{array}{rr}
-1 &amp; 0 \\
0 &amp; -1
\end{array}\right]
\]</span></p>
<p>Yani birim matrisinin negatifi. Niye böyle oldu? Düşünelim, eğer bir vektörü 90 derece döndürürsem, sonra bir daha 90 derece döndürürsem, sonuç olarak 180 derece döndürmüş olurum, yani tam tersi yöne gitmiş olurum. Birim matrisin negatifi de budur zaten.</p>
<p>Matrisler denklem sistemlerini temsil edebilirler, alttaki gibi</p>
<div class="figure">
<img src="3_5.png" />

</div>
<p>Bu tür sistemlerde belki <span class="math inline">\(X\)</span> değerleri verilmiştir, <span class="math inline">\(U\)</span>'yu hesaplamamız isteniyordur, ya da tam tersi de olabilir, <span class="math inline">\(U\)</span> verilmiştir, <span class="math inline">\(X\)</span> hesaplamamız isteniyordur. Ters yönde gitmek için matris tersini (inverse) almak gerekir.</p>
<p>Not: Bir matrisin tersini alabilmemiz için onun kare matrisi olması gerekir, yani boyutu <span class="math inline">\(n\)</span> x <span class="math inline">\(n\)</span> olmalıdır.</p>
<p>Ters yönde çözüme gelelim. Mesela elimizde şöyle bir sistem var</p>
<p><span class="math display">\[  AX = B\]</span></p>
<p><span class="math display">\[  A^{-1}(AX) = A^{-1}B\]</span></p>
<p><span class="math display">\[  X = A^{-1}B\]</span></p>
<p>Böylece <span class="math inline">\(X\)</span>'i elde edebilmiş oluruz. O zaman <span class="math inline">\(A\)</span> matrisinin tersini alma operasyonunu yapabiliyorsak, istediğimiz herhangi bir lineer denklem sistemini çözebiliriz demektir.</p>
<p>Aşağıdaki eşitlik de bir matrisin tersini bulabilmek adına geçerlidir.</p>
<p><span class="math display">\[ A^{-1} = \frac{1}{det(A)}  = adj(A)\]</span></p>
<p>Üstte <span class="math inline">\(adj\)</span> diye tanımlanan bir matrisin bitişiğini (adjoint matrix) nasıl buluruz?</p>
<p>Mesela</p>
<p><span class="math display">\[
\left[\begin{array}{rrr}
2 &amp; 3 &amp; 3 \\
2 &amp; 4 &amp; 5 \\
1 &amp; 1 &amp; 2
\end{array}\right]
\]</span></p>
<p>Adımlar:</p>
<ol style="list-style-type: decimal">
<li>Bu matrisin &quot;minörlerini'' bulmak lazım. O nedir? Aslında minörleri determinant işlemini işlediğimizde görmüştük, sadece bu ismi vermemiştik. Onlar en üst satırdaki matris hücrelerini teker teker merkez alıp, onun satırını, kolonunu iptal ettikten sonra geri kalan daha ufak bölgenin determinantlarıydı. Bitişiklik için bu hesabı sadece üst satır için değil, tüm hücreler için yapacağız. Üstteki örnek için</li>
</ol>
<p><span class="math display">\[
\left[\begin{array}{rrr}
3 &amp; -1 &amp; -2 \\
3 &amp; 1 &amp; -1 \\
3 &amp; 4 &amp; 2
\end{array}\right]
\]</span></p>
<ol start="2" style="list-style-type: decimal">
<li>Katsayıları bulma işlemi. Determinant işlemini bir matrisin minörlerini toplayarak buluyoruz. Ve her minörün önüne şimdi göstereceğimiz kurala göre &quot;+&quot; veya &quot;-&quot; işareti geliyor. Katsayı kuralımızın formülü şu şekildedir <span class="math inline">\((-1)^{m+n}\)</span>. Bu formülde &quot;m&quot; satır numarası, &quot;n&quot; ise kolon numarasıdır. Formülü daha iyi kavrayabilmek adına dama tahtası gibi bir şekil düşünelim, bunun üzerinde +,- işaretleri olsun.</li>
</ol>
<p><span class="math display">\[
\begin{array}{rr}
+ - + - + \\
- + - + - \\
+ - + - + \\
- + - + - \\
\end{array}
\]</span></p>
<p>Örnekteki bitişiklik ise şu hale gelir:</p>
<p><span class="math display">\[
\left[\begin{array}{rrr}
3 &amp; 1 &amp; -2 \\
-3 &amp; 1 &amp; 1 \\
3 &amp; -4 &amp; 2
\end{array}\right]
\]</span></p>
<ol start="3" style="list-style-type: decimal">
<li>Devriğini Al (Transpose)</li>
</ol>
<p>Satırlar ve kolonların yerini değiştir.</p>
<p><span class="math display">\[
\left[\begin{array}{rrr}
3 &amp; -3 &amp; 3 \\
1 &amp; 1 &amp; -4 \\
-2 &amp; 1 &amp; 2
\end{array}\right]
\]</span></p>
<ol start="4" style="list-style-type: decimal">
<li>Her şeyi <span class="math inline">\(det(A)\)</span>'ya böl</li>
</ol>
<p><span class="math display">\[
\left|\begin{array}{rrr}
2 &amp; 3 &amp; 3 \\
2 &amp; 4 &amp; 5 \\
1 &amp; 1 &amp; 2
\end{array}\right| = 3
\]</span></p>
<p><span class="math display">\[ A^{-1} =
\frac{1}{3}
\left[\begin{array}{rrr}
3 &amp; -3 &amp; 3 \\
1 &amp; 1 &amp; -4 \\
-2 &amp; 1 &amp; 2
\end{array}\right]
\]</span></p>
<p>Ekler</p>
<p>Bazı Çapraz Çarpım Kuralları [1, sf. 222]</p>
<p>BAC-CAB</p>
<p>`BAC-CAB açılımı'' denen teknik soyle</p>
<p><span class="math display">\[
A \times (B \times C) = B(A \cdot C) - C(A \times B)
\]</span></p>
<p>Dağılım (Distributive) Kuralı</p>
<p><span class="math display">\[
(A+B) \times C = (A \times C) + (B \times C)
\]</span></p>
<p><span class="math inline">\((A+B) \times (C+D)\)</span> açılımı da üstteki açılımdan türetilebilir.</p>
<p>Yerbağımsızlık</p>
<p>Normal çarpma toplamadaki yerbağımsızlık yok, çünkü işaret değişiyor,</p>
<p><span class="math display">\[
B \times A = - A \times B
\]</span></p>
<p>Kaynaklar</p>
<p>[1] <em>Mathematical Methods for Physics Engineering</em></p>
</body>
</html>
